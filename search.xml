<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-OS-TOP</title>
      <link href="/2023/06/os/buaa-os-top/"/>
      <url>/2023/06/os/buaa-os-top/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-文章传送门"><a href="#BUAA-OS-2023-文章传送门" class="headerlink" title="BUAA-OS-2023 文章传送门"></a>BUAA-OS-2023 文章传送门</h1><p>在这里，你可以跳转到站点里和 OS 有关的所有文章：</p><h1 id="实验报告（Lab0-Lab6）"><a href="#实验报告（Lab0-Lab6）" class="headerlink" title="实验报告（Lab0 - Lab6）"></a>实验报告（Lab0 - Lab6）</h1><ul><li><a href="https://cookedbear.top/2023/03/os/buaa-os-report-lab0/">BUAA-OS-2023-Lab0-Report</a></li><li><a href="https://cookedbear.top/2023/03/os/buaa-os-report-lab1/">BUAA-OS-2023-Lab1-Report</a></li><li><a href="https://cookedbear.top/2023/03/os/buaa-os-report-lab2/">BUAA-OS-2023-Lab2-Report</a></li><li><a href="https://cookedbear.top/2023/04/os/buaa-os-report-lab3/">BUAA-OS-2023-Lab3-Report</a></li><li><a href="https://cookedbear.top/2023/04/os/buaa-os-report-lab4/">BUAA-OS-2023-Lab4-Report</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-report-lab5/">BUAA-OS-2023-Lab5-Report</a></li><li><a href="https://cookedbear.top/2023/06/os/buaa-os-report-lab6/">BUAA-OS-2023-Lab6-Report</a></li></ul><h1 id="深入学习（Lab1-Lab6）"><a href="#深入学习（Lab1-Lab6）" class="headerlink" title="深入学习（Lab1 - Lab6）"></a>深入学习（Lab1 - Lab6）</h1><ul><li>Lab1 没写喵</li><li><a href="https://cookedbear.top/2023/03/os/buaa-os-probe-lab2/">BUAA-OS-2023-Lab2-Probe</a></li><li><a href="https://cookedbear.top/2023/04/os/buaa-os-probe-lab3/">BUAA-OS-2023-Lab3-Probe</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-probe-lab4/">BUAA-OS-2023-Lab4-Probe</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-probe-lab5-part1/">BUAA-OS-2023-Lab5-Probe-Part1</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-probe-lab5-part2/">BUAA-OS-2023-Lab5-Probe-Part2</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-probe-lab5-part3/">BUAA-OS-2023-Lab5-Probe-Part3</a></li><li>Lab6 没写喵</li></ul><h1 id="上机总结（Lab0-Lab5）"><a href="#上机总结（Lab0-Lab5）" class="headerlink" title="上机总结（Lab0 - Lab5）"></a>上机总结（Lab0 - Lab5）</h1><ul><li>Lab0 的题因为历史原因，丢失在数据长河里了！</li><li><a href="https://cookedbear.top/2023/03/os/buaa-os-lab1-exam/">BUAA-OS-2023-Lab1-Exam</a></li><li>Lab2 Extra 没过，很伤心，所以没写总结</li><li><a href="https://cookedbear.top/2023/04/os/buaa-os-lab3-exam/">BUAA-OS-2023-Lab3-Exam</a></li><li><a href="https://cookedbear.top/2023/04/os/buaa-os-lab4-1-exam/">BUAA-OS-2023-Lab4-1-Exam</a></li><li>Lab4-2 Extra 40分，也很伤心，所以也没写总结</li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-lab5-1-exam/">BUAA-OS-2023-Lab5-1-Exam</a></li><li><a href="https://cookedbear.top/2023/05/os/buaa-os-lab5-2-exam/">BUAA-OS-2023-Lab5-2-Exam</a></li></ul><h1 id="挑战性任务（Lab6）"><a href="#挑战性任务（Lab6）" class="headerlink" title="挑战性任务（Lab6）"></a>挑战性任务（Lab6）</h1><ul><li><a href="https://cookedbear.top/2023/06/os/buaa-os-challenge-lab6/">BUAA-OS-2023-Lab6-Challenge</a></li></ul><h1 id="课程资源"><a href="#课程资源" class="headerlink" title="课程资源"></a>课程资源</h1><ul><li><a href="https://gitee.com/osbuaa/mos">课程组<strong>实验</strong>代码仓库（未填空）</a></li><li><a href="https://wwge.lanzoup.com/iVLAx0zql5ng">沃天宇老师理论课PPT</a></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>终于，os 课程随着这篇文章的完工走到了尾声，学的时候感觉很累，但走到最后回头看感觉又不是那么累。整体学下来的关键就是<strong>体系</strong>，我觉得每一个 Lab 都是相对完整 &amp; 独立的，学习前要事先认识内部各部分在当前 Lab 中的作用，从全局的角度看功能，再从功能的角度看代码。直接闷头鼓捣代码确实会有折腾半天却不知道自己在干什么的苦恼，所以先想后看算是很关键的一步。</p><p>再一个就是要多看吧，不要理所当然认为这里就执行一个怎样怎样的功能，要多去想它如何实现的，在哪一步、具体到哪些汇编实现的？想深点总是有好处的，毕竟 os 不是程序员的战场，不仅要会调用函数，也要知道函数如何实现。</p><p>然后上机别给太大压力，做不出来的话，课程组真的会想办法捞。去年的课下强测补实验分，今年的取消申优要求分数线，都能感觉出课程组捞人的强烈愿望了</p><p><strong>一定要平时多看理论，不要把精力全给实验，然后整的理论只能在期末之前临时自救，一定不要！</strong></p><p>os 行笔至此已告一段落，希望这些记录能助后来者微薄之力。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT4-Summary</title>
      <link href="/2023/06/buaa-oo-unit4-summary/"/>
      <url>/2023/06/buaa-oo-unit4-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计与构造第四单元总结"><a href="#面向对象设计与构造第四单元总结" class="headerlink" title="面向对象设计与构造第四单元总结"></a>面向对象设计与构造第四单元总结</h1><ul><li>总结本单元所实践的正向建模与开发</li><li>总结本单元作业的架构设计，并对比分析最终的代码设计和UML模型设计之间的追踪关系</li><li>总结自己在四个单元中架构设计思维的演进</li><li>总结自己在四个单元中测试思维的演进</li><li>总结自己的课程收获</li></ul><h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><ul><li>本单元第一次作业以一个图书馆模拟系统为例，锻炼同学们<strong>对程序架构的设计能力，以及加强对 UML 类图的绘制训练</strong>。</li><li>本单元第二次作业以多学校的联网图书馆模拟系统为例，锻炼同学们<strong>对程序架构的抽象能力，以及加强对 UML 状态图的绘制训练</strong>。</li><li>本单元第三次作业以前两次作业为基础，锻炼同学们<strong>对 UML 顺序图的绘制训练</strong>。</li></ul><p>总的来说，我们在第一次作业实现了一个图书馆的基础功能（借阅、预定、书目数量限制、还书、损毁&amp;修复、丢失等），功能难点主要围绕借阅无书时的预定环节。在第二次作业中，我们将单个图书馆的功能封装，并提升为多个，并加入了校际借阅流程与无书购买流程，难点主要在闭馆后对不能立刻处理的借书请求的分类处理&amp;处理顺序，整理日的动作顺序&amp;购书操作，学生获取到一本书籍后对预约/校际借阅/预购队列产生的影响。在第三次作业中，增添了逾期还书的处理方式，对程序主干逻辑没有过多变动。</p><p>在程序之外，本单元重点训练了 UML 类图、状态图和顺序图的绘制，并分别在三次作业中进行了考察。</p><p>类图针对程序代码中所有的类。状态图针对一本书在借阅过程中发生的状态转移。顺序图针对预定成功到成功取书之间程序的调用关系与顺序。</p><h1 id="正向建模与开发"><a href="#正向建模与开发" class="headerlink" title="正向建模与开发"></a>正向建模与开发</h1><p>单元第一次作业实现单机图书馆的构建。我将图书馆各个部门分装为静态类，将输出功能和日期转换功能封装为工具类，将书籍、学生和借阅请求封装为类，在主类中进行图书馆功能的分发与实现。</p><p>过程中遇到的问题主要在学生获取书籍后要对预约队列进行刷新，需要一些容器操作。</p><p>单元第二次作业将图书馆变为联机图书馆。首先将原本代表部门的类从静态类转换为一般类，便于每个学校分别 <code>new</code> 一个对应的部门进行处理；然后将原本主类的逻辑封装为一个 <code>School</code> 类，代表一个学校的图书馆，再在主类创建一个图书馆的容器进行存放。其他类模型未发生改变。当接受请求后，先获取所在图书馆，再分发到对应图书馆执行相应功能函数，完成请求功能。</p><p>问题主要集中在请求分类流程：当一个请求不能实时满足，需要在闭馆后统一进行处理，并根据书籍余量、状态判断是校际借阅、校内预定或校内购买。指导书在此的说明不够详细，前后要求还有改动，所以这部分完成的不是很顺利。主要还是与第一次的处理逻辑不同，导致了架构修改上的困难。</p><p>单元第三次作业更像是补偿性作业，上次一作业难度过高导致这一次作业的内容就相对较少，只需要新增并维护书籍的一个字段即可，并在借还时更新字段，调用相应方法。</p><h1 id="UML模型设计"><a href="#UML模型设计" class="headerlink" title="UML模型设计"></a>UML模型设计</h1><p>以第三次作业为例，对比分析最终的代码设计和UML模型设计之间的追踪关系。本次作业<strong>类图</strong>如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306131732858.svg" alt="Main" style="zoom: 33%;" /><p>程序核心为 <code>School</code> 类，它作为包含结构、处理请求的基底存在，包含多个字段和方法。</p><p>其左侧的是学校内含有的各个部门，它们在 <code>School</code> 类内的方法调用中出现，接收响应请求并处理，图中调用输出类 <code>PrintAction</code> 进行统一规格化输出。</p><p><code>School</code> 类右下侧的是学校包含的学生、书籍、请求。它们也在方法中被调用，完成相应属性、状态的转换。</p><p>第三次作业<strong>顺序图</strong>如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306131738146.svg" alt="SequenceDiagram1" style="zoom: 80%;" /><p>消息 1-10 是评测要求出现的从预定成功到获取书籍用到的顺序逻辑，再下面是其他正常需要用到的功能逻辑。 <code>Main</code> 类通过调用 <code>School</code> 类中的处理方法，实现对请求的初步处理，在处理方法中，<code>School</code> 类又利用自身字段进行具体的业务逻辑实现。</p><h1 id="架构设计思维的演进"><a href="#架构设计思维的演进" class="headerlink" title="架构设计思维的演进"></a>架构设计思维的演进</h1><h2 id="第一单元：递归下降与表达式处理"><a href="#第一单元：递归下降与表达式处理" class="headerlink" title="第一单元：递归下降与表达式处理"></a>第一单元：递归下降与表达式处理</h2><p>在第一单元，由于不了解层次化与架构的设计方式，课程组安排了多项式作为训练内容，它半强制地让我们使用层次化的程序结构进行编程，以此来加深我们对层次化设计的印象。层次化设计、递归下降和化简运算是本单元的重难点，也拉开了oo课程的帷幕。<del>（性能分从这里开始卷烂）</del></p><h2 id="第二单元：多线程设计与电梯调度"><a href="#第二单元：多线程设计与电梯调度" class="headerlink" title="第二单元：多线程设计与电梯调度"></a>第二单元：多线程设计与电梯调度</h2><p>第二单元，在我们已经初步了解层次化设计后，采用了多线程的方式进行考察。一方面，对共享数据的线程安全、多线程锁的应用等方面进行了考察；另一方面，电梯运行逻、请求分配、拆分调度等内部逻辑也是需要考虑的重点。我在本单元采用了黑板模式进行设计，中心黑板为调度器，通过单向的数据访问确保了线程安全；使用过程模拟来将请求分配到合适的电梯中。途中虽然遇到了诸多问题，第三次作业还出现了修到最后一刻也没修完的 bug，我还是觉得这是面向对象课程中设计最成功的一个单元。</p><h2 id="第三单元：JML-契约与社交网络模拟"><a href="#第三单元：JML-契约与社交网络模拟" class="headerlink" title="第三单元：JML 契约与社交网络模拟"></a>第三单元：JML 契约与社交网络模拟</h2><p>第三单元中，我们了解了一种表述 Java 程序需求的语言模型 JML。它通过格式化的要求，约定了需求提出者与程序实现者之间的契约。我们在 JML 的基础上进行了程序设计，模拟了一个社交网络，实现了与其相关的数据指标计算。很遗憾本单元在实现上偏离了 JML 单元设计的核心，而更注重了在执行需求下的程序性能，不幸地将 JML 单元变成了惨烈的算法单元。虽然这个单元的得分要比开始的两个单元要高，但是过程中的设计体验和实现过程并不如前者。</p><h2 id="第四单元：UML-模型与图书馆系统模拟"><a href="#第四单元：UML-模型与图书馆系统模拟" class="headerlink" title="第四单元：UML 模型与图书馆系统模拟"></a>第四单元：UML 模型与图书馆系统模拟</h2><p>第四单元，我们详细介绍了 UML 图与其对设计的引导作用。作为设计中十分重要的一环，绘制出 UML 类图对程序中类的设计、管理都有十分重要的作用。本单元以考察 UML 图的设计、程序功能实现为核心，在架构上并不做严格限制，详细考察了同学们对类图、状态图、顺序图绘制的能力。但稍有遗憾的是，单元第二次作业的功能增加过于复杂，许多要求与第一次作业发生冲突，难以迭代开发，迫不得已只能选择重构。并且功能描述不清，题干中许多情况也因为情况复杂而难以考虑周全，UML 步 JML 后尘，成了模拟功能的牺牲品。</p><h1 id="测试思维的演进"><a href="#测试思维的演进" class="headerlink" title="测试思维的演进"></a>测试思维的演进</h1><p>从第一次作业开始，直至第十三次作业，，中间的每一次作业都进行了测评机的构造，因为最后两次作业的数据限制较为复杂，保证不出现的情况较难通过设置规则在自动生成时规避，所以没有设计测评机。</p><p>最开始的测试使用 Python 语言编写，但是本身就没学过 py，所以效果不是很满意，于是后来选择迁移到 Java 上写测评。在设计测试程序的过程中不仅需要考虑到数据产生的合法性、是否符合数据限制、测试对于程序处理的覆盖性（分支、循环与边界），在写测试的过程中让我对自己的程序本身有了更完整的了解，能够明白坑点在哪里。但是由于测试程序基于我自己的思路来写的，所以可能不太容易找出自己的 bug，不过找别人的还是很灵（</p><h1 id="总结课程收获"><a href="#总结课程收获" class="headerlink" title="总结课程收获"></a>总结课程收获</h1><p>终于，oo 课程走到了尾声，这途中的十二次代码作业和四次博客作业对我而言都是十分珍贵的经历，在其中不仅初步掌握了 Java 语言的使用，还初窥了面向对象思想的门径。不同于大一时程设、DS这类面向过程编程的课程，oo 课利用多种场景教会了我面向对象、设计模式与其他的重要思想与技巧。虽然在课程的后半段出了点小问题，但课程的整体收获仍然十分充实。同时还告诉了我写程序时做测试的重要性。很遗憾因为时间问题我没有参选 oo 课程助教，但我也相信老师和新的助教们在新的一学年里能把 oo 课越办越好，办成干货满满的好课。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从负开始的 vue 学习 (1)</title>
      <link href="/2023/06/learning/vue_init/"/>
      <url>/2023/06/learning/vue_init/</url>
      
        <content type="html"><![CDATA[<h1 id="引入-vue"><a href="#引入-vue" class="headerlink" title="引入 vue"></a>引入 <code>vue</code></h1><blockquote><p><code>vue</code> 为我们提供了四种引入的方法，各有优劣。</p><p>截至23年6月，官网已经把 CLI 和 Vite 方法替换为了 <code>create-vue</code> ，也就是只有下面的第1和4项可选</p></blockquote><h2 id="CDN、引入-js文件"><a href="#CDN、引入-js文件" class="headerlink" title="CDN、引入.js文件"></a><code>CDN</code>、引入<code>.js</code>文件</h2><p>借助 <code>script</code> 标签直接通过 <code>CDN</code> 引入<strong>全体源码</strong>的方式来使用  <code>Vue</code> ，具体可参考 <code>vue3</code> 官方文档，不建议在大型项目中使用这种方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>在后面的引入方法中，通常要使用 <code>npm</code> 命令对项目进行构建/启动，所以要先在终端上安装<code>node.js</code>，确保 <code>npm</code> 命令能够正常使用，安装可以参考网上文档，这里不再赘述。</p></blockquote><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a><code>Vite</code></h2><p>通过 <code>Vite</code> 工具安装 <code>Vue</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When has npm 7+</span></span><br><span class="line">$ npm init vite@latest &lt;projectName&gt; -- --template vue</span><br><span class="line"></span><br><span class="line">$ npm install<span class="comment"># Install dependencies</span></span><br><span class="line">$ npm run dev<span class="comment"># Compile and run for development </span></span><br></pre></td></tr></table></figure><h2 id="CLI工具"><a href="#CLI工具" class="headerlink" title="CLI工具"></a><code>CLI</code>工具</h2><p><code>vue-cli</code> 脚手架使用 <code>webpack</code> 进行编译，比 <code>Vite</code> 构建的项目拥有更多的依赖与包，但同时速度比 <code>Vite</code> 要慢</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vue create my-project</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">$ vue ui<span class="comment"># Create GUI for projects</span></span><br></pre></td></tr></table></figure><p>大概是22-23年，<code>Vue CLI</code> 进入了“维护模式”，官方推荐通过基于<code>Vite</code>的新引入方式创建新项目</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303161731567.png" alt="image-20230316173109517"></p><h2 id="create-vue"><a href="#create-vue" class="headerlink" title="create-vue"></a><code>create-vue</code></h2><p><code>create-vue</code> 是 <code>Vue</code> 官方近来推荐的新脚手架工具，它基于 <code>Vite</code> 开发，安装上和原本的 <code>cli</code> 区别不大</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm init vue@latest</span><br><span class="line"><span class="comment"># Initing your project settings</span></span><br><span class="line">$ <span class="built_in">cd</span> &lt;your-project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>在<code>npm init</code>后，你将会看到一些诸如 <code>TypeScript</code> 和测试支持之类的可选功能提示（全No也能跑）</p><p>不得不说现在这新界面比原来好看多了，当然内容也更复杂了</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306121258805.png" alt="image-20230612125759650" style="zoom: 33%;" /><h1 id="创建一个应用"><a href="#创建一个应用" class="headerlink" title="创建一个应用"></a>创建一个应用</h1><blockquote><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p></blockquote><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>在我们创建 vue 应用时，都是通过 <code>createApp</code> 函数创建一个新的<strong>应用实例</strong>并使用， <code>main.js</code> 内会包含这样一句话：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里的 <code>createApp</code> 就通过 <code>App</code> 的数据<strong>创建了一个 vue 应用</strong>，并把这个应用 <code>mount</code> 进 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 这个 DOM 内，最后再把这个 DOM 写入 html 文件，实现元素的展示。</p><h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h2><p>还是同样的例子，我们传入 <code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p><p>单文件组件可以直接从文件中 <code>import</code> 根组件使用</p><h2 id="应用挂载"><a href="#应用挂载" class="headerlink" title="应用挂载"></a>应用挂载</h2><p>应用实例必须在调用了 <code>.mount()</code> 方法后才会渲染出来。该方法接收一个“<strong>容器</strong>”参数，可以是一个实际的 <strong>DOM 元素</strong>或是一个 CSS 选择器字符串</p><p><code>.mount(&quot;#app&quot;)</code> 的容器就是一个 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 的 DOM 元素，经过 <code>createApp</code> 后产生的组件内容将会渲染在这个 DOM 元素中。</p><p><code>.mount()</code> 方法应该始终在整个应用配置和资源注册完成后被调用。</p><blockquote><p>同时请注意，不同于其他资源注册方法，它的返回值是<strong>根组件实例</strong>而非<strong>应用实例</strong>。也就是说，它会返回一个 <code>App</code> 元素（<code>createApp</code> 后产生的<strong>根组件实例</strong>）</p></blockquote><p>总结来说：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">应用实例   根元素  挂载  <span class="variable constant_">DOM</span> 元素</span><br></pre></td></tr></table></figure><h2 id="组件实例-property"><a href="#组件实例-property" class="headerlink" title="组件实例 property"></a>组件实例 <code>property</code></h2><p>我们通过组件选项，将用户定义的 <code>property</code> 添加到组件实例中，例如 data, methods, props, computed, inject, setup 等。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default(</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">      num: 1,</span><br><span class="line">       able: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>组件实例定义的所有 <code>property</code> 都可以在组件的<strong>模板</strong>（<code>template</code>）中进行访问</p><p>Vue 还在组件中定义了一部分内置 <code>property</code> ，它们在开头有一个 <code>$</code> 用于与用户定义的 <code>property</code> 相区分</p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><blockquote><p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据<strong>绑定</strong>到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。</p></blockquote><p>vue 会自动将模板 template 编译为优化的 js 代码，当元素变动时会动态地更改渲染的操作，实现实时变动。</p><h2 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h2><p>文本插值，是最基础的数据绑定形式，使用双大括号进行绑定声明，这被称为 <code>Mustache</code> 语法。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>双大括号内的内容会被替换为<strong>组件实例中</strong>对应的属性的值，同时绑定的值也会随着属性的更改而实时更新。如果想要单次绑定，不进行更新，则需要使用 <code>v-once</code> 指令进行绑定：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span v-once&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="原始-html"><a href="#原始-html" class="headerlink" title="原始 html"></a>原始 html</h2><p>若直接将数据通过 <code>Mastache</code> 的文本形式进行绑定，将视为直接输出字符串。如果字符串是 <code>html</code> 代码，并想要其根据 <code>html</code> 格式显示，需要使用 <code>v-html</code> 指令进行绑定：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span v-html=&quot;prop1&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">span1: &quot;&lt;span style=&quot;color: red&quot;&gt; red &lt;/span&gt;&quot;</span><br></pre></td></tr></table></figure><blockquote><p>请仅在内容安全可信时再使用 <code>v-html</code>，并且<strong>永远不要</strong>使用用户提供的 HTML 内容。</p></blockquote><h2 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h2><p>通过 <code>v-bind</code> 指令，可以动态地绑定一个标签，它指示 Vue 将元素的 <code>id</code> 标签与组件的指定属性保持一致。</p><p>可以用 <code>:attribute</code> 进行简写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-bind:id=&quot;dyid1&quot;&gt;id&lt;/p&gt;</span><br><span class="line">&lt;p :id=&quot;dyid1&quot;&gt;id&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 上下两行效果一致，id 会动态绑定为 dyid1 包含的内容 --&gt;</span><br></pre></td></tr></table></figure><h2 id="Mustache-amp-js-表达式"><a href="#Mustache-amp-js-表达式" class="headerlink" title="Mustache &amp; js 表达式"></a>Mustache &amp; js 表达式</h2><p>Vue 在下面两种数据绑定内都支持完整的 JavaScript 表达式，但只能出现单一的表达式，语句、多表达式是不合法的输入。</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><blockquote><p>指令是带有 <code>v-</code> 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 <code>v-bind</code> 和 <code>v-html</code>。</p></blockquote><p>指令的期望值为一个 JavaScript 表达式 (除 <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code> 外)</p><p>指令的任务是在其表达式的值变化时<strong>实时更新</strong> DOM。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</span><br></pre></td></tr></table></figure><p><code>seen</code> 作为 bool 变量，通过 <code>v-if</code> 控制当前元素的存在与否</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指令名冒号后的内容表示为参数，在 <code>v-bind</code> 中告知绑定的 attribute 是谁，在 <code>v-on</code> 中表示监听的事件名称（使用 <code>@</code> 进行缩写）</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab6-Challenge</title>
      <link href="/2023/06/os/buaa-os-challenge-lab6/"/>
      <url>/2023/06/os/buaa-os-challenge-lab6/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab6-挑战性任务"><a href="#Lab6-挑战性任务" class="headerlink" title="Lab6 挑战性任务"></a>Lab6 挑战性任务</h1><h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>在 Lab6 的后半程，我们在 MOS 上实现了一个基本的外部指令 Shell，其能够通过不断创建 <code>sh.c</code> 的进程，并调用其他文件来处理用户指令。在 Lab6 的挑战任务中，我们要在这基础上对 Shell 进行迭代开发，使其能完成更丰富的服务要求。</p><h1 id="实现一行多命令"><a href="#实现一行多命令" class="headerlink" title="实现一行多命令"></a>实现一行多命令</h1><blockquote><p>用 <code>;</code> 分开同一行内的两条命令，表示<strong>依次</strong>执行前后两条命令。<code>;</code> 左右的命令都可以为空。</p></blockquote><p>在 Linux 的控制台中也支持这样的指令，例如在控制台输入如下指令会有对应的现象：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029503.png" alt="image-20230607102927426"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029406.png" alt="image-20230607102937379"></p><p>可以看到先实现了 <code>clear</code> 操作，后进行了 <code>echo</code> 操作。</p><p>我们要求，用 <code>;</code> 隔开的两条指令必须有执行的先后顺序，即<strong>先执行左侧指令，后执行右侧指令</strong>。利用 <code>gettoken</code> 中自支持的 <code>;</code> 在 <code>parsecmd</code> 中新添加判断分支即可实现对 <code>;</code> 的识别。</p><p>由于执行两条指令，并保证指令执行的先后顺序，则需要先 <code>fork</code> 进程并执行左侧指令，使用 <code>wait</code> 等待其执行完后再继续解析右侧指令（重复 <code>parsecmd</code> 即可）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    debugf(<span class="string">&quot;parsed &#x27;;&#x27;, created %x\n&quot;</span>, *rightpipe);</span><br><span class="line">                    wait(*rightpipe);</span><br><span class="line"></span><br><span class="line">                    close(<span class="number">0</span>);close(<span class="number">1</span>);</span><br><span class="line">                    dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><ul><li>upd 23.6.16：这里需要处理重定向的问题，以防左侧指令修改了输出 fd ，但右侧指令的 fd 不仅没有恢复为控制台，修改的 fd 还被左侧指令关了的情况。所以需要调 <code>opencons</code> 把控制台重新开开，并且 <code>dup</code> 给两个 fd。</li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>为了体现 shell 的两条指令是分开执行的，这里采用不会实时结束的 <code>cat.b</code> 作为左端指令.</p><p>当运行 <code>cat.b</code> 并输入 <code>Ctrl + D</code> 时，应该继续右侧指令的解析与执行。现试输入 <code>cat.b ; ls.b</code> 和不包含单侧指令的数据测试功能：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat.b ; ls.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3004       // 识别到 <span class="string">&#x27;;&#x27;</span>，并创建新 Shell 3004</span><br><span class="line">llaabb66CChhaalllleennggee     // cat.b 执行内容，使用 Ctrl + D 结束</span><br><span class="line">[00003805] destroying 00003805 // cat.b 执行结束，终止其进程 3805</span><br><span class="line">[00003805] free <span class="built_in">env</span> 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004 // 子 Shell 执行完毕，终止其进程 3004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b // ls.b 执行内容</span><br><span class="line">[00004004] destroying 00004004 // ls.b 执行结束，终止其进程 4004</span><br><span class="line">[00004004] free <span class="built_in">env</span> 00004004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803 // 原 Shell 执行完毕，终止其进程 2803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ... </span><br><span class="line">$ cat.b;</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 5004</span><br><span class="line">ssssssssss</span><br><span class="line">[00005805] destroying 00005805</span><br><span class="line">[00005805] free <span class="built_in">env</span> 00005805</span><br><span class="line">i am killed ... </span><br><span class="line">[00005004] destroying 00005004</span><br><span class="line">[00005004] free <span class="built_in">env</span> 00005004</span><br><span class="line">i am killed ... </span><br><span class="line">[00004803] destroying 00004803 // 原有 Shell 无命令处理，直接终止进程 4803</span><br><span class="line">[00004803] free <span class="built_in">env</span> 00004803</span><br><span class="line">i am killed ... </span><br><span class="line"></span><br><span class="line">$ ;cat.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 6804</span><br><span class="line">[00006804] destroying 00006804 // 子 Shell 无命令处理，直接终止进程 6804</span><br><span class="line">[00006804] free <span class="built_in">env</span> 00006804</span><br><span class="line">i am killed ... </span><br><span class="line">aaaaaa</span><br><span class="line">[00007004] destroying 00007004</span><br><span class="line">[00007004] free <span class="built_in">env</span> 00007004</span><br><span class="line">i am killed ... </span><br><span class="line">[00006003] destroying 00006003</span><br><span class="line">[00006003] free <span class="built_in">env</span> 00006003</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><p>测试中 Shell 均能正常回显，可认为功能实现。</p><h1 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h1><blockquote><p>用 <code>&amp;</code> 分开同一行内的两条命令，表示<strong>同时</strong>执行前后两条命令。<code>&amp;</code> 左侧的命令应被置于后台执行，Shell 只等待 <code>&amp;</code> 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出。</p><p><strong>左侧命令不可为空</strong>。</p></blockquote><p>与 <code>;</code> 类似，<code>&amp;</code> 也要求实现两条指令的运行，但是要求其同时运行，只等待右侧指令。处理时同样要修改 <code>parsecmd</code> 的 <code>switch</code>，在这里要额外注意不要用 <code>rightpipe</code> 承载 <code>fork</code> 的返回值了。因为在 <code>runcmd</code> 中需要等待 <code>rightpipe</code> 执行结束才能完成，而 Shell 应该只等待右侧命令的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            debugf(<span class="string">&quot;parsed &#x27;&amp;&#x27;, created %x\n&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line"><span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;redirction_1: open file in shell failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd = r;</span><br><span class="line">dup(fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>不知道怎么测试合适，就先不测了（</p><h1 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h1><blockquote><p>实现引号支持后，shell 可以处理如： <code>echo.b &quot;ls.b | cat.b&quot;</code> 这样的命令。即 shell 在解析时，会将双引号内的内容看作单个字符串，将 <code>ls.b | cat.b</code> 作为一个参数传递给 <code>echo.b</code></p></blockquote><p>实质上我们要把引号中的这些内容当作一个 <code>w</code> 类型处理，所以与其修改 <code>parsecmd</code> 的逻辑，不如直接从 <code>_gettoken</code> 入手，直接把引号处理成一个内容再返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; _gettoken</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;parsed &#x27;\&quot;&#x27;: begin\n&quot;</span>);</span><br><span class="line">s++;</span><br><span class="line">*p1 = s;</span><br><span class="line">debugf(<span class="string">&quot;parsed: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (*s &amp;&amp; *(s++) != <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;%c&quot;</span>, *(s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">*(s - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">*p2 = s;</span><br><span class="line">debugf(<span class="string">&quot;\nparsed &#x27;\&quot;&#x27;: end\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体实现相对简单，可以参照前后的解析方式，在面向对象第一单元的解析器也是一个道理（划</p><p>需要注意的就是 <code>p1</code> 和 <code>p2</code> 两个指针的定位， <code>p1</code> 应该指向 token 的起始字符，而 <code>p2</code> 应该指向 token 结束后的下一个字符；还有就是引号这个符号是要去掉的，也不要忘记用 0 将引号内的部分截断。</p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试主要看能否把引号内包含的 <code>SYMBOL</code> 正确解析为字符即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b <span class="string">&quot;sh.b | cat.b&quot;</span></span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: begin</span><br><span class="line">parsed: sh.b | cat.b</span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: end</span><br><span class="line">sh.b | cat.b</span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><h1 id="实现键入命令时任意位置的修改"><a href="#实现键入命令时任意位置的修改" class="headerlink" title="实现键入命令时任意位置的修改"></a>实现键入命令时任意位置的修改</h1><blockquote><p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p></blockquote><p>在 MOS 的 Shell 中，我们设计了 <code>readline</code> 函数处理指令的输入，它实际上利用了一个控制台，并从中逐个读取字符，从而解析读入的字符串。设计的核心，读入实际上一次只向目标缓冲区 <code>buf</code> 中读取一个字符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(<span class="number">0</span>, buf + i, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>因为 <code>readline</code> 会直接向表示指令的 <code>buf</code> 中直接写入内容，当我们想要删除时可能会稍显麻烦，于是我们采用一个临时的 <code>char</code> 保存每次 <code>read</code> 获得的字符，并根据其值判断下一步该如何处理。由于在判断应该如何回显时需要注意光标的位置，所以我们用一个变量 <code>i</code> 代表光标所在下标，用变量 <code>len</code> 代表已经读入 <code>buf</code> 的总长度。在此基础上修改 <code>readline</code> 函数使其支持原生功能应该不是难事，不再赘述。</p><p>首先我们来处理<strong>键入光标时的左右移动</strong>。</p><p>在终端中，ANSI 标准声明左右方向键分别为 <code>\033[D</code> 和 <code>\033[C</code>，也就是说，在向控制台输入 “←” 时，实际上会<strong>解析成三个字符</strong>，即 <code>\033</code> 、<code>[</code>、 <code>D</code> 。那么我们就对暂时读入的字符（称为 <code>temp</code>）进行判断，如果是 <code>\033</code>，就进入方向键的判断，连续获取到左、右键代表的三个字符后，才能令光标变量做出对应的修改。</p><p>还有一点需要注意：光标在 0 字符时的 ← 与 光标在末端字符的 → 需要考虑其处理方式，首先不能修改光标变量的值了，否则会造成越界；其次可以让控制台显示的光标停在原地，这样就不会跑到左边的 <code>$</code> 字符那里了（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123;          <span class="comment">// get input ←</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;            <span class="comment">// have space for cursor to move left</span></span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[C&quot;</span>);   <span class="comment">// print a reverse arrow to pull back the cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;  <span class="comment">// get input →</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) &#123;         <span class="comment">// have space for cursor to move right</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[D&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>随后处理移动后的插入与删除。实际上我们实现的核心在这里就变成了字符串的操作，还有就是如何在终端上覆盖旧字符串，显示正确的新字符串。</p><p>注意到， <code>BackSpace</code> 键的 ASCII 码为 127 （<code>0x7f</code>），而在原程序的循环中已经为我们判断了 <code>buf[i] == 0x7f</code> 的分支判断，我们需要先删掉它然后新开一个 <code>case</code> （</p><p>类似的，<code>Delete</code> 键在读入时和 <code>~</code> 键的 ASCII 相同，所以也要做响应的处理，注意退格位置不同</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x7f</span>:</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;                   <span class="comment">// cursor at left bottom, ignore backspace</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = (--i); j &lt;= len - <span class="number">1</span>; j++) &#123; <span class="comment">// move chars already in buf</span></span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;                          <span class="comment">// cut the last char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, (i + <span class="number">1</span>), buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;~&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (i == len) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, i, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \033[%dD&quot;</span>, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>最后的 <code>printf</code> 用处是覆盖原有的字符串，再把新的字符串打印上去，打印后再控制光标的位置。这个操作可以分成三部分：</p><ul><li><code>\033[%dD</code>：终端的光标向左移动 <code>i + 1</code> 个字符</li><li><code>%s&lt;space&gt;</code>：把新字符串从光标所在处打印出来，<strong>追加一个空格</strong>（因为删除后字符串变短，需要覆盖掉多出来的一个字符）</li><li><code>\033[%dD</code>：终端的光标向左移动 <code>len - i + 1</code> 个字符</li></ul><p>至于为什么移动的字符是这些值，可以拿笔试一试，主要还是为了保证光标的位置不发生改变</p><h2 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试过程中发现如果网络不太稳定，就会输出 <code>[D</code> 之类的字符，不太理解原因，初步推断可能是因为传输字符速度慢，被解析成了分开的三个字符进行输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ha2Dhal3Dha[2Dh[1Djhalt</span><br><span class="line">spawn jhalt: -10</span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><h1 id="实现程序名称中-b-的省略"><a href="#实现程序名称中-b-的省略" class="headerlink" title="实现程序名称中 .b 的省略"></a>实现程序名称中 <code>.b</code> 的省略</h1><blockquote><p>目前的用户程序被烧录到文件系统中后，其可执行文件以 <code>.b</code> 为后缀，为 shell 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 <code>.b</code> 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 <code>.b</code> 再打开。</p></blockquote><p>比较简单的一个小功能。</p><p>在 Shell 中具体运行外部命令的原理是创建一个子进程，加载命令对应的 ELF 文件，传递相应参数，然后 Shell 等待子进程上加载的程序运行结束后再循环执行。在创建子进程时，我们用到的是在 <code>runcmd</code> 中使用的 <code>spawn</code>，其参数为 <code>argv[0]</code>。我们只需要在打开 <code>argv[0]</code> 失败后再尝试打开追加 <code>.b</code> 后的 <code>argv[0]</code> 即可。如果仍然无法打开，说明指令名错误。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> child;</span><br><span class="line"><span class="keyword">if</span> ((child = spawn(argv[<span class="number">0</span>], argv)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">strcpy</span>(name, (<span class="type">const</span> <span class="type">char</span> *) argv[<span class="number">0</span>]);</span><br><span class="line">    name[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// add &#x27;.b&#x27; to old filename</span></span><br><span class="line">    child = spawn(name, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h2><p>尝试省略文件中的 <code>.b</code> 后进行调用，效果如下（已省略进程销毁输出）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">echo</span> aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b </span><br></pre></td></tr></table></figure><h1 id="实现更丰富的命令"><a href="#实现更丰富的命令" class="headerlink" title="实现更丰富的命令"></a>实现更丰富的命令</h1><blockquote><p>参考实验环境中的 Linux 命令 <code>tree</code>、<code>mkdir</code>、<code>touch</code> 来实现这三个命令，请尽可能地实现其完整的功能。</p></blockquote><h2 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a><code>tree</code> 命令</h2><p><code>tree</code> 命令，用于输出指定路径的文件树，使用字符码进行树状表示的生成。</p><p>本次实现的 <code>tree</code> 命令包括一个参数的实现：</p><blockquote><p><code>-d</code>：只输出目录文件，省略非目录的输出</p></blockquote><p>输出指定目录的文件树，可以分成以下几部分：</p><ul><li>打开指定目录的文件控制块</li><li>遍历目录中的每个文件，并进行输出</li><li>递归地对每个<strong>目录</strong>重复第二步，直至不存在子目录</li></ul><p>在这里需要注意输出的形式，由于需要保持缩进，于是我们在递归的过程中需要保留文件的深度；又由于目录中最后一个文件需要输出 <code>└──</code> 而不是 <code>├──</code> ，所以需要判断当前输出的文件是不是目录中的最后一个文件。同时需要注意输出缩进时的输出格式，如果不是本目录最后一个文件，中途的文件夹也应该输出 <code>│</code>，否则会出现以下的状况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">├── testa</span><br><span class="line">    ├── testb</span><br><span class="line">        └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line">└── testb</span><br></pre></td></tr></table></figure><p>很显然 <code>testa</code> 文件夹中输出时没有输出最开头的 <code>│</code>，应该判断是不是最后一个文件，并且补上</p><p>一个更复杂的情况如下，不过这次的输出是正确的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testa $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">│   └── a</span><br><span class="line">├── b</span><br><span class="line">│   ├── a</span><br><span class="line">│   ├── b</span><br><span class="line">│   │   └── c.c</span><br><span class="line">│   └── c.c</span><br><span class="line">└── c</span><br><span class="line">    ├── c.c</span><br><span class="line">    └── a</span><br><span class="line">        └── c.c</span><br></pre></td></tr></table></figure><ul><li>注意 a b 两文件夹下的内容输出时，必须在第一个字符输出 <code>│</code>，而 c 文件夹下内容则相反</li><li>内层文件夹也要递归地遵守这个规则</li></ul><p>输出使用到的函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printFile</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> depth, <span class="type">int</span> pos, <span class="type">int</span> isDir)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出预留的缩进</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; depth; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (poss[i] == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;│   &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos = 1 即最后一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;├── &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;└── &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDir == <span class="number">1</span>) &#123;      <span class="comment">// 目录文件会输出为蓝色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m\n&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfsFile</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fdnum, size, va, j, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fdnum = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;open %s: %d&quot;</span>, path, fdnum); &#125;</span><br><span class="line">    fd = (<span class="keyword">struct</span> Fd *) num2fd(fdnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">struct</span> Filefd *) fd)-&gt;f_file.f_type != FTYPE_DIR) &#123;</span><br><span class="line">        fileCount++; <span class="comment">// 对文件计数，并返回（不存在子目录）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dircCount++; <span class="comment">// 对目录计数，准备输出其内的所有文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ((<span class="keyword">struct</span> Filefd *)fd)-&gt;f_file.f_size;</span><br><span class="line">    va = (<span class="type">int</span>) fd2data(fd);</span><br><span class="line">    <span class="comment">// 遍历目录中的每个文件（文件控制块）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2FILE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> File *) (va + i);</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得完整的路径名，为递归调用预留</span></span><br><span class="line">        <span class="type">char</span> fullPath[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(fullPath, path);</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(fullPath);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(file-&gt;f_name); j++) &#123;</span><br><span class="line">            fullPath[len + j] = file-&gt;f_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fullPath[len + j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否达到目录末尾，控制输出中的 &#x27;pos&#x27; 变量</span></span><br><span class="line">        <span class="type">int</span> pos = (i == size || (file + <span class="number">1</span>)-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="number">1</span> || file-&gt;f_type == FTYPE_DIR) &#123;</span><br><span class="line">            poss[depth] = pos; <span class="comment">// 把当前层是否为最后一个文件的状态保存，输出时使用</span></span><br><span class="line">            printFile(file-&gt;f_name, depth, pos, (file-&gt;f_type == FTYPE_DIR));</span><br><span class="line">        &#125;</span><br><span class="line">        dfsFile(fullPath, depth + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, fullPath);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要注意的是判断到达目录末尾的方式，一个是遍历到了目录的最后一个控制块，或者是下一个控制块<strong>名称为空</strong>（名称为空意味着文件不存在）</li></ul><p>顶层的调用函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tree</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入文件类型</span></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(path, &amp;st)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;stat %s: %d&quot;</span>, path, r); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123; user_panic(<span class="string">&quot;%s is not a directory!&quot;</span>, path); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 开始递归</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    dfsFile(path, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后需要对输出进行计数</span></span><br><span class="line">    <span class="keyword">if</span> (directory == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories\n&quot;</span>, dircCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories, %d files\n&quot;</span>, dircCount, fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后文件的 <code>main</code> 函数可以封装如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ARGBEGIN &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            directory = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; ARGEND</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(argc == <span class="number">0</span>)</span> &#123; <span class="comment">// 默认为根目录</span></span><br><span class="line">        tree(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         <span class="comment">// 选定指定目录</span></span><br><span class="line">        tree(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 <code>tree.c</code> 后，需要回到 <code>user</code> 目录中修改 <code>include.mk</code>，在 <code>USERAPP</code> 中把 <code>tree.b</code> 加进去，这样刚写完的文件就会编译并烧录进磁盘了，这样就可以使用了</p><h2 id="mkdir-amp-touch-命令"><a href="#mkdir-amp-touch-命令" class="headerlink" title="mkdir &amp; touch 命令"></a><code>mkdir</code> &amp; <code>touch</code> 命令</h2><p>其实两个命令实现的功能类似，唯一差异在创建文件后的文件类型 <code>f_type</code>：<code>mkdir</code> 需要 <code>FTYPE_DIR</code> ， <code>touch</code> 则是 <code>FTYPE_REG</code></p><p>内核中其实已经在 <code>fs/fs.c</code> 中预留好了创建文件的函数，但是没有向用户态提供接口。我们可以通过新增 <code>fsipc</code> 类型从而让文件服务函数调用这个接口，从而实现文件的创建</p><p>Lab5 Probe 中已经详细介绍过创建 <code>fsipc_*</code> 的过程了，这里就只写代码了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/fsreq.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CREATE 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int f_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/fsipc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int f_type, <span class="keyword">struct</span> Fd* fd)</span> &#123;</span><br><span class="line">    u_int perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    req = (<span class="keyword">struct</span> Fsreq_create *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The path is too long.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">    req-&gt;f_type = f_type;</span><br><span class="line">    <span class="keyword">return</span> fsipc(FSREQ_CREATE, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (req) &#123;</span><br><span class="line">    <span class="keyword">case</span> FSREQ_CREATE:</span><br><span class="line">        serve_create(whom, (<span class="keyword">struct</span> Fsreq_create *)REQVA);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// touch 和 mkdir 的区别仅限于此，所以只需要控制这个值的传递就能实现两个函数</span></span><br><span class="line">    f-&gt;f_type = rq-&gt;f_type;</span><br><span class="line">    ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pfile)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, u_int, <span class="keyword">struct</span> Fd *)</span>;</span><br></pre></td></tr></table></figure><p>以上便创建了创建文件的 <code>fsipc</code> 请求。接下来两个函数实际上是对这个请求的调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unimplemented open modes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT 0x0100 <span class="comment">/* create if nonexistent */</span></span></span><br></pre></td></tr></table></figure><p>我们利用上面这个定义，对 <code>open</code> 函数做一些改动，使得当传入函数的 <code>omode</code> 包含 <code>O_CREAT</code> 时，就会触发文件创建的过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Prepare the &#x27;fd&#x27; using &#x27;fsipc_open&#x27; in fsipc.c.</span></span><br><span class="line">    <span class="comment">/* Exercise 5.9: Your code here. (2/5) */</span></span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; O_CREAT) == <span class="number">0</span>) &#123;   <span class="comment">// 如果不包含 O_CREAT 走正常的路线，不进行变动</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                       <span class="comment">// mkdir &amp; touch</span></span><br><span class="line">        mode &amp;= ~O_CREAT;</span><br><span class="line">        <span class="comment">// 如果打开文件失败就进行文件创建，反之则报错（已存在文件，不能再创建）</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fsipc_create(path, mode, fd); <span class="comment">// mode = f_type</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// already exist.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>当进入 <code>else</code> 分支时，此时的 <code>mode</code> 就不再是代表文件打开的方式了，它代表的是创建文件的类型，我们在这里不修改 <code>open</code> 的参数数量，而通过 <code>mode</code> 这个参数进行额外信息的传递</li></ul><p>最后顶层封装两个功能函数，加入相关的函数声明，并在对应的文件的 <code>main</code> 方法中调用即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c (实现在哪里其实不影响)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = open(path, O_CREAT | FTYPE_DIR)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir: path %s already exist!\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir %s: %d\n&quot;</span>, path, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-Shell-中重定向符的实现"><a href="#修改-Shell-中重定向符的实现" class="headerlink" title="修改 Shell 中重定向符的实现"></a>修改 Shell 中重定向符的实现</h2><p>在 Linux 的 Shell 中，我们可以通过重定向符 <code>&gt;</code> 将输出重定向到文件中，我们的 MOS 也可以实现类似的操作，但是不能创建新文件并进行输入，我们在这里对 <code>sh.c</code> 文件进行修改，使其能实现此功能</p><p>实现要点就是在原有要打开文件的地方进行判断，如果打开失败了就追加一句创建文件的函数</p><p>注意要<strong>再调用一次 <code>open</code></strong> 以传递新创建文件的文件管理符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Open &#x27;t&#x27; for writing, dup it onto fd 1, and then close the original fd.</span></span><br><span class="line">    <span class="comment">/* Exercise 6.5: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = touch(t)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;redirction_2: create file in shell failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;redirction_2: open file in shell failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = r;</span><br><span class="line">    dup(fd, <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user_panic(&quot;&gt; redirection not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h2><p>三个函数的功能可以相互验证：先通过 <code>touch</code>、<code>mkdir</code> 创建新的文件/目录，再调用 <code>tree</code> 对这些文件的存在和位置进行检查，如果 <code>tree</code> 能检查并正确输出，说明文件创建和文件树的功能都是正常的。下面的输出隐藏了进程销毁信息</p><ul><li>本处的功能测试已经完成了相对目录的实现，故输入使用了相对目录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> b.c</span><br><span class="line">created file: b.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a.c</span><br><span class="line">created file: a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa</span><br><span class="line">created path: /testdir/testa</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa/testb</span><br><span class="line">created path: /testdir/testa/testb</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/testb/a.c</span><br><span class="line">created file: testa/testb/a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/test.c</span><br><span class="line">created file: testa/test.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">└── testa</span><br><span class="line">    ├── testb</span><br><span class="line">    │   └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line"></span><br><span class="line">3 directories, 5 files</span><br></pre></td></tr></table></figure><h1 id="实现历史命令功能"><a href="#实现历史命令功能" class="headerlink" title="实现历史命令功能"></a>实现历史命令功能</h1><blockquote><p>在 Linux 的 shell 中我们输入的命令都会被保存起来，并可以通过 Up 和 Down 键回溯，这为我们的 shell 操作带来了极大的方便。在此项任务中，需要实现保存所有输入至 shell 的命令，并可以通过 <code>history.b</code> 命令输出所有的历史命令，以及通过上下键回溯命令并运行。</p></blockquote><p>实现这个功能的要点如下：</p><ul><li>首先需要在 <code>sh.c</code> 中调用 <code>touch</code> 函数生成 <code>.history</code> 文件</li><li>将每条解析的命令都输入进 <code>.history</code> 文件中，这里需要额外实现<strong>文件的追加写入</strong></li><li>在输入中实现对 Up/Down 键的识别，并回显对应的指令</li><li>实现 <code>history.c</code> 的 <code>history</code> 功能，读取 <code>.history</code> 文件，显示全部历史命令</li></ul><h2 id="history-文件的生成"><a href="#history-文件的生成" class="headerlink" title=".history 文件的生成"></a><code>.history</code> 文件的生成</h2><p>当我们在解析指令结束后，应该对指令进行保存，如果是第一次解析，则需要额外创建一个存放历史指令的 <code>.history</code> 文件。在这里我们使用一个变量 <code>int hisCount = 0</code> 表示已经处理过的历史指令数，当历史为空则进行文件的创建。</p><p>与光标的左右移动类似，我们需要一个表示当前指令所处行数的变量 <code>int curLine = 0</code>，用以指明当前输入显示的行数</p><h2 id="文件的追加输入模式-O-APPEND"><a href="#文件的追加输入模式-O-APPEND" class="headerlink" title="文件的追加输入模式 - O_APPEND"></a>文件的追加输入模式 - <code>O_APPEND</code></h2><p>在 MOS 系统中，我们只实现了从头打开文件，即 <code>f_offset = 0</code> 的打开方式，在这里为了便于我们对 <code>.history</code> 文件的输入，试实现文件的追加输入模式：<code>O_APPEND</code> 。</p><p>由于 <code>O_APPEND</code> 只是指定了文件打开时的偏移指针位置，原则上我们仍需要控制文件的打开方式。为了不遮盖原本的打开方式，可以把 <code>O_APPEND</code> 的控制位放大一点，以实现应有的功能。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_APPEND 0X00002000 <span class="comment">/* open file and redirect cursor to the last char */</span></span></span><br></pre></td></tr></table></figure><p>设置好后，接下来需要修改 <code>open</code> 函数以识别 <code>O_APPEND</code>，并尝试在文件服务进程中的 <code>serve_open</code> 函数中实现对偏移指针的定位，这样我们就不需要再更改 <code>open</code> 函数的逻辑了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c -&gt; serve_open</span></span><br><span class="line"></span><br><span class="line">o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add here for O_APPEND</span></span><br><span class="line"><span class="keyword">if</span> (o-&gt;o_mode &amp; O_APPEND) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fff</span> =</span> (<span class="keyword">struct</span> Fd *) ff;</span><br><span class="line">fff-&gt;fd_offset = f-&gt;f_size; <span class="comment">// redirect the file pointer</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到 <code>sh.c</code>，完成写入历史命令和回显的功能。为了便于快速找到对应的指令数，我们事先实现一个数组 <code>int hisBuf</code>，其内存放第 $i$ 条指令所占的字节数，便于我们在 <code>.history</code> 中快速找到指定的行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisCount, curLine;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisBuf[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p>然后在 <code>sh.c</code> 内实现一个快速读取第 <code>target</code> 行指令的函数，将其存入 <code>code</code> 指向的空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readPast</span><span class="params">(<span class="type">int</span> target, <span class="type">char</span> *code)</span> &#123;</span><br><span class="line"><span class="type">int</span> r, fd, spot = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">10240</span>];</span><br><span class="line"><span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G1&quot;</span>);<span class="keyword">return</span> fd; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target; i++) &#123;</span><br><span class="line">spot += (hisBuf[i] + <span class="number">1</span>); <span class="comment">// + &#x27;\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((r = readn(fd, buff, spot)) != spot) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G2&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">if</span> ((r = readn(fd, code, hisBuf[target])) != hisBuf[target]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G3&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">if</span> ((r = close(fd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G4&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">code[hisBuf[target]] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先读取 0 ~ target - 1条指令，并丢弃，然后读取第 target 条指令，保存在传入的参数 <code>code</code> 内。读取前面指令时需要根据预设的 <code>hisBuf</code> 控制读取的字符数，需要注意每一条语句后面都存放一个 <code>\n</code> 用以区分，所以需要多读一个字符。</li></ul><h2 id="历史指令的写入"><a href="#历史指令的写入" class="headerlink" title="历史指令的写入"></a>历史指令的写入</h2><p>相对简单的一部分。</p><p>当 Shell 检测到 换行符时，便会判断指令输入的结束，从而开始解析，我们就从这里开始写入历史命令。</p><p>在 <code>readline</code> 函数的 <code>switch</code> 分支内，针对 <code>case &#39;\r&#39;</code> 与 <code>case &#39;\n&#39;</code> 需要做写入文件的操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;hisCount: %d\n&quot;, hisCount);</span></span><br><span class="line">        <span class="keyword">if</span> (hisCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = touch(<span class="string">&quot;/.history&quot;</span>)) != <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hisFd;</span><br><span class="line">        <span class="keyword">if</span> ((hisFd = open(<span class="string">&quot;/.history&quot;</span>, O_APPEND | O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, buf, len)) != len) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)) != <span class="number">1</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = close(hisFd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        hisBuf[hisCount++] = len;</span><br><span class="line">        curLine = hisCount; </span><br><span class="line"><span class="comment">// cannot &#x27;curLine++&#x27;, otherwise usable instrctions will be [0, curLine + 1]</span></span><br><span class="line">        <span class="built_in">memset</span>(curIn, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(curIn));</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>这里要在每一条指令写入后追加一个和常规指令有区分的字符，为了方便这里就选了 <code>\n</code>，原因可以在 <code>history</code> 功能实现时再看。再注意写入时使用刚刚写好的（追加 + 只写）即可。</li><li>当按下回车时，不能简单地让 <code>curLine++</code> ，因为可能当前 <code>curLine</code> 并不在最底端，此时错误的自增操作会让 <code>curLine</code> 的值出错 </li></ul><h2 id="up-down-键的识别-amp-指令回显"><a href="#up-down-键的识别-amp-指令回显" class="headerlink" title="up/down 键的识别 &amp; 指令回显"></a>up/down 键的识别 &amp; 指令回显</h2><p>最后修改 <code>readline</code> 的逻辑，需要在键入方向键的分支处继续判断。同时为了能够恢复当前已经输入的字符，我们把已输入的字符也存入一个缓冲的字符数组 <code>char curIn</code> 内，在按下 down 键时视情况回显。</p><p>每次回显，都需要实时变动 <code>buf</code> 的内容，也包括显示的光标位置。因为我们可能会在此基础上修改 <code>buf</code>，或直接运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; readline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123; <span class="comment">// have space for left</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">// up</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[B&quot;</span>);     <span class="comment">// 恢复光标位置</span></span><br><span class="line">            <span class="keyword">if</span> (curLine != <span class="number">0</span>) &#123;   <span class="comment">// 处在第一行时应忽略 up 的输入</span></span><br><span class="line">                buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curLine == hisCount) &#123; <span class="comment">// 显示的是正在输入的字符</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(curIn, buf);    <span class="comment">// 暂时保存在 curIn 中，暂时视作一条指令</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用 &lt;space&gt; + 光标移动，清空当前行</span></span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 读入指定的历史指令并输出，重定位光标</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(--curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                len = i; <span class="comment">// redirect cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 同理</span></span><br><span class="line">            buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> + curLine &lt; hisCount) &#123;     <span class="comment">// 注意这里的判断</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(++curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(buf, curIn);</span><br><span class="line">                curLine = hisCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            len = i;</span><br><span class="line">            <span class="comment">// redirect cursor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>这部分比较重要的就是边界情况的处理和写入后光标的定位。<ul><li>输入 up 键，需要把光标向下移动一行（固定，不要乱跑），使 <code>curLine--</code>，如果 <code>curLine == 0</code> （第一条指令）就不再响应</li><li>输入 down 键，光标不需移动，<code>curLine++</code>，如果 <code>curLine + 1 = hisCount</code> （即马上要从 <code>.history</code> 的最后一行换成最开始预存的缓冲输入时）需要特别处理；若 <code>curLine == hisCount</code> 则不再响应</li><li>无论输入 up/down 键，只要重新回显了字符，就需要借助 <code>printf(&quot;\033[A&quot;);</code> 等方法实现的光标移动和打印空格把当前行原本的内容清空后再输出</li></ul></li></ul><h2 id="history-b-功能的实现"><a href="#history-b-功能的实现" class="headerlink" title="history.b 功能的实现"></a><code>history.b</code> 功能的实现</h2><p>还是一样的，别忘了把 <code>history.b</code> 加入 <code>include.mk</code>，让程序进行编译并烧录磁盘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/history.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;history instruction:\n\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd, r, line = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">1</span>], print;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;history: %d&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no history instruction.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    print = temp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, line);</span><br><span class="line">    <span class="keyword">while</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, print);</span><br><span class="line">        <span class="keyword">if</span> (print == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, ++line);</span><br><span class="line">        &#125;</span><br><span class="line">        print = temp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\ntotal instruction: %d\nhistory finished.\n\n&quot;</span>, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是对文件的打开、读取、判断和输出。而判断是否为一条指令的标准就是 <code>\n</code>，这也就是在前面写入指令时要加入一个分隔符的理由。我们根据 <code>\n</code> 编排输出的方式，从而实现历史命令的输出。</p><h2 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="上下键指令回显"><a href="#上下键指令回显" class="headerlink" title="上下键指令回显"></a>上下键指令回显</h3><p>先在 Shell 中输入几条指令，随后输入半条还没有执行的指令，然后连续按上下键观察变化</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ input halfway</span><br><span class="line">[2000] /testdir $ tree             // press ↑</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a          // press ↑</span><br><span class="line">[2000] /testdir $ tree             // press ↓</span><br><span class="line">[2000] /testdir $ input halfway    // press ↓</span><br></pre></td></tr></table></figure><ul><li>并且可以随时修改回显的任意一条指令，并随时按下回车输出</li></ul><h3 id="history-指令功能"><a href="#history-指令功能" class="headerlink" title="history 指令功能"></a><code>history</code> 指令功能</h3><p>在上一测试的基础上直接输入 <code>history</code> 观察输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ <span class="built_in">history</span></span><br><span class="line"><span class="built_in">history</span> instruction:</span><br><span class="line"></span><br><span class="line">    1 : <span class="built_in">mkdir</span> testdir</span><br><span class="line">    2 : <span class="built_in">cd</span> testdir</span><br><span class="line">    3 : <span class="built_in">touch</span> a</span><br><span class="line">    4 : tree</span><br><span class="line">    5 : input half|<span class="built_in">cut</span>|way</span><br><span class="line">    6 : <span class="built_in">history</span></span><br><span class="line"></span><br><span class="line">total instruction: 6</span><br><span class="line"><span class="built_in">history</span> finished.</span><br><span class="line"></span><br><span class="line">[00007804] destroying 00007804</span><br></pre></td></tr></table></figure><p>检测到 <code>.history</code> 文件的内容可以正常写入、读出，并且 <code>history</code> 指令功能也正常实现</p><h1 id="选做部分-2：支持相对路径"><a href="#选做部分-2：支持相对路径" class="headerlink" title="选做部分 2：支持相对路径"></a>选做部分 2：支持相对路径</h1><blockquote><p>MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。</p><p>现在，我们需要在 MOS 中<strong>支持相对路径的输入与解析</strong>，并且当前工作路径的保存是进程级别的，也就是说不同进程的工作目录可能不同。</p></blockquote><p>首先我们要求：只有以 <code>/</code> 开头的目录才会被识别为绝对路径，此外的所有非 <code>/</code> 开头路径（包括 <code>./</code> ）都会被识别为相对路径并进行识别与处理。</p><p>需要完成的工作有以下几点：</p><ul><li>在内核态中为进程维护一个表示当前工作目录的字符数组 <code>char r_path</code></li><li>通过系统调用向用户态提供更改 <code>r_path</code> 的接口，实现用户调用函数 <code>chdir()</code> 和 <code>getcwd()</code></li><li>更改 <code>sys_exofork</code> 逻辑，使其能令子进程<strong>继承</strong>父进程的工作目录</li><li>修改 <code>sh.c</code> 实现<strong>内部命令</strong> <code>cd</code> 和<strong>外部命令</strong> <code>pwd</code></li><li>修改文件操作函数（Shell 已有命令能调用的只有 <code>open</code> 函数），识别并提供相对路径的功能支持</li><li>更改已实现的 Shell 命令对文件的操作</li><li>优化 Shell 输出界面</li></ul><h2 id="维护工作目录数组"><a href="#维护工作目录数组" class="headerlink" title="维护工作目录数组"></a>维护工作目录数组</h2><p>为了便于管理与复制，同时能够体现不同进程目录不同的特点，这里直接将字符数组放置在进程控制块中，当然在内核态中开一个大二维数组也是可行的，比修改进程控制块更安全。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/env.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> r_path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建进程时，也需要在创建进程的函数中初始化进程的目录为 <code>/ </code> 根目录</p><h2 id="系统调用设置接口-amp-实现用户调用函数"><a href="#系统调用设置接口-amp-实现用户调用函数" class="headerlink" title="系统调用设置接口 &amp; 实现用户调用函数"></a>系统调用设置接口 &amp; 实现用户调用函数</h2><p>为了便于用户态<strong>获取/修改</strong>当前进程所处的工作目录，我们添加两个系统调用为用户态提供接口。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SYS_get_rpath,</span><br><span class="line">    SYS_set_rpath,</span><br><span class="line">    MAX_SYSNO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(newPath) &gt; <span class="number">1024</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(curenv-&gt;r_path, newPath);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(dst, curenv-&gt;r_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *syscall_table[MAX_SYSNO] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_get_rpath] = sys_get_rpath,</span><br><span class="line">    [SYS_set_rpath] = sys_set_rpath,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_set_rpath, newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_get_rpath, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_set_rpath(newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_get_rpath(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在相应的头文件中添加声明</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><p>实现用户态函数后，可以直接新建 <code>pwd.c</code> 文件，直接调用 <code>getcwd</code> 函数输出当前路径</p><h2 id="工作目录传递"><a href="#工作目录传递" class="headerlink" title="工作目录传递"></a>工作目录传递</h2><p>现在在单个进程中，我们已经完成了工作目录的修改，现在需要在<strong>所有会出现创建进程的位置</strong>添加对父进程工作目录的复制工作。算过来也就只有 <code>env_alloc</code>、<code>fork</code>、<code>spawn</code> 三个函数会创建进程，而它们最终也都会调用 <code>sys_exofork</code> 作为进程创建的核心函数。所以直接修改 <code>sys_exofork</code> 来实现父子进程中的工作目录复制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">strcpy</span>(e-&gt;r_path, curenv-&gt;r_path); <span class="comment">// copy at here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现内部命令-cd"><a href="#实现内部命令-cd" class="headerlink" title="实现内部命令 cd"></a>实现内部命令 <code>cd</code></h2><p>这里实现的 <code>cd</code> 指令需要作为<strong>内部指令</strong>，也就是执行后并不<strong>切换进程</strong>，而是继续处理。处理方法是在读入结束后、解析开始前的这一段空隙对输入指令做一次预处理，如果满足 <code>cd</code> 指令格式，就进行工作目录切换，切换后重新读入；反之则开始解析，准备调用外部命令。</p><p>要注意的是，Linux 中只输入 <code>cd</code> 相当于<strong>跳转至家目录</strong>，MOS 就直接跳根目录得了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parseCD(buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面一段在 main 函数中先预先判断是否存在 <code>cd</code>，如果存在，则不应创建进程，而直接解析，反之就应该创建子进程并运行指令。</p><p><code>parseCD</code> 函数实现时需要注意：<code>cd</code> 并不一定出现在指令开头，也可能出现在 <code>ins1; cd</code> 的格式中，所以需要对 <code>;</code> 和 <code>&amp;</code> 进行特判。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; runcmd</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;cd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">char</span> cur[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        cur[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; p += <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">        syscall_get_rpath(cur);</span><br><span class="line">        <span class="type">int</span> len1 = <span class="built_in">strlen</span>(cur);</span><br><span class="line">        <span class="type">int</span> len2 = <span class="built_in">strlen</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123; <span class="comment">// cur: &#x27;/&#x27;</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cur + <span class="number">1</span>, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         <span class="comment">// cur: &#x27;/a&#x27;</span></span><br><span class="line">            cur[len1] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(cur + len1 + <span class="number">1</span>, p);</span><br><span class="line">            cur[len1 + <span class="number">1</span> + len2] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cur:%s\n&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(cur, &amp;st)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not a directory\n&quot;</span>, cur);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);<span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = chdir(cur)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数的功能是获取 <code>cd</code> 后的绝对路径，并进行工作目录的切换；关键是输入的相对路径与工作路径之间的拼接。<code>cd</code> 大概可以分成以下几类， <code>if-else</code> 中的逻辑也是这么写的：</p><ul><li>输入路径为绝对路径（<code>/xxxx</code>、没有输入路径（默认为根目录 <code>/</code>））：不需要进行拼接，直接进行目录判断和跳转即可</li><li>输入路径为相对路径，形式上分两种（<code>./yyy</code> 、<code>zzz</code>）：根据形式不同，需要进行处理<ul><li>如果有 <code>./</code> 出现，需要先去掉，统一形式为 <code>zzz</code></li><li>获取工作目录，再进行字符串拼接，获取绝对目录</li></ul></li></ul><p>切换工作目录前要查看要跳转的路径是不是一个目录，若不是目录应不允许切换</p><h2 id="open-函数支持相对路径"><a href="#open-函数支持相对路径" class="headerlink" title="open 函数支持相对路径"></a><code>open</code> 函数支持相对路径</h2><p>我们已经实现的用户程序中，只有 <code>open</code> 会用到程序的路径名，并且 <code>ls</code>、<code>tree</code>、<code>mkdir</code>，甚至 <code>spawn</code> 都需要 <code>open</code> 函数支持，所以与其更改每个用户函数的接口，不如直接修改 <code>open</code> 函数逻辑，让文件系统支持输入相对路径。最后再在用户程序中做一些微调就能够正常使用了。</p><p>类似地， <code>open</code> 函数的输入路径也可能分为绝对路径和相对路径两种，这取决于用户的字符串输入。所以处理方式可以和上面 <code>cd</code> 的方式保持一致，直接 CV 都能用</p><h2 id="用户程序功能调整"><a href="#用户程序功能调整" class="headerlink" title="用户程序功能调整"></a>用户程序功能调整</h2><p>在已经实现好的用户程序中，大多数指令的默认情况都会以根目录为输入目录，如直接键入 <code>tree</code> 就会生成根目录文件树，现在我们就要把默认情况改为 <code>./</code> ，即输出当前工作目录的文件树</p><p>需要更改的文件有 <code>ls</code> 和 <code>tree</code></p><p>还有一个相对特殊的 <code>spawn</code>，它的默认打开路径就是只能从根目录开始，如果带上相对路径，那么在 <code>cd</code> 至其他路径后再输入外部命令，<code>spawn</code> 会先调用 <code>open</code>打开<strong>相对路径下的</strong>用户程序， Shell 就会因为 <code>spawn</code> 了错误的文件而无法运行。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">// 此刻 Shell 中在尝试调用工作目录下的 ls.b ，也即 /test/ls.b，显然这个文件是不存在的</span><br></pre></td></tr></table></figure><p>所以为了避免 <code>open</code> 将指令解析成相对路径文件，直接在最前面加一个 <code>/</code> 声明为绝对路径就可以了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/spawn.c -&gt; spawn</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (prog[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(path + <span class="number">1</span>, prog);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, prog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-界面优化"><a href="#Shell-界面优化" class="headerlink" title="Shell 界面优化"></a>Shell 界面优化</h2><p>既然已经支持了工作路径的使用，所以不如在 Shell 的工作状态下输出当前的工作目录，更符合 Linux 的界面风格</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = getcwd(curPath)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[%04x] %s $ &quot;</span>, syscall_getenvid(), curPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="纯指令功能"><a href="#纯指令功能" class="headerlink" title="纯指令功能"></a>纯指令功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure><h3 id="一条多语句测试"><a href="#一条多语句测试" class="headerlink" title="一条多语句测试"></a>一条多语句测试</h3><p>省略销毁进程输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /a $ <span class="built_in">mkdir</span> b ; <span class="built_in">cd</span> b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3803</span><br><span class="line">created path: /a/b</span><br><span class="line">cur:/a/b</span><br><span class="line"></span><br><span class="line">[2000] /a/b $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure><h3 id="spawn-amp-open-功能测试"><a href="#spawn-amp-open-功能测试" class="headerlink" title="spawn &amp; open 功能测试"></a>spawn &amp; open 功能测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">mkdir</span> testdir</span><br><span class="line">created path: /testdir</span><br><span class="line"></span><br><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a</span><br><span class="line">created file: a</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br></pre></td></tr></table></figure><ul><li>此处的 <code>touch</code> 在相对目录中使用 <code>spawn</code> 创建，可以正常打开根目录的用户程序</li><li><code>tree</code> 指令内部在 <code>open</code> 中使用了相对路径 <code>./</code> ，也可以正常解析</li></ul><p>lab6 挑战性任务需求的功能到这里就全部实现力，是时候休息一把了（×</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab6-Report</title>
      <link href="/2023/06/os/buaa-os-report-lab6/"/>
      <url>/2023/06/os/buaa-os-report-lab6/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab6-Report"><a href="#BUAA-OS-2023-Lab6-Report" class="headerlink" title="BUAA-OS-2023-Lab6-Report"></a>BUAA-OS-2023-Lab6-Report</h1><h1 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h1><ul><li>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</li></ul><p>原有代码的分支语句如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程- 作为管道的读者*/</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端*/</span></span><br><span class="line">read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据*/</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端*/</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程- 作为管道的写者*/</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端*/</span></span><br><span class="line">write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据*/</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端*/</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，作为读者，子进程关掉了管道写端；相应的，父进程关掉了管道读端。那么我们只要将关闭的端交换，并修改写入/读取语句即可实现要求，即：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程- 作为管道的写者 */</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程- 作为管道的读者 */</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">        read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 读入结束，关闭读端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h1><ul><li>上面这种不同步修改 <code>pp_ref</code> 而导致的进程竞争问题在 <code>user/lib/fd.c</code> 中的 <code>dup</code> 函数中也存在。请结合代码模仿上述情景，分析一下我们的 <code>dup</code> 函数中为什么会出现预想之外的情况？</li></ul><p>当我们调用 <code>dup</code> 函数时，会在进程中创建一个新的文件描述符 <code>newfd</code> ，这个文件描述符指向 <code>oldfd</code> 所拥有的文件表项，也就是在用户态中复制了一个文件的描述符。</p><p>实际上在执行复制的过程中，我们并不能一步把所有的数据都复制完，实际上是先对 <code>fd</code> 使用 <code>syscall_mem_map</code> 进行复制，再对它所属的 <code>data</code> 复制。</p><p>现在假设一个情景：子进程 <code>dup(pipe[1])</code> 后 <code>read(pipe[0])</code>，父进程 <code>dup(pipe[0])</code> 后 <code>write(pipe[1])</code> 。</p><p>先令子进程执行：顺序执行至 dup 完成后发生时钟中断，此时 <code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 1</code></p><p>随后父进程开始执行：执行至 dup 函数中 fd 和 data 的 map <strong>之间</strong>，此时 <code>pageref(pipe[0]) = 1</code>，<code>pageref(pipe) == 1</code></p><p>子进程再次开始执行：进入 read 函数，判断发现 <code>pageref(pipe[0]) == pageref(pipe)</code></p><p>这个非同步更改的 <code>pageref</code> 和管道关闭时的等式一致，这里会让 <code>read</code> 函数认为管道中已经没有了写者，于是关闭了管道的读端。</p><h1 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h1><ul><li>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明</li></ul><p>我认为系统调用是原子操作。因为系统调用开始前，通过修改 SR 寄存器的值，关闭了外部中断，而在执行内核代码时，合理的内核设计应保证不出现其它类型的异常。所以这使得系统调用成为了原子操作。</p><h1 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h1><ul><li>仔细阅读上面这段话，并思考下列问题<ul><li>按照上述说法控制 pipe_close 中fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件内容。试想，如果要复制的是一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</li></ul></li></ul><ul><li>可以解决上述问题。<ul><li>最初 <code>pageref(pipe[0]) = 2</code>，<code>pageref(pipe[1]) = 2</code>，<code>pageref(pipe) = 4</code></li><li>子进程先运行，执行 <code>close</code> 解除了 <code>pipe[1]</code> 的文件描述符映射</li><li>发生时钟中断，此时 <code>pageref(pipe[0]) = 2</code>，<code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 4</code></li><li>父进程执行完<code> close(pipe[0])</code> 后，<code>pageref(pipe[0]) = 1</code>，<code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 3</code></li><li>可以发现此过程中不满足写端关闭的条件</li></ul></li><li>在 <code>Thinking 6.2</code> 中用到的样例就体现了问题发生的原理。如果先映射作为 <code>fd</code> 的 <code>pipe[0]</code>，就会暂时产生 <code>pageref(pipe) == pageref(pipe[0])</code> 的情况，会出现类似问题。</li></ul><h1 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h1><ul><li>思考以下三个问题。<ul><li> 认真回看Lab5 文件系统相关代码，弄清打开文件的过程。</li><li>回顾Lab1 与Lab3，思考如何读取并加载ELF 文件。<ul><li> 在Lab1 中我们介绍了data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于memsize 和filesize ，我们在Note1.3.4中也解释了它们的含义与特点。关于Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。</li><li>回顾Lab3 并思考：elf_load_seg() 和load_icode_mapper()函数是如何确保加载ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在ELF 中并不占空间，但ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是0。请回顾elf_load_seg() 和load_icode_mapper() 的实现，思考这一点是如何实现的？</li></ul></li></ul></li></ul><ul><li>打开文件的过程：<ul><li>根据文件名，调用用户态的 <code>open</code> 函数，其申请了一个文件描述符，并且调用了服务函数 <code>fsipc_open</code> ，利用 <code>fsipc</code> 包装后向文件服务进程发起请求</li><li>文件服务进程接收到请求后分发给 <code>serve_open</code> 函数，创建 <code>Open</code> 并调用 <code>file_open</code> 函数从磁盘中加载到内存中，返回共享的信息，文件打开</li></ul></li><li>加载 ELF 文件：<ul><li>在进程中打开 ELF 文件后，先创建子进程，初始化其堆栈，做好前置工作</li><li>按段（Segment）解析 ELF 文件，利用 <code>elf_load_seg</code> 函数将每个段映射到子进程的对应地址空间中，在函数执行过程中，会对在文件中不占大小、在内存中需要补 0 的 <code>.bss</code> 段数据进行额外的映射（总文件大小与已经映射的大小的差值即为 <code>.bss</code> 段大小：追加在文件部分之后，并填充为 0）</li><li>实际的映射函数是 <code>spwan_mapper</code>，它利用 <code>syscall_mem_map</code> 将数据从父进程映射到子进程中，完成 ELF 文件的加载</li></ul></li></ul><h1 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h1><ul><li>通过阅读代码空白段的注释我们知道，将文件复制给标准输入或输出，需要我们将其 dup 到 0 或 1 号文件描述符 (fd)。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。</li></ul><p>注释中进行了如下标记：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br></pre></td></tr></table></figure><p>这意味着用于 <code>reading</code> 的文件描述符会被 <code>dup</code> 到 <code>fd[0]</code>，过程如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line"><span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;redirction_1: open file in shell failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd = r;</span><br><span class="line">dup(fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>映射 <code>writing</code> 部分的描述符操作类似</p><h1 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h1><ul><li>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子 shell，然后子 shell 去执行这条命令。</li><li>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？</li></ul><p>我们用到的 shell 命令均属于外部命令。在 shell 运行过程中，我们对指令调用 <code>runcmd</code> 进行处理，其内部调用了 <code>parsecmd</code> 进行解析，在指令解析后直接利用这个指令 <code>spwan</code> 了一个子进程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br></pre></td></tr></table></figure><p>这也就是说，无论执行任何指令，MOS 中的 shell 都会将这个流程解析为：创建子进程、运行指令所指向的文件、完成所需功能</p><h1 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h1><ul><li>在你的shell 中输入命令ls.b | cat.b &gt; motd。<ul><li>请问你可以在你的shell 中观察到几次spawn ？分别对应哪个进程？</li><li>请问你可以在你的shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul></li></ul><p>终端输出如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ ls.b | cat.b &gt; motd</span><br><span class="line">[<span class="number">00002803</span>] pipecreate </span><br><span class="line">[<span class="number">00003805</span>] destroying <span class="number">00003805</span></span><br><span class="line">[<span class="number">00003805</span>] <span class="built_in">free</span> env <span class="number">00003805</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00004006</span>] destroying <span class="number">00004006</span></span><br><span class="line">[<span class="number">00004006</span>] <span class="built_in">free</span> env <span class="number">00004006</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00003004</span>] destroying <span class="number">00003004</span></span><br><span class="line">[<span class="number">00003004</span>] <span class="built_in">free</span> env <span class="number">00003004</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00002803</span>] destroying <span class="number">00002803</span></span><br><span class="line">[<span class="number">00002803</span>] <span class="built_in">free</span> env <span class="number">00002803</span></span><br><span class="line">i am killed ... </span><br></pre></td></tr></table></figure><ul><li>可以观察到2次 <code>spawn</code>：3805 和 4006 进程，这是 ls.b 命令和 cat.b 命令通过 shell 创建的进程</li><li>可以观察到4次进程销毁：3805、4006、3004、2803，按顺序是 ls.b 命令、cat.b 命令 spawn 出的进程、通过管道创建的 shell 进程和 main 函数的 shell 进程。</li></ul><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>Lab6 实验共分为两部分。</p><p>第一部分是完善文件系统，为其增加管道、控制台两种文件属性，便于下一部分进行 shell 中命令等的传递。这其中需要注意的是非原子操作的进程安全问题，由于管道检测和 <code>dup</code> 函数的非原子性，可能会导致出现管道状态的错误判断，我们需要对其进行进程安全的保护。</p><p>第二部分是补充 shell 的相关代码，在 MOS 系统中实现一个通过外部命令驱动的 shell 。我们在代码中首先完成了使用指定 ELF 文件创建进程的 <code>spawn</code> 函数，这是我们 shell 创建子进程并实现功能的重点。随后通过解析输入命令，实现了对用户从终端输入命令的执行。但是在这个过程中我们填写的代码很少，也许不能有效地理清整个 shell 工作函数执行的顺序，还需要更进一步的分析和整理。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter7</title>
      <link href="/2023/05/os/buaa-os-theory-chapter7/"/>
      <url>/2023/05/os/buaa-os-theory-chapter7/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-文件系统"><a href="#第七章-文件系统" class="headerlink" title="第七章 文件系统"></a>第七章 文件系统</h1><h1 id="文件系统基本概念"><a href="#文件系统基本概念" class="headerlink" title="文件系统基本概念"></a>文件系统基本概念</h1><blockquote><p>为了解决计算机中数据无法长期保存、共享困难等问题，人们提出了文件的概念，把数据组织成文件的形式，用文件作为数据的存储、访问单位。</p></blockquote><ul><li><p>文件是一组带标识的、在逻辑上有完整意义的信息项的序列。信息项是构成文件内容的基本单位（字节/多字节）</p></li><li><p>所有的 I/O 设备、文本等资源都可以看成文件</p></li><li><p>典型的文件结构</p><ul><li>流式文件：构成文件的基本单位是字符。文件是字符的串构成的集合。</li><li>记录式文件：文件由若干条记录组成，可以按照记录进行读写等操作</li></ul></li><li><p>文件系统的定义：操作系统中与文件管理有关的软件、文件与需要的数据结构的总称。</p></li></ul><h2 id="文件系统模型的三个层次"><a href="#文件系统模型的三个层次" class="headerlink" title="文件系统模型的三个层次"></a>文件系统模型的三个层次</h2><h3 id="文件系统的接口"><a href="#文件系统的接口" class="headerlink" title="文件系统的接口"></a>文件系统的接口</h3><ul><li>命令行接口：用户（Shell）和文件系统交互的接口</li><li>程序接口：用户程序与文件系统的接口，<strong>通过系统调用的形式</strong>获取文件系统的服务</li></ul><h3 id="对象操作管理的软件集合"><a href="#对象操作管理的软件集合" class="headerlink" title="对象操作管理的软件集合"></a>对象操作管理的软件集合</h3><ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>文件逻辑地址 → 物理地址</li><li>文件读写管理</li><li>文件共享与保护功能</li></ul><h3 id="对象及其属性"><a href="#对象及其属性" class="headerlink" title="对象及其属性"></a>对象及其属性</h3><ul><li>文件：管理的直接对象</li><li>目录：包含文件的指针，组织管理文件</li><li>磁盘存储空间</li></ul><h1 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h1><h2 id="文件编排的结构"><a href="#文件编排的结构" class="headerlink" title="文件编排的结构"></a>文件编排的结构</h2><ul><li>逻辑结构：文件组织，逻辑地址连续，但是实际上不连续</li><li>物理结构：文件在存储介质上的位置，同一个文件可能物理地址不连续</li></ul><h3 id="连续结构"><a href="#连续结构" class="headerlink" title="连续结构"></a>连续结构</h3><p>单个文件所占据的空间是先后连续的，即物理结构相邻</p><p>结构简单易实现，支持顺序和随机存取；但不利于文件长度的动态变化</p><h3 id="串联结构"><a href="#串联结构" class="headerlink" title="串联结构"></a>串联结构</h3><p>文件的信息存于若干块中，并且这些块不一定连续</p><p>每个物理块的最后一个字作为<strong>链接字</strong>，指向后继块的物理地址，直至指向 NULL 代表文件结束。</p><p>当访问文件块时需要遍历该文件的所有前驱块，通过链接字进行访问</p><p>空间利用率高，动态修改文件大小；随机存取效率低，通过指针链接易出问题</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul><li>一个文件的信息存放在若干个不连续的物理块中。</li><li>系统以文件为单位创建了专用数据结构：索引表，索引表就是磁盘块的地址数组，是逻辑块号和物理块号的对照表</li></ul><p>文件若采用索引结构存储，则需要分索引区和数据区。索引区存放索引表，数据区存放数据文件本身。访问时：索引区查表 → 数据区获取磁盘块的信息</p><ul><li>顺序、随机存取效率高，也能满足地址动态地要求；但本身带来了空间（索引表结构占空间）和时间（访问索引表）的开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter6</title>
      <link href="/2023/05/os/buaa-os-theory-chapter6/"/>
      <url>/2023/05/os/buaa-os-theory-chapter6/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-磁盘存储管理"><a href="#第六章-磁盘存储管理" class="headerlink" title="第六章 磁盘存储管理"></a>第六章 磁盘存储管理</h1><h1 id="磁盘存储的工作原理"><a href="#磁盘存储的工作原理" class="headerlink" title="磁盘存储的工作原理"></a>磁盘存储的工作原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>扇区：磁盘片上被分成许多的扇形区域</li><li>磁道：以磁盘片中心为圆心，半径不同的同心圆</li><li>柱面：同一半径的不同磁盘片形成的圆柱</li></ul><p>扇区是磁盘读取的单位，磁盘内容按扇区号顺序存储。</p><ul><li>磁盘访问时间包括寻道时间、旋转延迟时间、传输时间<ul><li>$寻道时间=磁盘启动时间+n条磁道×移动单次的时间$</li><li>$旋转延迟时间=\frac{1×旋转一圈的时间}{2}$</li><li>$传输时间=\frac{传输的字节数}{单个磁道上的字节数}×旋转一圈的时间$</li></ul></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul><li>先来先服务算法</li></ul><p>形成一个磁道队列，按序访问各个磁道，从而进行数据读写</p><ul><li>最短寻道时间算法</li></ul><p>优先选择距离磁头当前最近的请求进行寻道，<strong>寻道优先</strong>。但会出现饥饿现象，即远处的请求长期无法满足</p><ul><li>扫描算法 - SCAN</li></ul><p>电梯算法，先向一个方向移动，处理沿途的请求，直至该方向无请求，掉头处理反方向请求</p><ul><li>循环扫描算法 - CSCAN</li></ul><p>相对扫描算法，将每次开始的磁道设为0号，当单方向访问完后，立刻强制返回0号磁道，再次循环。</p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><blockquote><p>廉价冗余磁盘阵列，把多块独立的磁盘按照不同方式组合为一个大型的逻辑磁盘，从而提供比单个磁盘更高的存储性能、数据冗余。</p></blockquote><ul><li>数据冗余：用户数据损坏后，可利用磁盘中冗余信息进行恢复</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305301700733.png" alt="image-20230530170015633"></p><p><del>好像后面不咋考，先不看了</del></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter5</title>
      <link href="/2023/05/os/buaa-os-theory-chapter5/"/>
      <url>/2023/05/os/buaa-os-theory-chapter5/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-输入输出系统"><a href="#第五章-输入输出系统" class="headerlink" title="第五章 输入输出系统"></a>第五章 输入输出系统</h1><h1 id="I-O-硬件基本原理"><a href="#I-O-硬件基本原理" class="headerlink" title="I/O 硬件基本原理"></a>I/O 硬件基本原理</h1><h2 id="设备管理目标与功能"><a href="#设备管理目标与功能" class="headerlink" title="设备管理目标与功能"></a>设备管理目标与功能</h2><h3 id="管理目标"><a href="#管理目标" class="headerlink" title="管理目标"></a>管理目标</h3><ul><li>提高效率：提高 I/O 的访问效率，匹配 CPU 与外设间的速度差异</li><li>方便使用：便于用户使用</li><li>方便控制：便于操作系统内部对设备的控制</li></ul><h3 id="管理功能"><a href="#管理功能" class="headerlink" title="管理功能"></a>管理功能</h3><ul><li>提供设备使用的用户接口：命令接口、编程接口</li><li>设备分配和释放：使用设备前需要分配资源</li><li>设备的访问与控制：并发访问、差错处理</li><li>I/O 缓冲与调度：提高 I/O 效率</li></ul><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul><li>组成：数据寄存器、控制寄存器、状态寄存器</li></ul><h1 id="I-O-软件基本原理"><a href="#I-O-软件基本原理" class="headerlink" title="I/O 软件基本原理"></a>I/O 软件基本原理</h1><h2 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h2><ul><li>程序控制 I/O：轮询方式，由 CPU 发出忙等指令，直至操作完成才能继续执行</li><li>中断驱动：当 I/O 操作结束后，主动通知工作已完成，不需轮询</li><li>DMA：直接存储器访问，由一个控制器完成内存与设备间的传输工作。</li><li>通道：一个内存数据传输的处理器</li></ul><h3 id="轮询工作方式"><a href="#轮询工作方式" class="headerlink" title="轮询工作方式"></a>轮询工作方式</h3><ul><li>进程提出访问请求</li><li>驱动程序检查并向设备发出控制命令</li><li>驱动持续轮询设备是否完成任务</li><li>完成后返回，进程继续工作</li></ul><p>实现简单，但 CPU 利用率低，轮询浪费资源</p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><ul><li>进程提出访问请求</li><li>驱动程序发出控制命令，并记录目标设备，CPU <strong>继续工作</strong></li><li>设备完成操作后向 CPU 申请中断，把结果返回给上一步的记录处</li><li>数据送达，进程继续工作</li></ul><h3 id="DMA-直接存储访问方式"><a href="#DMA-直接存储访问方式" class="headerlink" title="DMA - 直接存储访问方式"></a>DMA - 直接存储访问方式</h3><p>CPU 设置 DMA 控制器中的数值，驱动 DMA 进行访问。CPU 只需要准备数值启动，但每个设备都要占用一个 DMA 控制器。</p><ul><li>中断和 DMA 方式都使用中断，但中断控制方式数据传输由CPU 完成，DMA 中由 DMA 控制器完成，不需要 CPU 干预。</li><li>中断在每个数据传输结束后中断 CPU，而 DMA 在传送的一批数据结束后才中断 CPU</li></ul><h3 id="I-O-通道控制方式"><a href="#I-O-通道控制方式" class="headerlink" title="I/O 通道控制方式"></a>I/O 通道控制方式</h3><p>I/O 通道是专门负责输入输出的处理器，执行通道程序，在内存中处理复杂的 I/O 控制，比 DMA 的 CPU 干预要少。</p><p>通道独立处理 I/O 的功能更强；同时通道比 DMA 控制的设备数/种类更多</p><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>利用缓冲可以提高外设的利用率，减少中断发生的次数，提高 CPU、I/O 设备的并行性。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305301455584.png" alt="image-20230530145421259" style="zoom:80%;" /><h3 id="缓冲分类"><a href="#缓冲分类" class="headerlink" title="缓冲分类"></a>缓冲分类</h3><ul><li>单缓冲：CPU、外设轮流使用，等待对方处理</li><li>双缓冲：CPU 和外设工作互不干扰，要求两者速度相近</li><li>环形缓冲：允许处理速度相差大</li><li>缓冲池：分三个队列利用缓冲区</li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>由于外设资源有限，需要通过设备分配管理进程使用外设的过程</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>设备控制表：描述单个设备的特性、状态、连接情况</li><li>控制器控制表：描述设备控制器占用的中断号、数据通道等的分配情况</li><li>通道控制表：描述单个通道的工作状态</li><li>系统设备表：系统内的所有资源状态，记录设备状态与设备控制表地址</li></ul><p>设备分配分为 单通路/多通路 I/O 系统的设备分配</p><ul><li>步骤为：分配设备、分配设备控制器、分配通道</li></ul><h3 id="设备驱动共性"><a href="#设备驱动共性" class="headerlink" title="设备驱动共性"></a>设备驱动共性</h3><p>核心代码、核心接口、核心机制与服务、动态可加载、动态性</p><h2 id="假脱机技术-SPOOLing"><a href="#假脱机技术-SPOOLing" class="headerlink" title="假脱机技术 - SPOOLing"></a>假脱机技术 - SPOOLing</h2><blockquote><p>SPOOLing 技术，即虚拟设备技术。系统利用一个 SPOOLing 进程完成对设备的 I/O 操作。</p></blockquote><p>实际上，用户进程与 SPOOLing 程序进行数据交互，随后 SPOOLing 再和外设进行数据交换。虚拟 I/O 程序包含一个缓冲池：用户持续访问缓冲池，SPOOLing 对数据进行合适的处理。</p><ul><li>SPOOLing 实现了一个虚拟 I/O 的端口，提高了实现 I/O 的速度</li><li>通过对物理设备的修饰，原本独享的设备也可以在 SPOOLing 中<strong>提供虚拟设备</strong>，按序共享使用</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在中断驱动方式中，CPU 以字节为单位干预；DMA 方式中以数据块为单位干预；I/O 通道方式中以一组数据块为单位干预</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter4</title>
      <link href="/2023/05/os/buaa-os-theory-chapter4/"/>
      <url>/2023/05/os/buaa-os-theory-chapter4/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-进程与并发程序设计"><a href="#第四章-进程与并发程序设计" class="headerlink" title="第四章 进程与并发程序设计"></a>第四章 进程与并发程序设计</h1><h1 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h1><h2 id="进程概念的引入"><a href="#进程概念的引入" class="headerlink" title="进程概念的引入"></a>进程概念的引入</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p>并发：只要某一时刻，活动1与活动2都处在运行状态，就称两者<strong>是并发执行的</strong>。</p></li><li><p>并行：两个程序在同一时刻运行在不同的处理机上，则称这两个程序是并行执行的</p></li><li><p>并发执行的特征：间断性、非封闭性、不可再现性</p><ul><li>间断性：并发程序具有“执行 - 暂停 - 执行”的间断性规律</li><li>非封闭性：存在共享资源，使得程序之间会相互影响</li><li>不可再现性：在初始条件相同时，程序<strong>结果依赖于执行顺序</strong></li></ul></li></ul><p>对于并发而言，偏重于开始 - 结束时间的区间上有重叠，两个程序不必在<strong>同一时刻</strong>都处于活跃状态；而并行则要求两个程序需要同时工作/活跃在 CPU 上，这需要多个处理机才能实现。<strong>并发的要求更加严格。</strong></p><h3 id="进程的定义与特征"><a href="#进程的定义与特征" class="headerlink" title="进程的定义与特征"></a>进程的定义与特征</h3><ul><li><p>进程是程序在一个数据集合上运行的过程，它是系统进行<strong>资源分配和调度</strong>的基本单位。</p></li><li><p>进程具有动态性、并发性、独立性、异步性</p><ul><li>动态性：进程是程序的一次调度过程，而程序是静态的实体</li><li>并发性：多个进程同时存在于内存中，能同时运行</li><li>独立性：进程是独立运行的基本单位</li><li>异步性：进程之间相互制约，存在相关联的关系</li></ul></li><li><p><strong>进程的结构</strong>：程序段、数据段、进程控制块 PCB</p></li><li><p>进程与程序之间的联系：</p><ul><li>进程是动态的，程序是静态的：进程是程序的执行过程</li><li>一个进程可以包括多个程序，一个程序也可以启动多个进程</li></ul></li></ul><h2 id="进程状态与控制"><a href="#进程状态与控制" class="headerlink" title="进程状态与控制"></a>进程状态与控制</h2><blockquote><p>进程控制的主要任务是创建和撤销进程，实现进程的状态转换。</p><p>大多由内核实现进程控制。</p><p>进程是系统进行<strong>资源分配</strong>的基本单位</p><p>线程是<strong>处理机调度和分派</strong>的基本单位</p></blockquote><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><ul><li>原语：由若干条指令组成的指令序列，用于实现某个特定功能。</li></ul><p>原语是<strong>不可分割</strong>的，并且必须在<strong>内核态</strong>执行，常驻于内存。</p><h3 id="进程状态及其演变"><a href="#进程状态及其演变" class="headerlink" title="进程状态及其演变"></a>进程状态及其演变</h3><ul><li><strong>进程的三种基本状态</strong>：就绪态、执行态、阻塞态<ul><li>就绪态：尚未运行，但只要提供 CPU 就能直接开始执行</li><li>执行态：占用处理机资源，当没有进程可执行时，会自动执行系统的 idle 进程（开摆）</li><li>阻塞态：等待某种信号的进程，不占用处理机资源</li></ul></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304191336574.png" alt="image-20230419133656524"></p><ul><li><p>状态转换方式</p><ul><li>就绪态 → 运行态：调度程序选择就绪进程，开始运行</li><li>运行态 → 就绪态：分配的时间片耗尽；当前<strong>存在高优先级进程</strong>可被调度（抢占式）</li><li>运行态 → 阻塞态：需要等待资源、系统信号、IO 结果等<strong>外部信号</strong></li><li>阻塞态 → 就绪态：上述等待的信号处理完毕</li></ul></li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><ul><li><p>进程控制块：创建、撤销进程，进程的唯一标志，限制总进程数目</p></li><li><p>进程控制块的主要内容：</p><ul><li>进程标识符：env_id</li><li>现场保护区：env_tf</li><li>当前状态与程序数据地址等</li></ul></li></ul><h4 id="进程上下文切换-amp-陷入内核"><a href="#进程上下文切换-amp-陷入内核" class="headerlink" title="进程上下文切换 &amp; 陷入内核"></a>进程上下文切换 &amp; 陷入内核</h4><ul><li>进程上下文切换，通常由调度器执行，会切换内存映射</li><li>陷入内核：CPU 状态会进入内核态，由中断异常等引起，发生时需要保存执行时现场</li></ul><p>相较而言，陷入内核开销较小</p><h2 id="线程概念的引入"><a href="#线程概念的引入" class="headerlink" title="线程概念的引入"></a>线程概念的引入</h2><ul><li>线程是系统<strong>调度和分派的单位</strong>，它不基本拥有资源、数据，但有线程栈，同时可以访问所在进程的数据，同进程的所有线程也可以共享所有资源</li><li>引入线程可减少切换进程带来的开销、提升进程的并发速度（划分尺度更小），但线程必须依赖进程才能被执行</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ul><li><strong>用户级线程 ULT</strong>：用户在进程空间中模拟出新的进程<ul><li>ULT 对于系统来说是不可见的，程序外观测不到额外线程</li><li>ULT 上下文切换快，本质上是用户对虚存空间与时间片的再分配</li><li>ULT 会因为内核阻塞而导致所有线程都被阻塞（内核看不到其他线程）；即使有多个处理器，ULT 进程也<strong>最多占用一个</strong>（内核看不到其他线程），<strong>无法实现多线程并行执行</strong></li></ul></li><li><strong>内核级线程 KLT</strong>：在内核中创建线程，支持线程的分发<ul><li>内核可以做到调度同进程的多个线程<strong>并行执行</strong></li><li>线程切换必须使用内核，切换的效率低</li></ul></li><li>混合实现方式：用户空间中可以创建管理线程，内核中存在多个内核线程，需要实现两类线程的映射</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304191414736.png" alt="image-20230419141435676" style="zoom:67%;" /><ul><li><p>线程映射方式：</p><ul><li>多用户 → 单内核：用户级线程不可见，用户进行调度，阻塞会全部阻塞</li><li>单用户 → 单内核：并发能力强，创建、切换线程开销大</li><li>多用户 → 多内核：折中</li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><strong>可重入</strong>不一定线程安全，但不可重入一定线程安全</li></ul><h1 id="4-2-同步与互斥"><a href="#4-2-同步与互斥" class="headerlink" title="4.2 同步与互斥"></a>4.2 同步与互斥</h1><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><h3 id="访问与竞争"><a href="#访问与竞争" class="headerlink" title="访问与竞争"></a>访问与竞争</h3><blockquote><p>程序的并发执行，不可避免地使得共享数据会被多个进程访问，这就造成了资源的<strong>竞争</strong></p></blockquote><ul><li>竞争条件：多个进程并发访问、变更同一数据，且执行后结果与访问的顺序相关</li><li>临界资源：仅允许一个进程访问的资源；访问临界资源的代码称为<strong>临界区</strong></li></ul><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul><li><p>进程互斥：间接制约关系</p><ul><li>两个或以上进程不能同时访问临界资源，否则会发生错误，是程序间的间接作用</li><li>互斥是无序访问</li></ul></li><li><p>进程同步：直接制约关系</p><ul><li>各进程间相互合作从而满足程序正常执行需求的过程；当需要前后进程交换信息时，通常使其进入等待，这种制约关系便是进程同步</li><li>同步是有序访问，通常同步已经实现了互斥（写入过程必然互斥）</li></ul></li></ul><p>临界区设计：空闲让进，忙则等待，有限等待，让权等待</p><h2 id="忙等待解决互斥"><a href="#忙等待解决互斥" class="headerlink" title="忙等待解决互斥"></a>忙等待解决互斥</h2><ul><li>忙等待方法的解决方法都是正确的，原理在于<strong>使用循环</strong>持续检查程序是否能进入临界区（不能进入会原地等待并继续查询）；但是因为使用 <code>while();</code> 会产生忙等待，而导致性能的浪费</li></ul><h3 id="软件互斥算法"><a href="#软件互斥算法" class="headerlink" title="软件互斥算法"></a>软件互斥算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat:</span><br><span class="line">    entry section</span><br><span class="line">    critical section</span><br><span class="line">    exit section</span><br><span class="line">    remainder section</span><br><span class="line">Until false</span><br></pre></td></tr></table></figure><h4 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h4><ul><li><p>顾客进入面包店按照号码从小到大的次序购买面包，并且假定：</p><ul><li>面包店按照递增顺序发放号码，并且多个顾客可能拿到相同号码（即不严格递增）</li><li>当号码相同时，按照顾客名字排序</li></ul></li><li><p>当多个进程同时进行号码计算时可能拿到相同号码，此时则按照进程 id 决定进入临界区的顺序</p></li><li><p>使用 <code>while();</code> 来循环测试进入互斥区的条件，形成<strong>忙等待</strong>，消耗 CPU 资源</p></li></ul><h3 id="硬件互斥方法"><a href="#硬件互斥方法" class="headerlink" title="硬件互斥方法"></a>硬件互斥方法</h3><h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><ul><li>实现简单</li><li>单 CPU 系统中可以使用，多 CPU 会出现大幅性能损失</li><li>内核进程会少量使用来保证互斥</li></ul><h4 id="TS-原语"><a href="#TS-原语" class="headerlink" title="TS 原语"></a>TS 原语</h4><ul><li>TS(test-and-set)是一种原语，写入新的值后会将旧值传回</li><li>在多进程中，如果一个程序<strong>处于 TS 原语中</strong>，则其他进程不可以使用 TS 原语</li><li>相当于原子读写<strong>锁</strong>的内容，来保证临界区的互斥，但仍然需要忙等待 <code>while</code></li></ul><h4 id="swap-指令"><a href="#swap-指令" class="headerlink" title="swap 指令"></a>swap 指令</h4><ul><li>swap 是一种交换地址内容的原语，互斥描述如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> k = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> use = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k != <span class="literal">false</span>) &#123;    <span class="comment">// check use == 0 ?</span></span><br><span class="line">    Swap(&amp;use, &amp;k); <span class="comment">// use cannot be changed by others now</span></span><br><span class="line">&#125;                   <span class="comment">// use has been changed by the program now</span></span><br><span class="line">criticalRegionCode();</span><br><span class="line">use = <span class="literal">false</span>;</span><br><span class="line">otherRegionCode();</span><br></pre></td></tr></table></figure><ul><li>swap 也会因为循环 swap 而导致忙等待</li></ul><h2 id="信号量解决同步互斥"><a href="#信号量解决同步互斥" class="headerlink" title="信号量解决同步互斥"></a>信号量解决同步互斥</h2><blockquote><p>信号量方法改变了忙等待的特质，使用了<strong>阻塞方式</strong>休眠进程，避免了不必要的性能损失</p></blockquote><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul><li>使用新的变量类型：<code>semaphore</code></li><li>信号量只能通过初始化和 <code>P(semaphore)</code> <code>V(semaphore)</code> 两个<strong>原语</strong>访问，不受进程调度的影响</li><li>S 的值为正时表示<strong>可用资源</strong>的个数、负表示<strong>等待资源</strong>的进程个数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semapgore S = ableNumber;</span><br><span class="line">P(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123; blockProgram(S); &#125;  </span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">    wakeProgram(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用信号量，能解决同步与互斥两类问题：</p><ul><li>互斥：<code>S = 1</code>，同时只有一个进程能申请资源（进入临界区）</li><li>有限并发：<code>S = const</code>，分配 n 个资源，允许 n 个进程同时使用</li><li>同步：<code>S = 0</code>，可以描述进程执行的先后关系，只有在前驱 <code>V</code> 后，自身的 <code>P</code> 才能解除 wait</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 互斥使用：每个进程都先 P 后 V</span></span><br><span class="line">P(S);</span><br><span class="line"><span class="comment">// CODE HERE</span></span><br><span class="line">V(S);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步使用：后继进程先 P，等待前驱进程 V，传递了可以执行的信号</span></span><br><span class="line">P(S);</span><br><span class="line"><span class="comment">// S != 0</span></span><br><span class="line"><span class="comment">// CODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CODE</span></span><br><span class="line">V(S);</span><br><span class="line"><span class="comment">// S == 0</span></span><br></pre></td></tr></table></figure><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304200059552.png" alt="image-20230420005920486" style="zoom:50%;" /><ul><li>只有前驱任务发出信号后（“释放”资源），后继任务才能从阻塞中脱离（“占用”资源），开始执行任务</li></ul><h3 id="一般信号量集"><a href="#一般信号量集" class="headerlink" title="一般信号量集"></a>一般信号量集</h3><ul><li>SP(S,a,d)：每次申请d个资源，少于a个便不再分配</li><li>SP(S,1,1)：互斥信号量</li><li>SP(S,1,0)：每次申请0个资源，s=0时禁止进入临界区</li></ul><h4 id="PV-操作优缺点"><a href="#PV-操作优缺点" class="headerlink" title="PV 操作优缺点"></a>PV 操作优缺点</h4><ul><li>表达能力强，使用简单</li><li>使用不当易发生死锁</li></ul><h2 id="管程解决同步互斥"><a href="#管程解决同步互斥" class="headerlink" title="管程解决同步互斥"></a>管程解决同步互斥</h2><ul><li>管程把分散地临界区集中起来，可以以函数库的形式实现，是一种高级同步原语</li><li>管程由变量、过程、数据结构等组成</li><li>互斥：只能同时有一个活跃进程</li></ul><h3 id="管程的实现"><a href="#管程的实现" class="headerlink" title="管程的实现"></a>管程的实现</h3><ul><li><p>Hoare 管程：执行 signal 的进程等待，直至其他 signal 唤醒</p><ul><li>入口等待队列：由于互斥而等待的一般队列</li><li>紧急等待队列：由于唤醒操作而自身进入等待的进程队列，优先级高</li></ul></li><li><p>Hansen 管程：signal 放在最后执行，执行后立即退出管程</p></li><li></li></ul><h2 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h2><ul><li>低级通信：只能传递控制信号</li><li>高级通信：共享内存、消息系统、管道</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul><li>管道是<strong>半双工</strong>的，即单向流动信息，对于管道双方，管道是一个文件系统</li><li><strong>无名管道</strong>只能用于有亲缘关系的进程，<strong>有名管道</strong>支持不相关进程</li><li>数据传递先进先出，保持队列顺序</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul><li>依靠通信原语实现：send(dst, &amp;message), receive(src, &amp;message)，类似于我们实现的ipc_send</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304201058829.png" alt="image-20230420105758743" style="zoom:67%;" /><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li>避免缓冲复制，最快的 ipc 形式</li><li>实质是一块物理内存被同时映射到多个进程的虚拟内存空间，<strong>写机制需要同步约束</strong></li></ul><h2 id="经典同步互斥问题"><a href="#经典同步互斥问题" class="headerlink" title="经典同步互斥问题"></a>经典同步互斥问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ul><li>生产者通过有限缓冲区向消费者发送数据，同时只有一个进程可对缓冲区操作</li></ul><p>生产者、消费者自身互斥，两者之间同步（先放后取）</p><h4 id="信号量设置"><a href="#信号量设置" class="headerlink" title="信号量设置"></a>信号量设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1; // 互斥访问量</span><br><span class="line">semaphore empty = N; // 同步使用，缓冲区空闲数量</span><br><span class="line">semaphore full = 0;</span><br></pre></td></tr></table></figure><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>生产者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(empty); <span class="comment">// 全满(empty = 0) 则无法放置</span></span><br><span class="line">P(mutex); <span class="comment">// 最后再申请互斥信号量，避免等待死锁</span></span><br><span class="line">putOne();</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">getOne();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br></pre></td></tr></table></figure><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li><p>对共享资源的访问操作，写者只允许一个，读者可以不限制数量 ，但是读写也存在互斥</p></li><li><p>读写者有利：</p><ul><li>读者有利：只要有读者开始读，写者就必须一直等待到所有读者结束；写者需要确保没有读进程才能写，写完后允许读者进入</li><li>写者有利：输入写后不再允许后续读者进入（reader++操作）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写有利</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> read_count = <span class="number">0</span>, write_count = <span class="number">0</span>;</span><br><span class="line">semaphore read_mutex = <span class="number">1</span>, write_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;  <span class="comment">// 互斥访问共享数据</span></span><br><span class="line">semaphore read = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(write_count);</span><br><span class="line">        <span class="keyword">if</span> (write_count++ == <span class="number">0</span>) P(read);  <span class="comment">//只要有写者，就占着read</span></span><br><span class="line">        V(write_count);</span><br><span class="line"></span><br><span class="line">        P(data_mutex);</span><br><span class="line">        <span class="comment">// writing</span></span><br><span class="line">        V(data_mutex);</span><br><span class="line"></span><br><span class="line">        P(write_count);</span><br><span class="line">        <span class="keyword">if</span> (--write_count == <span class="number">0</span>) V(read);  <span class="comment">//没有写者才释放read</span></span><br><span class="line">        V(write_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(read);  <span class="comment">// 没有写者才能进入临界区</span></span><br><span class="line"></span><br><span class="line">        P(read_mutex);</span><br><span class="line">        <span class="keyword">if</span> (read_mutex++ == <span class="number">0</span>) P(data_mutex);</span><br><span class="line">        V(read_mutex);</span><br><span class="line"></span><br><span class="line">        V(read);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reading</span></span><br><span class="line"></span><br><span class="line">        P(read_mutex);</span><br><span class="line">        <span class="keyword">if</span> (--read_mutex == <span class="number">0</span>) V(data_mutex);</span><br><span class="line">        V(read_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读有利：</p><p>写者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(wmutex);</span><br><span class="line">doWrite();</span><br><span class="line">V(wmutex);</span><br></pre></td></tr></table></figure><p>读者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span> (reader == <span class="number">0</span>) &#123;</span><br><span class="line">    P(wmutex);</span><br><span class="line">&#125;</span><br><span class="line">reader++;</span><br><span class="line">V(mutex);</span><br><span class="line">doRead();</span><br><span class="line">P(mutex);</span><br><span class="line">reader--;</span><br><span class="line"><span class="keyword">if</span> (reader == <span class="number">0</span>) &#123;</span><br><span class="line">    V(wmutex);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304201128040.png" alt="image-20230420112817001"></p><ul><li>rwmutex 满足先到先得，谁先出现，谁先响应</li></ul><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul><li>五个哲学家坐成一圈，并且有五支筷子，哲学家动作包括思考和进餐，如何避免死锁，使得流程进行顺利？</li></ul><p>显然不能直接 PV 筷子，这样每人一支肯定会死锁，应该最多允许四个人<strong>尝试进餐</strong></p><h1 id="4-3-进程调度"><a href="#4-3-进程调度" class="headerlink" title="4.3 进程调度"></a>4.3 进程调度</h1><h2 id="调度的概念与问题"><a href="#调度的概念与问题" class="headerlink" title="调度的概念与问题"></a>调度的概念与问题</h2><ul><li>CPU 调度就是按照一定的策略，从就绪的进程队列中选择一个进程并开始运行的过程</li><li>进程调度主要需要考虑：进程调度的算法、进程调度的时机、进程切换的过程</li></ul><h3 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h3><ul><li>高级调度：又称宏观调度，通常上，高级调度的单位是分钟、小时或更大单位。它从用户工作流程的角度出发，关注宏观。</li><li>中级调度：主要涉及内外存交换，从不同级别的存储器中进行内容交换</li><li>低级调度：又称微观调度，通常单位是毫秒，特点是执行频率高，从 CPU 资源出发进行调度；<ul><li><strong>抢占式调度</strong>：进程在运行过程中，处理机可能被其他进程抢走（被迫停止）</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305031452166.png" alt="image-20230503145224087" style="zoom:80%" /><h3 id="调度时机与操作"><a href="#调度时机与操作" class="headerlink" title="调度时机与操作"></a>调度时机与操作</h3><p>实际上，只要操作系统能够获取到 CPU 的使用权（系统调用、时钟中断等进入内核态），就有可能发生进程的调度</p><p>在进行调度前，需要先给当前进程生成快照，保存信息；然后把进程控制块移动至队尾，最后选用其他的控制块并恢复其现场即可</p><h3 id="调度性能准则"><a href="#调度性能准则" class="headerlink" title="调度性能准则"></a>调度性能准则</h3><ul><li><p>周转时间：作业从提交到最后完成所经历的时间，包括所有等待、执行、输出等时间</p></li><li><p>等待时间：用户输入请求到系统开始处理任务所需要的时间</p></li><li><p>吞吐量、处理机利用率、资源利用率等</p></li></ul><h2 id="调度算法设计要点"><a href="#调度算法设计要点" class="headerlink" title="调度算法设计要点"></a>调度算法设计要点</h2><h3 id="进程优先级-数"><a href="#进程优先级-数" class="headerlink" title="进程优先级/数"></a>进程优先级/数</h3><p>优先数相当于把优先级用数字具体表示了出来，反映了某个优先级，可以采用静态/动态的方式组织优先级。<strong>按优先级排队方式</strong>就是按照不同进程优先级进行等待队列排序的一种调度方式。</p><h3 id="占用-CPU-的方式"><a href="#占用-CPU-的方式" class="headerlink" title="占用 CPU 的方式"></a>占用 CPU 的方式</h3><ul><li>不可抢占式方式：一旦 CPU 资源被分配，除非进程自身进入阻塞状态，或时间片耗尽外，不会让出 CPU</li><li>抢占式方式：就绪队列中一旦存在更高优先级进程，就直接进行进程调度</li></ul><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片决定了 CPU 允许进程运行的时间长度：<strong>时间片短</strong>导致频繁切换进程，会产生大量开销；<strong>时间片长</strong>又会导致某些进程不能得到及时响应，调度能力退化；同时时间片的设置也与 CPU 硬件能力、进程执行的操作等相关</p><h3 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h3><ul><li>第一种分类方式：<ul><li>I/O 密集型：频繁进行 I/O，会花费很多时间进行阻塞等待</li><li>CPU 密集型：计算需求大，需要大量算力进行运算</li></ul></li><li>第二种分类方式：<ul><li>批处理进程：无需交互、响应，通常自行完成功能</li><li>交互式进程：I/O 等交互频繁，同时响应速度要求高</li><li>实时进程：实时性高，响应时间短，不能被低优先级进程阻塞，优先处理</li></ul></li></ul><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><blockquote><p>批处理系统有以下几种常见的调度算法：先来先服务-FCFS，最短时间优先-SJF，最短剩余时间有限-SRTF，最高响应比优先-HRRF</p></blockquote><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 - FCFS"></a>先来先服务 - FCFS</h3><p>进程按照就绪的顺序进行调度，并采用<strong>非抢占式</strong>执行，进程阻塞结束后也不会立即抢回 CPU 继续执行，而是重新进入队列排队</p><ul><li>FCFS 特点：</li><li>利于长时间作业，不利于短时间作业</li><li>利于 CPU 集中型作业，不利于 I/O、交互集中型作业</li></ul><h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先 - SJF"></a>短作业优先 - SJF</h3><p>在 FCFS 的基础上改进，同样采用非抢占式执行，但<strong>进程的排队顺序变为占用时间长短</strong>，短进程优先执行，用以减少 CPU 的等待时间</p><ul><li>SJF特点：</li><li>提高系统吞吐量，缩短作业总等待时间</li><li>不能体现作业之间的优先级，同时对长作业很不利，可能长时间无法运行</li></ul><h3 id="最短剩余时间-SRTF"><a href="#最短剩余时间-SRTF" class="headerlink" title="最短剩余时间 - SRTF"></a>最短剩余时间 - SRTF</h3><p>一言蔽之，抢占式的短作业优先策略。</p><p>如果一个新就绪的进程如果时间比当前进程短，就会直接切换，即一直运行剩余时间最短的进程。</p><ul><li>持续的短任务可能会导致长任务一直无法运行/被抢占，导致长进程饥饿</li></ul><h3 id="最高响应比算法-HRRF"><a href="#最高响应比算法-HRRF" class="headerlink" title="最高响应比算法 - HRRF"></a>最高响应比算法 - HRRF</h3><p>HRRF 实际上是短作业优先与先到先服务两个算法的结合，即综合考虑作业等待时间和作业运行时间后再进行调度，同时系统是非抢占的。</p><p>在每次选择作业投入运行时，先计算每个作业的响应比（RR），然后选择权重最大的投入运行。<br>$$<br>RR=1+\frac{已等待时间}{要求运行时间}<br>$$</p><ul><li>HRRF特点：</li><li>短作业容易获得高权重（同等的等待时间时，其要求运行时间更短）</li><li>不会发生饥饿现象（由于等待时间能控制权重，所以长作业不会饥饿）</li><li>计算响应比需要时间开销，算法本身的性能较差</li></ul><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><blockquote><p>交互式系统常见调度算法如下：时间片轮转算法、优先级算法、多级队列算法、多级反馈队列算法</p></blockquote><h3 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h3><p>各个进程通过轮换运行较短的时间片，使用进程切换来提高<strong>进程的并发性</strong>和<strong>响应时间</strong>等特性，从而提高资源利用率</p><h4 id="时间片轮转的步骤"><a href="#时间片轮转的步骤" class="headerlink" title="时间片轮转的步骤"></a>时间片轮转的步骤</h4><ul><li>按照插入时间形成调度队列</li><li>将 CPU 分配给队列头部进程，并运行一个时间片</li><li>时间片结束后使用时钟中断来暂停进程，并将该进程移动至队尾</li><li>重新分配 CPU，直至所有进程结束</li></ul><p>系统是非抢占式的，进程停止运行可以是时钟中断，或是自行让出（阻塞态）。时间片长度过长会导致算法退化为 FCFS，即每个进程都只在单个时间片内运行结束；过短则会导致进程频繁切换，切换上下文的过程中时间开销大。</p><h3 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h3><p>优先级算法平衡了各进程对响应时间的要求，优先级可以是静态/动态生成的。</p><ul><li>静态优先级：在创建进程时就确定该进程的优先级：进程类型（用户/内核），资源需求量、用户等级</li><li>动态优先级：在进程调度过程中可能发生动态更改；可以类似于一堆人等着吃饭，厨师看情况再决定给谁先做<ul><li>进程等待时间过长等可以导致优先级提高（等的时间长了就先做饭）</li><li>进程每次执行一个时间片就降低优先级（吃了一点了就后做）</li></ul></li></ul><h3 id="多级队列算法"><a href="#多级队列算法" class="headerlink" title="多级队列算法"></a>多级队列算法</h3><p>引入多个就绪队列，并给各个队列不同的优先级，以此调度进程。</p><p>不同的队列有不同的优先级、时间片长度、调度策略。例如系统进程和用户进程、不同用户的进程就可以放在不同的就绪队列中用以优先调度</p><h4 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a>多级反馈队列算法</h4><p>在多级队列算法和时间片轮转算法基础上发展而来，优先短进程以提高系统吞吐量、缩短平均周转时间；优先 IO 进程以获得更短的响应时间</p><p>实际操作：</p><ul><li>设置多个不同优先级的就绪队列，并保证<strong>优先级越低时间片越长</strong></li><li>新进入的进程从最高优先级队列开始插入，如果在该时间片结束后仍未结束，则对其“降级”，即插入下一级的队列中</li><li>只有当高优先级队列为空时才能调度低优先级队列中的进程；当出现抢占时，被抢占进程重新插入至原队列末尾，不改变优先级</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305071557744.png" alt="image-20230507155736703"></p><p>在这种算法下， I/O 进程通常在最高优先级队列/阻塞队列中，计算进程通常在低优先级队列中</p><h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><blockquote><p>优先级倒置是高优先级进程被低优先级进程阻塞，或在其之后运行的现象</p></blockquote><p>常见于高、低优先级进程共享临界资源时：当低优先级进程先获取了临界资源，随后被高优先级进程抢占，高优先级进程又需要该临界资源。此时高优先级进程只能阻塞，等待低优先级进程完成临界资源使用后才能恢复。</p><p>下图的 Task A 就被 Task C 阻塞了，这里的 Task B 就先于 Task A 运行，产生了优先级的倒置</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305071602070.png" alt="image-20230507160228040"></p><p>解决优先级倒置的方式是<strong>优先级继承</strong>：当高优先级进程阻塞后，可以令等待的目标进程获取和高优先级进程相同的优先级，这样就会立即运行拥有临界资源的进程。</p><p>也就是给 Task C 一个和 A 相同的优先级，当 Task A 阻塞后，B 的优先级没有继承后的 C 高，所以不会发生优先级倒置</p><h2 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h2><p>实时系统是一种时间起主导作用的系统，也就是说，计算机系统需要对某个外界产生的操作在合适的时间内做出响应，也就是说，操作响应的实时性在这类系统中十分重要。</p><p>实时系统的进程要求更详细的调度信息：资源要求、详细优先级、响应截止时间。采用<strong>抢占式调度</strong>，响应中断快速，采用较小的调度单位（更轻量的线程）</p><p>常见的实时调度算法有以下几种：静态表调度、单调速率调度，最早截止时间优先算法</p><h3 id="静态表调度算法"><a href="#静态表调度算法" class="headerlink" title="静态表调度算法"></a>静态表调度算法</h3><p>通过对所有周期性任务的分析预测，预先确定一个固定的调度方案。</p><ul><li>不需要计算，只按照固定的方案进行，调度的开销最小</li><li>拓展性差，只适用于固定的场景，要求系统中只有已知的进程</li></ul><h3 id="单调速率调度算法"><a href="#单调速率调度算法" class="headerlink" title="单调速率调度算法"></a>单调速率调度算法</h3><p>静态要求下最优的调度算法，开销小，灵活性相对好</p><ul><li><strong>任务的周期越小，优先度越高</strong>，按照优先级高低进行调度，对于同优先级进程随机调度</li><li>该调度是静态、抢占式的</li></ul><h3 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h3><p>按照任务的截止时间设置优先级，优先级越高的任务最先被调度，也就是说优先级是实时变化的，对同优先级进程随机调度。</p><h3 id="最低松弛度优先算法"><a href="#最低松弛度优先算法" class="headerlink" title="最低松弛度优先算法"></a>最低松弛度优先算法</h3><p>$$<br>松弛度=截止时间-剩余运行时间-当前时间<br>$$</p><p>该算法按照各进程的松弛度进行进程的调度，当某个进程的松弛度为0时会发生<strong>抢占式调度</strong>（此刻全力运行该进程才能刚好运行完，换句话说不抢占就完不成了）</p><h2 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h2><p>多处理机调度更注重整体的运行效率，对于单个处理机不过分注重其利用率，同时多调度机需要考虑访问的互斥问题；<strong>调度单位多为线程</strong></p><p>多处理机系统可分为非对称式和对称式两种。</p><ul><li>非对称式：各个处理器的地位不同，每个处理器有各自分工，存在一个<strong>主处理机</strong>向外分发任务</li><li>对称式：处理器地位相同，调度算法分集中、分散两种。</li></ul><h3 id="对称式处理系统的调度算法"><a href="#对称式处理系统的调度算法" class="headerlink" title="对称式处理系统的调度算法"></a>对称式处理系统的调度算法</h3><ul><li>静态分配（集中）：每个 CPU 设立一个就绪队列，进程分配给某个处理器后就不会变更处理器运行；调度算法的开销小，但是各处理器会<strong>忙闲不均</strong></li><li>动态分配（集中）：所有 CPU <strong>共享</strong>一个就绪队列，队首进程分派到空闲 CPU 中运行，能解决忙闲不均问题</li><li>自调度（分散）：系统采用一个公共就绪队列，处理机选取适当进程执行，易于移植，相对成熟<ul><li>不需要处理机进行任务分配，但是共享队列的同步、不同处理机的 cache 等缓存、线程协作等需要设计</li></ul></li><li>成组调度（分散）：分配和阻塞时的单位为<strong>一组线程</strong>，每次分配都为这组线程寻找一组合适的处理机<ul><li>成组调度提高了线程的并行度，有利于减少阻塞</li><li>可以减少调度次数，从而减少调度算法自身的开销</li><li>相当于面向进程分配任务，而不是面向线程</li></ul></li></ul><h1 id="4-4-死锁"><a href="#4-4-死锁" class="headerlink" title="4.4 死锁"></a>4.4 死锁</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>一组进程中，每个进程都无限等待被其他进程所占用的资源，并且将永远获取不到对应资源而无法运行的现象。</p><h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><p>注意这里说的是<strong>必要条件</strong>，也就是说只要有一个条件被打破，死锁就不会存在</p><ul><li>互斥条件：存在互斥资源，并且只能由一个进程占用，只有该进程主动释放，其他进程才能再分配给其他进程</li><li>请求并占有条件：当进程无法获得所有资源请求，而被迫阻塞时，不会释放自己已经获得的资源（类似于 sleep 不放锁</li><li>不可剥夺条件：进程已获得的资源<strong>只能由</strong>进程在使用结束后释放</li><li>环路等待条件：发生死锁时，必然存在一条环状链将所有发生死锁的进程有序连接<ul><li>需要注意如果环路中的某个点同时可以请求环路外的某进程所持有的资源，这个环路将不成立，也就是这个回路不一定能锁上</li></ul></li></ul><h3 id="活锁和饥饿"><a href="#活锁和饥饿" class="headerlink" title="活锁和饥饿"></a>活锁和饥饿</h3><ul><li>活锁：执行者未被阻塞，但某些条件不满足，导致进程持续尝试（也持续失败<ul><li>活锁可能会在某次尝试中自行解开，死锁由于陷入等待，无法自救</li></ul></li><li>饥饿：资源分配策略不公平导致某些进程长时间等待，产生饥饿。<ul><li>通常在短任务优先等抢占式调度方式时，长作业就很容易饥饿</li></ul></li></ul><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><blockquote><p>通常采用死锁预防、死锁避免、死锁检测三个方式对死锁进行处理。</p></blockquote><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><blockquote><p>死锁预防通过打破死锁的<strong>四个必要条件</strong>，阻止死锁的形成。是排除死锁的<strong>静态策略</strong>。</p></blockquote><ol><li>互斥条件：允许多个进程占用同一个互斥资源（通常不可实现）</li><li>申请且占有条件：实现资源的预分配，当系统能够满足进程的全部资源请求时一次性把所有资源全部分配，否则不分配任何资源<ul><li>资源的利用率低；同时计算一个动态进程需要的全部资源也很困难</li></ul></li><li>不可剥夺条件：当请求不能被满足时，进程立刻释放已有的全部资源并等待之后重新申请，相当于这部分已分配的资源被“剥夺”了</li><li>循环等待条件：实施资源有序分配的策略，将所有资源按号分配，并且所有资源请求都必须先申请小号资源，从而避免产生环路。<ul><li>编号带来的系统开销大；同时会预先占用可能不常用的资源，导致资源利用率低</li></ul></li></ol><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><blockquote><p>死锁避免不限制死锁的必要条件，而是动态地检测每一个申请资源的请求，然后再决定是否进行资源分配，是一种排除死锁的<strong>动态策略</strong>。</p></blockquote><p>安全序列：一个进程的序列，对于其中每一个进程而言，其占用的资源可以被系统可用资源 + <strong>已被序列靠前的进程</strong>占用的资源所满足</p><p>如果不存在这样一个序列，则系统是<strong>不安全的</strong>。但是系统不安全不一定会发生死锁，反之，死锁时系统一定处于不安全状态。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><blockquote><p>银行家把固定资金贷款给若干顾客，在过程中只要不出现超过最大值的请求，应能保证资金安全。</p></blockquote><ul><li>单次请求的最大需求量不超过现有现金时即可处理请求</li><li>一次请求中的金额可以分期支付，但总和不会超过请求的最大需求量</li><li>当现有现金不能满足请求的请求剩余的金额时，请求会被搁置，但总能处理</li><li>当满足了请求的所有需求后，会在一定时间内归还所有资金</li></ul><p>这里处理的资源就只有一种：“现金”，而在操作系统中，我们会对可能用到的所有种类的资源都进行如上的限制。</p><p>在银行家算法中，我们假定有 $n$ 个进程，同时有 $m$ 种类型的资源</p><h4 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h4><ul><li>可利用资源向量 <code>Available</code>：一个具有 $m$ 个元素的向量，向量的每一个值都代表对应类资源的<strong>可用资源数量</strong>。即 <code>Available[j] = k</code> 说明第 $j$ 类资源目前可用 $k$ 个。</li><li>最大需求矩阵 <code>Max</code>：一个大小为 $n × m$ 的矩阵，定义了所有进程对于所有资源的最大需求数量。即 <code>Max(i, j) = k</code> 说明第 $i$ 个进程最多需要 $k$ 个 $j$ 类资源</li><li>分配矩阵 <code>Allocation</code>：一个大小为 $n × m$ 的矩阵，定义已经分配给进程的资源数目，规则类似于 <code>Max</code> 矩阵</li><li>需求矩阵 <code>Need</code> ：一个大小为 $n × m$ 的矩阵，定义进程仍需的资源数目。</li></ul><p>根据三者关系，易得<br>$$<br>Need(i,j)=Max(i,j)-Allocation(i,j)<br>$$</p><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>当一个进程发出资源请求后，操作系统会按序进行检查：</p><ul><li>如果数量超过了 $Need(i,j)$，说明前提/请求出错</li><li>当数量超过了$Available(i,j)$，说明当前资源无法满足请求，<strong>进程等待</strong></li><li>尝试修改资源矩阵，并进行<strong>安全性算法</strong>检查；未通过则复原矩阵，拒绝请求</li></ul><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><ol><li>设置两个向量：<ul><li><code>Work</code>：一个 m 个元素的向量，表示系统可提供的资源数，初始值与$Available$相同</li><li><code>Finish</code>：表示系统是否有足够资源进行分配，初始时为 <code>false</code></li></ul></li><li>从进程集合中找到一个进程 $i$，满足：<ul><li>$Finish[i] = false\ \ &amp;&amp;\ \ Work \gt Need(i)$，说明进程 $i$ 可以正常结束，并释放 $Max(i)$ 所占用的全部资源</li><li>令 $Finish[i] = true\ \ &amp;&amp;\ \ Work\ += Allocation(i)$，并重复本过程，直至找不到满足条件的进程</li></ul></li><li>循环结束，检查此刻的 $Finish$ 向量，如果满足所有进程均为 <code>true</code>，则说明系统出于安全状态（能找到一个序列进行资源的分配）；否则系统将处于不安全状态</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>允许互斥、资源部分分配、满足不可抢占、资源利用率高</li><li>要求进程预先计算最大资源请求，难以实现</li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><blockquote><p>保存资源的请求、分配信息，判断是否会在分配的过程中发生死锁</p></blockquote><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p><strong>资源分配图算法</strong>：一个有向图 $G$ 的顶点为<strong>资源或进程</strong>，这个图的边有两种属性：</p><ul><li>进程 → 资源：进程发起资源的<strong>请求</strong>，也叫<strong>请求边</strong></li><li>资源 → 进程：资源已经<strong>分配</strong>给进程，也叫<strong>分配边</strong></li></ul><p>对于它的进程顶点，也有两种属性：</p><ul><li>封锁进程：请求了超过系统中未分配的总数的资源</li><li>未封锁进程：与封锁进程相对应</li></ul><p>在这样的资源分配图中，若要发生死锁，则图中必须有环，<strong>反之则不然</strong>。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305300040363.png" alt="有环无死锁案例"></p><p>图中 $R$ 为进程节点， $P$ 为资源节点</p><h4 id="资源分配图的化简"><a href="#资源分配图的化简" class="headerlink" title="资源分配图的化简"></a>资源分配图的化简</h4><p>对于一个非封锁进程，有如下的化简流程：</p><ul><li>对于所有请求边，都转化为分配边</li><li>当进程只含有分配边时，说明程序所需的所有资源请求都已满足，这时等待程序结束释放资源</li><li>释放资源时将所有的分配边也去掉，只保留进程和资源的节点</li></ul><h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统处于死锁状态，当且仅当资源分配图不可完全化简；换言之，若能消去所有边，即说明资源请求关系已被处理，则系统不处于死锁状态。</p><h2 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h2><p>死锁解除要求释放资源的进程恢复到原来的状态，保证程序的正常运行。</p><ul><li>资源剥夺法：先挂起一些进程，暂时释放它们拥有的资源，供其他进程调度<ul><li>保证不总是剥夺一个进程的资源，均匀处理</li></ul></li><li>撤销进程法：使全部进程按照某种顺序回退，直至死锁状态消除<ul><li>经济合算的算法使得进程回退带来的开销最小</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305300057566.png" alt="死锁小结"></p><h1 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程由程序段、数据、进程控制块三部分构成</li><li></li><li>管道机制允许两个进程按<strong>生产者 - 消费者</strong>方式进行通信</li><li>内核级线程需要进入内核切换，用户级线程不需要；内核级线程可以按线程阻塞，用户级只能按进程</li><li>并发进程失去<strong>封闭性</strong>，指并发进程共享变量，其执行结果与速度有关（可受到外界影响）</li><li>关于数据结构的存放：<ul><li>正文段：全局<strong>变量</strong>（赋值 → <code>.data</code>、未赋值 → <code>.bss</code>），常量</li><li>进程控制块：进程优先级</li><li>堆区：<code>malloc</code> 等动态申请的存储区域</li><li>栈区：函数调用传递的参数、未赋值的局部<strong>变量</strong></li></ul></li><li><strong>进程唤醒</strong>指的是重新进入就绪态，并不能直接进入运行态，唤醒类似于 <code>notifyAll</code>，同时要区分唤醒（阻塞 → 就绪）与调度（就绪 → 运行）的区别</li><li>用户级线程可以在任意操作系统中执行，因为其实现基于用户程序</li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><ul><li>对短作业不利的是先进先出算法，所有因抢占式处理不当可能出现饥饿的调度算法都对长作业不利</li><li>考虑紧急作业时使用剥夺式优先级算法，提前运行特定任务；考虑人机交互时使用时间片轮转算法，均衡运行各个任务</li><li>优先级算法是绝对可抢占的</li><li>$响应比=\frac{等待时间+运行时间}{运行时间}$</li><li>$周转时间=处理结束时间-任务进入系统的时间$ ，计算平均周转时间时要记得减去任务进入的时间点</li></ul><h2 id="同步与互斥-1"><a href="#同步与互斥-1" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>临界区是指并发进程访问临界资源（共享变量）的代码程序</li><li>对并发进程同步的原因是并发进程是异步的</li><li>临界区的执行可以被中断，例如申请 I/O，但内核态的临界区不会中断</li><li>管程定义了共享数据结构和各种进程在该数据结构上的全部操作</li><li>用信号量实现互斥，初值为 1；实现同步，由用户决定</li><li>当采用“读/写者优先”的策略时，有可能会使得另一种角色发生<strong>饥饿</strong></li><li>管程中的 <code>signal</code> 与 <code>V</code> 操作不同，V一定释放信号量，signal 可能没有待唤醒的进程</li><li>并发进程是时间上重合的，可能有交互也可能没关系</li><li>信箱通信是一种间接通信方式</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>破坏四个必要条件的方式：<ul><li>循环等待：资源有序分配策略</li><li>不剥夺：暂时释放已有资源</li><li>请求并保持：预先静态分配，运行前一次性申请所有资源</li><li>无法破坏互斥条件</li></ul></li><li>资源分配图是一个有向图，用于表示某时刻<strong>系统资源</strong>与<strong>进程</strong>之间的关系</li><li>当每种资源都只有一个，且出现环路时，必然死锁；若没有前提限制，则不一定死锁</li><li>产生死锁的根本原因是系统资源分配不足和进程推进顺序非法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter3-2</title>
      <link href="/2023/05/os/buaa-os-theory-chapter3-2/"/>
      <url>/2023/05/os/buaa-os-theory-chapter3-2/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-内存管理-Part2"><a href="#第三章-内存管理-Part2" class="headerlink" title="第三章 内存管理 - Part2"></a>第三章 内存管理 - Part2</h1><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><blockquote><p>通过分页式存储管理可以把一个逻辑地址连续的程序装入到若干不连续的物理地址中，这可充分利用存储空间、减少移动带来的开销</p></blockquote><p>主要针对的问题：</p><ul><li>动态内存分配</li><li>碎片、紧凑问题</li></ul><p>定义：</p><ul><li>页：每个作业的<strong>地址空间</strong>分成的<strong>大小相同</strong>的片</li><li>存储块/页框：主存的<strong>存储空间</strong>也被分为与页相同大小的片</li></ul><h2 id="分页地址结构"><a href="#分页地址结构" class="headerlink" title="分页地址结构"></a>分页地址结构</h2><blockquote><p><code>页号 | 偏移量</code></p></blockquote><p>分页式结构下，地址由两部分组成，页号可以是物理块号也可以是逻辑页号，两者可以转换</p><ul><li><p>逻辑地址、物理地址在同一系统内的页/块内偏移位数（大小）一致</p></li><li><p>给定一个逻辑地址空间中的地址为 A ，页面的大小为 L ，则页号 P 和页内地址 d（从0 开始编号）为</p><ul><li>$P=INT[\frac A L],d=[A]modL$</li></ul></li><li><p><strong>页面大小</strong>是由硬件决定的，通常选用$2^n$作为页大小，最常用的页面大小为4KB</p><ul><li>若采用小页面：页内碎片、内存碎片减少，提高内存利用率；页面数多，<strong>页表</strong>占用内存大；换进换出速度降低，但<strong>效率高</strong>；若采用大页面则特点相反</li><li>分页开销为$\frac{se}p+\frac p 2$（页面大小$p=\sqrt{2se}$，进程平均字节s，页表项e）</li></ul></li><li><p>逻辑上相邻的页，在物理地址上不一定相邻</p></li></ul><h2 id="页表数据结构"><a href="#页表数据结构" class="headerlink" title="页表数据结构"></a>页表数据结构</h2><ul><li>进程页表：每个进程具有一个页表，描述该进程逻辑页与物理块的映射关系</li><li>物理页面表：整个系统只拥有一个物理页面表，描述物理空间的分配情况</li><li>请求表：整个系统有一个请求表，描述系统内各进程页表的大小额位置，用于地址转换</li></ul><p>页表的作用：</p><ul><li>记录进程的内存分配情况</li><li>实现进程运行时的动态重定位</li><li>访问内存数据需要访问内存两次（页表+内存地址）</li></ul><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>当逻辑地址较大时会导致页表增大，可以采用多级页表或动态调入页表的方式解决</p><ul><li>动态调入页表：只把部分页表项调入内存，待需要其他页面时再调入</li></ul><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><ul><li>逻辑地址划分：<code>二级页表|一级页表|页内地址</code></li><li>将一级页表再进行分页，将页表分散地存放在物理块中，再使用外部页表记录这些页</li><li>正在运行的进程必须调入二级页表，但是一级页表可以按需调入内存</li><li>对多级页表来说，各级页表存放的都是<strong>物理块号</strong>，他们指向内存中的下级页表或真正的被访问页</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201213740.png" alt="image-20230220121318596" style="zoom:67%;" /><h2 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h2><p>逻辑地址转换为物理地址：</p><ul><li>根据页号在页表中查询对应的项（页表始址+页号*页表项长度）</li><li>读出页表项对应的物理块号</li><li>使用<code>块号+页内地址</code>合成出物理地址</li></ul><h2 id="纯分页系统"><a href="#纯分页系统" class="headerlink" title="纯分页系统"></a>纯分页系统</h2><blockquote><p>若系统不支持内存主存的页面对换功能，就必须把程序的页一次性地装入内存；若当前内存不足则必须等待空闲</p></blockquote><p>优点</p><ul><li>没有外碎片，每个内碎片小于页大小（毕竟按页分块）</li><li>程序不必连续在内存中存放，系统可以轻易完成该进程新数据的装载</li></ul><p>缺点：</p><ul><li>程序需要一次性全部装入内存，占用开销大</li></ul><h2 id="MMU（Memory-Management-Unit）"><a href="#MMU（Memory-Management-Unit）" class="headerlink" title="MMU（Memory Management Unit）"></a>MMU（Memory Management Unit）</h2><blockquote><p>CPU为了提高地址转换效率，添加了一个硬件单元MMU，其主要包括：</p><ul><li>快表TLB：存放于虚拟地址相关的物理地址</li><li>TLB控制单元：TLB内容的填充覆盖、越界检查</li><li>页表查找单元：当TLB未命中时查找页表并输送给TLB单元</li></ul></blockquote><ul><li>MMU的工作流程：<ul><li>先在TLB中查询，成功匹配则分段查询（如果有多级页表）页表并得到物理地址；若未匹配则到外部页表中查询并置换进TLB中</li><li>根据TLB项判断是否符合访问规范</li><li>符合规范后再分段查询页表，返回物理地址</li></ul></li></ul><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><blockquote><p>TLB，即Translation Lookaside Buffer，是专门针对页表项的高速缓存Cache，其<strong>内容是</strong>页表中的一部分或全部内容</p></blockquote><ul><li>TLB的工作流程<ul><li>接收CPU产生的逻辑地址并将其分解为虚拟页码和页内地址</li><li>根据页码号在TLB中寻找有无对应的条目：成功匹配则返回物理块；若未命中则前往完整页表中寻找，并将页表项复制进TLB中</li><li>最终合成出物理块+页内地址形式的物理地址</li></ul></li><li>通常TLB的条目数在$64\textasciitilde1024$之间，并且有些条目有可能不能被替换出TLB（比如内核代码）</li><li><code>ASID</code>：其可以用来唯一地标识进程，只有当申请访问的程序和页表项对应的进程一致（<code>ASID</code>相同）才允许访问，否则即说明<strong>页表项失效</strong><ul><li>（说明不同的程序正在访问相同的虚拟页码，因不同程序的映射规则不同，对应的物理块也不会一致，此时存放的物理块号是错误的）</li><li>如果允许TLB同时包含多个进程的页表项时，每次选择页表TLB都必须被<code>flushed</code>或删除，以确保下一个进程不会使用不匹配的映射</li></ul></li></ul><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><blockquote><p>一般意义上的页表构造了一个虚拟页$\to$物理块的映射，当虚拟页数量大时会消耗大量内存；而反置页表则是构建了一个物理块$\to$虚拟页的映射，其为每个物理块都说明了对应的虚拟页</p></blockquote><ul><li>反置页表项：<code>进程ID|逻辑页号</code></li><li>反置页表中，每一个物理块$i$都对应着反置页表的第$i$项，而第$i$项的信息则提示了这个物理块属于哪个进程、<strong>对应了哪个逻辑页</strong></li><li>通过构造反向的映射，<strong>反置页表的大小</strong>只与物理内存的大小相关</li><li><strong>反置页表的工作流程</strong>：<ul><li>利用进程ID和虚拟页号在反置页表中<strong>遍历所有项</strong>（相当于查询所有物理块）</li><li>如<strong>第$i$项</strong>产生匹配，则该虚拟页对应的**物理块号就为$i$**；如未发生匹配，则说明此虚拟页未存放在内存中，申请从主存中调页</li><li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282220544.png" alt="image-20230220183050472" style="zoom:67%;" /></li></ul></li><li>可以借助哈希表，将反置页表改造成反置链表：通过虚拟页码指向对应链表的头，进而仅查询该链表中的表项，从而减少遍历带来的时间消耗<ul><li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201834843.png" alt="image-20230220183423808" style="zoom:67%;" /></li><li>（只查询图中<code>Page Table</code>中的<code>Chain</code>内容即可）</li></ul></li><li>采用反置页表的系统难<strong>共享内存</strong>：每个物理块只对应一个虚拟页条目</li></ul><h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><ul><li>页的共享：对于多个程序需要共享同一个物理块的数据/程序时，应让它们包含该块的虚拟地址全部指向相同的物理块</li><li>共享带来的问题：<ul><li>若共享、不共享数据被划分在同一块内，将泄露数据；可以采用分段存储管理的方式专门对公开数据进行共享</li></ul></li><li>页的保护：<ul><li>地址越界保护</li><li>在页表中设置保护位：定义访问时的操作权限（有可能不同进程对相同的共享数据拥有不同的权限）</li></ul></li></ul><h1 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h1><blockquote><p>对于一个程序的各组成部分来说，他们对内存的需求并不相同</p></blockquote><ul><li>编程用户<ul><li>用户一般按照<strong>逻辑关系</strong>对作业分段，并根据名字访问程序段和数据段</li></ul></li><li>信息共享<ul><li>共享是以信息的<strong>逻辑单位</strong>——段，为基础的；而存储却是以物理单位——页，进行的</li><li>共享段的难度要比共享页的难度高</li></ul></li><li>信息保护<ul><li>一个页中可能存放了多个程序的内容，简单的页分享可能会导致数据的错误泄露</li><li>可以对信息采取段为单位进行分享和保护</li></ul></li><li>动态增长<ul><li>在进程运行的过程中，某些数据段可能会不断增长，存储管理方法存在困难</li></ul></li><li>动态链接<ul><li>在程序运行时才把目标程序和主程序进行链接</li></ul></li></ul><h2 id="分段地址空间"><a href="#分段地址空间" class="headerlink" title="分段地址空间"></a>分段地址空间</h2><blockquote><p>将<strong>段</strong>作为地址的分割依据，使得地址空间由各个分段组成，这些段可以不相连，但一个段的内部地址一定连续</p></blockquote><ul><li><strong>逻辑地址结构</strong>：<code>段号|位移量</code><ul><li>分区：按照磁盘的物理地址对内存进行划分</li><li>分页：按照固定大小的页对内存进行划分</li><li>分段：按照程序段长度对内存进行划分（分段长度自由，前两者都已固定）</li></ul></li></ul><h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><ul><li>段表记录了段号与内存物理地址的对应关系，并存放于内存当中</li><li>基址与长度由段表寄存器给出</li><li>优点：<ul><li>易于实现段的共享与保护</li></ul></li><li>缺点：<ul><li>处理地址花费时间，也要考虑段表的占用内存</li><li>为满足分段的动态增长、减少外碎片，要采用拼接内存的手段</li><li>在辅存中难管理不定长度的分段</li><li>分段尺寸受到内存大小的限制，不能超出内存空间</li></ul></li></ul><h3 id="地址变换过程-1"><a href="#地址变换过程-1" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul><li>查询申请访问的段号是否在段表内，如果超界则产生中断</li><li>检查段内位移量是否超出段的长度，如果超界则产生中断</li><li>若均为越界，则返回对应段号所在的物理地址<strong>基址</strong>，与段内位移量相加则得到物理地址</li></ul><h3 id="段共享"><a href="#段共享" class="headerlink" title="段共享"></a>段共享</h3><blockquote><p>若对于某一个程序/程序段，会被众多用户/程序调用，那么就可以共享这个段，声明其为<strong>可重入的</strong>，这样只需要保留一份<strong>只读代码</strong>在内存当中即可</p></blockquote><h1 id="分页式与分段式的比较"><a href="#分页式与分段式的比较" class="headerlink" title="分页式与分段式的比较"></a>分页式与分段式的比较</h1><ul><li>分页式地址空间是一维线性的；分段式则是二维地址空间</li><li><strong>页</strong>是信息的物理单位，其大小固定；<strong>段</strong>是信息的逻辑单位，其大小不定（但总具有完整的意义）</li><li>分页用户不可见，系统直接操作内存；分段用户可见</li></ul><p>分页有效解决了碎片问题，同时使得程序可以不连续存放</p><p>分段实现了数据高效共享与保护，可便捷所需空间动态增长的程序，也利于动态链接</p><h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><blockquote><p>段页式内存管理是分段、分页原理的结合：系统先将程序分为若干段，再把每段按照固定大小进行分页</p></blockquote><ul><li><strong>逻辑地址结构</strong>：<code>段号|段内页号|页内地址</code></li><li>访问时先访问内存的段表，找到<strong>对应页表</strong>的起始地址；再查该段的页表，找到段内页号对应的物理块号，最后根据物理块和页内地址访问物理内存</li><li>在逻辑上，程序被分成了长度不同的段，<strong>段内连续</strong>；在空间上，程序的段被分为了长度相同的页，<strong>段内不连续</strong></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202002672.png" alt="image-20230220200154810"></p><h2 id="x86的段页式实现（待补）"><a href="#x86的段页式实现（待补）" class="headerlink" title="x86的段页式实现（待补）"></a>x86的段页式实现（待补）</h2><h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><blockquote><p>覆盖，就是一个相对独立的程序单位。一个大的程序可以划分为一系列的覆盖</p></blockquote><ul><li>覆盖段：程序执行时并不要求同时装入主存的一组覆盖；这个覆盖段被分到同一个存储区域（覆盖区）</li><li>使用覆盖则必须在编程时提前确定模块间的覆盖关系，时间换空间</li></ul><blockquote><p>交换，把暂时不用的数据/程序从内存转移到辅存中，再把使用的数据转入主存</p></blockquote><ul><li>交换可以增加并发的程序数目；提供适当的响应时间</li><li>交换会增加处理机开销；没有考虑执行过程中地址访问的统计特性</li></ul><blockquote><p>因为<strong>在同一个覆盖段内</strong>的两个覆盖不会同时使用，所以可以对两个覆盖进行交换</p></blockquote><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><blockquote><p>局部性原理指在执行过程中的一个较短的时间内执行的指令和其操作数的地址都在都某区域内并受到约束</p></blockquote><ul><li>时间局部性：一条指令、一段数据的前后两次访问集中在某时间内</li><li>空间局部性：邻近的几条指令，访问的数据集中在某区域内</li><li>当程序出现对某数据结构的多次操作，通常局限在较小的范围内</li></ul><blockquote><p>快排的局部性比堆排好：堆排使得数据在整个数组内做大范围的跳动，而快排的数据访问间隔比较小，显然快排的空间局部性更好</p></blockquote><h1 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h1><blockquote><p>虚拟存储为每个进程提供了一个连续完整的地址空间，利用了主存和磁盘的特点（类似于Cache和主存的关系，下沉了一层，但两者<strong>有一定区别</strong>）</p></blockquote><blockquote><p>虚拟内存把地址空间定义为连续的虚拟内存地址，欺骗程序在使用一大段连续地址</p></blockquote><ul><li>每个进程都认为自己正在独占系统的所有内存；但并不是所有内容都直接放置在内存中，操作系统遵循<strong>覆盖</strong>的规则保留一部分内容</li><li>虚存保护了每个进程的地址访问操作，防止出现冲突</li><li>虚拟存储在主存和硬盘存储间<strong>交换</strong>，利用了主存的快速、硬盘的大空间特点</li></ul><h2 id="虚拟存储的基本原理"><a href="#虚拟存储的基本原理" class="headerlink" title="虚拟存储的基本原理"></a>虚拟存储的基本原理</h2><ul><li>按需装载：只需要将当前需要的分页/分段读入内存，后续需要的页/程序段在使用时再读入</li><li>缺页调入：在执行过程中发生缺页/缺段时从磁盘调入内存</li><li>不用调出：操作系统将内存不常用的页/段归还磁盘外存，调出后的空间供新的页/段调入使用</li></ul><h2 id="虚拟存储的特征"><a href="#虚拟存储的特征" class="headerlink" title="虚拟存储的特征"></a>虚拟存储的特征</h2><ul><li>离散性：物理内存分配上的不连续性、虚拟地址使用上的不连续性</li><li><strong>多次性</strong>：（<strong>分时复用</strong>）分多次调用程序进入内存，使得虚拟存储具有了在逻辑上<strong>扩大内存</strong>的功能；这时虚拟存储最重要的特征</li><li>对换性：内存、外存可进行交换，提高内存利用率</li><li>虚拟性：虚拟存储允许程序从逻辑的角度上访问存储器，而不需考虑实际的物理空间</li></ul><blockquote><p>虚拟性以多次性和对换性为基础</p><p>多次性、对换性以离散性为基础</p></blockquote><p>优点：</p><ul><li>程序调用的内存限制扩大，通常大于物理内存</li><li>可容纳更多的程序并发执行</li><li>不影响编程时的程序结构（与覆盖技术相比）</li></ul><p>缺点：</p><ul><li>时间换空间，以CPU工作时间和内外存交互的长时间为代价</li></ul><p>限制：</p><ul><li><strong>虚拟内存的最大容量由计算机的地址结构决定</strong></li></ul><h2 id="虚拟内存与Cache"><a href="#虚拟内存与Cache" class="headerlink" title="虚拟内存与Cache"></a>虚拟内存与Cache</h2><p>相同点：</p><ul><li>都为分层存储体系：充分利用高速存储器的速度和低速存储器的容量</li><li>原理相同：利用程序的局部性原理，进行信息的部分调用</li></ul><p>不同点：</p><ul><li>Cache侧重访问低速存储器的速度问题，虚存侧重高速存储器的容量问题（+内存管理、保护等）</li><li>CPU可直接访问内存；但不能直接访问外存，仍需要调取至内存才能访问</li><li>透明性不同：Cache作为硬件对程序员透明；虚存采用软件管理，受操作系统控制（对实现存储管理的系统程序员不透明，对应用管理员透明）</li><li>损失不同：主存未命中的损失远大于Cache未命中的损失</li></ul><h2 id="虚拟内存名词解释"><a href="#虚拟内存名词解释" class="headerlink" title="虚拟内存名词解释"></a>虚拟内存名词解释</h2><h3 id="进程的逻辑空间（虚拟空间）"><a href="#进程的逻辑空间（虚拟空间）" class="headerlink" title="进程的逻辑空间（虚拟空间）"></a>进程的逻辑空间（虚拟空间）</h3><p>使用虚存技术后对单个程序可见的空间，从0开始编址。这段空间逻辑上连续，但并不实际存在于内存/外存中</p><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230220212737131.png" alt="image-20230220212737131" style="zoom: 60%;" /><h3 id="虚拟地址空间与虚拟存储（内存）空间"><a href="#虚拟地址空间与虚拟存储（内存）空间" class="headerlink" title="虚拟地址空间与虚拟存储（内存）空间"></a>虚拟地址空间与虚拟存储（内存）空间</h3><p>进程的虚拟地址空间是进程在内存中存放的逻辑视图</p><p>一个程序的虚拟地址空间与虚拟存储空间大小相同</p><h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>一段按页划分的磁盘空间，对用户不可见</p><p>在物理内存不足时存放内存数据，为其他进程解放物理内存</p><h2 id="虚拟内存需要解决的问题"><a href="#虚拟内存需要解决的问题" class="headerlink" title="虚拟内存需要解决的问题"></a>虚拟内存需要解决的问题</h2><ul><li>地址映射问题：<strong>进程的逻辑空间</strong>到实际内存的映射问题</li><li>调入问题：调入机制、调入块的选择</li><li>替换问题：调出相关问题</li><li>更新问题：内存、外存数据的同步</li><li>其他问题：存储保护、程序重定位等</li></ul><h2 id="虚存的地址映射"><a href="#虚存的地址映射" class="headerlink" title="虚存的地址映射"></a>虚存的地址映射</h2><ul><li>内核在进程创建时没有把程序与数据交换进物理内存中（此时仅建立<code>虚存-磁盘</code>的映射），等到需要使用时才会通过<strong>缺页机制</strong>交换数据</li><li>用户可执行文件和共享库都以文件的形式存储在磁盘中，在页表中类型为<code>file backed</code></li><li><code>heap</code>和<code>stack</code>在磁盘上没有对应的文件，类型为<code>anonymous</code>，<strong>地址为空</strong></li><li><strong>未分配部分</strong>没有对应的页表项，只有当<code>malloc</code>申请内存时才建立页表项</li></ul><h2 id="虚存的调用机制"><a href="#虚存的调用机制" class="headerlink" title="虚存的调用机制"></a>虚存的调用机制</h2><blockquote><p>调入主存的数据有两类：</p><ul><li>OS的核心程序与数据</li><li>正在运行的用户进程相关的程序与数据</li></ul><p>借助<strong>缺页错误处理</strong>机制进行调用</p></blockquote><ul><li><p>调用时间：</p><ul><li>OS在系统启动时调入</li><li>用户数据调入有不同策略：预调页、按需调页</li></ul></li><li><p>预调页：同时将<strong>所有页</strong>都调入内存中，阻止大量开始运行时产生的页错误</p></li><li><p>按需调页：只有当缺页时才进行调用，类似使用<strong>交换</strong>的分页系统</p></li><li><p><strong>缺页错误处理机制过程</strong>：</p><ul><li>现场保护：发现异常进入内核态，保存现场信息</li><li><strong>页面定位</strong>：查找异常的虚拟页面</li><li>权限检查：检查虚拟地址有效性、安全保护位，出错则<code>kill</code></li><li>新页面调入1：通过页面置换找到一个需要换出的物理页</li><li><strong>旧页面写回</strong>：把这个物理页写回外存（需要置为忙状态，以防被其他进程抢占）</li><li><strong>新页面调入2</strong>：将虚存所需的页面从外存调入内存</li><li><strong>更新页表</strong>：项操作系统发出中断，更新内存的页表项</li><li>恢复现场</li></ul></li></ul><h1 id="实存管理与虚存管理"><a href="#实存管理与虚存管理" class="headerlink" title="实存管理与虚存管理"></a>实存管理与虚存管理</h1><p>实存管理方法：分区、分页、分段、段页式</p><p>虚存管理方法：（向外存）请求分页、请求分段、请求段页式</p><h2 id="请求分页-段式系统"><a href="#请求分页-段式系统" class="headerlink" title="请求分页/段式系统"></a>请求分页/段式系统</h2><p>与原本的分页/段式类似，只不过内存中只存放了部分的程序和数据，待其启动后再按需从外存中以页/段为单位进行调用即可</p><ul><li>硬件支持：页表/段表机制、缺页/缺段时的中断机构和地址变换机构</li><li>软件支持：请求调页/段、请求页/段置换的功能</li><li>页表项：<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202155726.png" alt="image-20230220215555699" style="zoom:67%;" /><ul><li>驻留位：1-在内存；0-在外存</li><li>保护位：只读、可写、可执行</li><li>修改位：此页在内存中有无修改操作</li><li>访问位：用于页面置换算法</li></ul></li></ul><h2 id="虚存页面置换策略"><a href="#虚存页面置换策略" class="headerlink" title="虚存页面置换策略"></a>虚存页面置换策略</h2><h3 id="最优置换策略"><a href="#最优置换策略" class="headerlink" title="最优置换策略"></a>最优置换策略</h3><blockquote><p>把所有页中未来最久不会被使用的页替换出去</p></blockquote><ul><li>具有最低的页错误率，然而这种方法不可能被实现</li></ul><h3 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h3><blockquote><p>当需要替换页时，把最先进入的页替换出去</p></blockquote><ul><li>借助一个队列，新访问的页面插入队尾，替换的页从队首出队</li><li><strong>性能较差</strong>：较早调入的页访问通常较多</li><li>Belady现象：分配的页面数增多，但缺页率却增高的现象</li></ul><blockquote><p>FIFO的置换特征，与进程访问内存的动态特征是矛盾的</p></blockquote><h3 id="Second-Chance策略、Clock（最近未使用算法）策略"><a href="#Second-Chance策略、Clock（最近未使用算法）策略" class="headerlink" title="Second Chance策略、Clock（最近未使用算法）策略"></a>Second Chance策略、Clock（最近未使用算法）策略</h3><blockquote><p>Second Chance是改进后的FIFO法，给每一个页面一个标记位，记录此页面是否被访问过</p></blockquote><ul><li>如果将要被换出的页面曾被访问过，就清除标记位，放至队尾重新入队；否则直接出队</li><li>当所有页面<strong>都被访问过</strong>时，也直接出队</li></ul><blockquote><p>Clock在Second Chance的基础上变更为了<strong>环形队列</strong>；在注意指针移动的基础上，其余操作保持一致</p></blockquote><ul><li><strong>FIFO类算法对比</strong>：<ul><li>命中率：Clock = Second &gt; FIFO</li><li>复杂度：Second &gt; Clock &gt; FIFO</li><li>代价：Second &gt; Clock &gt; FIFO</li></ul></li></ul><h3 id="LRU（最近最少使用）策略"><a href="#LRU（最近最少使用）策略" class="headerlink" title="LRU（最近最少使用）策略"></a>LRU（最近最少使用）策略</h3><blockquote><p>根据页面的历史访问记录进行替换：最近使用过的数据将来的访问几率更高</p><p>这种算法是局部性原理的合理近似，但硬件开销较大</p></blockquote><ul><li>设置一个栈，保存当前的所有页面号</li><li>当某个页面被访问时，取出栈中的页面号，重新压栈</li><li>当需要替换时，退出栈底的元素</li></ul><h4 id="AGING（老化算法）策略（-待补）"><a href="#AGING（老化算法）策略（-待补）" class="headerlink" title="AGING（老化算法）策略（*待补）"></a>AGING（老化算法）策略（*待补）</h4><blockquote><p>AGING是LRU的一种简化，性能上接近LRU，但减少了硬件开销</p></blockquote><ul><li>为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入。</li></ul><h3 id="虚存同步更新问题"><a href="#虚存同步更新问题" class="headerlink" title="虚存同步更新问题"></a>虚存同步更新问题</h3><blockquote><p>当一个页面被换出时，为了保持内存外存信息的一致性，必要时需要进行信息的更新</p></blockquote><ul><li>换出页面为<code>file backed</code>类，并未被修改：直接<code>discard</code>，因外存含有副本</li><li>换出页面为<code>file backed</code>类，但有修改：写回原有位置，因外存副本过期</li><li>换出页面为<code>anonymous</code>类，若第一次换出+未修改：写入<code>Swap</code>区；否则<code>discard</code></li><li>换出页面为<code>anonymous</code>类，且有修改：写入<code>Swap</code>区</li></ul><h2 id="工作集与驻留集管理"><a href="#工作集与驻留集管理" class="headerlink" title="工作集与驻留集管理"></a>工作集与驻留集管理</h2><blockquote><ul><li><strong>工作集</strong>：<strong>过去一段时间内</strong>进程访问的页面集合</li><li><strong>驻留集</strong>：进程被分配的物理页集合</li></ul></blockquote><h3 id="工作集策略"><a href="#工作集策略" class="headerlink" title="工作集策略"></a>工作集策略</h3><blockquote><p>引入工作集是为了调整驻留集的大小</p></blockquote><p>当进程开始执行后，工作集随着页面加载逐渐稳定；当进程的局部性区域变化时，工作集进行一次快速扩张和收缩，再到达一个稳定的值</p><h1 id="页表与自映射"><a href="#页表与自映射" class="headerlink" title="页表与自映射"></a>页表与自映射</h1><blockquote><p>假设页式内存管理中，一页大小为 a Byte，一个页表项的大小为 b Byte，且页表起始地址为 x（保证<strong>页对齐</strong>），求页目录（自映射）的地址？</p></blockquote><p>在实验课中我们很容易就能回答，答案是 x + x &gt;&gt; 10，但是怎么来的还是要有自己的理解。</p><p>首先可知，页表在所有页面的第 x / a 页上，那么页目录就应该从页表的起始地址向后数和页面数同样多的页表项数，这样取到的页表项就恰好对应页表的起始地址，也就是向后数 (x / a) * b Byte</p><p>最后再加上起始的页表基地址，结果为 <strong>x + (x / a) * b</strong></p><p>在这里代入 MOS 的数据，就是 x + (x / 4096) * 4 = x + x &gt;&gt; 10了</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter3-1</title>
      <link href="/2023/05/os/buaa-os-theory-chapter3-1/"/>
      <url>/2023/05/os/buaa-os-theory-chapter3-1/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-内存管理-Part1"><a href="#第三章-内存管理-Part1" class="headerlink" title="第三章 内存管理 - Part1"></a>第三章 内存管理 - Part1</h1><h1 id="存储器的管理"><a href="#存储器的管理" class="headerlink" title="存储器的管理"></a>存储器的管理</h1><ul><li>存储层次：寄存器-cache-主存-外存</li><li>存储管理的基本目标：<strong>地址独立</strong>（程序地址与物理地址无关）、地址保护（程序之间不能访问）</li><li>存储管理的核心问题：分配和回收</li><li>地址变换：可执行文件生成中的链接技术、程序加载时的重定位技术，进程运行时硬件和软件的地址变换技术和机构。</li><li>存储共享与保护：代码数据共享对地址空间的访问权限</li><li>存储器扩充：存储器的逻辑组织和物理组织</li><li><strong>地址空间与存储空间</strong><ul><li>地址空间（<strong>虚拟地址</strong>）：程序编译后限定于地址空间内，是<strong>逻辑地址</strong>的集合</li><li>存储空间（<strong>物理地址</strong>）：主存存储单元相关，是<strong>物理地址</strong>的集合</li></ul></li></ul><h1 id="单程序的内存管理"><a href="#单程序的内存管理" class="headerlink" title="单程序的内存管理"></a>单程序的内存管理</h1><blockquote><p>此情况下内存中只有操作系统和一个用户程序</p></blockquote><ul><li>操作系统只占用固定空间</li><li>用户程序永远从同一个地方开始运行，地址在运行前可以进行计算</li></ul><ul><li>方法：<ul><li>静态地址翻译：在程序运行前计算出所用的物理地址（可以由程序加载器实现），且无需地址翻译，运行速度快</li></ul></li><li>缺点：<ul><li>比物理内存大的程序无法加载、运行</li><li>不区分常用数据导致资源浪费</li></ul></li></ul><h1 id="多程序的内存管理-分区式内存管理"><a href="#多程序的内存管理-分区式内存管理" class="headerlink" title="多程序的内存管理 - 分区式内存管理"></a>多程序的内存管理 - 分区式内存管理</h1><blockquote><ul><li>把内存分为相等或不等的分区，操作系统占用一个分区，每个程序占用一个/多个分区</li><li>支持多程序并发执行，但难以进行内存分区的<strong>共享</strong></li></ul></blockquote><h2 id="静态式分区分配：程序适应分区"><a href="#静态式分区分配：程序适应分区" class="headerlink" title="静态式分区分配：程序适应分区"></a>静态式分区分配：程序适应分区</h2><ul><li>存储空间被分为任意大小的区域，区域大小不能更改，每次获取一部分分区进行作业</li><li>分区数据统计：分区表</li><li>分区分配：以待分配程序构成的队列<ul><li>单队列：所有程序在一条队列中等待任意一个空白分区</li><li>多队列：每个分区都有若干大小相近的程序等待</li></ul></li><li>优点：开销小，实现简单</li><li>缺点：<strong>内碎片浪费</strong>、分区数目受限</li></ul><p>静态式分区也被叫做固定式分区，其<strong>允许不同分区大小不同</strong></p><h2 id="动态式分区分配：分区适应程序"><a href="#动态式分区分配：分区适应程序" class="headerlink" title="动态式分区分配：分区适应程序"></a>动态式分区分配：分区适应程序</h2><ul><li>分区的边界可以进行移动，即动态地改变分区大小，以适应程序需要</li><li>优点：无内碎片</li><li>缺点：<strong>有外碎片</strong></li></ul><h2 id="可变分区分配（不常用）"><a href="#可变分区分配（不常用）" class="headerlink" title="可变分区分配（不常用）"></a>可变分区分配（不常用）</h2><ul><li>内存分配使用两张表：已分配分区表和未分配分区表；<ul><li>每张表单项为存储控制块<code>MCB</code>，分配了的即<code>AMCB</code>(allocated)，未分配即<code>FMCB</code>(free)</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181509788.png" alt="image-20230218150958760" style="zoom:67%;" /><ul><li>空闲分区中的一小部分作为<strong>存储控制块</strong>按次序形成<code>FMCB</code>链表结构；当分区被分配后，前后指针无意义</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181512892.png" alt="image-20230218151214857" style="zoom:50%;" /><h1 id="系统中的碎片"><a href="#系统中的碎片" class="headerlink" title="系统中的碎片"></a>系统中的碎片</h1><blockquote><p>内存中无法被利用的存储空间被称为<strong>碎片</strong></p></blockquote><ul><li>内部碎片：<ul><li>分区分配后，区块内没被使用的内存</li><li><strong>分区大小固定</strong>的存储管理方式均会出现内部碎片</li><li>内部碎片无法整理，只能等待程序结束后释放整个分区，从而释放这些碎片</li></ul></li><li>外部碎片：<ul><li>系统无法利用的空闲分区、分区<strong>间</strong>存在的内存，空间小且不连续</li><li>动态分区管理会产生外部碎片</li><li>外部碎片是<strong>造成内存系统性能下降的主要原因</strong>，对分区进行<strong>紧凑处理</strong>可消除外部碎片</li></ul></li></ul><h2 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h2><blockquote><p>操作系统跟踪内存的两种方法：位图表示法（<strong>分区表</strong>）、链表表示法（<strong>分区链表</strong>）</p></blockquote><ul><li>位图表示法：给每个分区赋予一个字位，记录该单元是否闲置（例如取0代表闲置，取1代表占用）<ul><li>空间成本固定：仅依赖于内存分区数量，与程序数量无关</li><li>时间成本低：直接对位图修改即可</li><li>无容错能力：若位图因错误访问被更改，其本身不具有检错的能力</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181459310.png" alt="image-20230218145920225" style="zoom:67%;" /><ul><li>链表表示法：将给程序分配的单元按照位图的形式连接起来，再在不同程序间采用链表进行连接<ul><li>空间成本不定：取决于程序数量</li><li>时间成本：链表遍历、修改、插入删除较慢</li><li>有一定容错能力：链表有被占用的标志位，可以一定程度上互相验证</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181502696.png" alt="image-20230218150205665" style="zoom:67%;" /><h1 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h1><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><ul><li>实现内存分配的流程：<ul><li>规定<code>size</code>为不再切割的剩余分区的大小、请求的分区大小为<code>u.size</code>，空闲分区的大小为<code>m.size</code></li><li>若<code>m.size - u.size &lt;= size</code>，则将整个分区都分配给请求者（按最小单位也分不开了，就全给了吧）</li><li>否则从该分区内划分一部分并进行分配，余下部分保留在空闲分区表/链表中</li></ul></li><li>流程图如下：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181519733.png" alt="image-20230218151956700" style="zoom:50%;" /><h2 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h2><ul><li>回收分区上下紧邻空闲分区时，直接进行<strong>合并</strong>，合并后修改空闲分区表/链表中的首地址和大小</li><li>回收分区不邻接空闲分区时，在空闲分区表/链表中<strong>新建</strong>表项，记录分区的首地址和大小</li></ul><h2 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h2><ul><li>首次适应算法：按地址递增顺序<strong>从头查询</strong>，选择第一个空间符合要求的分区分配<ul><li>优先利用低地址的空闲分区，开始时查找简单，但易在低地址产生大量不能利用的碎片，增加了后续查找的开销</li></ul></li><li>下次适应算法：按地址递增顺序<strong>从上次分配的地址</strong>开始查询（到达最大值后循环），选择第一个符合要求的分区<ul><li>均匀利用所有分区，不会产生密集的碎片，但使得内存中不存在大空间的分区</li></ul></li><li>最佳适应算法：总寻找<strong>大小最接近</strong>作业所需区域的分区进行分配<ul><li>由于选取大小最接近的分区，划分后的碎片几乎没有办法应用，所以极易产生大量碎片</li></ul></li><li>最坏适应算法：只寻找<strong>最大</strong>的空白分区并进行分配<ul><li>内存中大空间的分区较难保留，大任务难处理，但碎片相对少</li></ul></li></ul><p>为了提高搜索空闲分区的速度，大中型系统使用基于索引搜索的动态分区分配算法</p><ul><li>快速适应算法：把空闲分区按照容量大小进行分类，根据程序所需找到能容纳它的最小的空闲区链表，取下第一块进行分配<ul><li>可以保留大的分区，也不会产生碎片；但归还内存时系统开销大</li></ul></li></ul><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><blockquote><p>伙伴系统是介于固定分区和可变分区间的动态分区方法</p><p>在分配存储块时将一个大块分裂成两个<strong>相同大小</strong>的小块（伙伴）</p></blockquote><ul><li>伙伴系统内所有分区的大小都是$2^k$，其中$n\le k\le m$，$2^n$表示最小的分区大小，$2^m$表示整个可分配内存的大小</li><li>在不断划分分区的过程中，可能形成若干个<strong>不连续的</strong>空闲分区</li><li>内存管理模块包含多个空闲块链表，单个链表内部都指向相同大小的空分区</li><li><strong>内存分配时</strong>：程序提出一个$2^k$字节（应大于所需内存字节数，同时保证$k$最小）大小的申请，从链表中查找一个$2^{k+1}$字节大小的空分区，一半供给程序，另一半放入空闲块链表中</li><li><strong>内存回收时</strong>：考虑能否和伙伴块合并为一个更大的块，再递归此操作（注意不能和<strong>非伙伴块</strong>合并）</li><li>特点：<ul><li>回收内存时只需要搜索一部分块（同大小的）进行查询</li><li>会产生内部碎片</li></ul></li></ul><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230218212431919.png" alt="image-20230218212431919" style="zoom: 67%;" /><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230218212528666.png" alt="image-20230218212528666" style="zoom: 67%;" /><h2 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h2><p>定时地、或在内存紧张时，移动已分配区域的数据，把外部碎片和空白的分区合并为一个大的连续区域</p><ul><li>以时间换空间</li><li>对系统的性能开销要求大</li></ul><h1 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h1><blockquote><p>一个用户源程序在内存中通常需要如下处理：</p><ul><li>编译：使用编译程序将源程序编译成若干个模块</li><li>链接：将目标模块和使用的库函数链接成可装载模块（可执行文件）</li><li>装入：将可装载模块装入内存空间   </li></ul></blockquote><h2 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h2><blockquote><p>系统编译C程序时，是以<code>.c</code>文件作为编译单元的，每个文件都会生成一个<code>.o</code>文件，但这些文件<strong>无法知晓地址</strong></p><p><strong>链接</strong>则是将这些<code>.o</code>文件组合到一起，形成最终的可执行文件，并将未填写的地址补充（<strong>重定位</strong>），组合的本质是将相同的程序段段合并到一起</p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302192022325.png" alt="image-20230219202217260" style="zoom: 67%;" /><ul><li><strong>重定位</strong>：在符号解析基础上将有关联的模块合并，确定符号在<strong>虚拟地址空间中的地址</strong>，在符号的引用处重定位引用的地址；总的来说就是把和地址跳转相关的数值/地址值全部修改成能保证运行时地址正确的值</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Addr r_offset;</span><br><span class="line">    <span class="comment">/* 给出了使用重定位的地址地点*/</span></span><br><span class="line">    Elf32_Word r_info;(symbol:<span class="number">24</span>; type:<span class="number">8</span>)</span><br><span class="line">    <span class="comment">/* 给出了与修改地点相关的符号表索引和重定位类型*/</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p>对于使用重定位动作的地点：</p><ul><li><p>重定位文件：从节起始处到收重定位影响的存储单元的<strong>字节偏移量</strong></p></li><li><p>可执行文件、共享目标文件：受重定位影响的存储单元的<strong>虚拟地址</strong></p></li><li><blockquote><p>一个源程序可以采用静态链接或动态链接的方式完成链接这一操作</p></blockquote></li><li><p>静态链接：把共享库代码直接链接入程序代码时使用静态链接</p></li><li><p>动态链接：仅当需要某些目标模块时才进行链接工作，节省内存但速度较慢</p></li></ul><h2 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h2><blockquote><p>程序一般采用动态运行时装入方式</p></blockquote><ul><li>程序在内存中的物理位置（绝对地址）会根据系统需求发生改变，为了保证能够便捷更改位置，装入程序在程序运行时才把相对地址转换为绝对地址（需要一个重定位寄存器支持这个功能）</li><li>名空间、地址空间与存储空间：<ul><li>名空间：包括符号指令、数据说明、I/O说明</li><li>地址空间：从0开始，到程序结束的一段空间</li><li>存储空间：从装入地址开始到程序结束的一段空间</li></ul></li><li>多重分区分配：一个作业常由多段相对独立的程序、数据段组成，把这些片段分别装入存储空间的不同区域的过程被称为多重分区分配</li></ul><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><blockquote><p>一个程序本质上是由<code>.bss</code>段、<code>.data</code>段、<code>.text</code>段三部分组成的</p><p>一个装入内存的程序还需要一个<code>stack</code>和一个<code>heap</code></p></blockquote><ul><li><code>bss</code>段：程序中<strong>未初始化</strong>的全局变量的存放空间，采用<strong>静态内存分配</strong></li><li><code>data</code>段：<strong>已初始化</strong>的全局变量（和<code>static</code>修饰的变量）的存放空间，采用<strong>静态内存分配</strong></li><li><code>text</code>段：存放程序代码的一段空间，大小确定，大多为<strong>只读</strong>（可能包含只读常量）</li></ul><p>这三部分中，<code>.data</code>和<code>.text</code>从可执行文件中加载到内存中，<code>.bss</code>段由系统进行初始化</p><ul><li>程序段内存示意图：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302182309978.png" alt="image-20230218230855885" style="zoom: 60%;" /><ul><li><code>stack</code>段：存放、交换临时数据的区域；用于临时存放<strong>函数中的</strong>局部变量、保存或恢复函数现场</li><li><code>heap</code>段：存放进程中动态分配的内存段；<strong>大小并不固定</strong>，使用<code>malloc</code>或<code>free</code>等函数时内存变动都在<code>heap</code>上进行</li></ul><blockquote><p><code>gcc</code>编译+链接时使用的工具：</p><ul><li>预处理器+编译器：<code>cc1</code></li><li>汇编器：<code>as</code></li><li>链接器：<code>collect2</code></li></ul></blockquote><h1 id="程序的装载与运行"><a href="#程序的装载与运行" class="headerlink" title="程序的装载与运行"></a>程序的装载与运行</h1><h2 id="程序的装载"><a href="#程序的装载" class="headerlink" title="程序的装载"></a>程序的装载</h2><ul><li>装载前调用<code>fork()</code>，创建<strong>子进程</strong></li><li>该子进程调用<code>execve()</code>加载需要执行的程序</li><li>加载器查询<code>ELF</code>文件中与<code>segment</code>相关的信息，其中<code>Type</code>为<code>Load</code>的<code>segment</code>是需要被加载到<strong>内存中</strong>的</li><li><code>segment</code>在<strong>文件中</strong>的大小<strong>小于</strong>在<strong>内存中</strong>的大小，如果出现此种情况在载入内存时需要<strong>补零</strong>使其达到内存所占用的大小</li></ul><h3 id="程序的装载流程"><a href="#程序的装载流程" class="headerlink" title="程序的装载流程"></a>程序的装载流程</h3><ul><li>读取<code>ELF</code>文件的开头魔数进行比对</li><li>根据<code>ELF</code>文件中的段表信息（起始位置在文件中偏移、段表大小、包含了多少项）找到<strong>段表项</strong></li><li>解析各段应当被加载的虚地址、文件中的偏移、内存中/文件中的大小</li><li>根据段在内存中的大小分配物理页并映射到虚地址上，并拷贝文件至内存中</li><li>设置进程块中PC为<code>ELF</code>记录的入口地址，进程开始执行</li></ul><h3 id="可执行文件的内存映像（x86）"><a href="#可执行文件的内存映像（x86）" class="headerlink" title="可执行文件的内存映像（x86）"></a>可执行文件的内存映像（x86）</h3><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302192125234.png" alt="image-20230219212547198" style="zoom:67%;" /><h2 id="程序、进程和作业"><a href="#程序、进程和作业" class="headerlink" title="程序、进程和作业"></a>程序、进程和作业</h2><ul><li>程序是静态的可执行文件，存放在磁盘上</li><li>进程是动态的，<strong>是程序的执行过程</strong>、用户分配资源的基本单位；进程可以创建其他的进程<ul><li>系统进程：完成操作系统功能的进程</li><li>用户进程：完成用户功能的进程</li></ul></li><li>作业是用户要求计算机完成工作的集合；一个作业由至少一个进程构成<ul><li>作业常用于批处理系统，进程常用于分时系统、多道程序系统</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作业 - 若干进程 - 程序 + 数据集合 + 进程控制块</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter2</title>
      <link href="/2023/05/os/buaa-os-theory-chapter2/"/>
      <url>/2023/05/os/buaa-os-theory-chapter2/</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-系统引导"><a href="#第2章-系统引导" class="headerlink" title="第2章 系统引导"></a>第2章 系统引导</h1><p>计算机启动前必须使得硬件处在最安全、通用、功能最弱的状态，并在启动过程中对硬件进行设置，逐步提升硬件处理能力</p><ul><li>必须使用启动程序对计算机进行启动</li><li>启动程序必须运行在启动好的计算机上</li></ul><blockquote><p>OS启动是一个逐步释放系统灵活性的过程</p></blockquote><p>启动的流程：BIOS → MBR → BootLoader → OS</p><h1 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a><code>BootLoader</code></h1><blockquote><p><strong>引导加载程序</strong>，是系统加电后运行的第一段代码，在操作系统内核启动前运行</p></blockquote><ul><li><code>Booter</code>：初始化并运行系统硬件</li><li><code>Loader</code>：将操作系统代码<strong>加载到内存</strong>中，并跳转运行</li></ul><p>嵌入式系统经常用<code>U-boot</code>作为OS装载程序，<code>X86</code>常使用<code>LILO</code>和<code>GRUB</code></p><h1 id="计算机的启动过程（MIPS）"><a href="#计算机的启动过程（MIPS）" class="headerlink" title="计算机的启动过程（MIPS）"></a>计算机的启动过程（<code>MIPS</code>）</h1><blockquote><p><code>MIPS</code>架构使用的<code>U-boot</code>分为<code>stage1</code>和<code>stage2</code>两个阶段，通常<code>stage1</code>使用汇编语言实现，<code>stage2</code>使用C语言实现</p><ul><li><code>stage1</code>实现简单的功能，初始化设备</li><li><code>stage2</code>在<code>stage1</code>的基础上可以实现更复杂的功能</li></ul></blockquote><h2 id="MIPS的基本地址空间"><a href="#MIPS的基本地址空间" class="headerlink" title="MIPS的基本地址空间"></a><code>MIPS</code>的基本地址空间</h2><blockquote><p>在32位系统下，程序地址空间（共4GB）被划分为四个区域，不同区域具有不同的属性：</p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172039803.png" alt="image-20230217203905712" style="zoom:67%;" /><p>按物理地址自下而上地，具有自己的特征：</p><ul><li><code>kuseg</code>：用户态可用地址，只有在<code>MMU</code>建立好后才能使用这2GB的地址</li><li><code>kseg0</code>：去除最高位后，能直接映射到地址从0开始的区域；只有在<code>cache</code>设置好后才能访问这段地址<ul><li>几乎访问这段地址时都需要经过<code>cache</code></li><li>对于有<code>MMU</code>的系统，<strong>操作系统核心</strong>存放在这个区域</li></ul></li><li><code>kseg1</code>：去除高三位后与<code>kseg0</code>类似，但非<code>cache</code>存取<ul><li><code>kseg1</code>是<strong>唯一</strong>在系统重启时能正常工作的地址空间：<code>MIPS</code>系统的启动入口地址为<code>0xBFC00000</code>，就位于<code>kseg1</code>段内</li></ul></li><li><code>kseg2</code>：仅核心态可用地址，同样需要先建立<code>MMU</code></li></ul><h2 id="MIPS启动stage1"><a href="#MIPS启动stage1" class="headerlink" title="MIPS启动stage1"></a><code>MIPS</code>启动<code>stage1</code></h2><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172046694.png" alt="image-20230217204603657"></p><h2 id="MIPS启动stage2"><a href="#MIPS启动stage2" class="headerlink" title="MIPS启动stage2"></a><code>MIPS</code>启动<code>stage2</code></h2><blockquote><p><code>stage2</code>开始时在<code>board_init_f</code>中初始化并分配内存、堆和栈，把<code>U-boot</code>代码复制至<code>ram</code>上运行，在结束时启动<code>Linux kernel</code></p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172050022.png" alt="image-20230217205011993" style="zoom:67%;" /><h1 id="MIPS下Linux系统引导过程"><a href="#MIPS下Linux系统引导过程" class="headerlink" title="MIPS下Linux系统引导过程"></a><code>MIPS</code>下<code>Linux</code>系统引导过程</h1><ul><li><code>BootLoader</code>将<code>Linux</code>内核移动到指定的物理地址处，确定内核开始执行的第一条指令地址</li><li>第一阶段从<code>head.s</code>文件开始，初始化堆栈、内存等</li><li>第二阶段从<code>start_kernel()</code>开始初始化硬件平台相关的代码</li></ul><h1 id="计算机的启动过程（X86）"><a href="#计算机的启动过程（X86）" class="headerlink" title="计算机的启动过程（X86）"></a>计算机的启动过程（<code>X86</code>）</h1><blockquote><p>计算机首先跳转至<code>BIOS</code>处运行寻找硬件设备，随后读取<code>MBR</code>区段并把控制权转移给操作系统的<code>BootLoader</code></p></blockquote><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a><code>BIOS</code></h2><blockquote><p><code>BIOS</code>设置程序是在<code>ROM</code>上固定的一组程序，为电脑提供最底层的硬件控制，与硬件系统集成在一起</p></blockquote><ul><li>系统上电时会自动跳转至<code>BIOS</code>存放的地址开始运行，等待<code>BIOS</code>提供硬件等信息</li><li><code>Power-On Self-Test</code>：<code>BIOS</code>支持上电自检，保证关键组件都能启动并正确初始化</li><li><code>BIOS</code>可更改启动引导设备</li></ul><h3 id="UEFI与BIOS"><a href="#UEFI与BIOS" class="headerlink" title="UEFI与BIOS"></a><code>UEFI</code>与<code>BIOS</code></h3><ul><li><code>EFI</code>使用模块化、C语言风格的参数堆栈传递方式，动态链接的形式构建的系统，突破了<code>BIOS</code>16位的寻址限制</li></ul><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a><code>MBR</code></h2><blockquote><p>硬盘上第0磁头第0磁道第1扇区被称为<code>MBR</code>(Master Boot Record)，大小为<code>512B</code></p></blockquote><ul><li><code>MBR</code>中存放了<code>BootLoader</code>和驱动器的逻辑分区信息：前446字节为启动代码与数据（<code>BootLoader</code>），随后是16字节的分区数据*4个分区（分区数据意义见课件<code>P39</code>），最后的两个字节应存放<code>AA 55</code>，他们被称为幻数（当<code>BIOS</code>读取<code>MBR</code>时，如果末位无幻数就认为这是一个没有分区的硬盘）</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172113489.png" alt="image-20230217211343465" style="zoom:67%;" /><ul><li>硬盘分区共三种：主磁盘分区、扩展磁盘分区、逻辑分区</li><li><code>MBR</code>限制磁盘至多只能有4个主分区，系统必须位于主分区上</li><li>单一硬盘最多4个主分区，最多一个拓展分区，（并且主+扩不超过4），逻辑分区可有若干个</li><li>主分区只能有一个为激活状态</li></ul><h1 id="X86下的Linux系统引导过程"><a href="#X86下的Linux系统引导过程" class="headerlink" title="X86下的Linux系统引导过程"></a>X86下的<code>Linux</code>系统引导过程</h1><blockquote><p>当<code>MBR</code>被读取到内存中后，其中的<code>BootLoader</code>接管系统，并初始化硬件设备、建立内存映射，为启动系统做好准备</p></blockquote><ul><li><code>BIOS</code>将<code>MBR</code>读入<code>0x7C00</code>处，检查<code>0x7DFE</code>是否为<code>0xAA55</code>后，执行<code>MBR</code>程序</li><li>将自身复制至<code>0x0600</code></li><li>搜索<strong>激活的主分区</strong>，将其第一个扇区（<code>Boot Sector</code>）读入<code>0x7C00</code>处，检查<code>0x7DFE</code>是否为<code>0xAA55</code>，跳转<code>0x7C00</code>执行特定系统的启动程序</li></ul><h2 id="MBR与分区引导扇区Boot-Sector"><a href="#MBR与分区引导扇区Boot-Sector" class="headerlink" title="MBR与分区引导扇区Boot Sector"></a><code>MBR</code>与分区引导扇区<code>Boot Sector</code></h2><ul><li>启动顺序有先后。PC机启动时，先执行MBR，再根据选择执行某个分区下的boot sector。<ul><li>（选择执行的boot sector所在分区就是活动分区。“用户选择一个操作系统” 实际上也就是选择一个分区作为活动分区。）</li></ul></li><li>boot sector可以为空（没装系统），但MBR必须包含内容。</li><li>MBR必须被读取并执行；引导扇区根据选择执行，有的甚至可以不执行（即上文中的”数据是无效的”）。</li><li>MBR实际上包含的内容也比boot sector广泛，MBR中相当于包含了硬盘整体层面上的引导扇区(自举装入程序）、根目录区（分区表）。</li><li>MBR选择Boot Sector，Boot Sector驱动分区内的操作系统</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172133565.png" alt="image-20230217213348532" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter1</title>
      <link href="/2023/05/os/buaa-os-theory-chapter1/"/>
      <url>/2023/05/os/buaa-os-theory-chapter1/</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-引论"><a href="#第1章-引论" class="headerlink" title="第1章 引论"></a>第1章 引论</h1><h1 id="一些小点"><a href="#一些小点" class="headerlink" title="一些小点"></a>一些小点</h1><ul><li><p>操作系统的工作</p><ul><li><p>程序的执行</p></li><li><p>完成与硬件有关的工作</p></li><li><p>完成于应用无关的工作</p></li><li><p>计算机系统的效率与安全问题</p></li></ul></li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><blockquote><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务。</p></blockquote><ul><li>提供了用户与硬件间的接口</li><li>控制、管理计算机硬软件资源</li><li>组值计算机系统工作流程，改善系统性能</li></ul><h1 id="操作系统的特征与功能"><a href="#操作系统的特征与功能" class="headerlink" title="操作系统的特征与功能"></a>操作系统的特征与功能</h1><p>特征：并发、共享、虚拟、异步</p><p>功能：</p><ul><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>作业控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-2-Exam</title>
      <link href="/2023/05/os/buaa-os-lab5-2-exam/"/>
      <url>/2023/05/os/buaa-os-lab5-2-exam/</url>
      
        <content type="html"><![CDATA[<p>完结撒花，感谢陪伴（？）</p><h1 id="Exam-打开相对路径文件"><a href="#Exam-打开相对路径文件" class="headerlink" title="Exam - 打开相对路径文件"></a>Exam - 打开相对路径文件</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 Lab5 的课下内容中，我们实现了通过<strong>绝对路径</strong>，也即相对于磁盘根目录而言的路径，打开文件，为其获取 <code>struct Open</code> 与 <code>struct File</code> 的函数—— <code>open</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>现在，为了拓展打开文件的方式，我们计划额外实现一个通过指定目录 + 相对路径打开指定文件的函数：<code>openat</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>在这里，我们保证：</p><ul><li>目录代表的文件已经在文件管理系统中（占据 <code>Open</code>）与当前进程中（占据 <code>Fd</code>）被打开，即可以通过其 <code>fdnum</code> 对应的 <code>struct Fd</code> 获取信息</li><li>调用 <code>open</code>、<code>openat</code> 的所有目录/文件均存在，且 <code>openat</code> 只会打开普通文件（非目录）</li><li>调用 <code>openat</code> 打开的路径均为相对路径，即不会以 <code>/</code> 开头</li></ul><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>我们可以按照通过<strong>新建 <code>fsipc</code> 的种类</strong>以实现目标功能。那对于实现新 <code>fsipc_*</code> 的全过程，有必要进行总结</p><ul><li><code>user/include/fsreq.h</code> <ul><li>增加一个对于文件系统的请求类型 <code>FSREQ_OPENAT</code> 和请求结构体 <code>struct Fsreq_openat</code>；<strong>完成基础的数据结构准备</strong></li></ul></li><li><code>user/lib/file.c</code> <ul><li>仿照 <code>open</code> 函数实现 <code>openat</code> 函数；<strong>供用户程序直接启动 <code>openat</code> 流程</strong></li></ul></li><li><code>user/lib/fsipc.c</code> <ul><li>仿照 <code>fsipc_open</code> 实现 <code>fsipc_openat</code>；完成对 <code>Fsreq_openat</code> 各个字段的赋值；<strong>使其能发送 <code>openat</code> 的请求</strong></li></ul></li><li><code>fs/serv.c</code>：<ul><li>修改 <code>serve</code> 函数，使其能转发 <code>FSREQ_OPENAT</code> 请求</li><li>仿照 <code>serve_open</code> 实现 <code>serve_openat</code> 函数；<strong>实现 <code>openat</code> 整体的功能</strong></li></ul></li><li><code>fs/fs.c</code>：<ul><li>仿照 <code>walk_path</code> 实现 <code>walk_path_at</code>；<strong>从文件层面实现按相对路径 <code>path</code> 查找文件的功能</strong></li><li>仿照 <code>file_open</code> 实现 <code>file_openat</code> ，类似地调用 <code>walk_path_at</code> 函数；<strong>封装功能，供文件服务进程调用</strong></li></ul></li><li>头文件：<ul><li><code>user/include/lib.h</code>：增加 <code>openat</code> 、 <code>fsipc_openat</code> 声明</li><li><code>fs/serv.h</code>：增加 <code>file_openat</code> 声明</li></ul></li></ul><p>过程中仍然保留了 <code>openat</code> 字样，实际可以根据情况自由调整。除了 <code>fs.c</code> 中功能具体实现的方式不同之外，基本上面几个文件的修改都是有规律的，和 Lab4 添加系统调用类似。</p><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>因为比较繁琐，所以就把提示塞代码里了，顺序是按照刚才介绍的顺序来的</p><h3 id="user-include-fsreq-h"><a href="#user-include-fsreq-h" class="headerlink" title="user/include/fsreq.h"></a><code>user/include/fsreq.h</code></h3><p>没什么好说的，直接写就完了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPENAT 8         <span class="comment">// serve 函数分发时的标准</span></span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_openat</span> &#123;</span></span><br><span class="line">    u_int dir_fileid;          <span class="comment">// 相对的 &#x27;根目录&#x27; 打开的文件 id </span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN]; <span class="comment">// 打开的文件的相对路径</span></span><br><span class="line">    u_int req_omode;           <span class="comment">// 打开文件的模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="user-lib-file-c"><a href="#user-lib-file-c" class="headerlink" title="user/lib/file.c"></a><code>user/lib/file.c</code></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">dir</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">filefd</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="comment">/* Step 1: 获取相对目录在进程中的 fd，申请待打开的文件的 fd */</span></span><br><span class="line">  fd_lookup(dirfd, &amp;dir);</span><br><span class="line">  <span class="keyword">if</span> ((r = fd_alloc(&amp;filefd)) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Step 2: 根据目录在文件服务进程中的 fileid，发送请求 */</span></span><br><span class="line">  <span class="type">int</span> dir_fileid = ((<span class="keyword">struct</span> Filefd *)dir)-&gt;f_fileid;</span><br><span class="line">  <span class="keyword">if</span> ((r = fsipc_openat(dir_fileid, path, mode, filefd)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">  u_int size, fileid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 获取到文件的 fd，对 fd 字段进行赋值，把内容 map 到 data 区域 */</span></span><br><span class="line">  va = fd2data(filefd);</span><br><span class="line">  ffd = (<span class="keyword">struct</span> Filefd *)filefd;</span><br><span class="line">  size = ffd-&gt;f_file.f_size;</span><br><span class="line">  fileid = ffd-&gt;f_fileid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2BLK) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_map(fileid, i, (<span class="type">void</span> *)(va + i))) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 4: 返回文件的 fd 号 */</span></span><br><span class="line">  <span class="keyword">return</span> fd2num(filefd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="user-lib-fsipc-c"><a href="#user-lib-fsipc-c" class="headerlink" title="user/lib/fsipc.c"></a><code>user/lib/fsipc.c</code></h3><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-Report</title>
      <link href="/2023/05/os/buaa-os-report-lab5/"/>
      <url>/2023/05/os/buaa-os-report-lab5/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab5-Report"><a href="#BUAA-OS-2023-Lab5-Report" class="headerlink" title="BUAA-OS-2023-Lab5-Report"></a>BUAA-OS-2023-Lab5-Report</h1><h1 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h1><ul><li>如果通过kseg0 读写设备，那么对于设备的写入会缓存到Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</li></ul><p>如果使用 kseg0 段读写设备，那么对于外设而言，在系统读取外设时就会不可避免地先在 Cache 中查找设备对应的地址，如果查询到就会返回缓存的值。但如果在上一次缓存过后，设备的值已经发生了改变，这时我们从 Cache 中读取到的就是过时的错误信息。</p><p>对于写入也是同理，我们会优先写入到 Cache 中对应的地址处，那么下一次写就会覆盖上一次写的结果，导致外设并不能及时、正确地读取到我们写入的值。</p><p>对于不同的外设种类而言，这个现象会有些微差异。串口设备由于其即时性与高使用频率，会更容易出现这样的错误，对于磁盘而言则不太容易。</p><h1 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h1><ul><li>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</li></ul><p>首先根据定义 <code>BY2BLK</code> 可知一个磁盘块大小为 4096 Byte。同时一个文件控制块 <code>File</code> 大小为 256 Byte。则一个磁盘块中最多能存储 $4096 / 256 = 16$ 个文件控制块。</p><p>一个目录可以通过 <code>f_indirect</code> 字段指向 1024 个指向其内包含的<strong>磁盘块</strong>的指针，那么一个目录下最多有 $1024 * 16 = 16384$ 个文件。</p><p>对于单个文件也是同理，<code>f_indirect</code> 字段会指向 1024 个包含其内容的磁盘块指针，这样一个文件最大大小就是 $1024 * 4KB = 4MB$</p><h1 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h1><ul><li>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</li></ul><p>由于 MOS 中一个进程可以拥有 4 GB 的虚拟内存空间，并且对于文件管理进程而言， <code>DISKMAP</code> 到 <code>DISKMAP + DISKMAX</code> 这一段虚存地址空间 (0x10000000-0x4fffffff) 会作为作为磁盘块的缓冲区。那么最大的磁盘大小就是 <code>DISKMAP</code>，即 1 GB。</p><h1 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h1><ul><li>在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</li></ul><p>其实文件控制块和超级块都比较好理解</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span><span class="comment">//文件控制块，是文件系统用于管理文件的数据结构</span></span><br><span class="line">    u_char f_name[MAXNAMELEN];  <span class="comment">// filename</span></span><br><span class="line">    u_int f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    u_int f_type;           <span class="comment">// file type</span></span><br><span class="line">    u_int f_direct[NDIRECT];</span><br><span class="line">    u_int f_indirect;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>     <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">u_char f_pad[BY2FILE - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC    0x68286097  <span class="comment">// Everyone&#x27;s favorite OS class</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span> <span class="comment">// 根目录块</span></span><br><span class="line">    u_int s_magic;      <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    u_int s_nblocks;    <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fsreq 的请求分类</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC  7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> req_fileid;</span><br><span class="line">    u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> req_fileid;</span><br><span class="line">    u_int req_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// continue</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    req = ipc_recv(&amp;whom, (<span class="type">void</span> *)REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All requests must contain an argument page</span></span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">      debugf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>, whom);</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (req) &#123;</span><br><span class="line">    <span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">      serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">      serve_map(whom, (<span class="keyword">struct</span> Fsreq_map *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">      serve_set_size(whom, (<span class="keyword">struct</span> Fsreq_set_size *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">      serve_close(whom, (<span class="keyword">struct</span> Fsreq_close *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">      serve_dirty(whom, (<span class="keyword">struct</span> Fsreq_dirty *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">      serve_remove(whom, (<span class="keyword">struct</span> Fsreq_remove *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">      serve_sync(whom);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_OPENAT:</span><br><span class="line">      serve_openat(whom, (<span class="keyword">struct</span> Fsreq_openat *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      debugf(<span class="string">&quot;Invalid request code %d from %08x\n&quot;</span>, whom, req);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)REQVA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是我们进行ipc通讯后，对数据进行分发的场所，我们会根据收获到的req的不同，将用于接受信息（文件系统接受，由用户发来）的REQVA解读为不同的结构体，并传入不同的服务函数进行实现。</p><p>整个分发实现是文件系统与外界的接口，文件系统内部的实现是相对自由的（你可以进行系统调用、使用用户态函数、操作磁盘等等），只要反馈给用户进程的结果对就行</p><h1 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h1><ul><li>在 Lab4 “系统调用与 fork” 的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code here</span></span><br><span class="line"><span class="type">int</span> r, fdnum, n; </span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>]; </span><br><span class="line"></span><br><span class="line">fdnum = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR); </span><br><span class="line"><span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123; </span><br><span class="line">    n = read(fdnum, buf, <span class="number">4</span>); </span><br><span class="line">    debugf(<span class="string">&quot;[child] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    n = read(fdnum, buf, <span class="number">4</span>); </span><br><span class="line">    debugf(<span class="string">&quot;[father] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">welcome to MOS with a file system.</span><br><span class="line"></span><br><span class="line"><span class="comment">// output here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[father] buffer is <span class="string">&#x27;welc&#x27;</span></span><br><span class="line">[child] buffer is <span class="string">&#x27;ome &#x27;</span></span><br></pre></td></tr></table></figure><p>显然，父子进程也会同样共享相同的文件描述符和定位指针。其原因在于页面是 <code>PTE_LIBRARY</code> 的而非 <code>PTE_COW</code> 的。</p><h1 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h1><ul><li>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span> <span class="comment">//文件描述符；用户用于描述该文件，单纯的内存数据，关机就消失；</span></span><br><span class="line">    u_int fd_dev_id; <span class="comment">//该文件对应的设备id</span></span><br><span class="line">    u_int fd_offset; <span class="comment">//读写偏移量</span></span><br><span class="line">    u_int fd_omode; <span class="comment">//允许用户进程对文件的操作权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span> <span class="comment">//单纯的内存数据，关机就消失，是便于文件系统查看的结构；</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span> <span class="comment">//文件描述符</span></span><br><span class="line">    u_int f_fileid; <span class="comment">//文件系统为打开的文件进行的编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">//对应文件的文件控制块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span> <span class="comment">// 文件系统用来保存已打开的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// 指向文件控制块的指针</span></span><br><span class="line">    u_int o_fileid; <span class="comment">// 文件打开后的编号</span></span><br><span class="line">    <span class="type">int</span> o_mode; <span class="comment">// 允许用户进程对文件的操作权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span> <span class="comment">// 指向该文件描述符的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这部分的部分内容借鉴了学长的报告</li></ul><h1 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h1><ul><li>图 5.7 中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</li></ul><ol><li>同步消息，用黑三角箭头搭配黑实线表示：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111105489.png" alt="image-20230511110441745"></p><p>同步意义：消息的发送者把进程控制传递给消息的接收者，然后<strong>暂停活动</strong>，<strong>等待</strong>消息接收者的回应消息。</p><ol><li><p>返回消息，用开三角箭头搭配黑色虚线表示：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111105896.png" alt="image-20230511110455875"></p></li></ol><p>返回消息和同步消息结合使用，因为异步消息不进行等待，所以不需要知道返回值。</p><p>对于文件系统，通过特定调用号使得文件系统知道请求者有何种需求，然后文件系统进入相应处理函数中处理，将结果通过ipc_send传回用户进程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>纵观 Lab5，MOS 在其中为我们构造了一个通配的文件系统。</p><p>它通过统一的结构体 <code>Fd</code> <strong>层次化地</strong>管理所用可用的设备。<strong>向上</strong>，在 <code>fd.c</code> 中为用户提供统一的操作函数；<strong>向下</strong>，不同设备通过 <strong>implements 实现</strong> <code>Dev</code> 的功能函数，达到同一调用的效果。</p><p>在此之下，<code>file.c</code>、<code>console.c</code>、<code>pipe.c</code> 三文件实现了 <code>Dev</code> 中的”抽象函数“。为了优化函数实现的效果，我们建立了一个为所有进程管理纯文件 file 的文件服务进程 <code>serv.c</code>，并通过 <code>fsipc.c</code> 借助 进程间 IPC 通信机制实现数据传输。</p><p>对文件服务进程而言，它通过 IPC 通信与用户进程（请求方）通信，利用文件级、磁盘块级的交互函数 <code>fs.c</code> 与磁盘进行交互，并利用块缓存的机制对磁盘块进行管理，以满足请求者<strong>对指定文件的特定文件块</strong>的访问。</p><p>再细化到最后一步，所有的磁盘交互函数都是利用<strong>系统调用</strong>访问 <code>KSEG1</code> 段实现与外设的直接交互，并在最底层的函数中实现了以块、甚至扇区为单位的读写，即 <code>ide.c</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part3</title>
      <link href="/2023/05/os/buaa-os-probe-lab5-part3/"/>
      <url>/2023/05/os/buaa-os-probe-lab5-part3/</url>
      
        <content type="html"><![CDATA[<h1 id="用户态定义与接口"><a href="#用户态定义与接口" class="headerlink" title="用户态定义与接口"></a>用户态定义与接口</h1><p>在之前的分析中，我们已经完成了文件管理进程中的函数实现。现在我们来分析用户态中用户直接可用的函数接口与数据结构定义</p><p>我们还是从距离文件系统<strong>最近</strong>的函数与文件开始：<code>user/lib/fsipc.c</code> 和 <code>user/include/fsreq.h</code></p><p>首先明确用户进程和文件管理进程<strong>使用 IPC 通信进行交互</strong>。在文件管理进程的运行的核心、分发函数 <code>serve</code> 中，我们通过 <code>ipc_recv</code> 从用户进程获取到了一片虚拟地址 <code>REQVA</code>，并且针对不同的信息，将 <code>REQVA</code> 转换成了不同的数据结构，进行处理。这些数据结构就定义在 <code>fsreq.h</code> 文件中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line"><span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line"><span class="type">int</span> req_fileid;</span><br><span class="line">u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// CONTINUE...</span></span><br></pre></td></tr></table></figure><p>篇幅所限不再全部排列。</p><p>那这片 <code>va</code> 到底是谁发送来的呢？在用户态中存在一个专门的分发函数：<code>fsipc</code></p><h2 id="fsipc-c-文件请求服务函数"><a href="#fsipc-c-文件请求服务函数" class="headerlink" title="fsipc.c - 文件请求服务函数"></a><code>fsipc.c</code> - 文件请求服务函数</h2><ul><li>我们规定在 MOS 系统中，文件管理进程必须为第二个进程（<code>envs[1]</code>），以保证传输正确性</li><li>可以看出，本接口通过 <code>fsreq</code> 参数传输页面，<code>type</code> 参数传输申请的服务类型</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Send an IPC request to the file server, and wait for a reply.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">u_int whom;</span><br><span class="line"><span class="comment">// Our file system server must be the 2nd env.</span></span><br><span class="line">ipc_send(envs[<span class="number">1</span>].env_id, type, fsreq, PTE_D);</span><br><span class="line"><span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个用户态的每一个<strong>请求服务函数</strong>中，即 <code>fsipc_*</code> 函数，都会用到一个临时的页面用来传输数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_char fsipcbuf[BY2PG] __attribute__((aligned(BY2PG)));</span><br></pre></td></tr></table></figure><p>通过修改页面内的数据，搭配不同的服务函数，让文件管理进程<strong>以不同的方式去解析这片地址空间</strong>，以实现传输相同页面却能实现不同功能的效果。例如我们要实现的函数 <code>fsipc_remove</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  请求文件系统移除某文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查文件名长度 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAXPATHLEN || <span class="built_in">strlen</span>(path) == <span class="number">0</span>) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 2: 把预留的临时地址 **视作** Fsreq_remove 结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span> =</span> (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 3: 修改传输页面的数据，以实现 remove 功能 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (2/3) */</span></span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *) req-&gt;req_path, path);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 4: 发送操作类型 FSREQ_REMOVE 和所需数据 req ，启动服务 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上每个函数中，对 <code>fsipc_req</code> 这片第地址的类型转换都不同，也会写入不同的信息。</p><h2 id="file-c-纯文件操作函数"><a href="#file-c-纯文件操作函数" class="headerlink" title="file.c - 纯文件操作函数"></a><code>file.c</code> - 纯文件操作函数</h2><p>再向上一层，调用这些用户态中的请求服务函数 <code>fsipc_*</code> 的函数位于 <code>user/lib/file.c</code> 中。</p><p>它们是用户态中能<strong>直接执行特定文件操作</strong>的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the file descriptor, 也就是 Fd 号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 申请一个 Fd</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (1/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 2: 调用服务函数 fsipc_open，同时指定 Fd 的工作模式</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (2/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached, using</span></span><br><span class="line"><span class="comment">// &#x27;fd2data&#x27;. Set &#x27;size&#x27; and &#x27;fileid&#x27; correctly with the value in &#x27;fd&#x27; as a &#x27;Filefd&#x27;.</span></span><br><span class="line"><span class="type">char</span> *va;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">u_int size, fileid;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (3/5) */</span></span><br><span class="line">va = fd2data(fd);</span><br><span class="line">ffd = (<span class="keyword">struct</span> Filefd *) fd;</span><br><span class="line">size = ffd-&gt;f_file.f_size;</span><br><span class="line">fileid = ffd-&gt;f_fileid;</span><br><span class="line"><span class="comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (4/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc_map(fileid, i, (<span class="type">void</span> *) (va + i))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: 返回执行函数用到的 Fd 对应的 Fd 号</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (5/5) */</span></span><br><span class="line"><span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// Call fsipc_remove.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exercise 5.13: Your code here. */</span></span><br><span class="line"><span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们在用户程序中通常不使用这些函数，具体的原因在下一个文件中说。</p><h3 id="fsipc-c-amp-file-c"><a href="#fsipc-c-amp-file-c" class="headerlink" title="fsipc.c &amp; file.c"></a>fsipc.c &amp; file.c</h3><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192207570.png?imageMogr2/format/webp" alt="user_lib_in_lab5" style="zoom:67%;" /><h2 id="fd-c-文件系统顶层函数"><a href="#fd-c-文件系统顶层函数" class="headerlink" title="fd.c - 文件系统顶层函数"></a><code>fd.c</code> - 文件系统顶层函数</h2><h3 id="struct-Dev"><a href="#struct-Dev" class="headerlink" title="struct Dev"></a>struct Dev</h3><p>对于整个文件系统而言，总共能操作的设备共有三种：（纯）文件设备、控制台和管道。而我们在 <code>file.c</code> ，甚至 Lab5 之前部分中实现的都是对<strong>文件设备</strong>的操作，而剩余两个部分是 Lab6 的内容了。</p><blockquote><p>其实本来是没有括号这个“纯”字的，但是个人觉得比较好区分“操作 fd “和”操作 file “两个层次，于是就瞎分了分</p></blockquote><p>上面提到的这三类设备，都是 dev （即 <code>file device</code>）的一种，我们在 <code>fd.c</code> 的最顶层函数中也是直接对 <code>dev</code> 进行对应的操作，表层并无法分辨“文件”这一概念。所以应该对每个操作涉及到的不同设备类型进行<strong>分发</strong>，让每个设备对应一个执行任务的函数，再把分发函数封装在执行功能的函数内。</p><p>这三类设备平等，并且在文件系统中视角来看，都属于 <code>Fd</code> ，即 file descriptor 的一种（继承？）。每类设备拥有自己的<strong>功能函数</strong>以处理对应的请求，结构体定义中的 3-7 字段就是存放功能函数的指针。三种设备的信息统一存放在一个 <code>Dev</code> 数组内，设备具体又分别定义在各自功能函数的头文件内。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dev_id;</span><br><span class="line"><span class="type">char</span> *dev_name;</span><br><span class="line"><span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line"><span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line"><span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line"><span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line"><span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> &#123;&amp;devfile, &amp;devcons, &amp;devpipe&#125;; <span class="comment">// 纯文件、控制台、管道</span></span><br></pre></td></tr></table></figure><h3 id="struct-Fd"><a href="#struct-Fd" class="headerlink" title="struct Fd"></a>struct Fd</h3><p>其次是文件描述符 <code>Fd</code>，<strong>每一个用户进程</strong>可以同时操控多个设备，为了对这些设备加以区分，就引入了文件描述符的定义。通过访问对应设备的文件描述符，就能得知它的设备种类（<code>dev_lookup</code>），因此我们只需要传入文件描述符，就能自动地获得 <code>Dev</code> 中存放的函数指针并执行。这也许是一种面向对象的处理方式。</p><p>同时，每个进程的文件描述符上限为 <strong>32</strong> 个，每个描述符<strong>单独占用一个虚拟页</strong>，并且还<strong>对应</strong>一个 <code>PDMAP</code> 大小的 data 空间处理该设备打开后处理的内容。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">u_int fd_dev_id;  <span class="comment">// 此设备对应的 Dev 类型</span></span><br><span class="line">u_int fd_offset;  <span class="comment">// 目前的文件指针距离起始的偏移量，类似 ftell 的文件指针</span></span><br><span class="line">u_int fd_omode;   <span class="comment">// 该设备的读写模式，只读、读写等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们对文件描述符的访问，通过它在空间中的顺序（下标）实现。对外界，<strong>文件描述符相当于一个整数</strong>，服务函数 <code>fd_lookup</code>、<code>fd2data</code> 等和宏定义通过“翻译”这个整数，获得文件描述符的地址和它对应的 <code>data</code> 空间。存放的地址如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192217962.png?imageMogr2/format/webp" alt="fd_in_memory" style="zoom:40%;" /><p>为了我们更容易实现对纯文本的操作，所以又再次对 <code>Fd</code> 结构进行了封装，实现了一个专门为 file 使用的 <code>FileFd</code> 结构，它包含了更多的信息，能够更容易地处理 file 类的操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">u_int f_fileid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上可以直接把 <code>FileFd</code> 当作普通的 <code>Fd</code> 用，因为字段原因，所以内存上读起来是这样的效果</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192221386.png?imageMogr2/format/webp" alt="fd_and_filefd" style="zoom:60%;" /><p>我们之前提到， <code>Open</code> 结构体类似于一个文件服务进程使用的“窗口”，实际上文件描述符 <code>Fd</code> 也<strong>类似一个在用户态中的窗口</strong>，只不过它的范围更广，可以包含除了 <code>File</code> 以外的其他设备，但同时它也只为自己的进程而服务。</p><p>如何根据 <code>Fd</code> 执行功能函数？</p><ul><li>根据 <code>Fd</code> 号找到对应的 <code>Fd</code> 数据</li><li>判断其 <code>Dev</code> 种类，获取执行该操作的函数指针</li><li>直接调用函数指针，实现该 <code>Dev</code> 自行实现的底层函数，完成操作。</li></ul><p>我们以 <code>read</code> 一个<strong>设备</strong>（Fd）为例，分析以上过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Read at most &#x27;n&#x27; bytes from &#x27;fd&#x27; at the current seek position into &#x27;buf&#x27;.</span></span><br><span class="line"><span class="comment">//  read(fdnum, (char *)buf + tot, n - tot);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 1: 根据 fdnum 获取 Fd 结构体和 Dev 种类</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (1/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 2: 检查 fd 的开启模式</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (2/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123; <span class="keyword">return</span> -E_INVAL; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 3: 调用该 dev 提供的 dev_read 函数</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (3/4) */</span></span><br><span class="line">r = dev-&gt;dev_read(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 4: 更新文件指针的偏移</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (4/4) */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123; fd-&gt;fd_offset += r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致思路如上，所以我们实际上只需要准备好这个 <code>dev_*</code> 函数即可完成功能。</p><p>接着以定义在 <code>file.c</code> 中的 <code>devfile</code> 为例，由于 <code> .dev_read = file_read</code>，所以我们之前编写的读 file 的函数 <code>file_read</code> 就会在顶层的 <code>read</code> 中被直接执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id = <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read = file_read,</span><br><span class="line">    .dev_write = file_write,</span><br><span class="line">    .dev_close = file_close,</span><br><span class="line">    .dev_stat = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终于，我们在用户态直接对某个设备调用顶层的功能函数，就能直接获得响应了。</p><h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>纵观 Lab5，MOS 在其中为我们构造了一个通配的文件系统。</p><p>它通过统一的结构体 <code>Fd</code> <strong>层次化地</strong>管理所用可用的设备。<strong>向上</strong>，在 <code>fd.c</code> 中为用户提供统一的操作函数；<strong>向下</strong>，不同设备通过 <strong>implements 实现</strong> <code>Dev</code> 的功能函数，达到同一调用的效果。</p><p>在此之下，<code>file.c</code>、<code>console.c</code>、<code>pipe.c</code> 三文件实现了 <code>Dev</code> 中的”抽象函数“。为了优化函数实现的效果，我们建立了一个为所有进程管理纯文件 file 的文件服务进程 <code>serv.c</code>，并通过 <code>fsipc.c</code> 借助 进程间 IPC 通信机制实现数据传输。</p><p>对文件服务进程而言，它通过 IPC 通信与用户进程（请求方）通信，利用文件级、磁盘块级的交互函数 <code>fs.c</code> 与磁盘进行交互，并利用块缓存的机制对磁盘块进行管理，以满足请求者<strong>对指定文件的特定文件块</strong>的访问。</p><p>再细化到最后一步，所有的磁盘交互函数都是利用<strong>系统调用</strong>访问 <code>KSEG1</code> 段实现与外设的直接交互，并在最底层的函数中实现了以块、甚至扇区为单位的读写，即 <code>ide.c</code>。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part1/">See Part1 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part2/">See Part2 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part2</title>
      <link href="/2023/05/os/buaa-os-probe-lab5-part2/"/>
      <url>/2023/05/os/buaa-os-probe-lab5-part2/</url>
      
        <content type="html"><![CDATA[<p>当实现完 Part1 中的函数后，磁盘就通过 <code>fsformat</code> 程序成功地生成了。在继续之前，建议大家看一看指导书的这个图，这个文章的顺序大概是：文件系统服务进程→交互区→用户进程</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305181232771.png?imageMogr2/format/webp" alt="lab5_total"></p><p>接下来我们正式进入内核，处理后续工作。</p><h1 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h1><ul><li><strong>块缓存</strong>指的是借助虚拟内存来实现磁盘块缓存的设计。</li></ul><p>在 MOS 系统中，文件管理“系统”，是以一个进程的形式存在的，它通过从磁盘中读写数据，并与其他用户进程交互来实现文件的管理，这些被使用到的文件就会先被<strong>缓存</strong>在文件服务进程的进程空间中。类似于批发商从生产商处取货，存储在自己的仓库里，使用时再拿出来给下级的经销商（x）</p><p>我们规定，文件管理进程使用大小为 <code>DISKMAX</code> 字节的空间作为磁盘块的缓存区，并且缓存区的存取<strong>单位为磁盘块</strong>。每个磁盘块都应该在内存中有<strong>单独相对应的位置</strong>进行缓存，这样就限制了我们内核支持的最大磁盘大小。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure><p>为了在磁盘块和内存之间进行交换，我们需要准备一系列辅助和工作函数，而这系列的共 35 个函数都被放置在 <code>fs/fs.c</code> 文件中。（file service？）</p><h2 id="fs-c-中的磁盘块操作函数"><a href="#fs-c-中的磁盘块操作函数" class="headerlink" title="fs.c 中的磁盘块操作函数"></a><code>fs.c</code> 中的磁盘块操作函数</h2><p>我们通过简单的函数，一步一步组合执行复杂的功能，有以下函数：</p><h3 id="diskaddr-Exercise-5-6"><a href="#diskaddr-Exercise-5-6" class="headerlink" title="diskaddr - Exercise 5.6"></a>diskaddr - Exercise 5.6</h3><p>和上文的块缓存相对应，返回某个特定块在文件管理系统进程内存中<strong>应该被放置到</strong>的虚拟地址，实际上就按照上面提的线性映射就行了，一块一块挨着排</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.6: Your code here. */</span></span><br><span class="line">u_int addr = DISKMAP + blockno * BY2BLK;</span><br><span class="line"><span class="keyword">if</span> (addr &gt; DISKMAX + DISKMAP) &#123;</span><br><span class="line">debugf(<span class="string">&quot;illegal blockno_addr!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *) <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *) addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="va-is-mapped-amp-block-is-mapped"><a href="#va-is-mapped-amp-block-is-mapped" class="headerlink" title="va_is_mapped &amp; block_is_mapped"></a>va_is_mapped &amp; block_is_mapped</h3><p><code>va_is_mapped</code> 检查文件管理进程中某个虚拟地址是否被使用</p><p>通常情况下不会单独使用，一般配合 <code>diskaddr</code> 在 <code>block_is_mapped</code> 中使用</p><p><code>block_is_mapped</code> 则检查特定的磁盘块是否使用块缓存装入了内存。其实觉得应该叫 block is mapped <strong>at</strong> 比较合适，因为返回的是映射所在的地址（返回 NULL 说明映射在空气里了）</p><p>由于块缓存是<strong>一一对应</strong>的，所以只要查虚拟地址的使用，就能获得独一的磁盘块是否有了缓存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this disk block is mapped in cache.</span></span><br><span class="line"><span class="comment">//  Returns the virtual address of the cache page if mapped, 0 otherwise.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);  <span class="comment">// 获取块映射的缓存虚拟地址</span></span><br><span class="line"><span class="keyword">if</span> (va_is_mapped(va)) &#123;        <span class="comment">// 查一下虚拟地址用没用</span></span><br><span class="line"><span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-block-amp-unmap-block"><a href="#map-block-amp-unmap-block" class="headerlink" title="map_block &amp; unmap_block"></a>map_block &amp; unmap_block</h3><p>光检查还不行，也得有形成/解除映射的函数不是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 如果已经映射，返回 0 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (1/5) */</span></span><br><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 使用系统调用申请一个含 PTE_D 的页面，通过 diskaddr 查询映射的虚拟地址 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (2/5) */</span></span><br><span class="line"><span class="keyword">return</span> syscall_mem_alloc(syscall_getenvid(), diskaddr(blockno), PTE_D |PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 获得指定块的映射地址，没映射就是 NULL */</span></span><br><span class="line"><span class="type">void</span> *va;</span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (3/5) */</span></span><br><span class="line">va = block_is_mapped(blockno);</span><br><span class="line"><span class="keyword">if</span> (va == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 如果磁盘中块仍使用，缓存还 DIRTY 了，解除映射之前要先写回 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (4/5) */</span></span><br><span class="line"><span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">write_block(blockno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Step 3: 通过系统调用解除地址映射 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (5/5) */</span></span><br><span class="line">syscall_mem_unmap(syscall_getenvid(), va);</span><br><span class="line"></span><br><span class="line">user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-block-amp-read-block"><a href="#write-block-amp-read-block" class="headerlink" title="write_block &amp; read_block"></a>write_block &amp; read_block</h3><p>形成映射的下一步，就是把数据写到内存之中了</p><p>要注意 <code>write_block</code> 是写到磁盘里，<code>read_block</code> 是写到内存里，也就是 write <strong>to</strong> block &amp; read <strong>from</strong> block</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查内存中是否映射，没映射 = 没数据，肯定没法写回 */</span></span><br><span class="line"><span class="keyword">if</span> (!block_is_mapped(blockno)) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;write unmapped block %08x&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step2: 使用 ide_write 把当前缓存块写回 */</span></span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">ide_write(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  **blk != 0 ，则向 *blk 中存入写入后的虚拟地址</span></span><br><span class="line"><span class="comment">//  **isnew != 0，则按照以下规则更新 *isnew：</span></span><br><span class="line"><span class="comment">//  *isnew = 0: 虚拟地址原本就被写入过</span></span><br><span class="line"><span class="comment">//  *isnew = 1: 虚拟地址此前没有写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  (Isnew lets callers like file_get_block clear any memory-only </span></span><br><span class="line"><span class="comment">//  fields from the disk blocks when they come in off disk.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查 blockno 的合法性 */</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123; user_panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line"><span class="comment">/* Step 2: 检查磁盘中块是否有效，如果磁盘块是 free 的，说明里面没东西 */</span></span><br><span class="line"><span class="comment">// Hint: 读之前要先读一下 bitmap 是不是倒进内存里了</span></span><br><span class="line"><span class="comment">//  If the bitmap is NULL, indicate that we haven&#x27;t read bitmap from disk to memory</span></span><br><span class="line"><span class="comment">//  until now. So, before we check if a block is free using `block_is_free`, we must</span></span><br><span class="line"><span class="comment">//  ensure that the bitmap blocks are already read from the disk to memory.</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123; user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line"><span class="comment">/* Step 3: 找到待写入的虚拟地址 */</span></span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="comment">/* Step 4: 读入内存，更新 *isnew */</span></span><br><span class="line"><span class="comment">// Hint: 如果已经 mapped 则只更新 isnew，否则先 alloc 页面，再 read</span></span><br><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">// 已经 mapped</span></span><br><span class="line"><span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 未 mapped</span></span><br><span class="line"><span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">1</span>; &#125;</span><br><span class="line">syscall_mem_alloc(<span class="number">0</span>, va, PTE_D);                <span class="comment">// 申请页面</span></span><br><span class="line">ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);  <span class="comment">// 使用 ide_read 读入页面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Step 5: 赋值 *blk */</span></span><br><span class="line"><span class="keyword">if</span> (blk) &#123; *blk = va; &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block-is-free-amp-free-block"><a href="#block-is-free-amp-free-block" class="headerlink" title="block_is_free &amp; free_block"></a>block_is_free &amp; free_block</h3><p>这两个函数改变的是内存中存放的 <code>bitmap</code> 数组，检查磁盘中是否使用了这个块/操作块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  通过内存中的 bitmap 检查 block 是否在磁盘中有效</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">    <span class="comment">// blockno 不合法，一定不有效</span></span><br><span class="line"><span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 查 bitmap，如果指定位为 1，说明有效</span></span><br><span class="line"><span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 其余情况无效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark a block as free in the bitmap.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 如果 blockno 不合法，不更改 bitmap */</span></span><br><span class="line"><span class="comment">/* Exercise 5.4: Your code here. (1/2) */</span></span><br><span class="line"><span class="comment">// if blockno = 0, the boot sector will have the chance to be overwrited</span></span><br><span class="line"><span class="keyword">if</span> (blockno == <span class="number">0</span> || blockno &gt; super-&gt;s_nblocks) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 通过位运算改变 bitmap 的值，使指定位置为 1. */</span></span><br><span class="line"><span class="comment">/* Exercise 5.4: Your code here. (2/2) */</span></span><br><span class="line">bitmap[blockno / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放第 blockno 个磁盘块时，就需要先找到 <code>bitmap</code> 的对应位，bitmap 的类型是 32 位的，也就是说第 blockno 个磁盘块应该位于第 blockno / 32 个数组元素中，再利用位运算把代表 blockno 的那一位置 1 即可。</p><h3 id="alloc-block-num-amp-alloc-block"><a href="#alloc-block-num-amp-alloc-block" class="headerlink" title="alloc_block_num &amp; alloc_block"></a>alloc_block_num &amp; alloc_block</h3><p>这两个函数主要负责管理内存中的 <code>bitmap</code>，带 <code>num</code> 的函数负责申请块，不带的则直接完成了申请+映射</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Search in the bitmap for a free block and allocate it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> blockno;</span><br><span class="line"><span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line"><span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line"><span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="comment">// the block is free</span></span><br><span class="line">bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">write_block(blockno / BIT2BLK + <span class="number">2</span>); <span class="comment">// write to disk.</span></span><br><span class="line"><span class="keyword">return</span> blockno;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// no free blocks.</span></span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Allocate a block -- first find a free block in the bitmap, then map it into memory.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> r, bno;</span><br><span class="line"><span class="comment">// Step 1: find a free block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123; <span class="comment">// failed.</span></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">bno = r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">free_block(bno);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: return block number.</span></span><br><span class="line"><span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-super-amp-read-bitmap"><a href="#read-super-amp-read-bitmap" class="headerlink" title="read_super &amp; read_bitmap"></a>read_super &amp; read_bitmap</h3><p>在这两个函数中，我们完成了文件管理进程的<strong>基础数据准备</strong>：读取了磁盘的超级块（获得基础信息），同时得到了磁盘的位图 <code>bitmap</code>（占用情况）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_super</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="comment">/* Step 1: 读取 super 块，blockno = 1 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;cannot read superblock: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">super = blk; <span class="comment">// 把 super 块缓存地址所在的指针赋给进程中的变量 super，便于后续使用</span></span><br><span class="line"><span class="comment">/* Step 2: 检查 MAGIC NUMBER */</span></span><br><span class="line"><span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC) &#123; user_panic(<span class="string">&quot;bad file system magic number %x %x&quot;</span>, super-&gt;s_magic, FS_MAGIC); &#125;</span><br><span class="line"><span class="comment">/* Step 3: 检查磁盘大小，超过块缓存允许的大小就会 panic，对应了 Thinking */</span></span><br><span class="line"><span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKMAX / BY2BLK) &#123; user_panic(<span class="string">&quot;file system is too large&quot;</span>); &#125;</span><br><span class="line">debugf(<span class="string">&quot;superblock is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Read and validate the file system bitmap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  把磁盘中表示 bitmap 的几个磁盘块全读取到内存中，并设置一个数组指向它们，代表内存中的 bitmap</span></span><br><span class="line"><span class="comment">//  For each block i, user_assert(!block_is_free(i))) to check that they&#x27;re all marked as in use.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">u_int i;</span><br><span class="line"><span class="type">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* Step 1: 计算块数量，并进行  */</span></span><br><span class="line">u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitmap = diskaddr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 确保特殊块为 in-use 状态 */</span></span><br><span class="line"><span class="comment">// Hint: use `block_is_free`</span></span><br><span class="line">user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: 确保 bitmap 对应的块为 in-use 状态 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debugf(<span class="string">&quot;read_bitmap is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="va-is-dirty-amp-block-is-dirty"><a href="#va-is-dirty-amp-block-is-dirty" class="headerlink" title="va_is_dirty &amp; block_is_dirty"></a>va_is_dirty &amp; block_is_dirty</h3><p>与上文类似，之不过检查的是对应的 <code>PTE_DIRTY</code> 位，也就是检查块缓存是否发生了更改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this block is dirty. (check corresponding `va`)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_dirty</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_dirty</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> vpt[VPN(va)] &amp; PTE_DIRTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dirty-block"><a href="#dirty-block" class="headerlink" title="dirty_block"></a>dirty_block</h3><p>既然能够对块缓存进行写入，那就一定要有一个能产生 <code>PTE_DIRTY</code> 的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark this block as dirty (cache page has changed and needs to be written back to disk).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dirty_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> (!va_is_mapped(va)) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125;</span><br><span class="line"><span class="keyword">if</span> (va_is_dirty(va)) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, PTE_D | PTE_DIRTY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fs-init"><a href="#fs-init" class="headerlink" title="fs_init"></a>fs_init</h3><p>这个函数初始化了文件系统.初始化后，<code>super</code> 和 <code>bitmap</code> 都被缓存到了文件管理进程中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Initialize the file system.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  1. read super block.</span></span><br><span class="line"><span class="comment">//  2. check if the disk can work.</span></span><br><span class="line"><span class="comment">//  3. read bitmap blocks from disk to memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">read_super();         <span class="comment">// 缓存 super 块</span></span><br><span class="line">check_write_block();  <span class="comment">// 一个测试函数</span></span><br><span class="line">read_bitmap();        <span class="comment">// 缓存 bitmap 所用块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，与磁盘块相关的函数就结束了。<code>fs.c</code> 中剩余的函数均以文件为读取单位，它们基于我们刚刚分析的读取块的函数而实现，等文件说完再回来看。</p><h2 id="struct-File"><a href="#struct-File" class="headerlink" title="struct File"></a>struct File</h2><p>在 MOS 中，描述文件使用文件控制块 File，其定义于 <code>user/include/fs.h</code>，每个控制块的大小为 256 Byte</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line"><span class="type">uint32_t</span> f_size; <span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type; <span class="comment">// file type</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line"><span class="type">uint32_t</span> f_indirect; <span class="comment">// points to a block contains pointers</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128</span></span><br></pre></td></tr></table></figure><p>基础的文件结构不再赘述，需要注意文件控制块中包含一个指向目录的控制块指针，可以用来表示位置；同时还使用 <code>f_pad</code> 域将控制块补全至 256 字节，使得一个 Block 能包含整数个文件块。</p><p>前面说了那么多，大部分是从<strong>物理单位</strong>（块、扇区）对磁盘进行操作，实际上我们真正要对磁盘操作时，应该从<strong>逻辑单位</strong>（文件）操作。说白了，文件/磁盘块有点类似于页式存储中段/页的概念。在 <code>load_icode</code> 中我们以页为单位进行了读入，实际上还是为了把整个二进制 ELF 全部读入；文件也类似，要读写文件，最终也是以块为单位出发去实现的。</p><h1 id="serv-c-文件系统服务进程"><a href="#serv-c-文件系统服务进程" class="headerlink" title="serv.c - 文件系统服务进程"></a><code>serv.c</code> - 文件系统服务进程</h1><p>与指导书介绍顺序不同，我们这里先讲一下文件系统服务进程。</p><h2 id="struct-Open"><a href="#struct-Open" class="headerlink" title="struct Open"></a>struct Open</h2><p>在文件服务进程的源代码中，我们找到了一个新数据结构的定义：<code>Open</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">u_int o_fileid;     <span class="comment">// file id</span></span><br><span class="line"><span class="type">int</span> o_mode;         <span class="comment">// open mode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span> <span class="comment">// va of filefd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构可以看成是文件服务的<strong>柜台窗口</strong>，文件管理进程想要打开/操作一个文件，必须先获取一个窗口，然后再在窗口上进行操作。其中的 <code>o_ff</code> 字段大小为一页，我个人把他叫做这个<strong>窗口的工作区</strong>，在工作区中存放了当前操作文件的 <code>Filefd</code> ，并且经常要发生赋值和写入（为了更新文件状态）。</p><p>同样的，我们设置了一个管理窗口的数组 <code>opentab</code>，可以对其<strong>标识符</strong> <code>o_fileid</code> 进行遍历，从而获取指定窗口。具体存放结构如图：</p><p>总而言之，文件系统进程通过 Open 来管理文件的打开与否，但文件信息大多还是需要 File 和 Filefd</p><p>插播一个很巧妙的函数：<code>open_alloc</code>，也即申请空闲窗口的函数。</p><h3 id="open-alloc"><a href="#open-alloc" class="headerlink" title="open_alloc"></a>open_alloc</h3><p>为什么说它巧，因为它利用了 <code>pp_ref</code> 字段判断窗口当前是否处于使用中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find an available open-file table entry</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, opentab[i].o_ff, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">*o = &amp;opentab[i];</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)opentab[i].o_ff, <span class="number">0</span>, BY2PG);</span><br><span class="line"><span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在下面的开启文件的函数中，最后一步是把窗口的工作区<strong>映射并共享</strong>给请求者，这使得 <code>pp_ref</code> 必然 ≥ 2（自身 + 不少于一个请求者）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br></pre></td></tr></table></figure><p>当遍历所有窗口的工作区时，一旦发现 <code>pp_ref == 1</code>，则意味着<strong>所有</strong>请求者都主动释放了该页面（文件不再使用后请求者会自行释放，但文件服务进程永远不会主动释放）。也就意味着当前工作区无人使用，就拿来再次分配了。</p><h2 id="文件块-amp-磁盘块-amp-块缓存"><a href="#文件块-amp-磁盘块-amp-块缓存" class="headerlink" title="文件块 &amp; 磁盘块 &amp; 块缓存"></a>文件块 &amp; 磁盘块 &amp; 块缓存</h2><p>开始还有点不解，不是说每个磁盘块都要装到固定的块缓存中吗，在 <code>file_map_block</code> 中指定了块号为什么随便 <code>alloc</code> 了一个就用了呢？</p><p>前半句确实是正确的，这是<strong>磁盘块缓存</strong>的要求，但是我们这里“指定”的块号是<strong>文件块号</strong>，它代表文件中的第 filebno 块，而在磁盘中具体怎么存放我们并不关心。</p><p>更通俗的讲，可以把文件看成虚拟内存，而磁盘看成物理内存：</p><ul><li>文件块是逻辑上连续的，每个文件都是如此</li><li>磁盘块是物理上连续的，同时，它在装入块缓存时又是一一对应的</li><li>相邻的文件块可以通过 <code>alloc_block</code> 函数<strong>映射到</strong>不相邻的磁盘块内</li></ul><p>但和存储管理不同的是，我们这里并没有什么页表去存放映射关系，<strong>保存映射的是文件管理块</strong>。所以 pgdir_walk 查的是页表， file_block_walk 查的是文件块和文件块内部的数据，如图：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305161150782.png?imageMogr2/format/webp" alt="mapping_relation" style="zoom: 10%;" /><h2 id="fs-c-中的文件操作函数"><a href="#fs-c-中的文件操作函数" class="headerlink" title="fs.c 中的文件操作函数"></a><code>fs.c</code> 中的文件操作函数</h2><p>在文件系统服务函数中，我们可以发现它们大多使用了 <code>file_*</code> 类型的函数，他们来自之前剩一点没讲的 <code>fs.c</code>，剩下的部分是以文件为单位进行交互的函数集合。</p><p>现在我们就对这些函数做一些分析。</p><h2 id="一图流"><a href="#一图流" class="headerlink" title="一图流"></a>一图流</h2><blockquote><p>包含了前面的块操作函数</p></blockquote><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236155.svg" alt="fs.c"></p><h3 id="file-create"><a href="#file-create" class="headerlink" title="file_create"></a>file_create</h3><ul><li>创建 <code>path</code> 指向的文件，返回文件控制块</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Create &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *file to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">/* Step 1: 主要获取 path 包含的目录，顺便查一下文件是否存在 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123; <span class="keyword">return</span> -E_FILE_EXISTS; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 路径、过程中的路径不存在，返回错误 */</span></span><br><span class="line"><span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 在指定目录下申请一个文件 */</span></span><br><span class="line"><span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 向文件赋名，返回 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(f-&gt;f_name, name);</span><br><span class="line">*file = f;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-open-amp-walk-path"><a href="#file-open-amp-walk-path" class="headerlink" title="file_open &amp; walk_path"></a>file_open &amp; walk_path</h3><p>直接调用了另一个函数：<code>walk_path</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  从根目录开始，搜索 path 指向的文件，返回路径目录的控制块和文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">walk_path</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir, <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start at the root.</span></span><br><span class="line">path = skip_slash(path);</span><br><span class="line">file = &amp;super-&gt;s_root;</span><br><span class="line">dir = <span class="number">0</span>;</span><br><span class="line">name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = <span class="number">0</span>; &#125;</span><br><span class="line">*pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find the target file by name recursively.</span></span><br><span class="line"><span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">dir = file;</span><br><span class="line">p = path;</span><br><span class="line"><span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123; path++; &#125;</span><br><span class="line"><span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line"><span class="built_in">memcpy</span>(name, p, path - p);  <span class="comment">// 截断路径并存入 name 数组中</span></span><br><span class="line">name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">path = skip_slash(path);</span><br><span class="line"><span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125; <span class="comment">// 检查途径目录的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 若正常，则应递归查找 path</span></span><br><span class="line"><span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// dir_lookup：path 结束且找不到文件</span></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;</span><br><span class="line"><span class="keyword">if</span> (lastelem) &#123; <span class="built_in">strcpy</span>(lastelem, name); &#125;</span><br><span class="line">*pfile = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;  <span class="comment">// 成功递归出 file 的位置</span></span><br><span class="line">*pfile = file;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Open &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *pfile to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们的查找从根目录开始（<code>super</code>），一直到路径结束前，都采用递归的形式对路径中每个用“/”分开的文件夹进行<strong>搜索</strong>（dir_lookup）</li><li>dir_lookup：如果进入异常退出的分支，则意味着 <code>r == -E_NOT_FOUND</code>（目录里没有这个文件） &amp;&amp; <code>*path == &#39;\0&#39;</code>（找到文件所在的最底一层目录了），也就是文件不存在，应当退出。</li></ul><h3 id="file-get-block-amp-file-map-block-amp-file-block-walk"><a href="#file-get-block-amp-file-map-block-amp-file-block-walk" class="headerlink" title="file_get_block &amp; file_map_block &amp; file_block_walk"></a>file_get_block &amp; file_map_block &amp; file_block_walk</h3><ul><li>file_block_walk：类似 pgdir_walk，获取文件 f 的第 filebno 块在磁盘中的磁盘块号；如果在非直接指针区域、没有间接指针块，会创建一个间接块（但是没有申请 filebno 的块）</li><li>file_map_block：上一个函数的封装，获取第 filebno 块在磁盘中的块号；如果文件块 → 磁盘块的映射不存在，则会申请磁盘块形成一个映射</li><li><strong>file_get_block</strong>：先获取第 filebno 块在磁盘中的块号，再把数据从磁盘中<strong>读到内存中</strong>（read_block）</li></ul><p>第三个函数是在服务进程中申请某个地址的内容时使用的，用于把指定地址所在的块一并加载，供用户使用。最后实现时需要把直接指针和间接指针块对外包装出<strong>同等的访问方式</strong>，因此需要在内部处理差异。</p><p>前两个是比较底层的工具函数，没有在 fs.c 之外的文件内出现，所以没什么印象也没关系的吧（大嘘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Set *blk to point at the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int diskbno;</span><br><span class="line">u_int isnew;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到文件 f 第 filebno 个块在磁盘中对应的磁盘号</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 从磁盘中读该磁盘号的数据到 blk 中</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OVerview:</span></span><br><span class="line"><span class="comment">//  Set *diskbno to the disk block number for the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="comment">//  If alloc is set and the block does not exist, allocate it.</span></span><br><span class="line"><span class="comment">//  完整的封装</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到指定块的地址，存在 ptr 里</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 目标块的地址不存在，根据 alloc 决定是否申请</span></span><br><span class="line"><span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 类似的，给指针赋值</span></span><br><span class="line">*diskbno = *ptr;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  获取指定文件 f 的指定块在磁盘中的块号，alloc == 1 &amp;&amp; NINDIRECT 时需要申请指针块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  Return 0 on success, and set *ppdiskbno to the pointer to the target block.</span></span><br><span class="line"><span class="comment">//  Return -E_NOT_FOUND if the function needed to allocate an indirect block, but alloc was 0.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_MEM if there&#x27;s not enough memory for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_INVAL if filebno is out of range (&gt;= NINDIRECT).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line"><span class="type">uint32_t</span> *blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line"><span class="comment">// Step 1: 直接指针，则 ptr 直接指向指定的块</span></span><br><span class="line">ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line"><span class="comment">// Step 2: 非直接指针，根据 alloc 决定是否需要为文件申请一个指针块</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;      <span class="comment">// 申请失败，返回</span></span><br><span class="line">&#125;</span><br><span class="line">f-&gt;f_indirect = r; <span class="comment">// 申请成功，建立连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 把指针块映射到文件管理进程的内存中，这时并没有为目标块创建块缓存</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span> **)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">ptr = blk + filebno;  <span class="comment">// 令 ptr 指向指针块中的第 filebno 项，也就是第 filebno 块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 保存 ptr 的值，返回</span></span><br><span class="line">*ppdiskbno = ptr;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush"><a href="#file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush" class="headerlink" title="file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush"></a>file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush</h3><p>函数的作用是设定指定文件的大小，其中还会调用三个底层函数</p><ul><li>file_truncate：释放文件缩小后占用多余的块</li><li>file_clear_block：实际释放块使用的函数</li><li>file_flush：同步文件内容至磁盘，此处用于更新被修改文件的目录，也就是同步目录中的所有文件</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  设定文件的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_set_size</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 若文件变小，则需要释放多余的块 */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_size &gt; newsize) &#123; file_truncate(f, newsize); &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 更新文件的大小 */</span></span><br><span class="line">f-&gt;f_size = newsize;</span><br><span class="line"><span class="comment">/* Step 3: */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件多余的占用块，同时注意清理间接指针块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_truncate</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">u_int bno, old_nblocks, new_nblocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 设定缩小前后所占用的块数量 */</span></span><br><span class="line">old_nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">new_nblocks = newsize / BY2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>) &#123; new_nblocks = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 释放多余的块缓存；同时如果缩小到不需要使用间接指针块，则释放间接块 */</span></span><br><span class="line"><span class="keyword">if</span> (new_nblocks &lt;= NDIRECT) &#123;</span><br><span class="line"><span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">file_clear_block(f, bno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_indirect) &#123;</span><br><span class="line">free_block(f-&gt;f_indirect);</span><br><span class="line">f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 否则只单纯释放块缓存，保留间接块 */</span></span><br><span class="line"><span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">file_clear_block(f, bno);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 更新文件大小 */</span></span><br><span class="line">f-&gt;f_size = newsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_clear_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line">    <span class="comment">/* Step 1: 找到 filebno 指定的块地址 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 释放指定块的块缓存 */</span></span><br><span class="line"><span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">free_block(*ptr);</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  同步块缓存中的文件内容至磁盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_flush</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line"><span class="comment">// Your code here</span></span><br><span class="line">u_int nblocks;</span><br><span class="line">u_int bno;</span><br><span class="line">u_int diskno;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 1: 对文件中所有占用的块遍历 */</span></span><br><span class="line"><span class="keyword">for</span> (bno = <span class="number">0</span>; bno &lt; nblocks; bno++) &#123;</span><br><span class="line">        <span class="comment">/* Step 2: 获取文件中第 bno 块的磁盘块号 diskno */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, bno, &amp;diskno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* Step 3: 如果磁盘块在加载到缓存后被更新过，则写回 */</span></span><br><span class="line"><span class="keyword">if</span> (block_is_dirty(diskno)) &#123;</span><br><span class="line">write_block(diskno);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-close"><a href="#file-close" class="headerlink" title="file_close"></a>file_close</h3><ul><li>比较简单，但是断档继续写的时候，我已经快忘了 <code>file_flush</code> 是干嘛的了（悲</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Close a file.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line"><span class="comment">// 将文件本身 + 目录同步回磁盘块中</span></span><br><span class="line">file_flush(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">file_flush(f-&gt;f_dir);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-dirty"><a href="#file-dirty" class="headerlink" title="file_dirty"></a>file_dirty</h3><ul><li>调用了前面的函数 <code>dirty_block</code>，实现了对指定文件的特定地址的 DIRTY 标识。（在写入 <code>offset</code> 后，为了保证能够同步块缓存和磁盘的数据，需要调用这个函数了）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  标记指定文件地 offset 所在的块为 DIRTY </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_dirty</span><span class="params">(<span class="keyword">struct</span> File *f, u_int offset)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int diskbno;</span><br><span class="line">    <span class="comment">// 使用 file_map_block 找到 offset 对应的磁盘块号</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, offset / BY2BLK, &amp;diskbno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">// 把指定磁盘块的块缓存置为 DIRTY</span></span><br><span class="line"><span class="keyword">return</span> dirty_block(diskbno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-remove"><a href="#file-remove" class="headerlink" title="file_remove"></a>file_remove</h3><ul><li>通过字符串展示的路径先查询到文件控制块，然后使用将自身大小减为 0 的方式解除所有占用的内存块；最后同步至磁盘内</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_remove</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到要 remove 的文件，指针存到 f 内</span></span><br><span class="line"><span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 将体积缩小为 0</span></span><br><span class="line">file_truncate(f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 清除名称，查询是否文件是否占用时看的就是 f_name[0]</span></span><br><span class="line">f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 同步自身内容和目录内容至磁盘内</span></span><br><span class="line">file_flush(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-sync"><a href="#file-sync" class="headerlink" title="file_sync"></a>file_sync</h3><ul><li>啊我整个大的.jpg</li></ul><p>对于整个块缓存空间来说，同步所有写入过的块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Sync the entire file system.  A big hammer.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_sync</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (block_is_dirty(i)) &#123;</span><br><span class="line">write_block(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dir-lookup-Exercise-5-8"><a href="#dir-lookup-Exercise-5-8" class="headerlink" title="dir_lookup - Exercise 5.8"></a>dir_lookup - Exercise 5.8</h3><ul><li>遍历目录中的每个文件，查找名称是否相同；同时，遍历的方式是先块后文件，详细可以看代码</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  查找当前路径下 dir 中字符串 name 指向的文件，返回文件控制块 file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">/* Step 1: 通过占用块计算目录 dir 大小 */</span></span><br><span class="line">u_int nblock;</span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (1/3) */</span></span><br><span class="line">nblock = dir-&gt;f_size / BY2BLK + (dir-&gt;f_size % BY2BLK == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* Step 2: 遍历目录中的每个文件： */</span></span><br><span class="line">    <span class="comment">// 2.1: 遍历每个文件块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line"><span class="comment">// 获取目录中的每个磁盘块</span></span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (2/3) */</span></span><br><span class="line">file_get_block(dir, i, &amp;blk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">files</span> =</span> (<span class="keyword">struct</span> File *)blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2: 遍历块中的每个文件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line"><span class="comment">// 比较文件名，相同则返回</span></span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(f-&gt;f_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">*file = f;</span><br><span class="line">f-&gt;f_dir = dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 所有文件内均未找到，返回 -E_NOT_FOUND */</span></span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dir-alloc-file"><a href="#dir-alloc-file" class="headerlink" title="dir_alloc_file"></a>dir_alloc_file</h3><ul><li>在目录中查找空白文件管理块，并返回这个块。当目录已满时需要自动扩容</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  在给定的路径 dir 中申请一个文件空间，返回文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_alloc_file</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int nblock, i, j;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 1: 遍历所有目录的磁盘块（按文件控制块大小遍历），尝试发现空白的控制块 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line"><span class="comment">// read the block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line">            <span class="comment">/* Step 2: 发现空白控制块，直接返回 */</span></span><br><span class="line"><span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">*file = &amp;f[j];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: 目录中已有的所有块都占用，通过 file_get_block 尝试申请新磁盘块，并把文件放在新块里 */</span></span><br><span class="line">dir-&gt;f_size += BY2BLK;</span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">f = blk;</span><br><span class="line">*file = &amp;f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数把 <code>file_get_block</code> 这个函数用得很灵活，一是执行其最基本的方法，即实现文件块到磁盘块的映射；同时在 Step 3 中还充当了为文件 <code>alloc_block</code> 的磁盘块申请者（映射肯定也同时生成在文件控制块中了）</p><h2 id="serv-c-文件系统进程服务函数"><a href="#serv-c-文件系统进程服务函数" class="headerlink" title="serv.c 文件系统进程服务函数"></a><code>serv.c</code> 文件系统进程服务函数</h2><p>里面函数太多了，偷个懒</p><h3 id="一图流-1"><a href="#一图流-1" class="headerlink" title="一图流"></a>一图流</h3><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236561.svg" alt="serv.c"></p><h3 id="serve-open"><a href="#serve-open" class="headerlink" title="serve_open"></a>serve_open</h3><p>根据输入，申请一个工作区后打开文件并保存文件信息，完成后直接 ipc_send 返回。</p><p>重点体现在后面这个保存信息上了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a file id.</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123; ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="comment">// Open the file.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Save the file pointer.</span></span><br><span class="line">o-&gt;o_file = f;                       <span class="comment">// file_open 里获取到的文件指针给窗口保管</span></span><br><span class="line"><span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;       <span class="comment">// 把工作区当成 Filefd 准备写入</span></span><br><span class="line">ff-&gt;f_file = *f;                     <span class="comment">// 工作区存放文件</span></span><br><span class="line">ff-&gt;f_fileid = o-&gt;o_fileid;          <span class="comment">// 文件的 id 来自于窗口的 id</span></span><br><span class="line">o-&gt;o_mode = rq-&gt;req_omode;           <span class="comment">// 窗口工作类型由输入决定</span></span><br><span class="line">ff-&gt;f_fd.fd_omode = o-&gt;o_mode;       <span class="comment">// Filefd 里的工作类型也进行更新</span></span><br><span class="line">ff-&gt;f_fd.fd_dev_id = devfile.dev_id; <span class="comment">// 意义不明，待补</span></span><br><span class="line"></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve-map"><a href="#serve-map" class="headerlink" title="serve_map"></a>serve_map</h3><ul><li>将目标文件 <code>offset</code> 处的磁盘块的内容映射（分享）给发起请求的用户进程</li></ul><p>用户进程请求获取文件块内容时，文件管理进程会使用这个函数，它先根据文件块和 <code>offset</code> 获取到实际所在的磁盘块，最后再把在文件管理进程中缓存的信息以共享页面的形式发送给用户进程。</p><p>这里也是一个有一个从文件块→磁盘块的映射</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_map</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_map *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">u_int filebno;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filebno = rq-&gt;req_offset / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 2: 获取映射的地址和磁盘块 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 将找到的磁盘块对应的块缓存分享给请求的用户进程 */</span></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, blk, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve-set-size"><a href="#serve-set-size" class="headerlink" title="serve_set_size"></a>serve_set_size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_set_size</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_set_size *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 2: 利用窗口中存放的文件控制块更改文件大小 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的 <code>serve_*</code> 函数实际上也类似，大部分都是对<strong>文件交互函数</strong> <code>file_*</code> 函数的调用，这里函数充当接口，统一化处理信息。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part1/">See Part1 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part3/">See Part3 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part1</title>
      <link href="/2023/05/os/buaa-os-probe-lab5-part1/"/>
      <url>/2023/05/os/buaa-os-probe-lab5-part1/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab5-文件系统"><a href="#Lab5-文件系统" class="headerlink" title="Lab5 文件系统"></a>Lab5 文件系统</h1><p>到 Lab4 为止，我们已经基本处理了操作系统中内存和进程的管理，现在已经能够执行基础的功能了。然而实际上我们并不能把所有数据都存放在内存中，这时我们就需要引入文件系统这一概念，把数据交由磁盘进行存储。</p><p>Lab5 中主要涉及到以下内容：</p><ul><li>硬件外设与读写驱动</li><li>磁盘结构与驱动</li><li>文件系统服务进程操作</li></ul><h1 id="硬件外设与读写驱动"><a href="#硬件外设与读写驱动" class="headerlink" title="硬件外设与读写驱动"></a>硬件外设与读写驱动</h1><p>本次实验中，我们要实现的驱动都使用 MMIO 技术进行编写，也就是直接向内存中某个空间写入以达成对外设的访问。具体到我们的 MOS 实验中，需要访问的外设共有三个：控制台、硬盘、时钟。<strong>在这一部分，我们需要实现的就是供这些外设使用的读写驱动（接口），为后面的文件系统的访问做准备。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">** ---------------------------------*</span><br><span class="line">*|   device   | start addr | length |</span><br><span class="line">** -----------+------------+--------*</span><br><span class="line">*|  console   | <span class="number">0x10000000</span> | <span class="number">0x20</span>   | (dev_cons.h)</span><br><span class="line">*|  IDE disk  | <span class="number">0x13000000</span> | <span class="number">0x4200</span> | (dev_disk.h)</span><br><span class="line">*|    rtc     | <span class="number">0x15000000</span> | <span class="number">0x200</span>  | (dev_rtc.h)</span><br><span class="line">** ---------------------------------*</span><br></pre></td></tr></table></figure><p>首先我们需要回顾一下之前完成的实验代码：</p><ul><li>我们在 Lab2 中已经完成了对实时钟 rtc 的写入，并且只需要在内核态提供为数不多的操作，不需要处理用户态试图访问、修改时钟的情况，也就不需要额外编写驱动。</li><li>在 Lab1 中，我们通过内核态中的 <code>printcharc</code> 函数实现了 <code>printk</code> 函数，并使之可以在用户态使用（<strong>写外设</strong>）；并且内核中的 <code>kern/console.c</code> 也实现了单个字符的读取（<strong>读外设</strong>）。实际上这也就是一种驱动。</li></ul><p>那么我们也就剩下一种外设缺少驱动程序了，那就是 <strong>IDE 磁盘</strong>，它恰好是文件管理系统中的关键部分。</p><h2 id="硬件外设的访问"><a href="#硬件外设的访问" class="headerlink" title="硬件外设的访问"></a>硬件外设的访问</h2><p>在 Report 中我们已经知道，访问外设需避免向 Cache 中写入，所以我们通过访问 kseg1 段，来实现对物理内存的访问。例如 console 设备物理地址为 <code>DEV_CONS_ADDRESS</code>，那么我们要写入的虚拟地址应该为 <code>DEV_CONS_ADDRESS | KSEG1</code> 。</p><h3 id="内核态实现"><a href="#内核态实现" class="headerlink" title="内核态实现"></a>内核态实现</h3><p>内核态中，我们访问的虚拟地址空间不受限制，所以可以直接访问对应地址。</p><p>例如函数 <code>printcharc</code> 就通过直接访问内存实现向控制台的输入：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意使用 volatile 关键字以避免写入操作被优化</span></span><br></pre></td></tr></table></figure><h3 id="用户态实现-Exercise-5-1-5-2"><a href="#用户态实现-Exercise-5-1-5-2" class="headerlink" title="用户态实现 - Exercise 5.1 5.2"></a>用户态实现 - Exercise 5.1 5.2</h3><p>由于我们采用微内核的思路进行设计，所以文件系统需要工作于用户态中，那么就必须要实现用户态中的读写操作。MOS 采用<strong>系统调用</strong>的方式，先<strong>陷入内核态</strong>，再直接利用上一种方法读写，最后完成信息等的传递。这也就是 Exercise 5.1 + 5.2 的实现内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  从 va 处读数据，并写入指定外设的地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *  Data within [va, va+len) is copied to the physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment"> *  Return 0 on success.</span></span><br><span class="line"><span class="comment"> *  Return -E_INVAL on bad address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: 使用 kseg1 段虚拟地址访问外设.</span></span><br><span class="line"><span class="comment"> * Hint: 使用 &#x27;is_illegal_va_range&#x27; 检测 va 有效性.</span></span><br><span class="line"><span class="comment"> * Hint: You MUST use &#x27;memcpy&#x27; to copy data after checking the validity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  All valid device and their physical address ranges:</span></span><br><span class="line"><span class="comment"> ** ---------------------------------*</span></span><br><span class="line"><span class="comment"> *|   device   | start addr | length |</span></span><br><span class="line"><span class="comment"> ** -----------+------------+--------*</span></span><br><span class="line"><span class="comment"> *|  console   | 0x10000000 | 0x20   | (dev_cons.h)</span></span><br><span class="line"><span class="comment"> *|  IDE disk  | 0x13000000 | 0x4200 | (dev_disk.h)</span></span><br><span class="line"><span class="comment"> *|    rtc     | 0x15000000 | 0x200  | (dev_rtc.h)</span></span><br><span class="line"><span class="comment"> ** ---------------------------------*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (1/2) */</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa &lt; <span class="number">0x10000000</span> || pa &gt; <span class="number">0x15000200</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEST 5-1: Forget to think about the illegal_pa in this part</span></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000021</span> &amp;&amp; pa &lt; <span class="number">0x13000000</span>) || </span><br><span class="line">(pa &gt;= <span class="number">0x13004201</span> &amp;&amp; pa &lt; <span class="number">0x15000000</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000000</span> &amp;&amp; pa &lt;= <span class="number">0x10000020</span> &amp;&amp; (pa + len) &gt; <span class="number">0x10000020</span>) ||</span><br><span class="line">    (pa &gt;= <span class="number">0x13000000</span> &amp;&amp; pa &lt;= <span class="number">0x13004200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x13004200</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x15000000</span> &amp;&amp; pa &lt;= <span class="number">0x15000200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *) (KSEG1 + pa), (<span class="type">const</span> <span class="type">void</span> *) va, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  从外设指定地址中读取数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: You MUST use &#x27;memcpy&#x27; to copy data after checking the validity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (2/2) */</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa &lt; <span class="number">0x10000000</span> || pa &gt; <span class="number">0x15000200</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000021</span> &amp;&amp; pa &lt; <span class="number">0x13000000</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x13004201</span> &amp;&amp; pa &lt; <span class="number">0x15000000</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000000</span> &amp;&amp; pa &lt;= <span class="number">0x10000020</span> &amp;&amp; (pa + len) &gt; <span class="number">0x10000020</span>) ||</span><br><span class="line">    (pa &gt;= <span class="number">0x13000000</span> &amp;&amp; pa &lt;= <span class="number">0x13004200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x13004200</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x15000000</span> &amp;&amp; pa &lt;= <span class="number">0x15000200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *) va, (<span class="type">const</span> <span class="type">void</span> *) (KSEG1 + pa), len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exercise 5.2 是实现在用户态中的 <code>msyscall</code> 接口，实现方式与其他系统调用类似。</p><h2 id="IDE-磁盘与读写"><a href="#IDE-磁盘与读写" class="headerlink" title="IDE 磁盘与读写"></a>IDE 磁盘与读写</h2><p>在 MOS 系统中，GXemul 为我们提供了模拟的 IDE 磁盘，每次读写的单位是一个扇区（512 Byte）。和其他的外设一样，在指定位置读写可以实现和磁盘的交互，地址表如下：</p><table><thead><tr><th align="center">偏移</th><th align="center">效果</th><th align="center">位宽</th></tr></thead><tbody><tr><td align="center">0x0000</td><td align="center">写：下一次读写操作的<strong>偏移字节数</strong></td><td align="center">4 Byte</td></tr><tr><td align="center">0x0008</td><td align="center">写：设置高 32 位偏移</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0010</td><td align="center">写：下一次读写的磁盘号</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0020</td><td align="center">写：开始操作（0读/1写）</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0030</td><td align="center">读：上一次操作的返回值（0成功/非0失败）</td><td align="center">4 Byte</td></tr><tr><td align="center">0x4000 - 0x414f</td><td align="center">读/写：512 Byte 的一个扇区</td><td align="center">none</td></tr></tbody></table><ul><li>读操作后需要从缓冲区取出数据，写操作前需要事先写入缓冲区内</li></ul><h3 id="内核态实现-1"><a href="#内核态实现-1" class="headerlink" title="内核态实现"></a>内核态实现</h3><p>课程组在指导书中给出了内核态的访问实现，但实际上我们的 MOS 中并不需要这一函数去实现驱动，因为我们采用微内核架构，将访问磁盘的操作交给用户态完成，这里的代码只起到示例作用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 - C</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">read_sector</span><span class="params">(<span class="type">int</span> diskno, <span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="comment">// 实现 - MIPS</span></span><br><span class="line">LEAF(read_sector)</span><br><span class="line">    sw a0, <span class="number">0xB3000010</span>  <span class="meta"># choose the IDE id, must 0 in our MOS</span></span><br><span class="line">    sw a1, <span class="number">0xB3000000</span>  <span class="meta"># offset in the disk</span></span><br><span class="line">    li t0, <span class="number">0</span></span><br><span class="line">    sw t0, <span class="number">0xB3000020</span>  <span class="meta"># launch a <span class="string">&#x27;read&#x27;</span> action</span></span><br><span class="line">    lw v0, <span class="number">0xB3000030</span>  <span class="meta"># get the result of the action</span></span><br><span class="line">    nop</span><br><span class="line">    jr ra</span><br><span class="line">    nop</span><br><span class="line"><span class="title function_">END</span><span class="params">(read_sector)</span></span><br></pre></td></tr></table></figure><h3 id="用户态实现-Exercise-5-3"><a href="#用户态实现-Exercise-5-3" class="headerlink" title="用户态实现 - Exercise 5.3"></a>用户态实现 - Exercise 5.3</h3><p>在 MOS 中，实际完成对磁盘读写操作的是 <code>fs/ide.c</code> 中的两个函数，他们可在用户态使用，充当磁盘驱动。在这里我们就相当于复刻了前面的内核态驱动，使用 C 语言替代 MIPS，并使用系统调用来完成写入地址的操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  read data from IDE disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//  diskno: disk number.</span></span><br><span class="line"><span class="comment">//  secno: start sector number.</span></span><br><span class="line"><span class="comment">//  dst: destination for data read from IDE disk.</span></span><br><span class="line"><span class="comment">//  nsecs: the number of sectors to read.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use syscalls to access device registers and buffers.</span></span><br><span class="line"><span class="comment">// Sample: ide_read(0, blockno * SECT2BLK, va, SECT2BLK);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT;</span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sample: ide_read(0, blockno * SECT2BLK, va, SECT2BLK);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (1/2) */</span></span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_ID), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">//select disk_id</span></span><br><span class="line">        </span><br><span class="line">temp = begin + off;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_OFFSET), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// select reading offset_address</span></span><br><span class="line">        </span><br><span class="line">temp = DEV_DISK_OPERATION_READ;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// select operation</span></span><br><span class="line">        </span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_STATUS), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// get reading result</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">panic_on(temp == <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev((<span class="type">void</span> *) ((u_int) dst + off), (DEV_DISK_ADDRESS | DEV_DISK_BUFFER), DEV_DISK_BUFFER_LEN));</span><br><span class="line">            <span class="comment">// pull from buffer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ide_write</code> 同理，不再添加注释</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  write data to IDE disk.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT;</span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (2/2) */</span></span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(src + off, (DEV_DISK_ADDRESS | DEV_DISK_BUFFER), BY2SECT));</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_ID), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">temp = begin + off;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_OFFSET), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">temp = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_STATUS), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">panic_on(temp == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在函数中设置读写的偏移量时（例如 read 的 26 行），这里的偏移量不是 off 提供的偏移，而是读写地址相对于磁盘起始的偏移，也就是 <code>secno * BY2SECT + off</code>，如图：</p><p>完成这两个函数后，我们就可以通过在用户态调用 <code>ide_read/write</code> 来对磁盘进行操作了，这里的读写操作并不限制我们读写的大小（扇区数），但一定是<strong>整数个扇区（section）</strong>。通过对磁盘的自由读写，我们就能在此基础上建立合适的文件系统了。</p><h1 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h1><p>首先我们要区分两种磁盘的常见空间单位：</p><ul><li>扇区（section）：物理上划分磁盘的一个单位，大小通常为 512 Byte</li><li>磁盘块（block）：为了便于磁盘管理而虚拟出的一个单元，在 MOS 中大小为 4 KB</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"><span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line"><span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br></pre></td></tr></table></figure><p>通常情况下我们以磁盘块作为逻辑上管理磁盘的单位，每个 Block 的大小为 4100 字节</p><p>其次是两个特殊的磁盘块，分别代表磁盘上的第0块和第1块：引导扇区+分区表、超级块（Super Block）</p><ul><li>引导扇区+分区表：这部分在理论课的第二单元系统引导中已经涉及，主要与 BootLoader 和硬件处理相关，我们在 Gxemul 中不需要考虑这部分</li><li>超级块：包含磁盘的一些判断信息，同时充当<strong>当前磁盘的根目录</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    u_int s_magic;         <span class="comment">// FS_MAGIC</span></span><br><span class="line">    u_int s_nblocks;       <span class="comment">// number of blocks = 1024</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>    <span class="comment">// root directory of the disk</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中 <code>s_root</code> 的类型为 <code>FTYPE_DIR</code>，<code>f_name</code> 为 <code>&quot;/&quot;</code></li></ul><p>在 MOS 中，我们通过设置结构体 Block 的数组 disk 来对磁盘进行表示，每个 Block 就代表一个磁盘块，data是具体的空间，type是磁盘块用途/状态的标记。</p><h2 id="磁盘状态与更改"><a href="#磁盘状态与更改" class="headerlink" title="磁盘状态与更改"></a>磁盘状态与更改</h2><p><code>tools/fsformat.c</code></p><p>在实验中的 IDE 磁盘中，我们占用了一些磁盘块用来充当标记是否已分配磁盘块的<strong>位图数组</strong>，通过读取数组的状态来得知磁盘块的分配情况，这点与内存管理中我们使用的链表不同。</p><p>通常情况下这部分磁盘块紧跟磁盘的<strong>超级块</strong></p><h3 id="磁盘文件的创建"><a href="#磁盘文件的创建" class="headerlink" title="磁盘文件的创建"></a>磁盘文件的创建</h3><p>我们使用 <code>tools/fsformat.c</code> 的 <code>main</code> 函数来在 Linux 中创建一个可供我们 MOS 使用的磁盘镜像文件。<code>Usage: fsformat &lt;img-file&gt; [files or directories]...</code> 意味着函数的 <code>argv[1]</code> 代表着生成镜像的路径，后面的每个参数都代表准备写入的文件/目录路径。</p><p>我们来分析一下 <code>fsformat.c</code> 是怎样创建一个磁盘镜像的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line">init_disk();  <span class="comment">// 初始化磁盘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: fsformat &lt;img-file&gt; [files or directories]...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="type">char</span> *name = argv[i];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line"><span class="type">int</span> r = stat(name, &amp;stat_buf);</span><br><span class="line">assert(r == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);</span><br><span class="line">write_directory(&amp;super.s_root, name); <span class="comment">// 向 root 写入该目录/文件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">write_file(&amp;super.s_root, name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name, stat_buf.st_mode);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flush_bitmap();</span><br><span class="line">finish_fs(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序逻辑如下：</li><li>磁盘空间分配：在 <code>main</code> 开始前，创建全局数组 <code>disk</code> 代表磁盘的<strong>全部空间</strong>，相当于在程序内存当中开辟了一块磁盘等待处理</li><li>写入前的初始化：检查 <code>File</code> 大小符合规格后，调用 <code>init_disk</code> 函数对磁盘块信息进行初始化。随后执行参数检查，不符合规格将无法创建磁盘镜像</li><li>文件信息获取：遍历每个文件，获取文件属性（主要区分是目录文件还是常规文件）</li><li>文件写入：获取文件属性后在不同的 <code>if-else</code> 分支中执行不同的写入函数</li><li>封装磁盘镜像：全部文件写入后，执行函数对位图进行更新，同时封装磁盘镜像，结束程序</li></ul><p>最后，在 <code>make</code> 的过程中会编译 <code>fsformat.c</code> 并调用程序，过程中的命令行与输出，<code>fs</code> 目录下的 Makefile 如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../tools/fsformat ../target/fs.img \</span><br><span class="line">$(<span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> rootfs/motd rootfs/newmotd   | awk -F/ <span class="string">&#x27;&#123; ns[$NF]=$0 &#125; END &#123; for (n in ns) &#123; print ns[n] &#125; &#125;&#x27;</span>)</span><br><span class="line">writing regular file <span class="string">&#x27;rootfs/newmotd&#x27;</span> into disk</span><br><span class="line">writing regular file <span class="string">&#x27;rootfs/motd&#x27;</span> into disk</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(user_dir)</span>/<span class="keyword">include</span>.mk</span><br><span class="line">USERLIB     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(user_dir)</span>/, <span class="variable">$(USERLIB)</span>)</span></span><br><span class="line">USERAPPS    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(user_dir)</span>/, <span class="variable">$(USERAPPS)</span>)</span></span><br><span class="line">FSIMGFILES  := rootfs/motd rootfs/newmotd <span class="variable">$(USERAPPS)</span> $(fs-files)</span><br><span class="line"></span><br><span class="line"><span class="section">image: <span class="variable">$(tools_dir)</span>/fsformat</span></span><br><span class="line">dd if=/dev/zero of=../target/fs.img bs=4096 count=1024 2&gt;/dev/null</span><br><span class="line"><span class="comment"># using awk to remove paths with identical basename from FSIMGFILES</span></span><br><span class="line"><span class="variable">$(tools_dir)</span>/fsformat ../target/fs.img \</span><br><span class="line">$<span class="variable">$(printf &#x27;%s\n&#x27; <span class="variable">$(FSIMGFILES)</span> | awk -F/ &#x27;&#123; ns[$$NF]=$$0 &#125; END &#123; for (n in ns)</span> &#123; print ns[n] &#125; &#125;&#x27;)</span><br></pre></td></tr></table></figure><p>具体而言，Makefile 会把 <code>rootfs/motd</code> <code>rootfs/newmotd</code> <code>USERAPPS</code> <code>fs-files</code> 这几类文件写入磁盘镜像中，但是在 <code>user/include.mk</code> 中，Lab5 处并没有定义 <code>USERAPP</code>，所以只有前两个文件被写入磁盘（）</p><h4 id="写入前的初始化-init-disk"><a href="#写入前的初始化-init-disk" class="headerlink" title="写入前的初始化 - init_disk"></a>写入前的初始化 - init_disk</h4><p>在 init_disk 中，我们需要对位图和特殊的磁盘块进行初始化。</p><ul><li>初始化引导扇区块（Step 1）和超级块（Step 3）</li><li>将所有位图需要的磁盘块标记为 BMAP 类</li><li>对这些块的 data 域进行初始化（全置为可用）</li><li>修订位图数组：删去那些本<strong>不存在</strong>、又被位图初始化的磁盘块</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_disk</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, diff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Mark boot sector block.</span></span><br><span class="line">disk[<span class="number">0</span>].type = BLOCK_BOOT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Initialize boundary.</span></span><br><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">nextbno = <span class="number">2</span> + nbitblock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Initialize bitmap blocks.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">disk[<span class="number">2</span> + i].type = BLOCK_BMAP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line"><span class="built_in">memset</span>(disk[<span class="number">2</span> + i].data, <span class="number">0xff</span>, BY2BLK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NBLOCK != nbitblock * BIT2BLK) &#123;</span><br><span class="line">diff = NBLOCK % BIT2BLK / <span class="number">8</span>;</span><br><span class="line"><span class="built_in">memset</span>(disk[<span class="number">2</span> + (nbitblock - <span class="number">1</span>)].data + diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: Initialize super block.</span></span><br><span class="line">disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">super.s_magic = FS_MAGIC;</span><br><span class="line">super.s_nblocks = NBLOCK;</span><br><span class="line">super.s_root.f_type = FTYPE_DIR;</span><br><span class="line"><span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097 <span class="comment">// Everyone&#x27;s favorite OS class （6.828是吧</span></span></span><br></pre></td></tr></table></figure><ul><li>由于我们不应修改引导扇区的内容，所以在 Step 1 中只进行了状态的标记；超级块则应该在 Step 3 中把包括状态在内的多个字段初始化。</li><li>Step 2 中，<code>nbitblock</code> 代表的是位图所需的磁盘块数量，最后的一个 <code>if</code> 判断将未对齐的尾端进行删除。</li></ul><h4 id="文件信息获取-struct-stat"><a href="#文件信息获取-struct-stat" class="headerlink" title="文件信息获取 - struct stat"></a>文件信息获取 - struct stat</h4><ul><li><code>struct stat</code> 这个结构体是用来描述一个 Linux 系统文件系统中的文件属性的结构。可以通过 stat 函数获取文件的所有相关信息，一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">// 返回值为 0 说明成功获取</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Stat *stat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">        <span class="type">mode_t</span>     st_mode;       <span class="comment">// - 文件对应的模式，文件，目录等</span></span><br><span class="line">        <span class="type">ino_t</span>      st_ino;        <span class="comment">// inode节点号</span></span><br><span class="line">        <span class="type">dev_t</span>      st_dev;        <span class="comment">// 设备号码</span></span><br><span class="line">        <span class="type">dev_t</span>      st_rdev;       <span class="comment">// 特殊设备号码</span></span><br><span class="line">        <span class="type">nlink_t</span>    st_nlink;      <span class="comment">// 文件的连接数</span></span><br><span class="line">        <span class="type">uid_t</span>      st_uid;        <span class="comment">// 文件所有者</span></span><br><span class="line">        <span class="type">gid_t</span>      st_gid;        <span class="comment">// 文件所有者对应的组</span></span><br><span class="line">        <span class="type">off_t</span>      st_size;       <span class="comment">// 普通文件，对应的文件字节数</span></span><br><span class="line">        <span class="type">time_t</span>     st_atime;      <span class="comment">// - 文件最后被访问的时间</span></span><br><span class="line">        <span class="type">time_t</span>     st_mtime;      <span class="comment">// - 文件内容最后被修改的时间</span></span><br><span class="line">        <span class="type">time_t</span>     st_ctime;      <span class="comment">// - 文件状态改变时间</span></span><br><span class="line">        <span class="type">blksize_t</span> st_blksize;     <span class="comment">// 文件内容对应的块大小</span></span><br><span class="line">        <span class="type">blkcnt_t</span>   st_blocks;     <span class="comment">// 伟建内容对应的块数量</span></span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>S_ISDIR(stat_buf.st_mode)</code> 是一个宏，查询当前的结构体是否为目录（isDir），<code>ISREG</code> 同理，说明是常规文件，我们据此将文件分类</li></ul><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>我们实现了两种写入函数，分别处理<strong>目录文件</strong>和<strong>常规文件</strong>的写入。这两类函数的基础是 POSIX 标准库函数，我们在 Linux 环境中利用这些函数把待写入的文件转写到磁盘镜像中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Write directory to disk under specified dir.</span></span><br><span class="line"><span class="comment">//  Notice that we may use POSIX library functions to operate on</span></span><br><span class="line"><span class="comment">//  directory to get file infomation.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_directory</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">DIR *dir = opendir(path); <span class="comment">// 获取路径所在信息</span></span><br><span class="line"><span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf); <span class="comment">// 创建目录文件</span></span><br><span class="line"><span class="built_in">strncpy</span>(pdir-&gt;f_name, basename(path), MAXNAMELEN - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pdir-&gt;f_name[MAXNAMELEN - <span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 过程中的目录名称超长度</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file name is too long: %s\n&quot;</span>, path);</span><br><span class="line"><span class="comment">// File already created, no way back from here.</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdir-&gt;f_type = FTYPE_DIR; <span class="comment">// 设置目录类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> dirent *e; (e = readdir(dir)) != <span class="literal">NULL</span>;) &#123; <span class="comment">// 递归地获取所有当前目录下的文件，并创建目录与文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(e-&gt;d_name) + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s/%s&quot;</span>, path, e-&gt;d_name);</span><br><span class="line"><span class="keyword">if</span> (e-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">write_directory(pdir, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">write_file(pdir, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>readdir</code> 函数循环读取当前目录中的下一个<strong>目录进入点</strong>，大概可以理解为遍历内容中的文件/目录。需要注意，代表当前目录的 <code>.</code> 和父目录的 <code>..</code> 也在循环中可被读取，所以循环中要把他们去掉。</li></ul><p><code>writefile</code> 逻辑相对简单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write file to disk under specified dir.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get file name with no path prefix.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">fname++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fname = path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br><span class="line"></span><br><span class="line">target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">target-&gt;f_type = FTYPE_REG;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start reading file. 从 Linux 的环境中读到 disk 中存储</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">while</span> ((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">&#125;</span><br><span class="line">close(fd); <span class="comment">// Close file descriptor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中也同样调用了一些本文件的函数，做一些基本介绍</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Allocate an unused &#x27;struct File&#x27; under the specified directory.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  Use &#x27;make_link_block&#x27; to allocate a new block for the directory if there are no existing unused</span></span><br><span class="line"><span class="comment">//  &#x27;File&#x27;s.</span></span><br><span class="line"><span class="keyword">struct</span> File *<span class="title function_">create_file</span><span class="params">(<span class="keyword">struct</span> File *dirf)</span> &#123;</span><br><span class="line"><span class="type">int</span> nblk = dirf-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Iterate through all existing blocks in the directory.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line"><span class="type">int</span> bno; <span class="comment">// the block number</span></span><br><span class="line"><span class="comment">// If the block number is in the range of direct pointers (NDIRECT), get the &#x27;bno&#x27;</span></span><br><span class="line"><span class="comment">// directly from &#x27;f_direct&#x27;. Otherwise, access the indirect block on &#x27;disk&#x27; and get</span></span><br><span class="line"><span class="comment">// the &#x27;bno&#x27; at the index.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">bno = dirf-&gt;f_direct[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bno = ((u_int *)(disk[dirf-&gt;f_indirect].data))[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get the directory block using the block number.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through all &#x27;File&#x27;s in the directory block.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> File *f = blk; f &lt; blk + FILE2BLK; ++f) &#123;</span><br><span class="line"><span class="comment">// If the first byte of the file name is null, the &#x27;File&#x27; is unused.</span></span><br><span class="line"><span class="comment">// Return a pointer to the unused &#x27;File&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (2/3) */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 2: If no unused file is found, allocate a new block using &#x27;make_link_block&#x27; function</span></span><br><span class="line"><span class="comment">// and return a pointer to the new block on &#x27;disk&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (3/3) */</span></span><br><span class="line"><span class="type">int</span> bno = make_link_block(dirf, dirf-&gt;f_size / BY2BLK);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"><span class="keyword">return</span> blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的磁盘镜像就生成完毕了，接下来完成的就是真正文件管理的内容。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part2/">See Part2 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part3/">See Part3 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT3-Summary</title>
      <link href="/2023/05/buaa-oo-unit3-summary/"/>
      <url>/2023/05/buaa-oo-unit3-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计与构造第三单元总结"><a href="#面向对象设计与构造第三单元总结" class="headerlink" title="面向对象设计与构造第三单元总结"></a>面向对象设计与构造第三单元总结</h1><ul><li>分析本单元的测试过程<ul><li>谈谈你对黑箱测试、白箱测试的理解</li><li>对单元测试、功能测试、集成测试、压力测试、回归测试的理解</li><li>是否使用了测试工具</li><li>数据构造有何策略</li></ul></li><li>梳理本单元的架构设计，分析自己的图模型构建和维护策略<ul><li>分析作业中出现的性能问题及其修复情况，谈谈自己对规格与实现分离的理解</li></ul></li><li>本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议</li><li>本单元学习体会</li></ul><h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><ul><li>单元第一次作业，需要完成的任务为实现简单社交关系的模拟和查询，学习目标为 <strong>入门级JML规格理解与代码实现</strong>。</li><li>单元第二次作业，需要完成的目标是进一步实现社交关系模拟系统中的群组和消息功能，学习目标为<strong>进一步掌握JML规格的理解与实现</strong>。</li><li>单元第三次作业，需要完成的目标是进一步实现社交关系系统中不同消息类型以及相关操作，学习目标是<strong>理解JML规格在面向对象设计与构造中的重要意义，并掌握利用JML规格提高代码质量的能力</strong></li></ul><p>这个单元主要根据课程组提供的类、方法及其相关的 JML 指导，由我们自行书写的这些要求的实现。本单元指导书内容较少，主要的信息来源是我们的官方代码包。阅读 JML 并提取信息，完成代码实现是本单元的主要难点和内容。</p><h1 id="思路重点"><a href="#思路重点" class="headerlink" title="思路重点"></a>思路重点</h1><p>由于我们实现的类 <code>Person</code>、<code>Group</code>、<code>Network</code> 含有包含关系，并且每个类中都含有不同的字段和相关信息。对于整个代码的实现，我们要考虑的点有以下几个：</p><ol><li>这些信息由输入提供，所以就需要合理选择数据结构对其内的对象进行管理。</li><li>由于会出现大量的 <code>query</code>（查询）操作，所以如何快速获取对象、查询信息是提高程序效率的一大关键。</li><li>同时在后两次作业中，还出现了修改、破坏已有数据的修改操作，对已有数据的维护需要着重考虑。</li><li>在最后一次作业中出现了某个节点的最小环查询，我们需要提高图论中的算法效率以满足大量的查询请求。</li></ol><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="本单元测试过程"><a href="#本单元测试过程" class="headerlink" title="本单元测试过程"></a>本单元测试过程</h2><p>本单元构造了自动数据生成器，针对网络中节点数、组的数量、关系的数量和抛出异常的综合性进行了考虑，通过与同学输出等进行对拍的形式进行<strong>黑盒测试</strong>。检测出了多个异常、Group 计算中发生的错误。</p><h2 id="黑箱测试-amp-白箱测试"><a href="#黑箱测试-amp-白箱测试" class="headerlink" title="黑箱测试 &amp; 白箱测试"></a>黑箱测试 &amp; 白箱测试</h2><blockquote><p><strong>黑箱测试</strong>又称为“功能测试”，是将测试对象看做一个黑盒，在并不考虑软件产品的内部结构和处理过程的基础上对软件产品进行功能测试。</p><p><strong>白箱测试</strong>是测试人员要了解程序结构和处理过程，按照程序内部逻辑测试程序，检查程序中的每条通路是否按照预定要求正确工作。它主要的针对被测程序的源代码，测试可以完全不考虑程序的功能。</p></blockquote><p>简单来说，黑盒测试不关注程序的内部构造、数据的存储与处理方式，只关心输出的结果是否有效、程序的最终效率如何。黑盒测试更多地用在系统级别的验收、检测上。因为系统中的黑盒范围大，各个模块能够产生更多的交互，检验模块间的组合正确性。</p><p>而白箱测试考虑的方向则大相径庭。白箱测试更注重信息在程序的各个方法（模块）内部的流动，保证其在单个方法内的正确性，再将多个方法的接口连接，从而检查整个系统的正确性。白箱测试由系统逻辑而来，需要测试人员知晓程序的工作方式，并据此进行测试用例的编写，并对覆盖情况进行分析。</p><h2 id="单元测试、功能测试、集成测试、压力测试、回归测试"><a href="#单元测试、功能测试、集成测试、压力测试、回归测试" class="headerlink" title="单元测试、功能测试、集成测试、压力测试、回归测试"></a>单元测试、功能测试、集成测试、压力测试、回归测试</h2><blockquote><p><strong>单元测试</strong>：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。</p></blockquote><p>单元测试大多为静态的白盒测试，它从系统的功能指导书出发，静态地检测代码的功能，避免要求读错等基础错误。</p><blockquote><p><strong>功能测试</strong>：使用人工和自动手段来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清楚预期结果与实际结果之间的差别。</p></blockquote><p>功能测试，一般是对单个模块测试，提供指定输入后检测输出，从而检测功能实现的正确与否。</p><blockquote><p><strong>集成测试</strong>：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。</p><ul><li>自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。</li><li>自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。</li></ul></blockquote><p>集成测试，则是将经过单元的功能测试后的模块进行一定程度组合，检测其能不能满足某种实际情况的应用。这种测试要求的综合性更强。</p><blockquote><p><strong>压力测试</strong>是一种基本的质量保证行为，它是每个重要软件测试工作的一部分。通过在有限时间内进行大量功能上的请求和并行请求以测试程序处理的效率与可靠性。</p></blockquote><p>在通过集成测试后，我们可以认为程序已经有了处理基础请求的能力。下一步进行的压力测试就是检测程序的效率和可靠程度。</p><blockquote><p><strong>回归测试</strong>：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。</p></blockquote><p>在检测过程中如果发生了修改与版本迭代，为了保证原有正确的样例、功能仍然可用，我们需要进行回归测试，保证之前正确的功能仍然正确，并且能把错误的样例修复。我们的 bug 修复采用的也是这种回归测试的思路。</p><h2 id="测试工具-amp-数据构造"><a href="#测试工具-amp-数据构造" class="headerlink" title="测试工具 &amp; 数据构造"></a>测试工具 &amp; 数据构造</h2><p>课程组推荐我们进行单元测试，但限于网络资源的覆盖性与时效性，我个人没有使用单元测试工具进行白箱测试，而是使用了数据构造并对拍的黑盒测试方式进行测试。</p><p>在进行自行数据构造的过程中，我主要对人数进行了限制，这样可以保证边、组等信息更加集中，查询数据时返回不为无效值的期望也会更高，测试的效果更好。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h2><p>本次作业的图结构中，节点是 <code>Person</code> 类型，边是 <code>person</code> 之间存在的 <code>acquaintance</code> 关系。我将 <code>acquaintance</code> 保存在每个 <code>Person</code> 结构体内，也就是说通过查询节点，可以获得与其相关的边。</p><p>同时，网络结构由 <code>Network</code> 结构实现，其中包含了一个所有 <code>Person</code> 的集合 <code>people</code>，以及包含所有边的集合 <code>arcPool</code>。他们都以 <code>HashMap</code> 的形式存在，便于对整个网络进行查询、获取操作。</p><h2 id="维护策略"><a href="#维护策略" class="headerlink" title="维护策略"></a>维护策略</h2><p>由于本单元作业存在大量的查询、计算操作，所以对数据进行动态维护十分重要，良好的动态维护结构能降低多次重复查询时的高消耗</p><p>对于指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query_group_value_sum <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">query_group_age_var <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 的年龄不会发生改变，所以在 <code>addToGroup</code> 指令发生时，对 <code>Group</code> 的 age 进行动态维护就可以避免反复的方差计算。由于只有 <code>addToGroup</code>、<code>addRelation</code>、<code>modifyRelation</code> 三个途径可以更改 <code>value</code>（前者直接改变 <code>Group</code>后两者通过更改 <code>Person</code> 的 <code>value</code> 来实现对所属的<strong>所有</strong> <code>Group</code> 进行改变），同理此时应该进行动态维护。</p><p>对于指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query_best_acquaintance <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">query_couple_sum</span><br></pre></td></tr></table></figure><p>由于 <code>acquaintance</code> 和 <code>couple</code> 只在 <code>addRelation</code> 和 <code>modifyRelation</code> 时发生改变，所以直接在这两类指令后进行更新即可，其余情况直接返回缓存的状态值即可满足要求。</p><h2 id="性能与修复"><a href="#性能与修复" class="headerlink" title="性能与修复"></a>性能与修复</h2><p>在前两次作业中，由于动态维护的实现较为完备，所以没有出现性能问题。在第三次作业中由于课程组劝导我们不要过度卷算法，所以在查询最小块时造成的部分性能损耗没有做修订，最后导致一个点出现了超时的情况。在 BUG 修复环节，对于这部分损耗的性能做了部分优化，通过了修复的回归测试。</p><h1 id="规格与实现"><a href="#规格与实现" class="headerlink" title="规格与实现"></a>规格与实现</h1><p>课程组提示我们要考虑<strong>规格与实现分离</strong>，我个人认为，规格是程序开发者对于程序功能的一种约束，它从黑盒的角度出发，只对输入、结果、副作用做了约束。而实现则不仅需要考虑以上这些，还要考虑程序内部的逻辑结构。实现可以不完全按照规格的要求，如果能保证输入、输出、副作用等前后置条件满足，也能称其<strong>满足</strong>了规则。</p><h1 id="OK-测试"><a href="#OK-测试" class="headerlink" title="OK 测试"></a>OK 测试</h1><p>对于检验代码实现与规格的一致性的作用</p><p>我认为 OK test 对于编写代码没有什么有效的帮助，因为在我们实现的 OK test 中，并没有存在检查出被检测方法错误的情况，反倒是这个 OK test 出过问题。</p><p>但它对于<strong>完全按照</strong>规格实现方法的程序员的还有点作用，它能帮你看出发生错误的操作具体在哪一步，从而根据当前状况反推、修改代码，修复 bug。而且我没有查出什么是“规格的一致性”。。。在这我无法做出解释。</p><h1 id="总结体会"><a href="#总结体会" class="headerlink" title="总结体会"></a>总结体会</h1><p>实际上，尽管本单元整体难度低，往届的学长也说第三单元的难度略有降低，但是实现的效果或者说最终成绩却和前两单元基本持平。最后一次作业在课程组的压力测试下没有抗住。</p><p>在实现规格时，不仅要考虑规格的要求，即完成度；也要考虑能否通过完善的方法去改进算法的实现，即效率。没有效率，你再对也没用，没有完成度，算的再快也没用。</p><p>本单元在设计方面的主要收获是学会了一种严谨的表达设计的方式。通过实现 JML 书写的方法引导，我对于如何表达设计以及准确表达自己的设计的重要性有了更深入的理解。</p><p>但可惜没有抗住，无言。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-1-Exam</title>
      <link href="/2023/05/os/buaa-os-lab5-1-exam/"/>
      <url>/2023/05/os/buaa-os-lab5-1-exam/</url>
      
        <content type="html"><![CDATA[<p>本次上机还算中规中矩，能够完全理解题意后，写起来还是很顺手的。<del>（实际上，根本读题的信息都读不全）</del></p><h1 id="Exam-时间查询与计算"><a href="#Exam-时间查询与计算" class="headerlink" title="Exam - 时间查询与计算"></a>Exam - 时间查询与计算</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 Lab5 与 Lab2 中，我们分别实现了不同种类外设的读写操作，现在我们需要实现一个能够获取当前物理时间的函数，和一个要求进程必须等待指定时间后才能运行的函数。现在我们介绍如何获取<strong>实时间</strong>。</p><p>GXemul 中除了磁盘 <code>disk</code> 还存在另一类外设——实时时钟 <code>rtc</code> (Real-Time Clock)，其中记录了 Unix 时间戳，即从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数。为了进一步精确 Unix 时间戳， <code>rtc</code> 中还记录了一个微秒字段。</p><p>当我们需要读取 <code>rtc</code> 中存放的时钟的值时，需要<strong>先触发时钟更新</strong>，才能获取到正确的数据，未更新时首次读取默认是 0（别问我怎么知道的）</p><p>在 GXemul 的手册中我们能查阅到 <code>rtc</code> 的起始地址为 <code>0x15000000</code>，且不同偏移量下的读写效果如下：</p><table><thead><tr><th>偏移</th><th>效果</th><th>数据位宽</th></tr></thead><tbody><tr><td><code>0x0000</code></td><td>读/写：触发时钟更新</td><td>4 bytes</td></tr><tr><td><code>0x0010</code></td><td>读：从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数</td><td>4 bytes</td></tr><tr><td><code>0x0020</code></td><td>读：为精确 Unix 时间戳而记录的微秒数，范围为 0 到 999999 微秒（1秒内）</td><td>4 bytes</td></tr></tbody></table><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>本题需要完成两个用户态中的函数，并要求在 <code>user/include/lib.h</code> 中声明，<code>user/lib/ipc.c</code> 中实现</p><ol><li><code>u_int get_time(u_int *us)</code></li></ol><p>从 <code>rtc</code> 中读取<strong>总秒数</strong>和<strong>微秒数</strong>，总秒数作为该函数的返回值，微秒数通过指针参数 <code>us</code> 返回。</p><ol start="2"><li><code>void usleep(u_int us)</code></li></ol><p>在任一用户态进程进入 <code>usleep</code> 函数后，必须停留 <code>us</code> 微秒后才能退出函数。这其中允许时间片的轮转，也就是说<strong>在等待调度的过程中仍然计时</strong></p><ul><li>请避免单位换算时可能发生的整数溢出</li><li><code>u_int</code> 为无符号整数，如果需要进行减法得到有符号整数，请在<strong>运算前</strong>使用 <code>(int)</code> 进行强制类型转换</li><li>课程组给出的一种 <code>usleep</code> 的实现：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usleep</span><span class="params">(u_int us)</span> &#123;</span><br><span class="line"><span class="comment">// 读取进程进入 usleep 函数的时间</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 读取当前时间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 当前时间 &gt;= 进入时间 + us 微秒*/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 进程切换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><ul><li><code>ipc.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">get_time</span><span class="params">(u_int *us)</span> &#123; <span class="keyword">return</span> syscall_get_time(us); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usleep</span><span class="params">(u_int us)</span> &#123;</span><br><span class="line">  u_int inUs = <span class="number">0</span>;</span><br><span class="line">  u_int nowUs = <span class="number">0</span>;</span><br><span class="line">  u_int inTime = get_time(&amp;inUs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    u_int nowTime = get_time(&amp;nowUs);</span><br><span class="line">    <span class="type">int</span> del = (<span class="type">int</span>)nowTime - (<span class="type">int</span>)inTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (del * <span class="number">1000000</span> + ((<span class="type">int</span>)nowUs - (<span class="type">int</span>)inUs) &gt; us) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>syscall_all.c</code>：增加了一个系统调用，用于直接访问用户态无权访问的 KSEG1 段内存</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">sys_get_time</span><span class="params">(u_int *us)</span> &#123;</span><br><span class="line">  u_int time = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;time, (KSEG1 + <span class="number">0x15000000</span>), <span class="keyword">sizeof</span>(u_int));  <span class="comment">// flush rtc to get correct time</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;time, (KSEG1 + <span class="number">0x15000010</span>), <span class="keyword">sizeof</span>(u_int));  <span class="comment">// store time in &#x27;time&#x27;</span></span><br><span class="line">  <span class="built_in">memcpy</span>(us, (KSEG1 + <span class="number">0x15000020</span>), <span class="keyword">sizeof</span>(u_int));     <span class="comment">// store utime in &#x27;us&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实读取时间的那部分还蛮简单的，直接写系统调用进入内核态，再向 KSEG1 区用 <code>memcpy</code> 就能实现读外设。真正能卡人的部分在时间比较上。<del><strong>哦，还有人忘了更新时钟</strong></del></p><p>关于时间比较上，群友们提供了以下几种可行的方法：</p><ol><li><strong><code>u_int</code> 溢出？我直接上 <code>long long</code>！</strong></li></ol><p>直接用 <code>long long</code> 类型存储时间，这样在 秒 → 微秒 的换算上就能避免溢出的问题，直接就能比较</p><ol start="2"><li><strong>我是守序善良者，我要选用合理的方法处理溢出</strong></li></ol><p>先获取微秒，再计算时间差就会溢出，那我先把大单位的秒相减，再移动不就溢出不了了？也就是先进行秒相减，随后再换算成微秒单位进行比较。在这个基础上还有混乱善良者，让（秒 - 秒）、（微秒 - 微秒），最后再换算相加作比较，实际上是一个意思</p><ol start="3"><li><strong>无所谓，我会 <code>% 100</code></strong></li></ol><p>还有一些同学对大单位的秒进行了<strong>取模运算</strong>，实际上这并不安全，有可能两次比较的时间的后三位分别跨在 100 这个线两边，然后相减可能就出锅了。不过没关系，我们的测评很宽松，而且这种看脸的几率也很小，因为题目要求 us 大小上小于 5 秒</p><h1 id="Extra-SSD-硬盘模拟"><a href="#Extra-SSD-硬盘模拟" class="headerlink" title="Extra - SSD 硬盘模拟"></a>Extra - SSD 硬盘模拟</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 MOS 的实现中，我们使用的是 GXemul 提供的 IDE 磁盘作为外挂的文件存储。现在我们使用固态硬盘 SSD 的概念对 IDE 磁盘进行模拟，即按照操作 SSD 的方法去操作我们的磁盘。</p><p>SSD 的特点是每个块存储数据后必须<strong>先擦除才能写入</strong>。同时闪存块是有擦写次数上限的，为了平衡各个块的擦写次数，SSD 引入了<strong>磨损平衡</strong>机制。我们在本次模拟过程中规定，模拟 SSD 的<strong>读、写、擦除</strong>均以块为单位，每块的大小都是 512 Bytes；且对于每个物理块，必须<strong>先擦除，才能写入数据</strong>。</p><p>我们定义如下几个概念：</p><p><strong>逻辑块号</strong>：文件系统读写的逻辑硬盘块编号，在物理上不一定连续，每个块的大小为512Bytes</p><p><strong>物理块号</strong>：SSD实际读写的闪存的物理编号，在物理上连续，每个块的大小都是512Bytes</p><p><strong>闪存映射表</strong>：记录逻辑块号对应物理块号信息的表</p><p><strong>物理块位图</strong>：记录各个物理块的状态信息</p><p>实际上，我们要先实现一个逻辑硬盘块到物理硬盘块的映射表，同时维护每个物理块的使用情况与擦除次数。并根据这些信息模拟正常的 SSD 工作流程。</p><p>首先说明，外界访问 SSD 时使用的是其逻辑块号，我们需要经<strong>闪存映射表</strong>获得其物理块号后，在 IDE 磁盘的对应<strong>扇区</strong>执行相关操作。</p><p>我们先规定 SSD 硬盘可能出现的四种操作：</p><ol><li><strong>初始化硬盘</strong>：清空闪存映射表，在物理块位图中将SSD的所有物理块初始化为可写状态，SSD各物理块的累计擦写次数清 0。（保证只在开始时调用一次）</li><li><strong>读取逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。如果为空，则返回 <code>-1</code> ；若不为空，就去读取对应的物理块，返回物理块内的数据，并返回 <code>0</code>。</li><li><strong>写入逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。若为空（初次写），则分配一个可写的物理块，在闪存映射 表中填入此映射关系，将数据写入该物理块，并标记此物理块为不可写；若不为空（覆盖写），则擦除原来的物理块并清除该逻辑块号的映射，并按相同方法分配一 个物理块向其写入数据。</li><li><strong>擦除逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。若为空，不做处理；若不为空，则将对应的物理块擦除（擦除表示将物理块数据全部清 0，下同）并清除此映射关系。</li></ol><p>为了描述上面需要的状态，我们需要在代码中定义如下数据结构：</p><ul><li><strong>闪存映射表</strong>：记录逻辑块号对应物理块号信息的表</li><li><strong>物理块位图</strong>：记录各个物理块是否可写。每次向可写的物理块中写入数据后，都需要标记物理块为不可写</li><li><strong>物理块累计擦除次数表</strong>：记录各个物理块的累计擦除次数</li></ul><p>在完成上述基础机制后，我们还需要实现一个简单实现磨损平衡的分配函数，在这里就不展开逻辑了。</p><h2 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h2><p>在本题中，<strong>你需要使用IDE 0号硬盘（<code>diskno = 0</code>）的第0~31个扇区来模拟SSD的第0~31个物理块</strong>，之后根据 <strong>题目描述部分</strong> 的描述，在 <code>fs/ide.c</code> 中实现下列函数：</p><p><strong>1. 初始化硬盘：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_init</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：初始化闪存映射表、物理块位图、物理块累计擦除次数表。</li></ul><p><strong>2. 读取逻辑块：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ssd_read</span><span class="params">(u_int logic_no, <span class="type">void</span> *dst)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li><code>dst</code>: 硬盘数据要加载到的内存地址</li><li>功能：读取逻辑块 <code>logic_no</code> 的数据到 <code>dst</code>，成功返回 <code>0</code>，失败返回 <code>-1</code></li></ul><p><strong>3. 写入逻辑块：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_write</span><span class="params">(u_int logic_no, <span class="type">void</span> *src)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li><code>src</code>: 要写入到硬盘中的数据的起始内存地址</li><li>功能：向逻辑块号对应的硬盘块写入以 <code>src</code> 为起始地址的512字节数据</li></ul><p><strong>4. 擦除逻辑块</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_erase</span><span class="params">(u_int logic_no)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li>功能：擦除逻辑块 <code>logic_no</code> 上的数据，并取消 <code>logic_no</code> 到物理块号的映射关系</li></ul><p>评测时将会调用上面的接口做一系列操作，验证操作执行结果是否正确，并会在操作的任何阶段读取硬盘数据以检查实现的正确与否。</p><p>为了实现上面的函数，你可能还需要自行实现以下两个函数，但我们不对函数的定义做具体要求：</p><ul><li>擦除物理块：将全 0 的数据写入到物理块中，物理块累计擦除次数加一，并置为可写状态</li><li>分配新物理块：按“题目描述”部分的方法分配，需要用到物理块位图和物理块累计擦除次数两个信息</li></ul><h2 id="一种可行的做法-1"><a href="#一种可行的做法-1" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>其实闪存映射表直接用一维的数组就足够了，下标代表逻辑号，内容代表物理号，无所谓，写完了才意识到。</p><p>首先按照合适的逻辑规定好数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int ssd_bitmap[<span class="number">32</span>];    <span class="comment">// 标记物理块是否可用，1 = free, 0 = using</span></span><br><span class="line">u_int ssd_cleanmap[<span class="number">32</span>];  <span class="comment">// 标记物理第 i 块的擦除次数</span></span><br><span class="line">u_int ssd_logic[<span class="number">32</span>];     <span class="comment">// 映射表中第 i 项映射的逻辑块号</span></span><br><span class="line">u_int ssd_physics[<span class="number">32</span>];   <span class="comment">// 映射表中第 i 项映射的物理块号</span></span><br></pre></td></tr></table></figure><p>然后顺手写好初始化函数：</p><h3 id="ssd-init"><a href="#ssd-init" class="headerlink" title="ssd_init"></a>ssd_init</h3><p>初始化标记可用的位图，闪存映射表。</p><p>擦除次数默认为 0，又写成了全局变量，所以直接跳过初始化。注意不要让映射表<strong>不存在映射时保存 0</strong>，否则可能会识别为第 0 块存在的某个映射，这里按照课程组建议写了 <code>0xffffffff</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        ssd_bitmap[ssdno] = <span class="number">1</span>;</span><br><span class="line">        ssd_physics[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">        ssd_logic[ssdno]   = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后可以先实现比较简单的读函数，因为它不需要检查/改变硬盘块状态</p><h3 id="ssd-read"><a href="#ssd-read" class="headerlink" title="ssd_read"></a>ssd_read</h3><p>为了给这个蹩脚的数据结构一些便利，我自己又写了个获取映射块的函数，多此一举。</p><p>注意下真正的读取函数还是 <code>ide_read</code>，要注意读取的扇区号和大小，其他的比较简单</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ssd_read</span><span class="params">(u_int logic_no, <span class="type">void</span> *dst)</span> &#123;</span><br><span class="line">    u_int physics_no = get_physics(logic_no);</span><br><span class="line">    <span class="keyword">if</span> (physics_no == (u_int)<span class="number">0xffffffff</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ide_read(<span class="number">0</span>, physics_no, dst, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是两个比较复杂的操作，我的建议是先写擦除的函数，因为写之前免不了要进行擦除</p><h3 id="ssd-erase"><a href="#ssd-erase" class="headerlink" title="ssd_erase"></a>ssd_erase</h3><p>这里又写了一个专门擦除的 <code>erase</code> 函数，没什么实际意义，需要注意别忘了<strong>消除原有的映射</strong>。同时，当且仅当磁盘块在进行擦除时（<code>erase</code> 函数）会发生 <code>cleanmap</code> 数组值的变化，其他地方就不要写这个数组了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_erase</span><span class="params">(u_int logic_no)</span> &#123;</span><br><span class="line">    u_int physics_no = get_physics(logic_no);</span><br><span class="line">    <span class="keyword">if</span> (physics_no == (u_int)<span class="number">0xffffffff</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找映射，并使用 erase 函数擦除物理块，同时消除映射</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == logic_no) &#123;</span><br><span class="line">            erase(ssd_physics[ssdno]);</span><br><span class="line">            ssd_logic[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">            ssd_physics[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">erase</span><span class="params">(u_int physics_no)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    ssd_cleanmap[physics_no]++;  <span class="comment">// 擦除次数 + 1</span></span><br><span class="line">    ssd_bitmap[physics_no] = <span class="number">1</span>;  <span class="comment">// 擦除后标记为可用块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        buf[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ide_write(<span class="number">0</span>, physics_no, buf, <span class="number">1</span>);  <span class="comment">// 使用 ide_write 进行实际的 &#x27;擦除&#x27; 工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是相对最复杂的写操作。因为这个函数中，不仅要完成写操作，主要是在写之前需要分配物理块，这其中的重点是实现磨损平衡的分配函数。</p><p>首先讲讲磨损平衡的实现方法：</p><ol><li>在低负荷状态下，我们优先选取擦除次数最少的、<strong>当前状态为可用的</strong>（<code>ssd_bitmap[i] = 1</code>）磁盘块（若同次数选物理块号小的），并将其返回，直接结束</li><li>在高负荷状态下，即当前可用块<strong>最小擦除次数大于等于 5</strong>，此时就需要考虑非可用块了（避免长期驻留的数据影响块的擦除数）。首先按照和第一步相同的逻辑，选出<strong>非可用块</strong>中擦除次数最少的块。随后我们进行一个简单的内容替换：</li></ol><p>将选出的非可用块包含的内容转存到选出的可用块中，这也包含<strong>将映射到该物理块的闪存表项同时更改</strong>；同时擦除非可用块，并进行分配。（有点像 Lab2 Extra 那味了）</p><p>总结一下，<strong>高负荷状态下需要</strong>：</p><ol><li>将原可用块状态标记为不可写</li><li>更新替换块的原有映射</li><li>复制<strong>替换块</strong>的内容到<strong>原可用块</strong>中</li><li>对替换块执行一次擦除操作，标记为可用</li></ol><h3 id="alloc-physics"><a href="#alloc-physics" class="headerlink" title="alloc_physics"></a>alloc_physics</h3><p>这个函数写的很臃肿，而且废话很多，怎么说呢，能跑就行（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">alloc_physics</span><span class="params">()</span> &#123;</span><br><span class="line">    u_int target_no   = <span class="number">1000</span>;  <span class="comment">// 低负荷下选出的可用块</span></span><br><span class="line">    u_int erase_time  = <span class="number">1000</span>;  <span class="comment">// 标记最少擦除次数</span></span><br><span class="line">    u_int exchange_no = <span class="number">1000</span>;  <span class="comment">// 高负荷下选出的替换块</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];             <span class="comment">// 用作转存时使用的中介</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 根据选择逻辑获得擦除最少的可用物理块块号和擦除次数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_cleanmap[ssdno] &lt; erase_time &amp;&amp; ssd_bitmap[ssdno] == <span class="number">1</span>) &#123;</span><br><span class="line">            target_no = ssdno;</span><br><span class="line">            erase_time = ssd_cleanmap[ssdno];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 低负荷状态可以直接结束函数，同时恭喜你拿到了 80 分 */</span></span><br><span class="line">    <span class="keyword">if</span> (erase_time &lt; <span class="number">5</span>) &#123; <span class="keyword">return</span> target_no; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: 高负荷状态下，按照选择逻辑再次获得替换块*/</span></span><br><span class="line">    erase_time = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_bitmap[ssdno] == <span class="number">0</span> &amp;&amp; ssd_cleanmap[ssdno] &lt; erase_time) &#123;</span><br><span class="line">            exchange_no = ssdno;</span><br><span class="line">            erase_time = ssd_cleanmap[ssdno];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 初始化转存的区域，不写也行 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123; buf[i] = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 替换块擦除，做出提到的相应更新 */</span></span><br><span class="line">    ssd_bitmap[target_no] = <span class="number">0</span>;                   <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;   <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span> (ssd_physics[ssdno] == exchange_no) &#123;</span><br><span class="line">            ssd_physics[ssdno] = target_no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ide_read(<span class="number">0</span>, exchange_no, buf, <span class="number">1</span>);            <span class="comment">// 3.</span></span><br><span class="line">    ide_write(<span class="number">0</span>, target_no, buf, <span class="number">1</span>);</span><br><span class="line">    ssd_cleanmap[exchange_no]++;                 <span class="comment">// 4.</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> exchange_no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Step 5 里完全忘记用 <code>erase</code> 函数了，无所谓</li><li>第一次写的时候，到后面逻辑就乱了，直接把 <strong>可用块</strong> 的内容复制给 <strong>替换块</strong> 了，导致最后一个高负荷的点跑不出来</li></ul><h3 id="ssd-write"><a href="#ssd-write" class="headerlink" title="ssd_write"></a>ssd_write</h3><p>实现分配逻辑函数后，写入就变得很简单了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_write</span><span class="params">(u_int logic_no, <span class="type">void</span> *src)</span> &#123;</span><br><span class="line">    u_int physics_no = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 1: 先擦除原有物理块，销毁映射 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == logic_no) &#123;</span><br><span class="line">            physics_no = ssd_physics[ssdno];</span><br><span class="line">            <span class="keyword">if</span> (physics_no != (u_int)<span class="number">0xffffffff</span>) &#123;</span><br><span class="line">                ssd_erase(logic_no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 2: 根据分配逻辑申请一个新物理块，同时新建映射，标记使用情况 */</span></span><br><span class="line">    u_int save_no = alloc_physics();</span><br><span class="line">    ssd_bitmap[save_no] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// debugf(&quot;alloc physics %d\n&quot;, save_no);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == (u_int)<span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            ssd_logic[ssdno] = logic_no;</span><br><span class="line">            ssd_physics[ssdno] = save_no;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 3: 最后进行写入的操作 */</span></span><br><span class="line">    ide_write(<span class="number">0</span>, save_no, src, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>其实说到底，最后实现的核心就是<strong>模拟</strong>，说是模拟 SSD 硬盘，但实际上完成的内容又和之前的<strong>页表映射</strong>有点像。 Lab2 Extra 要求实现的换入换出，到这里就变成了写磁盘读磁盘。不过之前 Extra 并没有限制换页的分配函数，这次却着重写了这个分配的逻辑，只能说侧重点不同吧。</p><p>这次 Extra 里数据结构的选取也相对关键，比如标记使用情况的结构就选用了 <code>bitmap</code>（虽然当成 <code>intmap</code> 来用了，不过总归还是位图）；但标记映射实际上应该用个一维数组就够了，我仓皇之中选用的结构给之后写代码无形中增添了很多负担（主要是每次查都要遍历)。没关系，<del>能跑就行</del>下次一定</p><p>最后附一张课上的疯狂涂鸦，也许能提供一些结构上的思路，等告一段落之后再换成能看的图罢：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305160042914.png?imageMogr2/format/webp" alt="image-20230516004219883"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab4</title>
      <link href="/2023/05/os/buaa-os-probe-lab4/"/>
      <url>/2023/05/os/buaa-os-probe-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab4-系统调用与进程创建"><a href="#Lab4-系统调用与进程创建" class="headerlink" title="Lab4 - 系统调用与进程创建"></a>Lab4 - 系统调用与进程创建</h1><p>Lab4 中主要涉及到以下内容：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><blockquote><p>首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，<strong>请善用目录！</strong> 其实最不好理解的部分是在汇编代码和C代码之间切换的部分，可能一些宏定义、编译器的一些操作就会漏掉很多细节。 所以，时不时用用 <code>make objdump</code> 吧！努力成为 buaa-os 领域大神（？</p></blockquote><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在计算机组成原理实验 P7 与 Lab3 中，我们大致已经能够理清异常的原因、怎样产生与处理的方式了，但在 MOS 之前提到的异常大多不能由用户主动触发（时钟中断、TLB MISS 等），接下来我们就要深入了解一种特殊的、可以<strong>由用户主动发起的异常</strong>：系统调用 <code>syscall</code></p><ul><li>  异常发生的原因：出现某些不符合操作规范的指令、外部中断、syscall 指令</li><li>  产生地点（硬件）：指令流水至（M级）时 CP0 协处理器分析异常，修改 SR、Cause 等寄存器，使得当前 PC 跳转至异常处理程序入口（<code>0x80000000</code>）</li><li>  异常处理（软件）：异常处理程序对 CP0 记录的信息进行分析，选择对应的 handler 函数并跳转；对应 handler 处理结束后通过 ret_from_exception 汇编函数返回 EPC，程序继续执行</li></ul><p>我们想要使用 syscall 指令，为的就是<strong>进入内核态</strong>，让操作系统为用户执行某些任务，这些任务出于安全等考虑，只有内核才能完成，所以在调用 syscall 时，就不可避免地要进行 CPU 状态的切换（标记于 SR 寄存器的 KUc 位中）</p><h2 id="系统调用在干啥（）"><a href="#系统调用在干啥（）" class="headerlink" title="系统调用在干啥（）"></a>系统调用在干啥（）</h2><p>在详细了解系统调用前，还有必要再补充一下进程运行时的虚拟空间知识（<strong>可以补充在Lab3中？</strong>） 每个进程，都有相同的虚拟地址划分方式，并按照 mmu.h 文件中所示进行排布。每个进程都具有一张这样的表。同时每个进程的 kseg0、kseg1 段也都存放（或者说映射）着内核相关的数据结构，存在于所有进程的虚拟空间中，相当于被所有进程<strong>只读共享</strong>。所以为了方便使用，它们被整体映射到物理地址的固定区域；对于 kuseg 段，用户的页表和虚拟地址相结合，会指向物理内存中的某些空间，不同进程可能对物理空间进行共享。 执行系统调用，<strong>汇编层面上</strong>就是从 kuseg 段的汇编指令跳转至 kseg0 段，（进入内核态）并执行特定序列（系统调用函数），最后返回用户态 EPC 。<strong>C层面上</strong>就是用户态函数和内核态的系统调用函数之间的调用跳转。</p><h2 id="系统调用过程概览"><a href="#系统调用过程概览" class="headerlink" title="系统调用过程概览"></a>系统调用过程概览</h2><p>我觉得 os 学的就是一个全局观，先把需求和路线理清了，细节咱们随后再细说（</p><ul><li>  用户提出请求：<code>syscall_</code> 函数</li></ul><p>在 MOS 中，操作系统为用户准备了一系列可以在用户态调用的函数： <code>syscall_*</code> 系列函数，他们每个函数都对应一个可以通过系统调用完成的任务，用户通过调用这些函数，向操作系统传达信息：<strong>我要使用系统调用完成某个功能</strong></p><ul><li>  进入内核态：汇编函数 <code>msyscall</code></li></ul><p>在刚提到的 <code>syscall_*</code> 函数中，存在一个 <code>msyscall</code> 函数，在这个汇编写成的 <code>msyscall</code> 中，才出现了真正的 <code>syscall</code> 汇编指令，也就是在这里正式地进入了内核态，准备使用异常处理程序解决 <code>syscall</code></p><ul><li>  用户态保存：<code>exc_gen_entry</code></li></ul><p>在异常处理程序中，调用 SAVE_ALL 保存当前现场为内核栈中的 trapframe ，并将当前使用栈转换为内核栈。</p><ul><li>  接收请求并分类：<code>handle_sys</code></li></ul><p>通过异常处理程序判断为系统调用后，转入 handler 这个函数创建了一个size = TFSIZE + 8 大小的栈帧，8byte 为了保存参数 *tf（函数开始后会写回 a0 寄存器）</p><ul><li>  参数预处理调用处理函数：<code>do_syscall</code></li></ul><p>在这个函数中，我们通过分析用户传入的信息（<code>syscall_*</code> 的类型和用户现场）来响应系统调用。 分析主要凭借 tf-&gt;regs[29] 获取用户 trapframe 状态，通过sp访问内核栈获取参数等</p><ul><li>  响应完毕，返回用户态：<code>ret_from_exception</code></li></ul><p>在从 <code>do_syscall</code> 跳出并执行完对应处理函数，并返回至 <code>handle_sys</code> 后，最后会和其他异常一样，执行 <code>ret_from_exception</code>，还原现场，返回用户态，整个系统调用的过程结束   至此，整个执行流程可以总结为这张图片： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304231627668.png" alt="image-20230423162717568"></p><h2 id="发起系统调用-syscall"><a href="#发起系统调用-syscall" class="headerlink" title="发起系统调用 - syscall_*"></a>发起系统调用 - syscall_*</h2><p>上面提到，可由用户调用、距离内核态最近的函数就是这一系列 <code>syscall_*</code> 函数了。它们作为用户可调用的函数，位于 <code>user/lib/syscall_lib.c</code> 文件中，现在来看看它们的具体内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为节省空间仅保留了部分函数，反正差不多里面所有函数都长这样()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_putchar</span><span class="params">(<span class="type">int</span> ch)</span> &#123;</span><br><span class="line">    msyscall(SYS_putchar, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">syscall_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_getenvid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_mem_map</span><span class="params">(u_int srcid, <span class="type">void</span> *srcva, u_int dstid, <span class="type">void</span> *dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_mem_map, srcid, srcva, dstid, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它们都只调用了<strong>不同参数</strong>的 <code>msyscall</code> 函数，然后早早跑路（x）。这里还需要注意，<code>syscall_putchar</code>、<code>syscall_yield</code>、<code>syscall_panic</code> 这几个函数没有以”return“的方式调用 <code>msyscall</code> ，因为他们不是 <code>void</code> 的，就是 <code>noreturn</code> 的，憋憋 可以发现每个不同的函数，第一个参数一定不同，并且都代表了这个函数。也就是说， <code>msyscall</code> 通过接收这系列函数传入的第一个参数，决定最后响应的内核函数是谁，而后续的参数充当信息，用于辅助处理。  </p><h2 id="转入内核态-msyscall-Exercise-4-1"><a href="#转入内核态-msyscall-Exercise-4-1" class="headerlink" title="转入内核态 - msyscall - Exercise 4.1"></a>转入内核态 - msyscall - Exercise 4.1</h2><p>这个在用户态执行的最后一个函数（但用户编程过程中实际上不用），位于 <code>user/lib/syscall_wrap.S</code> 中，这个函数很简单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;asm/asm.h&gt;</span><br><span class="line"></span><br><span class="line">LEAF(msyscall)</span><br><span class="line">    // Just use &#x27;syscall&#x27; instruction and return.</span><br><span class="line"></span><br><span class="line">    /* Exercise 4.1: Your code here. */</span><br><span class="line">    syscall</span><br><span class="line">    jr ra</span><br><span class="line">END(msyscall)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数实际上充当了用户态、内核态的转接口：执行 <code>syscall</code> 进入内核态，从调用返回后执行 <code>jr ra</code> ，十分简洁，分工明确 我们可能注意到了不同的 <code>msyscall</code> 调用可能有不同的参数数量，他们都被保存在堆栈中为函数创造的 stack frame 空间中，与 sp 相邻。 下一步，内核就会接收到由硬件产生的 8 号异常，通过处在 <code>kern/entry.S</code> 的异常分发程序 <code>exc_gen_entry</code> 跳转到 handler 函数： <code>do_syscall</code>  </p><h2 id="分发系统调用-do-syscall"><a href="#分发系统调用-do-syscall" class="headerlink" title="分发系统调用 - do_syscall"></a>分发系统调用 - do_syscall</h2><p>首先需要注意，在跳转至 <code>do_syscall</code> 前，我们在异常分发程序中向内核栈（SAVE_ALL）压入了用户态 trapframe 的信息。随后又通过 move 指令把 a0 寄存器复制成了 trapframe 的地址（SAVE_ALL 中 move sp 的值） 所以 <code>do_syscall</code> 在调用时就会自动地带有一个参数，它就是存放在 a0 寄存器中的用户态 <code>trackframe</code> <strong>指针</strong>（为什么是指针？因为传入的 sp 的值实际上指向了存放 tf 的地址）  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];    <span class="comment">// sysno 是 msyscall 的第一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (sysno &lt; <span class="number">0</span>  sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 移动 EPC，使得syscall返回后执行下一条指令 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/* Step 2: 通过 sysno 获得使用的处理函数 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">    func = syscall_table[sysno];</span><br><span class="line">    <span class="comment">/* Step 3: 获取前三个参数 $a1, $a2, $a3. */</span></span><br><span class="line">    u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">    u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">    u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 获取后两个参数 [$sp + 16 bytes], [$sp + 20 bytes] */</span></span><br><span class="line">    u_int arg4, arg5;</span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">    arg4 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>));</span><br><span class="line">    arg5 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>));</span><br><span class="line">    <span class="comment">/* Step 5: 调用处理函数，返回值保存在用户态的 v0 中 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h3><ul><li>  这里 sysno 取自 a0 寄存器，那前面说的 tf 地址保存在 a0 寄存器又是什么呢，不会互相覆盖吗？</li><li>  首先结论很明显，不会。这里的两个 a0 指的不是同样的东西</li></ul><p>首先我们需要明确一点：当进程运行在用户态时，使用的是用户栈，栈指针也指向用户栈；每当进程<strong>通过异常</strong>从用户态切换到内核态时，handler 会执行汇编函数 <code>SAVE_ALL</code>。 它的具体作用是把用户态的所有寄存器都保存到一个 trapframe 中，同时这个 tf 会被放置在内核栈中，同时还会切换当前使用的栈空间为<strong>内核栈</strong>。并且<strong>切换时内核栈总是空的</strong>。内核栈此时就保存了进程在进入内核态前的相关信息。重回到用户态时，再通过 ret_from_exception 中的 RESTORE_SOME 将内核栈中保存的信息恢复，再切回用户栈。 因为内核栈在切换后总是空的，每次又只会传入一个 trapframe ，所以这个 trapframe 实际上每次都占用的是 KSTACKTOP 向下的一个 sizeof(trapframe) 大小的空间 所以会出现这样的空间图：</p><ul><li>  stackframe：调用函数时创建，保存函数的参数、临时变量与相关跳转指针</li><li>  trapframe：陷入内核时使用 <code>SAVE_ALL</code> 创建，保存用户态寄存器</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012029029.png" alt="image-20230501202927787"> 新的内核栈 sp 指向 trapframe，旧的用户栈 sp 指向 arg0</p><ul><li>  使用当前（内核栈）的 sp，能访问到 trapframe 的信息；使用 tf 中 sp （用户栈）的信息，能访问到最近的 stackframe 的信息</li></ul><p>回到我们的 sysno，它是 <code>msyscall</code> 的第一个参数（<strong>用户态</strong>函数），也就是在分发异常调用 SAVE_ALL 时保存的 a0 寄存器，来源是用户态，所以要从用户态的 tf 里取 a0 寄存器（tf-&gt;regs[4]）；而参数 *tf 是保存在了调用 <code>do_syscall</code> 时的内核态 a0 中，并不干扰</p><ul><li>  后面的 arg4 类似，同样来源于用户态，但由于寄存器内没有保存，所以不能直接从 tf 里取得，需要通过用户栈指针回到 stackframe 中获取(tf-&gt;regs[29] + 16)</li></ul><h3 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 - stack frame"></a>栈帧 - stack frame</h3><p>这里是实际在网站里的教程里有讲过了，当时没有仔细理解，感觉还是再说说吧。 昨天有同学问我说为啥NESTED(handler_sys, TFSIZE + 8, 0)提示编译器共有 TFSIZE + 8 字节的栈帧，但是 ra 却只移动了 8Byte。然后我就发现，我确实没理解栈帧。。 存疑：栈帧在C语言函数中自动创建，汇编函数中需要手动创建 以下内容根据 R3000 手册筛选，但不能保证正确性，为了讨论，这里就只涉及到非叶函数，也就是一般函数的栈情况</p><ul><li>  栈帧 stackframe 创建于刚刚进入函数时：编译器会令 sp 指针向下移动一定空间，并使得这段空间成为该函数栈帧（大小由编译器通过函数变量、子函数参数、临时变量等指标确定；需要<strong>注意双字对齐</strong>，所以在没对齐时需要补充空白的单字（称作pad））</li><li>  随即，编译器调用 sw 指令，把 a0 - a3 寄存器中存放的本函数前四个参数填充到紧邻本栈帧的<strong>上方的空间</strong>里，不够四个就有几个补几个</li><li>  栈内高地址存放函数的临时变量等，低地址预留本函数可能调用的<strong>子函数的参数</strong>的空间，这部分空间在进入子函数时又会成为子函数第二步填充参数的地方</li></ul><p>那回来说这个 handler_sys，它通过NESTED宏中的.frame向编译器声明自己需要 TFSIZE+8 字节的栈帧，但是自己却只移动了 8 字节的 sp。 我感觉是因为 TFSIZE 实际上是上面调用 SAVE_ALL 时移动的一个 TFSIZE，这里为了避免覆盖掉就把它看成了栈的一部分（<strong>小孩子瞎猜的</strong>）。真正有用的是那8个字节：4字节的arg1和4字节的pad，而arg1又是在进入子函数do_syscall内，才从 a0 寄存器中填充的</p><h2 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h2><p>了解完系统调用的流程后，下一步就是填写具体用于处理系统调用的函数了，可能会把能写的都写一下，<strong>建议是跳着看</strong>。  </p><h3 id="获取进程块-envid2env-Exercise-4-3"><a href="#获取进程块-envid2env-Exercise-4-3" class="headerlink" title="获取进程块 - envid2env -Exercise 4.3"></a>获取进程块 - envid2env -Exercise 4.3</h3><p>首先是 envid2env 这个函数，它用来获取id对应的进程控制块。虽然它不是系统调用的一部分，但在进行交互、系统调用时，经常使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 赋值，当 envid == 0 时返回当前进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *penv = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE  e-&gt;env_id != envid) &#123;  <span class="comment">// double check: invaild env_id</span></span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 当 checkperm != 1 时，要求查询的 env 必须是当前运行进程块**本身或父亲**</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; (e-&gt;env_id != curenv-&gt;env_id &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)) &#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;E_BAD_ENV: %x, %x, %x\n&quot;</span>, e-&gt;env_id, curenv-&gt;env_id, e-&gt;env_parent_id);</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 向 *penv 中赋值 */</span></span><br><span class="line">    *penv = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身没什么问题，但要注意 <code>envid == 0</code> 时必须提前退出函数，否则会一直运行到最后，返回 envs 内的第一个进程控制块</p><ul><li>  当 checkperm == 0 时，不需处理进程块与当前进程之间的关系，反之则需要确保调用本函数的进程是被调用者的<strong>直接父亲或本身</strong>，否则返回错误。值得一提的是，除了在进行 ipc 通讯的过程外，所有 syscall 函数都需要令 checkperm != 0（传信息不用限定在父子进程中）</li></ul><p> </p><h3 id="强制进行进程切换-sys-yield-Exercise-4-7"><a href="#强制进行进程切换-sys-yield-Exercise-4-7" class="headerlink" title="强制进行进程切换 - sys_yield - Exercise 4.7"></a>强制进行进程切换 - sys_yield - Exercise 4.7</h3><p>具体而言就是调用一次 <code>schedule</code> 函数，使得运行的进程交出 CPU 时间片，记得 yield 别传 0（）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// Hint: Just use &#x27;schedule&#x27; with &#x27;yield&#x27; set.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.7: Your code here. */</span></span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这里函数 <code>noreturn</code> ，也就是说会直接开始运行下一个进程块  </p><h3 id="指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4"><a href="#指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4" class="headerlink" title="指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4"></a>指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4</h3><ul><li>函数作用：为指定进程的 va 申请一个物理页面并形成映射<ul><li>  类似于跨进程的 page_insert</li></ul></li><li>操作：<ul><li>  确认 va 和 env 的合法性，如有错误则直接返回错误值</li><li>  申请一个物理页，调用 page_insert 生成映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 envid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Hint: **Always** validate the permission in syscalls! except for in function sys_ipc_try_send */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;env, <span class="number">1</span>)) &#123;<span class="comment">// test 4-2: !envid2env() or 0 != envid2env())</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 申请物理页 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (3/3) */</span></span><br><span class="line">    try(page_alloc(&amp;pp));</span><br><span class="line">    <span class="comment">/* Step 4: 将 va 映射入指定进程 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这不就是一个 page_insert 吗，仔细一看确实。但是用户态的 page_insert 无法<strong>帮</strong>其他进程申请一个映射，因为根本看不到其他进程的进程块，所以原则上需要看得见所有东西的内核态来帮忙  </p><h3 id="在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5"><a href="#在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5" class="headerlink" title="在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5"></a>在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5</h3><ul><li>  函数作用：说白了就是把 src 进程 va 所在的物理页，在 dst 进程中找了指定位置形成了映射（insert）</li><li>操作：<ul><li>  检验传入的两个 va 合法性</li><li>  获取 srcid 和 dstid 的进程控制块</li><li>  page_lookup 获得 srcva 在 srcid 中映射的<strong>物理页</strong></li><li>  page_insert 让物理页在 dstid 中也形成一个映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="comment">//printk(&quot;mem_map:va is %x\n&quot;, srcva);</span></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (1/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(srcva)  is_illegal_va(dstva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;invaild va: %x or %x\n&quot;, srcva, dstva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 srcid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (2/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcid, &amp;srcenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;srcenv, 1)\n&quot;, srcid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 获取 dstid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (3/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(dstid, &amp;dstenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;dstenv, 1)\n&quot;, dstid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 找到 srcid + srcva 指向的物理页 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (4/4) */</span></span><br><span class="line">    <span class="keyword">if</span> ((pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 最终在 dst 中形成映射 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="解除指定进程的映射-sys-mem-unmap-Exercise-4-6"><a href="#解除指定进程的映射-sys-mem-unmap-Exercise-4-6" class="headerlink" title="解除指定进程的映射 - sys_mem_unmap - Exercise 4.6"></a>解除指定进程的映射 - sys_mem_unmap - Exercise 4.6</h3><ul><li>  函数作用：上一行就是.jpg</li><li>操作：<ul><li>  检验 va 有效性</li><li>  获取 envid 的进程块</li><li>  直接调用 page_remove 进行映射的删除</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取对应的进程控制块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 解除 env 中 va 的映射 */</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较好写，但是 MOS 也没调用过，之后可能会有用处吧  </p><h3 id="为当前进程创建一个子进程-sys-exofork-Exercise-4-9"><a href="#为当前进程创建一个子进程-sys-exofork-Exercise-4-9" class="headerlink" title="为当前进程创建一个子进程 - sys_exofork - Exercise 4.9"></a>为当前进程创建一个子进程 - sys_exofork - Exercise 4.9</h3><p> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 使用 env_alloc 申请新进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把当前进程存入的 trapframe 复制给子进程 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// e-&gt;env_tf = curenv-&gt;env_tf;</span></span><br><span class="line">    <span class="comment">/* Step 3: 把子进程的 v0 寄存器置0，即函数返回值为0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 设置子进程状态，继承优先级  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="设置进程块-status-sys-set-env-status"><a href="#设置进程块-status-sys-set-env-status" class="headerlink" title="设置进程块 status - sys_set_env_status"></a>设置进程块 status - sys_set_env_status</h3><p>见 fork 部分  </p><h3 id="设置-trapframe-sys-set-trapframe"><a href="#设置-trapframe-sys-set-trapframe" class="headerlink" title="设置 trapframe - sys_set_trapframe"></a>设置 trapframe - sys_set_trapframe</h3><p>见 fork 部分  </p><h3 id="ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8"><a href="#ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8" class="headerlink" title="ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8"></a>ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8</h3><ul><li>  函数作用：主动将当前进程<strong>阻塞</strong>，等待 send 信息</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 非 0 va 意味着传输页面，此时需检测 va 是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;<span class="comment">// test 4-3: English &quot;either or&quot;</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 标记：允许接收数据 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (1/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 3: 设置接收的指定va */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (2/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    <span class="comment">/* Step 4: 移出调度队列，进入阻塞态 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (3/8) */</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line">    <span class="comment">/* Step 5: schedule(1) 令当前进程开摆，设置返回值为0 */</span></span><br><span class="line">    ((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里最后一块：<code>((struct Trapframe *)KSTACKTOP - 1)</code> 指的就是 <code>do_syscall</code> 那之前创建的用户态 Trapframe，这里把用户态的 v0 寄存器值设为了0，用来代表用户态<strong>最初</strong>调用的 <code>syscall_ipc_recv</code> 的返回值为 0</li></ul><h3 id="ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8"><a href="#ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8" class="headerlink" title="ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8"></a>ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8</h3><ul><li>  函数作用：和 recv 配套使用，向<strong>已准备好</strong>的进程发送信息</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检测 va 有效性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (4/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;srcva is bad! %x\n&quot;, srcva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取进程块，无需令 perm = 1，非父子进程也可传输信息 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (5/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;envid is bad! %x\n&quot;, envid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 检测目标进程是否处于可接受状态(env_ipc_recving = 1) */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (6/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 设置目标进程字段 */</span></span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">    e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 恢复目标进程状态为可运行 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (7/8) */</span></span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    <span class="comment">/* Only link page while srcva != 0, to save running time */</span></span><br><span class="line">    <span class="comment">/* Step 6: va != 0 则传输页面 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">        <span class="comment">// printk(&quot;4.8 is sys_mem_map(%x, %x, %x, %x, %x));\n&quot;, curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm);</span></span><br><span class="line">        <span class="comment">// try(sys_mem_map(curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm));</span></span><br><span class="line">        <span class="comment">/* Test 4-5: do not use sys_mem_map because it call function envid2env with perm == 1; */</span></span><br><span class="line">        <span class="comment">// because two communicating env may not have parent relatioinship</span></span><br><span class="line">        p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="ipc-进程通信-ipc-c"><a href="#ipc-进程通信-ipc-c" class="headerlink" title="ipc 进程通信 - ipc.c"></a>ipc 进程通信 - ipc.c</h1><p>为了在进程间进行数据的传输，我们在 MOS 操作系统中设置了两种传输方式：传输单个 int，共享内存；并且两种方式都集成在了同一个系统调用，也即 <code>sys_ipc_send</code> 和 <code>sys_ipc_recv</code> 两个函数完成，并且两个函数执行时需要先 recv，声明自己已准备好，再调用 send，进行信息的发送。 但是，只设置好了系统调用函数还不足以让我们完成进程间的通信，因为系统需要对发送过程是否成功进行检测，若目标进程未准备好还需要等待，也有许多诸如此类的情况。所以为了方便使用，MOS 在用户态中封装了两个完整的函数用于进行信息传递的全流程，它们位于 <code>user/lib/ipc.c</code> 中，当有通信需求时，直接调用它们就能直观地完成进程通信。 <code>ipc.c</code> 文件开头就有一句这样的注释：<code>User-level IPC library routines</code>，也正好说明了下面两个函数在用户态服务</p><h2 id="用户态发送函数-ipc-send"><a href="#用户态发送函数-ipc-send" class="headerlink" title="用户态发送函数 - ipc_send"></a>用户态发送函数 - ipc_send</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use syscall_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 持续查询是否能进行传输 */</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_send(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 如果只因为对方未就绪，自身也停止这个 while 导致的忙等待，交出 CPU */</span></span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 如果 r != 0，说明退出 while 循环的原因是 -E_INVAL，说明出现错误 */</span></span><br><span class="line">    user_assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  这里使用的 <code>syscall_yield</code> 非常巧妙：如果对方进程未就绪，那在这个时间片中也不可能转换为就绪状态（本时间片一直是本进程运行），那为了避免当前时间片忙等，索性直接归还 CPU，等下一次调度到自己之后再查</li></ul><p> </p><h2 id="用户态接收函数-ipc-recv"><a href="#用户态接收函数-ipc-recv" class="headerlink" title="用户态接收函数 - ipc_recv"></a>用户态接收函数 - ipc_recv</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use env to discover the value and who sent it.</span></span><br><span class="line">u_int <span class="title function_">ipc_recv</span><span class="params">(u_int *whom, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 直接进系统调用，因为 recv 是先执行的，不用等 */</span></span><br><span class="line">    <span class="comment">/* 需要注意进程在下一条语句中调用了 schedule，传输完毕后才跳出 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_ipc_recv(dstva);</span><br><span class="line">    <span class="comment">/* Step 2: 检查返回值，错误值则 panic */</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;syscall_ipc_recv err: %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 返回发送者的 env_id */</span></span><br><span class="line">    <span class="keyword">if</span> (whom) &#123;</span><br><span class="line">        *whom = env-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 返回映射页权限位 */</span></span><br><span class="line">    <span class="keyword">if</span> (perm) &#123;</span><br><span class="line">        *perm = env-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 返回传输的单个 int */</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  相比之下，recv 函数内赋值语句较多，因为需要接收一些信息，系统调用函数倒比较简单，单纯调用一次 syscall_ipc_recv 就完事了</li></ul><p> </p><h1 id="用户进程的创建-fork-c"><a href="#用户进程的创建-fork-c" class="headerlink" title="用户进程的创建 - fork.c"></a>用户进程的创建 - fork.c</h1><p>用户进程调用 <code>fork</code> 函数时，将会创建一个<strong>和当前一模一样</strong>的新进程：父进程进行一次函数调用，父、子进程都产生一个返回值。父进程返回值为子进程的 <code>env_id</code>，子进程返回值是0，通过返回值不同来标定谁是子进程。 为了实现 <code>fork</code> 函数，我们主要需要补充<code>user/lib/fork.c</code> 中的函数。 实现 <code>fork</code> 的主要流程如下，我们接下来会按顺序介绍（感谢指导书的图.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011703551.png" alt="image-20230501170305441">  </p><h2 id="写时复制-COW-与页写入异常"><a href="#写时复制-COW-与页写入异常" class="headerlink" title="写时复制 COW 与页写入异常"></a>写时复制 COW 与页写入异常</h2><p>在通过后文提到的 <code>fork</code> 函数创建进程时，父子进程间会暂时共享内存空间，但实际上在<strong>写入</strong>这两个进程空间时，它们应该互不干扰。那一种直观的做法就是把父进程的<strong>所占用的物理页面</strong>全都复制一遍插入进子进程中。然而这么做会造成很大的内存开销，同时那些本身不可写的页面还需要白复制一遍。 所以我们引入了一种写时复制机制 <strong>COW</strong>，用来解决进程创建后的内存共享问题。COW 的解决思路：当父子进程需要修改可写页面内容（<code>PTE_COW = 1</code>）时产生一种异常，它只新复制出该页的内容以供修改，没用到的页面仍旧保持原状。 考虑到给 <code>PTE_D = 0</code> 的页面写入时会产生 TLB_MOD 异常，我们就顺便把 COW 需要的页面标记为 <code>PTE_D = 0, PTE_COW = 1</code>，也进入 TLB_MOD，并在其中中判断是真正的错误写入，还是 COW 触发。<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012033983.png" alt="image-20230501203319024">    </p><h2 id="申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9"><a href="#申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9" class="headerlink" title="申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9"></a>申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9</h2><ul><li>  函数作用：为子进程申请一个进程块，并把父进程的内容拷贝</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 通过 env_alloc 申请进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把 KSTACKTOP 下一个 tf 内容拷贝给子进程，tf 内放的是父进程调用 fork 前的用户态 TrapFrame */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Step 3: 子进程 v0 寄存器(env_tf.regs[2]) 设为 0，说明返回值为 0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 进程块初始化  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id; <span class="comment">// 这里返回实际上是父进程的返回值，返回子进程 env_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  为了避免 <code>syscall_exofork</code> 的栈帧在后续写时复制机制建立好<strong>之前</strong>被错误地更改，导致返回地址被覆盖，我们把 <code>syscall_exofork</code> 设置为了内联函数，不再创建栈帧，保护了进程地址跳转的正确性。</li></ul><h3 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd: 23.5.4"></a>Upd: 23.5.4</h3><ul><li>  在父进程执行这个函数的过程中，会把子进程的 v0 寄存器设置为 0；随后父进程从系统调用中返回并恢复现场，<code>syscall_exofork</code> 的返回值为子进程 env_id，而子进程<strong>并没有执行这个函数</strong>，只是在被调度时才首次开始运行，恢复进程控制块中存放的 trapFrame，其中的 EPC 也令进程从 fork 函数中的 <code>syscall_exofork</code> 结束后运行，这时存放于 v0 寄存器的返回值是 0，<strong>看起来好像子进程执行了</strong>这个函数并返回了 0。这就是 <code>syscall_exofork</code> 实现两个不同返回值的过程。</li></ul><p> </p><h2 id="写时保护函数-duppage-Exercise-4-10"><a href="#写时保护函数-duppage-Exercise-4-10" class="headerlink" title="写时保护函数 - duppage - Exercise 4.10"></a>写时保护函数 - duppage - Exercise 4.10</h2><ul><li>  这个函数功能比较单一，但考虑的情况比较多</li><li>  函数功能：将符合要求的页面 <code>PTE_D</code> 置0，<code>PTE_COW</code> 置1</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   若含有 PTE_LIBRARY 则说明该页面是共享页面，不做处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only the father env can call this function, &#x27;envid&#x27; in args is the child&#x27;s envid */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int addr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vpt is the 自映射页表 in env&#x27;s virtual memory */</span></span><br><span class="line">    <span class="comment">/* Step 1: 获得当前页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (1/2) */</span></span><br><span class="line">    perm = (vpt)[vpn];</span><br><span class="line">    addr = vpn * BY2PG;</span><br><span class="line">    <span class="comment">/* Step 2: 若页面可写，同时非共享，则标记为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: 先在子进程中映射、后更新父进程的权限位，原因见下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (((perm &amp; PTE_D)  (perm &amp; PTE_COW)) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;<span class="comment">// need to change perm and remap</span></span><br><span class="line">        perm = (perm &amp; ~(PTE_D))  PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 1!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, syscall_getenvid(), (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 2!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 3!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  先给子进程映射的原因可以看<a href="https://www.cnblogs.com/CindyZhou/p/12858468.html">这里</a></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011737320.png" alt="image-20230501173715236"></p><blockquote><p>如果先给父进程加PTE_COW，然后修改了该页，该页将进行写时复制，父进程指向新的页，而新页没有被加上PTE_COW。此时再map子进程，子进程该页加上PTE_COW位而父进程没有。在随后程序运行中，若父进程进行修改，由于缺失PTE_COW，导致无法进行写时复制，因此子进程的运行出现错误（子进程该页本来不该被改，但却由于父进程被改而一起改了）。</p></blockquote><p> </p><h2 id="设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12"><a href="#设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12" class="headerlink" title="设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12"></a>设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12</h2><p>在 “写时复制 COW 与页写入异常” 一节中，我们已经知道，MOS 处理<strong>写时复制</strong>的时间是在进入 TLB_Mod 异常之后的，现在我们需要先设置 TLB_Mod 的处理函数。注意这里的处理函数可以来自<strong>用户态</strong>。 这样，在后续触发写时复制机制时，就能直接从用户给出的函数开始执行，处理异常了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取目标进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (1/2) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 2: 给函数入口字段赋值 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (2/2) */</span></span><br><span class="line">    env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里的 func 指的实际是异常处理函数的入口地址，当触发异常时，<code>do_tlb_mod</code> 会将 EPC 设置为 func 的值，同时退出异常，借此执行 Mod 异常的处理。</li></ul><h2 id="TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11"><a href="#TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11" class="headerlink" title="TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11"></a>TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11</h2><ul><li>  当系统发生 TLB_Mod 异常后，首先进入这里的 handler，设置好跳转后再 <code>ret_from_exception</code> 回到用户态，执行真正响应异常的用户态函数，最后再从该函数中返回受害指令</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   This is the TLB Mod exception handler in kernel.</span></span><br><span class="line"><span class="comment"> *   Our kernel allows user programs to handle TLB Mod exception in user mode,</span></span><br><span class="line"><span class="comment"> * so we copy its context &#x27;tf&#x27; into UXSTACK and modify the EPC to the registered</span></span><br><span class="line"><span class="comment"> * user exception entry.</span></span><br><span class="line"><span class="comment"> *   The user entry should handle this TLB Mod exception and restore the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 置位用户异常栈指针，并将当前异常 TrapFrame 复制到用户异常栈中 */</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">    *(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 存在用户的异常处理函数，手动设置处理函数的参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];           <span class="comment">// a0 = 用户异常栈地址</span></span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);  <span class="comment">// 移动异常栈指针，为函数调用保存参数留出空间</span></span><br><span class="line">        <span class="comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to</span></span><br><span class="line">        <span class="comment">// &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span></span><br><span class="line">        <span class="comment">/* Exercise 4.11: Your code here. */</span></span><br><span class="line">        tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> </p><h3 id="用户异常栈"><a href="#用户异常栈" class="headerlink" title="用户异常栈"></a>用户异常栈</h3><ul><li>  前面在栈帧一小节中已经提到了用户栈、内核栈和他们的作用，这里还要提到一个新的栈帧：用户异常栈（<code>va = UXSTACKTOP</code>），它充当在用户态中处理异常所用到的函数的栈，这里就是页写入异常处理函数的栈</li><li>  用户异常栈和内核栈功能类似，都是在发生异常时开始使用，同时都从对应栈的 TOP 开始记录，看起来用户异常栈应该也允许异常重入。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果 regs[29] 在用户异常栈中，应该就不需要再次赋值了</span></span><br></pre></td></tr></table></figure><ul><li>  这里的 Step2 为什么要做这样一系列操作呢？因为这个C语言函数结束后，会通过汇编语言的 <code>ret_from_exception</code> 直接返回 EPC。因为没有显式的函数调用，所以编译器并不会为后续跳转到的处理函数创建栈帧，这里我们需要手动创建<strong>用户异常栈</strong>中的函数栈帧，供异常处理函数使用</li></ul><p> </p><h2 id="TLB-Mod-的实际处理-cow-entry-Exercise-4-13"><a href="#TLB-Mod-的实际处理-cow-entry-Exercise-4-13" class="headerlink" title="TLB_Mod 的实际处理 - cow_entry - Exercise 4.13"></a>TLB_Mod 的实际处理 - cow_entry - Exercise 4.13</h2><p>没错，这个函数就是刚才提到的用户态异常处理函数，执行 <code>ret_from_exception</code> 后会从这里继续执行。最终在这里完成写时复制页面的复制，并返回用户态继续执行受害指令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the faulting page to a private writable copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;va&#x27; 为受害的虚拟地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">    u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取受害页面的标志位，判断是否为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27; doesn&#x27;t have</span></span><br><span class="line"><span class="comment">     * &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (1/6) */</span></span><br><span class="line">    u_int envid = syscall_getenvid();</span><br><span class="line">    perm = ((Pte *)(vpt))[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;?&quot;</span>);   <span class="comment">// 不是写时复制，意味着就是访问错了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 写时复制，设置新页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (2/6) */</span></span><br><span class="line">    perm = (perm &amp; ~(PTE_COW))  PTE_D;</span><br><span class="line">    <span class="comment">/* Step 3: 在 UCOW 空间申请一个临时页面，并建立映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (3/6) */</span></span><br><span class="line">    syscall_mem_alloc(envid, (<span class="type">void</span> *) UCOW, perm);</span><br><span class="line">    <span class="comment">/* Step 4: 把 va 那个页面内容复制过去 */</span></span><br><span class="line">    <span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (4/6) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) UCOW, (<span class="type">void</span> *) ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line">    <span class="comment">/* Step 5: 用 Step2 的 perm 新建了一个 va 的新映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (5/6) */</span></span><br><span class="line">    syscall_mem_map(envid, (<span class="type">void</span> *) UCOW, envid, (<span class="type">void</span> *) va, perm);</span><br><span class="line">    <span class="comment">/* Step 6: 解除 UCOW 的占用 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (6/6) */</span></span><br><span class="line">    syscall_mem_unmap(envid, (<span class="type">void</span> *) UCOW);</span><br><span class="line">    <span class="comment">// Step 7: 恢复栈帧，彻底退出异常 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">    user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>cow_entry</code> 的实际作用就是建立了一个<strong>受害页面在页表中的新映射</strong>。这个映射只有权限位不同，当再次写入受害 va 所在的页面时，会得到正确的 perm。</li><li>  旧：UCOW 空，va 会触发写时复制（申请物理页面，复制va-&gt; UCOW） 过程中：UCOW va内容，va会触发写时复制 结束：UCOW 空，va不会触发写时复制，指向UCOW 申请得到的那个物理页面</li></ul><p> </p><h2 id="子进程控制块设置-sys-env-set-status-Exercise-4-14"><a href="#子进程控制块设置-sys-env-set-status-Exercise-4-14" class="headerlink" title="子进程控制块设置 - sys_env_set_status - Exercise 4.14"></a>子进程控制块设置 - sys_env_set_status - Exercise 4.14</h2><ul><li>  启动新进程的最后一步：执行完所有的设置后，最后通过这个函数将子进程插入待调度队列，正式启动子进程</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;status&#x27; is valid. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (2/3) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 4: Update &#x27;env_sched_list&#x27; if the &#x27;env_status&#x27; of &#x27;env&#x27; is being changed. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (3/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status == ENV_RUNNABLE) &#123;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: Set the &#x27;env_status&#x27; of &#x27;env&#x27;. */</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Upd-23-5-5"><a href="#Upd-23-5-5" class="headerlink" title="Upd: 23.5.5"></a>Upd: 23.5.5</h3><p>需要在 Step4 中额外留意 <code>status</code> 的变化，如果变为 RUNNABLE 则需要加入至调度队列，如果 NOT_RUNNABLE 则需要<strong>移出</strong>，因为在 Lab3 的 <code>schedule</code> 函数中，我们已经要求所有变化进程状态的函数需要负责维护 <code>env_sched_list</code>，在这里就需要将 NOT_RUNNABLE 的函数移除。感谢芬海哥哥捏，指出了这里的错误 以上，就是创建一个子进程所需要的全部步骤，那么 fork 函数，实际上就是这些函数的结合  </p><h2 id="子进程的创建-fork-Exercise-4-15"><a href="#子进程的创建-fork-Exercise-4-15" class="headerlink" title="子进程的创建 - fork - Exercise 4.15"></a>子进程的创建 - fork - Exercise 4.15</h2><p> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    u_int child;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line">    <span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix it to the</span></span><br><span class="line">    <span class="comment">// correct value.</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line">    <span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">for</span> (i = UTEMP &gt;&gt; <span class="number">12</span>; i * BY2PG &lt; USTACKTOP; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((vpd[i / <span class="number">1024</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;</span><br><span class="line">            duppage(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">     *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment">     *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (2/2) */</span></span><br><span class="line">    syscall_set_tlb_mod_entry(child, cow_entry);</span><br><span class="line">    syscall_set_env_status(child, ENV_RUNNABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在这里唯一需要考虑的点就是 Step3 中 for 循环的起止条件、if 的判断条件</li><li>  i 在这里表示的是<strong>用户态可用虚拟内存的页号</strong>： <code>UTEMP &gt;&gt; 12</code> ，是正式可以被用户态使用的第一个页面，而 <code>USTACKTOP &gt;&gt; 12</code> 则是最后一个</li><li>  if 的判断条件则是：i 对应的虚拟页面是否能在页表中查到有效的映射，如果有，说明它需要考虑是否需要标记 <code>PTE_COW</code>。</li></ul><p> </p><h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>Lab4 到这里可算是结束了，这个 Lab 给人最直观的感受就是码量的上升与内核态/用户态函数的协同更复杂了。这篇文章唠唠叨叨说了这么多，也是想尝试从更深一层去了解 MOS 运作的机理，而不是简单的完成几个填空，知晓表象就弃若敝履罢了。文章实际上没有想做什么分享，算是自我总结吧，因为自己都不知道对不对（笑 还剩两个 Lab，希望能把习惯保持下去  </p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>一些没用上的函数，贴一下</p><h2 id="syscall-all-c"><a href="#syscall-all-c" class="headerlink" title="syscall_all.c"></a>syscall_all.c</h2><h3 id="打印字符至控制台-sys-putchar"><a href="#打印字符至控制台-sys-putchar" class="headerlink" title="打印字符至控制台 - sys_putchar"></a>打印字符至控制台 - sys_putchar</h3><p>直接调用了 <code>printcharc</code> 函数，和 <code>printk</code> 效果类似吧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_putchar</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    printcharc((<span class="type">char</span>)c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="打印用户空间的定长字符串-sys-print-cons"><a href="#打印用户空间的定长字符串-sys-print-cons" class="headerlink" title="打印用户空间的定长字符串 - sys_print_cons"></a>打印用户空间的定长字符串 - sys_print_cons</h3><p>先检查了地址是否位于用户区域，然后检查了长度是不是正的，最后循环调用了 <code>printcharc</code> 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_print_cons</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s, u_int num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (((u_int)s + num) &gt; UTOP  ((u_int)s) &gt;= UTOP  (s &gt; s + num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        printcharc(((<span class="type">char</span> *)s)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="获得运行中进程块的-id-sys-getenvid"><a href="#获得运行中进程块的-id-sys-getenvid" class="headerlink" title="获得运行中进程块的 id - sys_getenvid"></a>获得运行中进程块的 id - sys_getenvid</h3><p>就一句话，但是好像还没有在 MOS 中使用过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="销毁进程-sys-env-destroy"><a href="#销毁进程-sys-env-destroy" class="headerlink" title="销毁进程 - sys_env_destroy"></a>销毁进程 - sys_env_destroy</h3><p>只有直系进程才能进行销毁（自己也行）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">    env_destroy(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="读入字符-sys-cgetc"><a href="#读入字符-sys-cgetc" class="headerlink" title="读入字符 - sys_cgetc"></a>读入字符 - sys_cgetc</h3><p>直接调用了函数 <code>scancharc</code> ，此时会让系统处于忙等状态，直至接收到字符返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-1-Exam</title>
      <link href="/2023/04/os/buaa-os-lab4-1-exam/"/>
      <url>/2023/04/os/buaa-os-lab4-1-exam/</url>
      
        <content type="html"><![CDATA[<p>中途脑梗了好几次，差点寄了，不过好在这次把题留下来了（</p><h1 id="Exam-进程组-ipc-通信"><a href="#Exam-进程组-ipc-通信" class="headerlink" title="Exam - 进程组 ipc 通信"></a>Exam - 进程组 ipc 通信</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><blockquote><p>在 Linux 中，进程理论上所拥有的权限与执行它的用户的权限相同。进程运行时能够访问哪些资源或文件，不取决于进程文件的属主属组，而是取决于<strong>运行该命令的用户身份的 uid/gid</strong>，以该身份获取各种系统资源。</p></blockquote><p>所以我们需要完成同一个进程组ID的不同进程的通信。具体而言，需要做到：</p><ol><li> 在 Env 结构体中添加 <code>u_int env_gid</code> 字段代表进程所在的进程组，初始值为 0。</li><li> 实现一个修改 <code>gid</code> 字段的<strong>用户态函数</strong>：<code>void set_gid(u_int gid);</code></li><li> 实现一个<strong>仅能</strong>向同组块发送消息的<strong>用户态函数</strong>：<code>int ipc_group_send(u_int whom, u_int val, const void *srcva, u_int perm);</code></li><li> 实现 2、3 两点中对应的<strong>系统调用函数</strong>和调用接口</li></ol><p>教程组已经把两个用户态函数实现了，我们只需要考虑系统调用函数 <code>syscall_set_gid</code> 和 <code>syscall_ipc_try_group</code> 即可</p><h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><ol><li>在内核中为每个进程维护<strong>进程组ID</strong>，并保证每个进程<strong>创建时的的组ID为0</strong>。</li><li>在 <code>user/include/lib.h</code> 中：<ul><li>  添加以下两个用户函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure><ul><li>  添加以下两个系统调用函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure></li><li>在 <code>include/error.h</code> 中，增加以下新错误码 <code>E_IPC_NOT_GROUP</code> ，表示组间通信时通信双方进程的组ID不匹配。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E_IPC_NOT_GROUP 14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>两个用户态函数的<strong>实现已经给出（请参看实验提供代码部分），你需要将其复制到 <code>user/lib/ipc.c</code> *_，具体代码的解释在*_提示</strong>部分给出。</li><li>在 <code>include/syscall.h</code> 中：定义两个新的系统调用号。请注意新增系统调用号的位置，应当位于 <code>MAX_SYSNO</code> 之前。</li><li>在 <code>user/lib/syscall_lib.c</code> 中：实现上述两个系统调用函数，发起系统调用。</li><li>在 <code>kern/syscall_all.c</code> 中：添加两个系统调用在内核中的实现函数。请保证两个函数的定义位于系统调用函数表 <code>void *syscall_table[MAX_SYSNO]</code> 之前。</li><li>在 <code>kern/syscall_all.c</code> 中的 <code>void *syscall_table[MAX_SYSNO]</code> 系统调用函数表中，为你定义的系统调用号添加对应的内核函数指针。</li><li>编写 <code>syscall_ipc_try_group_send</code> 系统调用<strong>在内核中的实现函数</strong>时，判断 <code>-E_IPC_NOT_RECV</code> 错误的<strong>优先级</strong>高于 <code>-E_IPC_NOT_GROUP</code></li></ol><h2 id="实验提供代码"><a href="#实验提供代码" class="headerlink" title="实验提供代码"></a>实验提供代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy to user/lib/ipc.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span> &#123;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_set_gid 系统调用</span></span><br><span class="line">    syscall_set_gid(gid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_ipc_try_group_send 系统调用</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_group_send(whom, val, srcva, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受方进程尚未准备好接受消息，进程切换，后续继续轮询尝试发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_RECV) syscall_yield();</span><br><span class="line">        <span class="comment">// 接收方进程准备好接收消息，但非同组通信，消息发送失败，停止轮询，返回错误码 -E_IPC_NOT_GROUP</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_GROUP) <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数返回0，告知用户成功发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>课上写了半天总是说函数名找不到，仔细一看写了一半的 <code>group_send</code>，写了一半的 <code>send_group</code>，难绷</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">                           u_int perm)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != envid2env(whom, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_gid != curenv-&gt;env_gid) &#123; <span class="comment">// 唯一与 ipc_send 不同的地方就在这了</span></span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e-&gt;env_ipc_value = val;</span><br><span class="line">  e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">  e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">  e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">    p = page_lookup(curenv-&gt;env_pgdir, (u_int)srcva, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_set_gid</span><span class="params">(u_int gid)</span> &#123; <span class="comment">// 简单赋值</span></span><br><span class="line">  curenv-&gt;env_gid = gid;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题目给的思路顺下来其实很容易就能写完，顺便也可以用这个题回顾一下系统调用：怎样添加一个新的、可用的系统调用？</p><ul><li>  首先从内核态出发，编写一个能够完成功能的函数，看一下它都需要什么参数 - <code>kern/syscall_all.c</code></li><li>  然后在 <code>void *syscall_table[MAX_SYSNO]</code> 把函数添加进去，使得 <code>do_syscall</code> 函数能跳到这个新函数里：这需要随便写一个字符串当成<strong>系统调用号</strong>，无所谓了 - <code>kern/syscall_all.c</code></li><li>  找到刚才那个系统调用号的枚举类，把定义加上 - <code>include/syscall.h</code></li><li>  <code>do_syscall</code> 不需要变化，然后再上一层是 <code>msyscall</code>，它需要一个 <code>syscall_</code> 开头的函数进行调用。到这里我们就完成了内核态中所需要做的所有改动</li><li>  回到用户态，编写一个用户态的 <code>syscall_new</code> 函数调用 <code>msyscall</code>，同时需要注意参数的第一个参数需要是刚才加进去的调用号 - <code>users/lib/syscall_lib.c</code></li><li>  最后编写顶层的用户态函数，其中调用 <code>syscall_new</code> 函数，用户态工作也就完成了 - <code>users/某个文件</code></li><li>  最最后别忘了<strong>加上函数声明</strong>：内核态不需要，用户态加在 <code>users/include/lib.h</code> 即可</li></ul><h1 id="Extra-家族-ipc-广播"><a href="#Extra-家族-ipc-广播" class="headerlink" title="Extra - 家族 ipc 广播"></a>Extra - 家族 ipc 广播</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>课下我们在 MOS 系统中实现了进程间通信。</p><p>现在你需要仿照 <code>ipc_send</code> 函数在 <code>user/lib/ipc.c</code> 中实现 <code>ipc_broadcast</code> 函数，使得调用 <code>ipc_broadcast</code> 可以使当前进程向其后代进程（也即当前广播进程的子进程、子进程的子进程、子进程的子进程的子进程…以此类推）发起广播消息，当后代进程进入 recv 后进行发送。</p><h3 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h3><p><strong><code>ipc_broadcast</code></strong></p><p>需要在 <code>user/lib/ipc.c</code> 新增：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> * srcva, u_int perm)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>  <code>val</code> ：进程广播传递的具体数值, 与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>srcva</code> ：进程广播发送页的对应用户虚地址，与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>perm</code> : 传递的页面的权限位设置，与 <code>ipc_send</code> 函数中的定义相同。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>  你可以实现 <code>syscall_ipc_try_broadcast</code> 系统调用，使其行为类似于 <code>syscall_ipc_try_send</code>，但尝试发送给当前进程的所有后代进程。</li><li>  你也可以尝试在用户空间利用 <code>envs</code> 实现相关行为。</li><li>  发送广播消息时，你可以先等待所有后代进程进入接受状态，再统一进行实际传输，也可以依次等待每个后代进程，一旦其处于接受状态，当即对其进行实际传输。</li></ul><p>也就是说可以在用户态使用这些已有的调用函数完成目标，也可以像 Exam 中添加一种新的系统调用处理这种请求。</p><p>如果注意到原来提供的 <code>ipc_send</code> 函数能使用 bfs 操作进程块数组，那实际上难度就会降低很多。无所谓，我没看出来</p><h2 id="两种可行的做法"><a href="#两种可行的做法" class="headerlink" title="两种可行的做法"></a>两种可行的做法</h2><h3 id="新建系统调用-sys-ipc-broadcast"><a href="#新建系统调用-sys-ipc-broadcast" class="headerlink" title="新建系统调用 - sys_ipc_broadcast"></a>新建系统调用 - <code>sys_ipc_broadcast</code></h3><p>类似在刚才 Exam 中提到的思路，加一个新的系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">  u_int childs[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    childs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// printk(&quot;childs ready!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step1: 找到直系的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_parent_id == curenv-&gt;env_id) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childs[j] == <span class="number">0</span>) &#123;</span><br><span class="line">          childs[j] = envs[i].env_id;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step2: 通过 bfs 找到所有子进程的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NENV; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envs[j].env_parent_id == childs[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == envs[j].env_id) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            childs[k] = envs[j].env_id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step3: 对所有待发送的进程进行发送 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// printk(&quot;%d: %x\n&quot;, i, childs[i]);</span></span><br><span class="line">      sys_ipc_try_send(childs[i], val, srcva, perm);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户态通过已有函数处理"><a href="#用户态通过已有函数处理" class="headerlink" title="用户态通过已有函数处理"></a>用户态通过已有函数处理</h3><p>因为代码不是我的，所以我就不贴了，说一说思路吧</p><p>首先和第一种做法一样，需要用循环和队列 bfs 出所有满足条件的进程 <code>env_id</code>，最后实际上可以直接用 <code>ipc_send</code> 解决，太快了。</p><h2 id="一点废话"><a href="#一点废话" class="headerlink" title="一点废话"></a>一点废话</h2><p>其实一开始读这个题我理解成调用 <code>env_alloc</code> 函数来创建进程了，然后就在 Env 里面加了一个数组字段保存自己的孩子，同时在 <code>env_alloc</code> 里通过 <code>env_parent_id</code> 更新<strong>所有</strong>祖宗进程的字段，最后在系统调用进行 send 的时候直接查一下自己的字段就能跑了</p><p>结果这个题它创建进程最后用的是宏 <code>ENV_CREATE_PRIORITY</code>，也就是调用了 <code>env_create</code> 函数。甚至 <code>parent_id</code> 是下面这么加进去的！看起来两个函数好像没啥差别，但是 <code>env_create</code> 函数只能产生 <code>parent_id = 0</code> 的新进程，我这一套直接寄了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa1</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa2</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa3</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa4</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">ppa2-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa3-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa4-&gt;env_parent_id = ppa3-&gt;env_id;</span><br></pre></td></tr></table></figure><p>幸亏看了一眼测试代码，要不寄大发了。不过反正写完这一版才发现写的不对，实际上已经寄了。</p><p>不然我觉得我那个做法将能算得上是绝杀（可能吧）</p><p>总之 lab4 这样就算结束一半了，之后再看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Exam</title>
      <link href="/2023/04/os/buaa-os-lab3-exam/"/>
      <url>/2023/04/os/buaa-os-lab3-exam/</url>
      
        <content type="html"><![CDATA[<p>这次比较尴尬，做完了忘记保存题目了，结果复盘的时候全程想不起来题目写的是啥</p><h1 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>我们提出了一种基于多个用户而平均分配的时间片轮转调度算法。对于每个进程来说，它的拥有者（用户，用 0 \sim 4 的数字表示）用一个新增字段 <code>u_int env_user</code>表示。我们要改进的这个调度算法，每次都会运行<strong>已经使用过的时间片最少的</strong>用户的进程（相同时<strong>取 id 小者</strong>），进程按在<code>env_sched_list</code> 中的顺序取出，每次运行该用户的第一个进程。</p><p>为了记录每个用户已经使用的时间片，我们设置了一个全局数组 <code>static int user_time[]</code>，当每次进程时间片耗尽时，对数组进行更新（对应用户加 pri即可）。例如对于如下的三个用户和三个进程，应该有这样的调度顺序（没保存所以只能上手绘图力！）</p><p>假装有图.jpg</p><p>请你按照这样的提示修改 <code>schedule</code> 函数，使其能满足刚才解释的按用户使用分配的时间片轮转算法。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (需要更换 e 的条件) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e 不为 <span class="literal">NULL</span> &amp;&amp; e 处在 ENV_RUNNABLE 状态) &#123;</span><br><span class="line">      移动 e 进程块</span><br><span class="line">      修改 user_time 数组（加对应的 env_pri 即可）</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (无调度进程块) &#123;</span><br><span class="line">      panic</span><br><span class="line">    &#125;</span><br><span class="line">遍历调度列表，查询列表中有哪些用户的进程块</span><br><span class="line"></span><br><span class="line">遍历每个有进程块的用户，哪个用户用过的时间片最少（user_time 最小）</span><br><span class="line"></span><br><span class="line">遍历调度列表，取出第一个该用户的进程块，e = env，count = env_pri</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  count--</span><br><span class="line">  env_run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  教程组给出的伪代码大致如上，可惜这次没有把题目记下来，只能靠记忆来了</li><li>  给的解释实际上已经足够清晰了，只需要按着步骤走就行。</li></ul><p>要注意<strong>额外声明变量时要考虑初始化</strong>的问题，有同学没初始化导致数组内的值反复横跳，根本没法debug（</p><h2 id="一种可行的解答"><a href="#一种可行的解答" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>贴一下我的做法，比较水，仅供参考</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> able[<span class="number">5</span>];   <span class="comment">// 额外声明了一个数组，当列表中存在该用户进程块时就置 1 ，否则保持 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 数组初始化</span></span><br><span class="line">    able[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">      TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">      <span class="comment">// 记得 + env_pri，有笨比上来直接丢了这一句，根本调度不起来</span></span><br><span class="line">      user_time[e-&gt;env_user] += e-&gt;env_pri;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">      panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">    count = e-&gt;env_pri;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">en</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用了 TAILQ_FOREACH 宏进行循环包装，循环查询有哪个用户在队列里，更新 able 数组</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (able[en-&gt;env_user] == <span class="number">0</span>) &#123;</span><br><span class="line">        able[en-&gt;env_user] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查看哪个用户使用的时间片最少（user_time 最小）</span></span><br><span class="line">    <span class="type">int</span> user = <span class="number">-1</span>;</span><br><span class="line">    u_int times = <span class="number">111111111</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (user_time[j] &lt; times &amp;&amp; able[j] == <span class="number">1</span>) &#123;</span><br><span class="line">        user = j;</span><br><span class="line">        times = user_time[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再循环调度链表，取出第一个目标用户的进程块，准备调度</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (en-&gt;env_user == user) &#123;</span><br><span class="line">        e = en;               <span class="comment">// 更换调度块</span></span><br><span class="line">        count = e-&gt;env_pri;   <span class="comment">// 重置时间片 count</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">  env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>在 Lab3/4 中，我们已经处理了若干种异常，但在 CO 学习中经常出现的一种异常我们还没有处理，就是<strong>数值溢出</strong>（Ov）。在 R3000 中，硬件已经把溢出设置为 <strong>12 号异常</strong>，也就是说，只要设置对应的 <strong>handle 函数</strong>、<strong>异常向量</strong>与<strong>异常处理函数</strong>，我们就能顺利响应这个异常了。 Extra 的任务，就是响应 addi、add、sub 这三类指令可能产生的<strong>溢出异常</strong>。</p><p>这三类溢出的处理规则如下：</p><ul><li>  <code>add</code>：将指令修改为 <code>addu</code>，直接返回原 EPC</li><li>  <code>sub</code>：将指令修改为 <code>subu</code>，直接返回原 EPC</li><li>  <code>addi</code>：令 RF[rt]=RF[rs]/2+imm/2 ，返回至 EPC + 4 继续执行</li></ul><p>下面还有很多提示，能想起来的就直接放下一部分了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>  首先需要明确我们需要做的有三件事：</li><li>  注册 handle 函数</li><li>  更新异常向量组，使其支持跳转至 Ov 的异常处理函数</li><li>  编写异常处理函数逻辑</li></ul><p>前两步很简单，只要仿照对应文件中其他异常的处理方式来就可以了</p><h3 id="注册-handle-函数"><a href="#注册-handle-函数" class="headerlink" title="注册 handle 函数"></a>注册 handle 函数</h3><ul><li>  在 <code>kern/genex.S</code> 中，增加处理 Ov 的 <code>handle_ov</code> ，可以命名其异常处理函数名为 <code>do_ov</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILD_HANDLER ov do_ov</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新异常向量组"><a href="#更新异常向量组" class="headerlink" title="更新异常向量组"></a>更新异常向量组</h3><ul><li>  开始没看见直接写了溢出是12号异常，我直接当场下载 See Mips Run Linux 开始查（）</li><li>  在 <code>kern/traps.c</code> 中，更新异常向量：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line">    [<span class="number">12</span>] = handle_ov,        <span class="comment">// 支持 handle_ov 以处理 ov</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异常处理函数-do-ov"><a href="#异常处理函数-do-ov" class="headerlink" title="异常处理函数 do_ov"></a>异常处理函数 <code>do_ov</code></h3><ul><li>  这个函数的核心就是<strong>分析 EPC</strong> 这条指令的内容并加以修改。</li></ul><p>但由于一些我忘了的原因（有笨比），我们不能在内核态中直接通过用户态的虚拟地址获得地址上的值，所以如何访存就又成了一个问题。</p><p>题目提示：可以从 EPC 的 va 出发，找到它所对应的 pa，再将 pa 转换为 kseg0 区域的 va ，这样就能不通过页表之类的操作直接访问到了。所以大致的处理思路如下：</p><p>EPC(va)\to pa\to va(kseg0)\to *va(code)</p><p>许多同学在第一步转化物理地址时使用了宏 <code>va2pa</code> ，但是这玩意它只能找到 pa 所在页框的<strong>基地址</strong>，<strong>页内偏移它没有！</strong>然后好多人就绷了（）</p><p>还好我根本没想起来有这么个宏，还好我机智地使用了 <code>page_lookup</code> 老老实实地从<strong>页控制块</strong>出发找物理地址，这样就很轻松地记住了要加偏移，要不然直接用了 <code>page2pa(p)</code>，看过去就显然没有页内偏移（）</p><p>然后就很轻松地得到了目标指令。</p><ul><li>  随后要分析指令类型进行异常处理</li></ul><p><code>add</code> 和 <code>sub</code> 两个指令修改太简单了，直接给指令值+1就能用了，在 <code>addi</code> 中要稍微多想一点。</p><p><code>addi</code> 需要更新寄存器的值，同时也需要更新 EPC，这时就要从传入的用户栈中修改信息。修改过程中需要注意从指令里取出寄存器号之后要<strong>移动到最低位</strong>才能使用，有人 <code>addi</code> 了半天 0 号寄存器，才发现原来寄存器号还在高位呆着（）</p><p>最最后，调用一下 <code>printk</code>，异常统计变量自增，结束力！</p><h2 id="一种可行的解答-1"><a href="#一种可行的解答-1" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>直接上代码了，依然是一坨不可名状的东西</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_ov</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">  <span class="comment">// printk(&quot;Got an ov\n&quot;);</span></span><br><span class="line">  u_int badva = tf-&gt;cp0_epc;</span><br><span class="line">  Pde *pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">  Pte **ppte = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page_lookup(pgdir, badva, ppte);</span><br><span class="line">  <span class="comment">// pgdir_walk(pgdir, badva, 0, &amp;p);</span></span><br><span class="line">  u_int badpa = page2pa(p) + (badva &amp; <span class="number">0xfff</span>);</span><br><span class="line">  u_int *badk0va = <span class="number">0x80000000</span>  badpa;</span><br><span class="line">  u_int code = *badk0va;</span><br><span class="line">  <span class="comment">// printk(&quot;got code %x\n&quot;, code);</span></span><br><span class="line">  <span class="keyword">if</span> (code &amp; <span class="number">0x20000000</span>) &#123; <span class="comment">// addi</span></span><br><span class="line">    u_int s = (code &amp; <span class="number">0x3e00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    u_int t = (code &amp; <span class="number">0x1f0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    u_int svalue = tf-&gt;regs[s];</span><br><span class="line">    u_int imm = code &amp; <span class="number">0xffff</span>;</span><br><span class="line">    tf-&gt;regs[t] = svalue / <span class="number">2</span> + imm / <span class="number">2</span>;</span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// printk(&quot;inform:%x %d %d %x %x\n&quot;, code, s, t, svalue, tf-&gt;regs[t]);</span></span><br><span class="line">    printk(<span class="string">&quot;addi ov handled\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((code &amp; <span class="number">0x1f</span>) == <span class="number">0</span>) &#123; <span class="comment">// add</span></span><br><span class="line">    printk(<span class="string">&quot;add ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// sub</span></span><br><span class="line">    printk(<span class="string">&quot;sub ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  curenv-&gt;env_ov_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="debug-思路"><a href="#debug-思路" class="headerlink" title="debug 思路"></a>debug 思路</h2><p>在第一次写完之后，测试很华丽地给我返回了错误值：<code>$v0 = 0xffffffff</code>（-1），这是测试程序提示处理有误的返回值。想要de出来bug在哪出现的，自然需要回到那个返回错误值的地方看一眼。所以我就在函数里打了几个 <code>printk</code>，现在还在注释里（）。 同时把三个会 <code>return -1</code> 的地方修改成了返回<strong>不同的值</strong>，然后看看到底是哪里寄了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tests/lab3_ov/test_ov.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> src1, src2, dst;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 add, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 + src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果异常处理结果不正确进程将运行结束并返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 sub, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 - src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// change the return value to figure the error place</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 addi, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 / <span class="number">2</span> + <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// change too</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一看，哈哈 <code>return -3</code> ，<code>addi</code> 我来辣（×）</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-Report</title>
      <link href="/2023/04/os/buaa-os-report-lab4/"/>
      <url>/2023/04/os/buaa-os-report-lab4/</url>
      
        <content type="html"><![CDATA[<p> </p><h1 id="BUAA-OS-2023-Lab4-Report"><a href="#BUAA-OS-2023-Lab4-Report" class="headerlink" title="BUAA-OS-2023-Lab4-Report"></a>BUAA-OS-2023-Lab4-Report</h1><h1 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h1><ul><li>  思考并回答下面的问题：</li><li>  内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>  系统陷入内核调用后可以直接从当时的$a0-$a3 参数寄存器中得到用户调用msyscall留下的信息吗？</li><li>  我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？</li><li>  内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul><ol><li> 在系统发生异常时跳入异常分发程序时，会先调用 <code>SAVE_ALL</code> 宏定义，把所有寄存器（用户态现场）保存在内核栈 KSTACKTOP 下。最后将 sp寄存器指向保存的这个栈帧。这样既能保护用户态时通用寄存器的值不被改变，同样也能在内核态中便捷地调用每个寄存器的值</li><li> 可以直接调用。系统调用 <code>msyscall</code> 时只通过 <code>SAVE_ALL</code>将寄存器的值复制到了内核栈中，但对寄存器中的值没有做任何处理，仍然保持着用户态进入时的状态。所以这时参数寄存器内数值仍然可用。</li><li> 在 <code>do_syscall</code> 函数中，我们通过系统调用向量 <code>syscall_table</code> 选择系统调用函数后，在函数内调用了 <code>func(arg1, arg2, arg3, arg4, arg5);</code> ，此处的 <code>arg</code>都来源于用户态中保存的参数寄存器和栈帧内。所以相当于调用了相同参数的函数。</li><li>系统调用过程中：<ul><li>  <code>tf-&gt;regs[2] = func(arg1, arg2, arg3, arg4, arg5);</code> 更改了 v0 寄存器以保存系统调用执行后的返回值；</li><li>  <code>tf-&gt;cp0_epc += 4;</code> 更改了 cp0_epc 寄存器以使得返回用户态的执行语句变为执行系统调用的后一条指令</li></ul></li></ol><h1 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h1><ul><li>  思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</li></ul><p>在产生 <code>env_id</code> 的函数 <code>mkenvid</code> 中，id 的低10位会保留为该 env 块在 envs 中的序号，高位是一个按序增大的数。当再次申请一个曾经被调度过的 env 块时，<strong>两次获取的 <code>env_id</code> 低10位相同，高位不同</strong>。 我们在 <code>envid2env</code> 中直接用 <code>e = &amp;envs[ENVX(envid)];</code> 选取了 env 块，实际上此时只能保证取出的块与 id 的低10位一定相同，没有对10位以上进行检验。为了避免出现高位不同而无效的 <code>env_id</code> ，我们需要再判断一次 <code>e-&gt;env_id != envid</code> 。 如果没有这步判断，可能会导致<strong>之前申请这个 env 产生的</strong> <code>env_id</code> 再次获取到这个 env 块。（然而实际上旧 id 已经失效了）</p><h1 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h1><ul><li>  思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释</li></ul><p>首先在 <code>envid2env</code> 函数中，为了进程能够便利地获得自身进程的 <code>env</code> ，我们规定了当输入 ID = 0 时，会返回当前进程的控制块。如果 <code>mkenvid</code> 函数产生了一个 ID = 0 的进程块，那么这个功能将无法判断当前是在查询 <code>ID = 0</code> 的进程块，还是在查询当前进程的进程块了 在 <code>sys_ipc_send</code> 中更新接收者信息时也会发生这样的状况，若发送者 <code>env_id</code> 为 0，那么接收者将混淆发送者，有可能会是自己发给自己的（）</p><h1 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h1><ul><li>  关于fork 函数的两个返回值，下面说法正确的是： A、fork 在父进程中被调用两次，产生两个返回值 B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回</li></ul><p>选 C 。 <code>fork</code> 函数在父进程想要创建子进程时被执行，在执行过程中创建了一个新的进程。同时子进程会返回 0 ，父进程将会返回子进程的 id，方便父进程进行规划。</p><h1 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h1><ul><li>  我们并不应该对所有的用户空间页都使用duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合kern/env.c 中env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考</li></ul><p><code>UTEXT</code> 之下的无效内存、<code>USTACKTOP</code> 之上的空白区与用户异常栈都不需要进行页面映射。在进入 <code>duppage</code> 函数内，只读页面与共享同写页面都不需要进行映射。除此之外，用户区的其他页面都需要进行映射。</p><h1 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h1><ul><li>  在遍历地址空间存取页表项时你需要使用到vpd 和vpt 这两个指针，请参考user/include/lib.h 中的相关定义，思考并回答这几个问题：</li><li>  vpt 和vpd 的作用是什么？怎样使用它们？</li><li>  从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>  它们是如何体现自映射设计的？</li><li>  进程能够通过这种方式来修改自己的页表项吗？</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure><p>  <code>vpt</code> 指向了用户进程自身的<strong>用户页表基址</strong>； <code>vpd</code> 指向了用户进程的<strong>用户页目录基址</strong>。<code>vpd</code> 可以视作用户的 <code>cur_pgdir</code>，<code>vpt</code>则可以看作 <code>cur_pgdir[0]</code> 这是两个系统定义的便于读取用户态页表的宏，它们指向了位于 kuseg 中的页表虚拟地址。程序允许访问 kuseg 中的虚拟地址，从过 vpt 和 vpd ，用户就能获取自身的页表。 UVPT 本身就是用户页表的基地址，vpt 自然是页表基址。<code>(PDX(UVPT) &lt;&lt; PGSHIFT))</code> 指向了用户页表所在的页目录项，这里的取法来自页表的自映射。 进程页表在这种情况下应当只允许读取，不允许这样修改，否则可能会出现错误的访问。</p><h1 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h1><ul><li>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：<ul><li>  这里实现了一个支持类似于“<strong>异常重入</strong>”的机制，而在什么时候会出现这种“异常重 入”？</li><li>  内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></li></ul><p>当处理 <code>tlb_mod</code> 时，可能会发生<strong>用户异常处理函数出错</strong>导致的异常，这时需要重入处理；同时由于没有关闭中断，所以若再次发生外部中断（时钟中断），也会触发异常的重入 如果在这里不保存 Trapframe 的话，do_tlb_mod 函数会跳转至用户设置的异常处理函数 <code>env_user_tlb_mod_entry</code> 中，但当该函数执行结束后，将无法恢复 EPC，所以需要先保存用户现场再返回  </p><h1 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h1><ul><li>  在用户态处理页写入异常，相比于在内核态处理有什么优势？</li></ul><p>在用户态处理，相较于内核态处理最明显的区别就在于其省去了跳转进入内核态的繁琐操作，为频繁的跳转省去了大量时间。 其次在用户态处理，给用户自定义页写入异常处理函数的入口，使得操作系统的处理更多样性、更灵活。  </p><h1 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h1><p>请思考并回答以下几个问题：</p><ul><li>  为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li><li>  如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul><h2 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd:23.5.4"></a>Upd:23.5.4</h2><p>前两年的这个题好像放的是缺页中断的处理函数？我们这里变成了设置页写入异常的处理函数。如果在 syscall_exofork 中，写入了某个曾经被标记为 TLB_COW 的页面，此时的 tlb_Mod 将无法处理。虽然我觉得这种情况应该不会发生？确实不太明白 其实我觉得如果我们的 syscall_exofork 不是一个内联函数的话，这里就有点意义了，可以防止 syscall_exofork 的栈帧被父进程覆盖，导致子进程无法返回（但是做法也不对，应该把duppage也移动过来，实际上更寄） 如果放在写时复制机制完成后设置，一旦在这两步操作中出现了进程的 TLB_Mod，进程就会因为无法处理异常而 panic 对于第二问，如果先执行完写时复制机制，这时的所有原本可写 &amp; 非共享的用户页都成为写时复制页，这就导致了 USTACKTOP 这一页也变成了写时复制页，在此之后的任意一个会创建栈帧的函数都不能执行了，因为这样会写入用户栈，并进入 TLB_Mod，此时又会因为没有设置 handler 导致 panic 可能是因为，如果先fork的话，还需要给子进程设置一下cow_entry；但如果先给父进程设置entry的话，生成子进程的exofork过程中调用了env_alloc，会自动复制父进程的cow_entry，就省去了额外在子进程中设置entry的步骤，写时复制机制可以直接运行（大概） 因为在 fork 函数中调用的 duppage 函数中也会发生页写入异常。如果不设置 mod_entry 就先进行 fork，会导致无法响应页写入异常。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在 Lab4 中，我们学习了：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><p>主要实现了用户进程的创建，完善了不同进程间内存空间的处理机制。完成进程创建，尤其是进程内存的使用后， Lab5 中，基于进程的文件系统才能更好实现。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab3</title>
      <link href="/2023/04/os/buaa-os-probe-lab3/"/>
      <url>/2023/04/os/buaa-os-probe-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab3-进程与异常"><a href="#Lab3-进程与异常" class="headerlink" title="Lab3 - 进程与异常"></a>Lab3 - 进程与异常</h1><p>Lab3 中主要涉及到以下内容：</p><ul><li>  进程的创建</li><li>  时钟中断与内核态</li><li>  进程调度与进程切换</li><li>  <strong>数据进程控制块</strong> <code>Env</code></li></ul><h1 id="进程控制块与初始化"><a href="#进程控制块与初始化" class="headerlink" title="进程控制块与初始化"></a>进程控制块与初始化</h1><ul><li>  由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。</li><li>  进程是一个活动中的实体，拥有自己的虚拟地址空间。</li><li>  程序是非活动的实体，<strong>执行中</strong>的程序就是<strong>进程</strong></li></ul><h2 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 - PCB"></a>进程控制块 - PCB</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// 保存上下文环境，定义于 trap.h 中</span></span><br><span class="line">    LIST_ENTRY(Env) env_link;<span class="comment">// 构建空闲进程链表 env_free_link</span></span><br><span class="line">    u_int env_id;<span class="comment">// 进程标识符</span></span><br><span class="line">    u_int env_parent_id;<span class="comment">// 父进程的进程 id</span></span><br><span class="line">    u_int env_status;<span class="comment">// 进程块状态位</span></span><br><span class="line">    Pde *env_pgdir;<span class="comment">// 进程页目录的虚拟地址</span></span><br><span class="line">    TAILQ_ENTRY(Env) env_sched_link;<span class="comment">// 构造调度队列 env_sched_list</span></span><br><span class="line">    u_int env_pri;<span class="comment">// 进程优先级，与后续时间片调度进程相关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>env_status</code>：<ul><li>  <code>ENV_FREE</code>：进程控制块处于空闲链表中，值为0</li><li>  <code>ENV_NOT_RUNNABLE</code>：<strong>阻塞态</strong>，可转变为就绪状态，值为1</li><li>  <code>ENV_RUNNABLE</code>：就绪、执行状态（等待调度/运行中），值为2</li></ul></li><li>  在 MOS 中，进程控制块的<strong>物理地址</strong>已经被分配好了（<code>envs</code>数组）</li></ul><p>这里的初始化使用了__attribute__函数，做完再看 其中的结构体 <code>TrapFrame</code> 在 Lab4 中作用比较大，但在 Lab3 中没有必要过于关注，结构就不再过多介绍了 Env 块中存在两个链表（<code>env_free_list</code>和<code>env_sched_list</code>），<code>TAILQ</code> 结构在 Lab2 的 Probe 中已经提过了，该结构为双向的有尾列表，支持在头尾进行元素增删操作。</p><h2 id="跨页地址映射-map-segment-Exercise-3-2"><a href="#跨页地址映射-map-segment-Exercise-3-2" class="headerlink" title="跨页地址映射 - map_segment - Exercise 3.2"></a>跨页地址映射 - <code>map_segment</code> - Exercise 3.2</h2><ul><li>  函数作用如下：物理地址映射到指定进程的虚拟地址中（更大的 <code>page_insert</code>）</li><li>将物理地址 pa <strong>按页映射</strong>到指定进程页表中（va）<ul><li>  映射大小 size 必须是<strong>页面大小的整数倍</strong></li></ul></li><li>  设置用到的页表项权限位为 perm</li></ul><p>这个函数在上面的 <code>env_init()</code>中使用过，其将内核中 pages 与 envs 所在的物理地址映射到内核页表中，我们可以根据下面这个实例补充代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), </span><br><span class="line">BY2PG), PTE_G);</span><br></pre></td></tr></table></figure><p>代码中注释已经给好方向，使用<code>page_insert()</code>，将 <code>[va, va+size)</code> 所涉及到的每个页面都映射到 pa 开始的页面中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 将 pa 地址内容映射到指定页目录中的虚拟地址 va</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">map_segment</span><span class="params">(Pde *pgdir, u_int asid, u_long pa, u_long va,</span></span><br><span class="line"><span class="params">                        u_int size, u_int perm)</span> &#123;</span><br><span class="line">  <span class="comment">/* 预先确保地址对齐 */</span></span><br><span class="line">  assert(pa % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(va % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(size % BY2PG == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 循环对应的每一页形成映射 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123; </span><br><span class="line">    <span class="comment">/*  使用 pa2page 获取物理地址 pa 对应的页控制块</span></span><br><span class="line"><span class="comment">     * va + i 表示每个虚拟页的基地址，pa + i 表示页框基地址</span></span><br><span class="line"><span class="comment">     * 使用 page_insert 形成新映射，**权限**设置为 perm</span></span><br><span class="line"><span class="comment">     * Exercise 3.2: Your code here. */</span></span><br><span class="line">    page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程块队列初始化-env-init-Exercise-3-1"><a href="#进程块队列初始化-env-init-Exercise-3-1" class="headerlink" title="进程块队列初始化 - env_init - Exercise 3.1"></a>进程块队列初始化 - <code>env_init</code> - Exercise 3.1</h2><ul><li>  函数功能：初始化 envs 链表</li><li>  完成 <strong>Env 控制块</strong>的空闲队列、调度队列的<strong>初始化功能</strong></li><li>  空闲队列需要<strong>倒序插入</strong>，用来优先分配小序号的进程控制块 Env</li><li>  临时存放 内核结构 ‘pages’ 与 ‘envs’ ，为后续映射做准备（详见 Exercise 3.3）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">/* Step 1: 初始化 `env_free_list` 与 `env_sched_list` 两个调度队列 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (1/2) */</span></span><br><span class="line">  LIST_INIT(&amp;env_free_list);</span><br><span class="line">  TAILQ_INIT(&amp;env_sched_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 将所有进程控制块插入空闲队列中，注意需要 **倒序** 插入 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (2/2) */</span></span><br><span class="line">  <span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;env_free_list, &amp;envs[i], env_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将内核结构 &#x27;pages&#x27; 与 &#x27;envs&#x27; 映射到每个用户空间的虚拟地址（UPAGES </span></span><br><span class="line"><span class="comment">   * 和 UENVS）中，并要求只读，这里先暂时把两个内容存在一个临时页目录 &#x27;base_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   * 中，并建立映射，直至 `env_setup_vm&#x27; 中再将其拷贝进用户页目录 &#x27;env_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  panic_on(page_alloc(&amp;p));</span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">  base_pgdir = (Pde *)page2kva(p);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES,</span><br><span class="line">              ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG), PTE_G);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS,</span><br><span class="line">              ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG), PTE_G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现较简单，注意要区分 Env 结构体中存在的链表，env_free_list 链表需要使用 env_link 连接，使用LIST类宏操作；而 env_sched_list 需要使用 env_sched_link 连接，使用 TAILQ 类宏操作</p><h2 id="env-id-与进程表示"><a href="#env-id-与进程表示" class="headerlink" title="env_id 与进程表示"></a>env_id 与进程表示</h2><p>在进程管理块 Env 中，有三个与 <code>id</code> 相关的字段，它们从不同的方式代表进程</p><ul><li>  <code>env_id</code> ：（进程标识符，unique environment identifier）MOS 操作系统中使用 <code>env_id</code> <strong>唯一地</strong>表示不同进程，在创建进程时被 <code>mkenvid</code> 函数赋值</li><li><code>env_asid</code> ：（地址空间标识符，Address-Space IDentifier）ASID也可以<strong>唯一地</strong>标记进程，同时为进程提供相应的<strong>地址保护</strong><ul><li>  在 MOS 实验系统中使用 &lt;VirtualPageNumber, ASID&gt; 作为索引在 TLB 中查询映射</li><li>  在 MOS 中，使用了<strong>位图法</strong>管理了64个 ASID ，具体位于 asid_alloc 函数中</li></ul></li><li>  <code>env_parentid</code> ：（env_id of this env’s parent）顾名思义是创建本进程的父进程的 <code>env_id</code></li></ul><p>对于<code>id</code>与<code>asid</code>：<code>id</code>指的是控制块和线程自己的属性；<code>asid</code>则在 TLB 、地址管理上用的比较多 <code>env_id</code> 的值从同文件中的 <code>mkenvid()</code> 函数中得来，asid由同文件中的 <code>asid_alloc()</code> 得到</p><h2 id="Linux-中的-ASID-分代机制-（有空再补）"><a href="#Linux-中的-ASID-分代机制-（有空再补）" class="headerlink" title="Linux 中的 ASID 分代机制 （有空再补）"></a>Linux 中的 ASID 分代机制 （有空再补）</h2><p>   </p><h1 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h1><p>程序想要成为进程，必须要把对应的的 ELF 文件（此处为<strong>可执行文件</strong>）中所有需要加载的 <strong>程序段(Segment)</strong> 分配进虚拟内存空间中。但在 lab3 中我们还不能直接操作磁盘中的文件，所以 ELF 文件被转化为C数组的形式，再通过编译到内核完成加载 这里可以使用部分函数操作 ELF 文件，加载整个文件进入内存、获取其文件头、加载 segment 至内存</p><h2 id="ELF-文件函数"><a href="#ELF-文件函数" class="headerlink" title="ELF 文件函数"></a>ELF 文件函数</h2><ul><li>  <code>load_icode()</code>：加载可执行文件至指定进程内存（调用的最外层函数）</li><li>  <code>elf_from()</code>：解析 ELF 文件头，获取段位置</li><li>  <code>elf_load_seg()</code>：加载 ELF 程序段</li><li><code>load_icode_mapper()</code>：分配一页物理页，在 env 块对应的页表中建立映射<ul><li>  可能需要复制 src 处的数据到该物理页面中</li></ul></li></ul><h2 id="加载-ELF-文件-load-icode-Exercise-3-6"><a href="#加载-ELF-文件-load-icode-Exercise-3-6" class="headerlink" title="加载 ELF 文件 - load_icode - Exercise 3.6"></a>加载 ELF 文件 - <code>load_icode</code> - Exercise 3.6</h2><ul><li>  函数作用：调用相关函数，将 ELF 文件加载进指定进程中</li><li>  解析 ELF 头获取段信息</li><li>  使用 <code>elf_load_seg</code> 加载每个程序段</li><li>  初始化 EPC 指向程序入口点地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: 解析 ELF 头 */</span></span><br><span class="line">  <span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size);</span><br><span class="line">  <span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 循环加载每个程序段</span></span><br><span class="line"><span class="comment">   * 循环：使用 ELF_FOREACH_PHDR_OFF</span></span><br><span class="line"><span class="comment">   * 加载：使用 elf_load_seg</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">size_t</span> ph_off;</span><br><span class="line">  ELF_FOREACH_PHDR_OFF(ph_off, ehdr) &#123;</span><br><span class="line">    Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">      <span class="comment">// &#x27;load_icode_mapper&#x27; 指定了用户的加载方式</span></span><br><span class="line">      panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将进程起始地址 EPC 指向 ELF 入口 e_entry ，执行程序入口点指令 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.6: Your code here. */</span></span><br><span class="line">  e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">  <span class="comment">/* env_tf.cp0_epc 字段指示了进程运行时PC 应指向的位置,说明其为连续的虚拟地址中</span></span><br><span class="line"><span class="comment">     的某一个值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ELF_FOREACH_PHDR_OFF</code>：在上述的顶层函数中，调用了一个宏，其展开后对 ELF 程序段进行循环：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_FOREACH_PHDR_OFF(ph_off, ehdr)        \</span></span><br><span class="line"><span class="meta">(ph_off) = (ehdr)-&gt;e_phoff;                   \</span></span><br><span class="line"><span class="meta">for (int _ph_idx = 0; _ph_idx <span class="string">&lt; (ehdr)-&gt;</span>e_phnum; ++_ph_idx, (ph_off) += (ehdr)-&gt;e_phentsize)</span></span><br></pre></td></tr></table></figure><h2 id="elf-load-seg"><a href="#elf-load-seg" class="headerlink" title="elf_load_seg"></a><code>elf_load_seg</code></h2><ul><li>  函数作用：把 ELF 程序段加载到 <code>data</code> 处； MOS 中在 <code>load_icode</code> 内配合 <code>load_icode_mapper</code> 调用，也就是<strong>把程序段加载到进程内存里</strong></li><li>  按页划分，分别映射每一页至 data 中</li><li>  回调函数 <code>map_page</code> 决定映射的方式</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 加载 ELF 文件的段至 data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   bin != NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 if success. Otherwise return &lt; 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">u_long va = ph-&gt;p_vaddr;</span><br><span class="line"><span class="type">size_t</span> bin_size = ph-&gt;p_filesz;<span class="comment">// 文件大小</span></span><br><span class="line"><span class="type">size_t</span> sgsize = ph-&gt;p_memsz;<span class="comment">// 内存大小，需要补齐这一段差值</span></span><br><span class="line">u_int perm = PTE_V;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">perm = PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;              <span class="comment">// 起始地址未页对齐，映射第一页</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: 映射 p_filesz 至指定区中 */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 补全空白页至 p_memsz */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">i += BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页映射回调函数-load-icode-mapper-Exercise-3-5"><a href="#页映射回调函数-load-icode-mapper-Exercise-3-5" class="headerlink" title="页映射回调函数 - load_icode_mapper - Exercise 3.5"></a>页映射回调函数 - <code>load_icode_mapper</code> - Exercise 3.5</h2><ul><li>  函数作用：作为 <code>load_icode</code> 中使用的回调函数，它决定了页映射的方式</li><li>  申请一个物理页 <code>page_alloc</code></li><li>  复制一下src内容（注意不要复制多/少了） <code>memcpy</code></li><li>  把这个复制好的物理页映射到目标 env 里 <code>page_insert</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 把 src 处数据映射到进程 data 的va 处，更新 perm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;offset + len&#x27; &lt;= &#x27;BY2PG&#x27;.</span></span><br><span class="line"><span class="comment"> * 换句话说就是复制过去后也只在**同一个**虚拟页里面，不会跨页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个装内容的物理页 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 2: 复制 src 内容 */</span></span><br><span class="line">  <span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) (page2kva(p) + offset), src, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 把物理页插进 env 进程页表，创建映射，完成复制 */</span></span><br><span class="line">  <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>创建进程的过程主要由 <code>env_alloc</code> 函数实现，其步骤大致如下：</p><ul><li>  申请一个空闲的进程控制块</li><li>  初始化这个空白的控制块</li><li>  初始化进程<strong>页目录</strong></li><li>  从 env_free_list 中取出该控制块</li></ul><p><strong>用户栈</strong>是在使用过程中动态分配的</p><h2 id="进程页目录初始化-env-setup-vm-Exercise-3-3"><a href="#进程页目录初始化-env-setup-vm-Exercise-3-3" class="headerlink" title="进程页目录初始化 - env_setup_vm - Exercise 3.3"></a>进程页目录初始化 - <code>env_setup_vm</code> - Exercise 3.3</h2><ul><li>  函数作用：初始化进程页目录（共享只读段映射和自映射）</li><li>  <strong>形成进程页表</strong>，初始化新进程的虚拟地址空间</li><li>  把 UTOP 至 UVPT 两段地址间的内核页表 base_pgdir 拷贝到进程页表中，借此暴露这段由<strong>所有进程共享</strong>的只读空间（ Exercise 3.1完成了 base_pgdir 的建立与映射）</li></ul><p>关于共享只读的空间，指导书这样解释：</p><blockquote><p>在MOS 操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这是MOS 特有的设计。在Lab4 和Lab6 中将用到此机制。而这里我们要暴露是<strong>UTOP 往上到UVPT 之间所有进程共享的只读空间</strong>，也就是把这部分内存对应的内核页表base_pgdir 拷贝到进程页表中。从UVPT 往上到ULIM 之间则是进程自己的页表。</p></blockquote><p>拷贝的这一段空间，具体来说存放的是 envs 和 pages 两个经常使用的结构体，使其共享只读确实能够减少大量对内核空间的访问；不然用户进程申请个物理页都要进内核看 pages 了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 初始化进程的**用户内存（虚拟地址）空间**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 1: 使用 page_alloc 申请一页物理页框存放进程页目录 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  try(page_alloc(&amp;p));</span><br><span class="line">  <span class="comment">/* Exercise 3.3: Your code here. */</span></span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line">  e-&gt;env_pgdir = (Pde *) page2kva(p);</span><br><span class="line">  <span class="comment">/* Step 2: 将 &#x27;base_pgdir&#x27; 页目录内容拷贝至 &#x27;e-&gt;env_pgdir&#x27; 中 */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">         <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 设置页表自映射：令对应的页目录项指向页目录物理基地址 */</span></span><br><span class="line">  e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir)  PTE_V;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  使用 memcpy 时虽然只进行了页目录的拷贝，但两个页目录此时指向了相同的二级页表（物理页），之后再寻址就一样了</li><li>  页表自映射细节在 Thinking 3.1 中，可以回 Report 看一眼</li></ul><h2 id="申请并初始化进程块-env-alloc-Exercise-3-4"><a href="#申请并初始化进程块-env-alloc-Exercise-3-4" class="headerlink" title="申请并初始化进程块 - env_alloc - Exercise 3.4"></a>申请并初始化进程块 - <code>env_alloc</code> - Exercise 3.4</h2><ul><li>  函数作用如下：</li><li>  从空闲控制块链表中申请一个<strong>进程控制块</strong>（类似于 <code>page_alloc</code> 申请页）</li><li>  使用 <code>env_setup_vm</code> 函数和赋值语句对控制块进行初始化</li><li>  把申请好的控制块从链表中摘除并返回</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   申请并初始化进程块，存放在 &#x27;*new&#x27; 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   无父进程时 parent_id = 0</span></span><br><span class="line"><span class="comment"> *   需要初始化 envs（使用 env_init 函数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 on success</span></span><br><span class="line"><span class="comment"> *   return &lt; 0 on error：无空闲进程、ASID 或 &#x27;env_setup_vm&#x27; 失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   可能需要初始化下列字段:</span></span><br><span class="line"><span class="comment"> *     &#x27;env_id&#x27;, &#x27;env_asid&#x27;, &#x27;env_parent_id&#x27;, &#x27;env_tf.regs[29]&#x27;,</span></span><br><span class="line"><span class="comment"> * &#x27;env_tf.cp0_status&#x27;, &#x27;env_user_tlb_mod_entry&#x27;, &#x27;env_runs&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请空闲块，存放在 e 里 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (1/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e = LIST_FIRST(&amp;env_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: 使用 &#x27;env_setup_vm&#x27; 初始化用户空间 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (2/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (env_setup_vm(e)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 3: 初始化字段：</span></span><br><span class="line"><span class="comment">   *   &#x27;env_user_tlb_mod_entry&#x27; (lab4), &#x27;env_runs&#x27; (lab6), &#x27;env_id&#x27; (lab3),</span></span><br><span class="line"><span class="comment">   * &#x27;env_asid&#x27; (lab3), &#x27;env_parent_id&#x27; (lab3)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Hint:</span></span><br><span class="line"><span class="comment">   *   asid: asid_alloc</span></span><br><span class="line"><span class="comment">   *   envid: mkenvid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  e-&gt;env_user_tlb_mod_entry = <span class="number">0</span>; <span class="comment">// for lab4</span></span><br><span class="line">  e-&gt;env_runs = <span class="number">0</span>;               <span class="comment">// for lab6</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (3/4) */</span></span><br><span class="line">  e-&gt;env_id = mkenvid(e);</span><br><span class="line">  <span class="keyword">if</span> (asid_alloc(&amp;(e-&gt;env_asid)) == -E_NO_FREE_ENV) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;env_parent_id = parent_id;</span><br><span class="line">  <span class="comment">/* Step 4: 初始化 CP0 寄存器与栈顶寄存器 sp */</span></span><br><span class="line">  <span class="comment">// Timer interrupt (STATUS_IM4) will be enabled.</span></span><br><span class="line">  e-&gt;env_tf.cp0_status = STATUS_IM4  STATUS_KUp  STATUS_IEp;</span><br><span class="line">  <span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">  e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 5: 移出控制块并赋值 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (4/4) */</span></span><br><span class="line">  LIST_REMOVE(e, env_link);</span><br><span class="line">  *new = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化两个 ID 时，使用了两个不需要填空的函数，体现了操作系统生成不重复的 ID 的方式和位图法保存 ASID 的应用，这边也来看一下吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算一个 ASID 并存入参数指针内</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">asid_alloc</span><span class="params">(u_int *asid)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NASID; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> index = i &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> inner = i &amp; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> ((asid_bitmap[index] &amp; (<span class="number">1</span> &lt;&lt; inner)) == <span class="number">0</span>) &#123;</span><br><span class="line">      asid_bitmap[index] = <span class="number">1</span> &lt;&lt; inner;</span><br><span class="line">      *asid = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据当前 env ，计算其 env_id</span></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV))  (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在设置<strong>寄存器初始化</strong>时，我们使用了两个赋值语句，这两句关键语句需要解释一下：</p><ul><li><code>e-&gt;env_tf.cp0_status = STATUS_IM4 STATUS_KUp STATUS_IEp</code><ul><li>  初始化 CP0 的 SR 寄存器， IM4 代表允许响应4号中断、 KUp 代表处于用户态、 IEp 代表允许中断，这里实际上是初始化了<strong>中断响应机制</strong>所需的寄存器条件</li></ul></li><li><code>e-&gt;env_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **)</code><ul><li>  在 USTACKTOP 下存放的实际上就是用户栈，还记得倒置的 mips 栈吗，这里就是栈顶</li></ul></li></ul><p>对于 SR 寄存器，更具体的解释如下： 指导书P66  </p><h2 id="创建内核进程-env-create-Exercise-3-7"><a href="#创建内核进程-env-create-Exercise-3-7" class="headerlink" title="创建内核进程 - env_create -Exercise 3.7"></a>创建内核进程 - <code>env_create</code> -Exercise 3.7</h2><ul><li>  函数作用：创建一个内核进程，并加载 ELF 文件</li><li>  申请没有父进程的进程控制块</li><li>  初始化 priority 和 ENV_RUNNABLE</li><li>  加载 ELF 文件并插入调度队列</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  使用 &#x27;binary&#x27; 与 &#x27;priority&#x27; 字段创建一个进程</span></span><br><span class="line"><span class="comment"> *  在进程调度开始之前创建**内核**进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> Env *<span class="title function_">env_create</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个进程控制块，因为没有父进程所以 parent_id = 0,  &#x27;env_alloc&#x27; */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (1/3) */</span></span><br><span class="line">  env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Step 2: 标记 &#x27;priority&#x27; 并设置为 ENV_RUNNABLE，表示可以运行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (2/3) */</span></span><br><span class="line">  e-&gt;env_pri = (u_int) priority;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  <span class="comment">/* Step 3: 加载 ELF 文件，并插入 &#x27;env_sched_list&#x27; 头，表示允许调度 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (3/3) */</span></span><br><span class="line">  load_icode(e, binary, size);</span><br><span class="line">  TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ENV_CREATE_PRIORITY</code>：MOS 创建内核<strong>示例</strong>进程时使用的宏，定义在 <code>include/env.h</code> 中</li></ul><p>这里用到的 <code>##x##</code> 可以理解成变量替换后的字符串拼接</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// priority = y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE_PRIORITY(x, y)                                             \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, y);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// priority = 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE(x)                                                         \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, 1);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 创建进程，binary字段来自名为 binary_user_bare_loop_start 的外部数组，定义在 user/bare/loop.b.c 中</span></span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p> </p><h2 id="再探-mmu-h"><a href="#再探-mmu-h" class="headerlink" title="再探 mmu.h"></a>再探 <code>mmu.h</code></h2><p>至此，一个新的<strong>内核进程</strong>创建过程就结束了，在 Lab4 中还会用部分函数创建<strong>用户进程</strong>。回顾一下。在申请进程之前，我们先初始化了进程控制块链表(<code>env_init</code>)，在申请过程中初始化了它的内存空间、页表(<code>env_setup_vm</code>)与进程控制块字段，最后返回(<code>env_alloc</code>)。 借助 Lab2 已有的布局和进程建立的过程，我们可以大致构建起一个不断完善的内存体系，这时候 <code>include/mmu.h</code> 内的内存布局图就可以再拿出来用了。不过实际上，仍有一些字段我们没有使用，这些字段在 Lab4 中会再加以利用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Part 2.  Our conventions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> o 4G -----------&gt;  +----------------------------+------------0x100000000</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg2</span></span><br><span class="line"><span class="comment"> o  KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span></span><br><span class="line"><span class="comment"> o                            Devices             kseg1</span></span><br><span class="line"><span class="comment"> o  KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span></span><br><span class="line"><span class="comment"> o                        Invalid Memory           /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+-----------Physical Memory Max</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg0</span></span><br><span class="line"><span class="comment"> o  KSTACKTOP-----&gt; +----------------------------+-----------0x8040 0000---end</span></span><br><span class="line"><span class="comment"> o                         Kernel Stack              KSTKSIZE            /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+----------                </span></span><br><span class="line"><span class="comment"> o                         Kernel Text                                  PDMAP</span></span><br><span class="line"><span class="comment"> o  KERNBASE -----&gt; +----------------------------+-----------0x8001 0000    </span></span><br><span class="line"><span class="comment"> o                        Exception Entry          \/                    \/</span></span><br><span class="line"><span class="comment"> o  ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span></span><br><span class="line"><span class="comment"> o                           User VPT                PDMAP                /\</span></span><br><span class="line"><span class="comment"> o  UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span></span><br><span class="line"><span class="comment"> o                             pages                 PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    </span></span><br><span class="line"><span class="comment"> o                             envs                  PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UTOP,UENVS ---&gt; +----------------------------+------------0x7f40 0000    </span></span><br><span class="line"><span class="comment"> o  UXSTACKTOP -/        user exception stack        BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f f000    </span></span><br><span class="line"><span class="comment"> o                                                   BY2PG                 </span></span><br><span class="line"><span class="comment"> o  USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    </span></span><br><span class="line"><span class="comment"> o                       normal user stack           BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f d000    </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                         kuseg</span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> o   UTEXT   -----&gt; +----------------------------+------------0x0040 0000    </span></span><br><span class="line"><span class="comment"> o                        reserved for COW           BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UCOW    -----&gt; +----------------------------+------------0x003f f000    </span></span><br><span class="line"><span class="comment"> o                     reversed for temporary        BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UTEMP   -----&gt; +----------------------------+------------0x003f e000    </span></span><br><span class="line"><span class="comment"> o                         invalid memory                                 \/</span></span><br><span class="line"><span class="comment"> a 0 ------------&gt;  +----------------------------+ ----------------------------</span></span><br><span class="line"><span class="comment"> o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> </p><ul><li>  UPAGES 和 UENVS 处于用户可见区内，包含内核的页面控制块和进程控制块，每个进程拷贝成了相同的内容</li></ul><h2 id="执行进程-env-run-Exercise-3-8"><a href="#执行进程-env-run-Exercise-3-8" class="headerlink" title="执行进程 - env_run - Exercise 3.8"></a>执行进程 - <code>env_run</code> - Exercise 3.8</h2><ul><li>  函数作用：切换并运行指定进程</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 切换当前运行进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   使用 &#x27;env_pop_tf&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  assert(e-&gt;env_status == ENV_RUNNABLE);</span><br><span class="line">  pre_env_run(e); <span class="comment">// WARNING: DO NOT MODIFY THIS LINE!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 保存当前运行栈 */</span></span><br><span class="line">  <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">    curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 变更全局变量 curenv */</span></span><br><span class="line">  curenv = e;</span><br><span class="line">  curenv-&gt;env_runs++; <span class="comment">// lab6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 更改当前运行进程的页目录 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (1/2) */</span></span><br><span class="line">  cur_pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 4: 使用 &#x27;env_pop_tf&#x27; 更新寄存器，并返回用户态 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (2/2) */</span></span><br><span class="line">  env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  返回用户态，实际上是个精妙的过程，只不过我们的填空不需要完成这部分，但实在是值得研究研究</li></ul><h2 id="env-pop-tf"><a href="#env-pop-tf" class="headerlink" title="env_pop_tf"></a><code>env_pop_tf</code></h2><ul><li>  修改 CP0 寄存器和 sp 寄存器，为跳回用户态提供数据</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(env_pop_tf)</span><br><span class="line">.set reorder</span><br><span class="line">.set at</span><br><span class="line">sll     a1, a1, 6</span><br><span class="line">mtc0    a1, CP0_ENTRYHI    # 把 ENTRYHI 中保存 ASID 的部分改为 curenv-&gt;env_asid</span><br><span class="line">move    sp, a0             # 把栈指针变更为 &amp;curenv-&gt;env_tf</span><br><span class="line">j       ret_from_exception # 离开异常处理程序，返回用户态</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure><h2 id="ret-from-exception"><a href="#ret-from-exception" class="headerlink" title="ret_from_exception"></a><code>ret_from_exception</code></h2><ul><li>  刚才在 <code>env_pop_tf</code> 的最后一句中，我们跳转到了这个汇编函数，它的作用是离开异常处理程序，回到用户态，虽然当前调用不算是异常处理，但是想要完成的作用都一样：<strong>恢复用户态现场，返回用户态执行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">RESTORE_SOME         # 从 sp（视作 tf）中恢复除了 sp 以外的大部分寄存器</span><br><span class="line">lw      k0, TF_EPC(sp)   # 从 tf 中取出 EPC </span><br><span class="line">lw      sp, TF_REG29(sp) # 从 env_tf 中取得用户栈指针，赋值给 sp ，即切换到用户栈</span><br><span class="line">.set noreorder</span><br><span class="line">jr      k0               # 跳转至用户态 EPC ，离开异常处理程序</span><br><span class="line">rfe                      # 调用 rfe，使 SR 寄存器中的二重栈出栈一层</span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure><ul><li>  这里的 EPC 在初始化进程块时就被赋值成了 <strong>ELF 程序入口点</strong>，也就是说会直接 jr 到加载的 ELF 程序开始</li><li>  其中最关键的是 lw sp这一句，把用户栈指针从 tf 中取出，恢复了用户栈</li><li>  最后使用的 rfe 指令也刚好把 <code>env_alloc</code> 时初始化的二重栈用上了。每个进程都需要由此启动，所以确实<strong>都需要执行一次 rfe 指令</strong></li><li>  md，太妙了</li></ul><p> </p><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>P7 的痛苦回忆又回来了.jpg</p><blockquote><p>我们实验里认为中断是异常的一种，并且是仅有的一种<strong>异步异常</strong>。</p></blockquote><h2 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h2><ul><li>  设置 <strong>EPC</strong> 指向返回地址</li><li>  设置 SR 寄存器，强制 CPU 进入内核态</li><li>  设置 Cause 寄存器记录异常原因</li><li>  跳转到异常处理程序入口，执行处理</li></ul><p> </p><h2 id="异常分发程序-exc-gen-entry-Exercise-3-9"><a href="#异常分发程序-exc-gen-entry-Exercise-3-9" class="headerlink" title="异常分发程序 - exc_gen_entry - Exercise 3.9"></a>异常分发程序 - <code>exc_gen_entry</code> - Exercise 3.9</h2><ul><li>  异常分发程序：根据发生的异常跳转到异常处理程序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">SAVE_ALL                      # 将当前寄存器形成 TrapFrame 保存在内核栈 KSTACKTOP 内</span><br><span class="line">/* Exercise 3.9: Your code here. */</span><br><span class="line">mfc0 t0, CP0_CAUSE</span><br><span class="line">andi t0, 0x7c                 # 获取 Cause 寄存器中的 ExcCode</span><br><span class="line">lw t0, exception_handlers(t0) # 通过 handler 获取分发的处理函数入口</span><br><span class="line">jr t0                         # 跳转到对应的异常处理入口，响应异常</span><br></pre></td></tr></table></figure><ul><li>  <code>lw t0, exception_handlers(t0)</code> 指令明明是个访存指令，如何做到获取处理函数地址的呢？</li></ul><p>实际上这是由于 <code>exception_handlers</code> 这个异常向量组以数组的形式保存在内存中。只需要将 t0 寄存器作为下标，我们就能直接访问了这个数组的对应内容（这个内容存放的就是处理函数的地址） 为了程序能找到这个分发程序和处理 TLB Miss 的程序，我们在 <code>kernal.lds</code> 中放置了它们所在的字段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.tlb_miss_entry : &#123;</span><br><span class="line">*(.text.tlb_miss_entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">= 0x80000080;</span><br><span class="line">.exc_gen_entry : &#123;</span><br><span class="line">*(.text.exc_gen_entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（虽然处理 TLB 的函数会直接跳到主异常分发程序，没啥用（</p><h2 id="异常向量组-exception-handlers"><a href="#异常向量组-exception-handlers" class="headerlink" title="异常向量组 - exception_handlers"></a>异常向量组 - <code>exception_handlers</code></h2><ul><li>  异常分发程序通过 <code>exception_handlers</code> 数组定位中断处理程序，而定义在 <code>kern/traps.c</code> 中的 <code>exception_handlers</code> 就称作<strong>异常向量组</strong>。</li></ul><p>这部分指导书的逻辑很明确，就直接借用了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_tlb</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_sys</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_mod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_reserved</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义在哪个文件可以参考 Report 内容，在思考题中出现过</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读 2 号异常的处理函数为handle_tlb，表示TLB load 异常 3 号异常的处理函数为handle_tlb，表示TLB store 异常 8 号异常的处理函数为handle_sys，表示系统调用，用户进程通过执行syscall 指令陷 入内核</p></blockquote><p>通过访问对应的异常下标，就能在异常分发程序中进入对应的处理函数（目前中断还不行），最后调用 <code>ret_from_exception</code> 返回用户态</p><h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><ul><li>  中断处理的流程</li><li>  进入异常分发程序，判断为中断</li><li>  进入<strong>中断处理程序</strong> <code>handle_int</code>，判断中断种类，再进行分发</li><li>  处理中断结束后，进入 <code>ret_from_exception</code> 返回用户态</li></ul><p>目前我们的 MOS 只能处理一种<strong>时钟中断</strong>，所以中断处理就只有一种选择（）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2              # 获取可以处理的时钟中断</span><br><span class="line">andi    t1, t0, STATUS_IM4  # 中断号 4 号：时钟中断</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0               # 将时钟响应位置0</span><br><span class="line">j       schedule            # 执行 schedule(0)</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><h2 id="时钟中断-kclock-init-Exercise-3-11"><a href="#时钟中断-kclock-init-Exercise-3-11" class="headerlink" title="时钟中断 - kclock_init - Exercise 3.11"></a>时钟中断 - <code>kclock_init</code> - Exercise 3.11</h2><p>MOS 系统产生定时的时钟中断，并根据这些中断分配每个进程运行的时间片（限制进程一次性运行的时间长度）</p><ul><li>  初始化并启用时钟中断</li></ul><p><code>kern/kclock.S</code> 中的 <code>kclock_init</code> 函数完成了时钟中断的初始化，该函数向 <code>KSEG1 DEV_RTC_ADDRESS DEV_RTC_HZ</code> 位置写入200，其中 <code>KSEG1 DEV_RTC_ADDRESS</code> 是模拟器（GXemul）映射<strong>实时钟</strong>的位置。偏移量为 <code>DEV_RTC_HZ</code> 表示设置实时钟中断的频率，200 表示1 秒钟中断200 次。 随后再调用 <code>kern/env_asm.S</code> 中的 <code>enable_irq</code> 函数开启中断。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(kclock_init)</span><br><span class="line">li      t0, 200 // the timer interrupt frequency in Hz</span><br><span class="line"></span><br><span class="line">/* Write &#x27;t0&#x27; into the timer (RTC) frequency register.</span><br><span class="line"> *</span><br><span class="line"> * Hint:</span><br><span class="line"> *   To access device through mmio, a physical address must be converted to a</span><br><span class="line"> *   kseg1 address.</span><br><span class="line"> * #define DEV_RTC_HZ 0x0100</span><br><span class="line"> * #define DEV_RTC_ADDRESS 0x15000000</span><br><span class="line"> *  #define KSEG1 0xA0000000U</span><br><span class="line"> */</span><br><span class="line">/* Exercise 3.11: Your code here. */</span><br><span class="line">sw t0 , (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_HZ)</span><br><span class="line">jr      ra</span><br><span class="line">END(kclock_init)</span><br></pre></td></tr></table></figure><p><code>enable_irq</code> 函数在 Report 里也有，文章太长就不写力</p><ul><li>  时钟中断的处理</li><li><ol><li> 中断产生，进入异常分发程序</li><li> 判断为中断，进入中断处理程序</li><li> 判断为时钟中断，执行处理函数</li><li> 执行 <code>schedule(0)</code>，进行进程调度</li></ol></li></ul><h2 id="进程调度-schedule-Exercise-3-12"><a href="#进程调度-schedule-Exercise-3-12" class="headerlink" title="进程调度 - schedule - Exercise 3.12"></a>进程调度 - <code>schedule</code> - Exercise 3.12</h2><ul><li>  函数功能：根据参数 <code>yield</code> 和当前进程状态进行进程调度</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment"> *   1. 使用 static 变量 count 记录剩余时间片</span></span><br><span class="line"><span class="comment"> *   2. 不需要在 &#x27;noreturn&#x27; 函数中使用 return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always decrease the &#x27;count&#x27; by 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span></span><br><span class="line"><span class="comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span></span><br><span class="line"><span class="comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span></span><br><span class="line"><span class="comment"> * if that list is empty**.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 3.12: Your code here. */</span></span><br><span class="line"><span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在 <code>schedule</code> 函数中，我们没有使用 <code>return</code>，而直接进入了新一轮的 <code>env_run</code>，保存当前已运行的部分内容，开始新的进程。</li><li>  这也说明了为什么只有 <code>timer_irq</code> 没有调用 <code>ret_from_exceprion</code> 函数，因为<strong>不用回到原本执行进程</strong>的用户态了</li></ul><p>  Lab3 大体到这里就结束了，要写的要看的也太多了，有点逆天。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Report</title>
      <link href="/2023/04/os/buaa-os-report-lab3/"/>
      <url>/2023/04/os/buaa-os-report-lab3/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab3-Report"><a href="#BUAA-OS-2023-Lab3-Report" class="headerlink" title="BUAA-OS-2023-Lab3-Report"></a>BUAA-OS-2023-Lab3-Report</h1><h1 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h1><ul><li>  Thinking 3.1 请结合MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) PTE_V</code> 的含义</li></ul><p>根据自映射机制可知， <code>e-&gt;env_pgdir[PDX(UVPT)]</code> 指的是进程块 <code>e</code> 的<strong>指向用户页表</strong>的页目录项，又根据页表映射的要求，这一项的内容应该是用户页表的物理地址，即<code>PADDR(e-&gt;env_pgdir)</code> ，再为其置有效位为1，初始化用户页表</p><h1 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h1><ul><li><p>  <code>elf_load_seg()</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code> 。请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></li><li><p>  <code>elf_load_seg()</code> 函数定义位于 <code>lib/elfloader.c</code> 中；使用仅有一处，位于 <code>kern/env.c</code> 的 <code>load_icode()</code> 函数中</p></li></ul><p>首先这里的回调函数是定义在 <code>kern/env.c</code> 的 <code>load_icode_mapper()</code> 函数，作用是把一段虚拟地址的内容<strong>加载</strong>到<strong>某个进程管理块对应进程</strong>的虚拟内存中（通过申请物理页面并建立页表映射）。这两个函数中的 <code>data</code> 参数相同，其来源是待加载的进程管理块指针，它用来告知 <code>load_icode_mapper()</code> 函数加载到哪个进程。所以<strong>不可以</strong>没有这个参数，如果没有这个参数，将无法确定加载到哪个进程的虚拟内存中。</p><p>在 <code>elf_load_seg()</code> 中使用回调函数，可以令用户自定义加载段中各个待加载页面的方式</p><h1 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h1><ul><li>  结合 <code>elf_load_seg()</code> 的参数和实现，考虑该函数需要处理哪些页面加载的情况</li></ul><p>考虑情况如下：</p><ul><li>  段起始地址未页面对齐</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  复制段大小不足一个页面</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))</span><br><span class="line"><span class="comment">// MIN(bin_size, BY2PG - offset) 选择了待复制段与页面偏移后</span></span><br><span class="line"><span class="comment">// 剩余空间中更小的值进行复制，避免复制不必要的内容</span></span><br></pre></td></tr></table></figure><ul><li>  为 <code>.bss</code> 段预留空间：文件大小与程序大小不同需要补充空页面</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  i += BY2PG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h1><blockquote><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code>，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。</p></blockquote><ul><li>  思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</li></ul><p>显然， PC 值应该在程序运行过程中<strong>保持连续</strong>，而程序运行时的物理地址应该是<strong>经过页表映射后</strong>不连续的，虚拟地址可以则保证其连续性。所以这里的 <code>env_tf.cp0_epc</code> 应该保存的是<strong>虚拟地址</strong></p><h1 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h1><blockquote><p>在<strong>异常向量组</strong>中，通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为 <code>handle_int</code> ，表示<strong>中断</strong>，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为 <code>handle_mod</code> ，表示<strong>存储异常</strong>，进行存储操作时该页被标记为只读 2 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB load</strong> 异常 3 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB store</strong> 异常 8 号异常的处理函数为 <code>handle_sys</code> ，表示<strong>系统调用</strong>，用户进程通过执行 <code>syscall</code> 指令陷 入内核</p></blockquote><ul><li>  试找出上述 5 个异常处理函数的<strong>具体实现位置</strong>。</li></ul><p>在 <code>kern/genex.S</code> 文件中，我们可以先找到其上声明的 <code>handle_int</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)# handle_int 实现</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM4</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><p>其余的四个函数通过同文件的宏 <code>BUILD_HANDLER exception handler</code> 定义在其后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro BUILD_HANDLER exception handler</span><br><span class="line">NESTED(handle_\exception, TF_SIZE + 8, zero)</span><br><span class="line">move    a0, sp</span><br><span class="line">addiu   sp, sp, -8</span><br><span class="line">jal     \handler</span><br><span class="line">addiu   sp, sp, 8</span><br><span class="line">j       ret_from_exception</span><br><span class="line">END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill# do_tlb_refill 实现于 kern/tlbex.c</span><br><span class="line"></span><br><span class="line">#if !defined(LAB)  LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod# do_tlb_mod 实现于 kern/tlbex.c</span><br><span class="line">BUILD_HANDLER sys do_syscall# do_syscall 实现于 kern/syscall_all.c</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved# do_reserved 实现于 kern/traps.c</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h1><ul><li>  阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出 <code>enable_irq</code> 和 <code>timer_irq</code> 中每行汇编代码的作用</li></ul><h2 id="enable-irq"><a href="#enable-irq" class="headerlink" title="enable_irq"></a><code>enable_irq</code></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">li      t0, (STATUS_CU0  STATUS_IM4  STATUS_IEc)    # 允许用户态使用 CP0 寄存器 + 允许4号中断响应 + </span><br><span class="line">                                                    # 开启当前状态CPU中断</span><br><span class="line">mtc0    t0, CP0_STATUS                              # 将 CPU 状态保存在 CP0 的 STATUS 寄存器</span><br><span class="line">jr      ra                                          # 返回调用者函数</span><br><span class="line">END(enable_irq)</span><br></pre></td></tr></table></figure><h2 id="timer-irq"><a href="#timer-irq" class="headerlink" title="timer_irq"></a><code>timer_irq</code></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">                                                    # 将 GXemul 时钟响应位置 0</span><br><span class="line">li      a0, 0                                       # 令 schedule 参数 yield = 0</span><br><span class="line">j       schedule                                    # 进入 schedule 函数进行进程块队列调度</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h1><ul><li>  阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的</li></ul><p>首先，我们在kern/kclock.S 中的kclock_init 函数完成了时钟中断的初始化，并在 genex.S 中的 enable_irq 中设置允许响应该中断</p><p>当时钟计时归零（时间片耗尽），产生时钟中断，进入<strong>异常处理程序</strong>，并跳转到 handle_int 处理中断。</p><p>当前我们的系统只能处理 <code>timer_irq</code> 一种时钟中断，所以直接进入 <code>timer_irq</code> 函数，恢复时钟，并执行 <code>schedule(0);</code></p><p>在 <code>schedule()</code> 中，我们根据当前进程块状态进行进程块队列调度，实现进程切换或进程的舍弃，至此完成时钟中断响应</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT2-Summary</title>
      <link href="/2023/04/buaa-oo-unit2-summary/"/>
      <url>/2023/04/buaa-oo-unit2-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，多线程要多测试</p></blockquote><ul><li><strong>博客撰写基本要求：</strong><ul><li>总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li><li>总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的<ul><li>结合线程协同的架构模式（如流水线架构），分析和总结自己<ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul></li></ul></li><li>分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li><li>心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul></li></ul><p><strong>注意：</strong>在编写完博客并发布在CSDN之后，请在选择要作为作业提交的博客，点击提交。</p><h1 id="架构思路总结"><a href="#架构思路总结" class="headerlink" title="架构思路总结"></a>架构思路总结</h1><p>本单元作业，我采取了一种专精调度器的路线，调度器知晓程序内几乎所有类、线程的数据，并根据这些数据进行全局的调度，其包括：</p><ul><li>  为指定请求分派特定的电梯</li><li>  唤醒、终止<strong>特定的</strong>电梯线程</li><li>  指定电梯运行的掉头楼层（抵达该楼层就进行转向）</li><li>  拆解不可直达请求为局部最优路线并分配电梯</li></ul><p>实现这样一个看起来全能全知的调度器就意味着它需要掌握大量数据，否则很难做出合理的调度。所以设计模式上我采取了一种”一家独大“的<strong>黑板模式</strong>：电梯类与生产者类持续进行数据的实时更新，调度器则根据这些实时数据做出判断。</p><p>为了减少死锁的发生，我限制了所有信息的流动方向：仅允许调度器这块黑板被外界访问，调度器只能向黑板上写数据，不能主动申请获取外界信息。<strong>单方向的信息传递</strong>保证死锁不会在这样的架构中产生。同时我并没有将调度器类转变为线程，而是以数据字段与众多处理方法组成，不同的数据更改会使用调度器类的不同方法，从而进行下一步的调度。</p><h2 id="同步块的设置与锁的选择"><a href="#同步块的设置与锁的选择" class="headerlink" title="同步块的设置与锁的选择"></a>同步块的设置与锁的选择</h2><ul><li>  总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li></ul><p>在三次作业中，我均使用了互斥锁 <code>synchronized</code> 进行代码同步块的保护。原有想重构为效率更高的 <code>ReentrantLock</code> 或可释放指定线程便于高效调度的 <code>LockSupport</code> 或更高端的读写锁 <code>ReentrantReadWriteLock</code> ，但是最后都因为原来架构压得有点死而放弃（</p><p>在本轮作业迭代中，我在生产者类、调度器类与电梯类中都出现了锁，但这些锁<strong>全部指向调度器类</strong>，并且只设置了一个调度器。也就是说，无论发生怎样的线程交互，都只能申请访问一个锁，所以根本不可能出现死锁状况，大家都在等着调度器那一把锁而已。</p><p>为了保证线程安全，我将调度器内的所有方法都使用了 <code>synchronized</code> 关键字进行包装，但其他的类除了电梯类 <code>wait()</code> 调度器锁时需要同步外，均未出现同步方法/同步块。</p><h3 id="各个类获取锁的目的"><a href="#各个类获取锁的目的" class="headerlink" title="各个类获取锁的目的"></a>各个类获取锁的目的</h3><ul><li>生产者类：<ul><li>  向调度器中的请求队列中添加新的请求（乘客请求）</li><li>  更新调度器类中的电梯集合（ADD、MAINTAIN）</li></ul></li><li>电梯类：<ul><li>  向调度器中<strong>写入</strong>当前自身状态（楼层、方向、运行与否等）</li><li>  从调度器中<strong>读取</strong>自身的下一步状态（运动方向/状态、MAINTAIN等）</li><li>  更新调度器中的请求队列（MAINTAIN、换乘下客）</li></ul></li></ul><h2 id="调度器设计与线程交互"><a href="#调度器设计与线程交互" class="headerlink" title="调度器设计与线程交互"></a>调度器设计与线程交互</h2><ul><li>  总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的</li></ul><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><p>本单元采用黑板模式进行设计。各个类都将信息交互集中于黑板之上，生产者写入请求，调度器调度请求，电梯获取自身预定的运动细节。由此，黑板便成了整个程序最大的、也是唯一的<strong>共享数据类</strong>。</p><p>三次作业中，调度器都建立在提到的共享数据类 “黑板” 之上。通过生产者和电梯的数据更新，调度器能够掌握全部线程的几乎全部信息，并根据信息设计调度策略。</p><h3 id="线程交互与信息传递"><a href="#线程交互与信息传递" class="headerlink" title="线程交互与信息传递"></a>线程交互与信息传递</h3><p>由于有且仅有一个共享数据类——黑板，所以程序内的信息流动都与这个数据类相关。</p><p>在设计本单元架构时，我考虑的第一个问题实际上是<strong>死锁</strong>，不知道同学们有没有因为程序死锁而难以推进的时候。为了解决这种困扰，我直接简单粗暴的将所有<strong>信息访问</strong>的方向固定为单向：生产者、电梯只能更新调度器内数据，或读取调度器产生的信息，正如在前面锁的部分提到的一样。这样做线程交互的难度能有所降低。</p><p>其实当时还并不理解这样做的原理是什么，直到第八周理论课上，我才发现自己采取的架构和老师谈到的黑板模式十分相近。具体的信息流动如下：</p><p>假装有图.jpg</p><p>但实际上，随着工程代码量与类的增多，黑板上记录的东西会越来越复杂，想来看黑板的人也会越来越多，这样必然会导致多线程交互效率下降，同时也会导致黑板与离着黑板最近的调度器类复杂度升高。</p><h3 id="调度策略与性能指标"><a href="#调度策略与性能指标" class="headerlink" title="调度策略与性能指标"></a>调度策略与性能指标</h3><p>在单元初就被告知今年的性能指标增加了一个用电量的限制。旨在加重调度器在程序设计中的地位，弱化所有电梯饿虎扑食的自由竞争的使用。这更加坚定了我要写一个全局调度器的决心，主要是不觉得写调度器优质规划是一件很酷的事情吗（并不）</p><p>再加上原本的传统性能指标：运行时间和等待时间。多数情况下，电梯移动更少的楼层能消耗更少的时间，所以我希望电梯能少跑一层就少跑一层（省电）；乘客能早接一下就早接一下（省时间）。</p><p>由此确定了基本的思路为：</p><blockquote><p>能近就近，能省就省</p><p>（乘客选用距离最近的电梯，电梯运行中考虑移动最少的楼层数）</p></blockquote><p>决定采用调度器全局调度的方式后，实际上后续迭代的请求分配策略几乎没有发生改变：</p><ul><li>准备工作：电梯在移动/休息过程中将自身状态实时写到黑板上</li><li>调度启动：生产者向黑板写入请求，告知调度器开始规划</li><li>规划思路：为请求分配等待最短时间就能搭上的电梯<ul><li>  遍历所有电梯，能否装下这个乘客（过程中会不会超载），若超载则被筛除</li><li>  根据 请求楼层/运动方向、电梯楼层/运动方向、电梯掉头时预计抵达的楼层，计算当前电梯接收请求所用的时间</li><li>  将请求分配给所需时间最短者（保证局部最优），并更新电梯掉头预计抵达的楼层（请求终点站与原本预计抵达楼层间的比较），以便电梯掌握运动路线，同时便利下次分配</li></ul></li></ul><p>这种做法，实际上和往年学长们的影子电梯/模拟做法类似，只不过这种做法精确度不如纯模拟，但是实现难度要比复制一遍电梯内容并全局模拟的难度还是要低不少的。这里唯一需要比模拟做法多考虑的点就是<strong>电梯超载</strong>：</p><p>试考虑以下场景：电梯停靠于1层，首先为其分配6个5-11层的请求令电梯满载，在电梯运行到2层时再输入一个3-11层的请求，显然电梯此刻为空，同时显然把7个请求全部分给这台电梯，会超载，或剩下一个请求等这台电梯回来接他。</p><p>假装有图.jpg</p><p>这样做的效果显然不如第一次就把请求分配给另一台电梯，那么如何表示<strong>当前有空间</strong>的电梯，在<strong>未来某一刻</strong>会满载呢？我使用了两个数组代表上行/下行过程中电梯在某个楼层时的人数，然后根据分配的请求进行动态变化，如果某一层达到capacity说明电梯在该层会出现满员状态。具体细节就不展开说了，有了思路后实现还是很轻松的。</p><p>在第三次作业中，加入了<strong>强制换乘</strong>请求，我的处理方式是将所有可联通（换乘）的电梯当作图中的两个连接的节点，然后从请求起始楼层所有可达的电梯出发，求到终止楼层所有可达电梯的<strong>多源对多源可达路径</strong>（全部可达路径，做法可参考<a href="https://blog.csdn.net/spnooyseed/article/details/106957325">这一篇文章</a>）。再按照换乘次数递增的方式排序路线并拆分每一个请求的第一次<strong>换乘段</strong>，查看能否分配。</p><p>总体来说性能还是蛮不错了，至少有人上来错仨点还能拿84+（</p><h2 id="架构分析与协作图"><a href="#架构分析与协作图" class="headerlink" title="架构分析与协作图"></a>架构分析与协作图</h2><p>结合线程协同的架构模式（如流水线架构），分析和总结自己</p><ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><ul><li>  类图中不包含<code>[]</code>标记的是第一次第一次的架构，方括号内数字代表这个字段/方法在第几次作业中加入</li></ul><p>通过三次迭代作业的类图可以发现，迭代过程中并没有增添过多的类，处理方式大多为增添函数以满足请求。</p><p>在拓展方面上，可以考虑迭代前两年作业中出现过的横向电梯，为此可能需要做出以下调整：</p><ul><li>  改良电梯间的图结构，使其能支持更复杂的换乘需求</li><li>  增添新的横向电梯类，优化电梯信息类以兼容两类电梯</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752603.jpg" alt="ClassUML3.jpg"></p><h3 id="UML-协作图"><a href="#UML-协作图" class="headerlink" title="UML 协作图"></a>UML 协作图</h3><p>UML 协作图如下，本架构中，调度器 Manager 并不属于运行中的线程，只不过因为方法与交互太多，导致它看起来好像在持续运行一样（）</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752093.jpg" alt="ProcessUML"></p><h2 id="代码中稳定-易变的内容"><a href="#代码中稳定-易变的内容" class="headerlink" title="代码中稳定/易变的内容"></a>代码中稳定/易变的内容</h2><ul><li>稳定内容：<ul><li>  电梯运行逻辑：在三次作业中，电梯都采用了 检查方向 - 移动 - 上下客 - 检查方向 的循环进行电梯的移动，同时电梯 MAINTAIN 逻辑也只在添加时进行了编写，后续没有改动</li><li>  电梯上下客逻辑：电梯检测每个请求是否标记为自身携带，如果是则进入电梯；检查自身队列，如果目的地是当前楼层则释放；这部分逻辑也没有发生过改变</li><li>  计算最优电梯逻辑：针对每一个请求，每台电梯都会计算接收请求所用时间长短，并分配电梯，这个逻辑也大致没有变化，只在第二次作业中<strong>将时间由固定值改为电梯属性</strong></li></ul></li><li>易变内容：<ul><li>请求读入逻辑：在第一次作业中请求只有 <code>PersonRequest</code> 一种，只需要考虑读取乘客请求并更新队列即可；在第二次作业中，增加了 <code>ADD</code> 、 <code>MAINTAIN</code> 请求，需要分类并处理增删电梯逻辑与对应的方法；在第三次作业中， <code>ADD</code> 电梯的逻辑更加复杂，需要额外考虑电梯的可达楼层。每次作业迭代都发生了改变。</li><li>线程终止逻辑：与请求输入相关的终止逻辑变更也较大。第一次作业中只要输入停止，就一定意味着线程可以处理完当前请求后结束；第二次作业中，必须考虑 <code>MAINTAIN</code> 电梯仍然会在输入结束后释放乘客，而这部分乘客需要回填请求队列，这就产生了新的请求；第三次作业中回填的情况也发生在不可直达请求的换乘过程中：换乘请求下车后仍需要回填请求序列。</li><li>第三次作业中的请求拆分逻辑：虽然这部分逻辑只在最后一次作业出现，但是我尝试过各种不同的方法，感觉也有必要做一些总结：<ul><li>  “<strong>电梯井</strong>”逻辑：按照 电梯ID + 楼层号 的方式创建节点，同时创建一个只连接<strong>可停靠在该层</strong>电梯的<strong>换乘大厅</strong>， dfs 找出所有可行路线，并排序最少换乘路线；但这个做法时间复杂度过高，处理单个请求都可能 CTLE ，无奈不得不放弃</li><li>  电梯邻接链表：同学分享的思路，将每一层构建一个节点，各层能停的电梯划分在楼层后，再根据所有能上的电梯继续寻找下一个能上的电梯，直至能够抵达最终目的楼层，回溯路径</li><li>  多源 - 多源 dfs：最后采用的方法，之前在前面写过了就不水了</li></ul></li></ul></li></ul><h2 id="bug-记录与多线程-bug-修复"><a href="#bug-记录与多线程-bug-修复" class="headerlink" title="bug 记录与多线程 bug 修复"></a>bug 记录与多线程 bug 修复</h2><ul><li>  分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li></ul><h3 id="bug记录"><a href="#bug记录" class="headerlink" title="bug记录"></a>bug记录</h3><p>在第一单元互测中，大家的常用攻击方式都是短时间大量投喂1 - 11之类的请求卡 RTLE。本地测试没出现过被卡的情况，但在互测中还真被刀了。在助教的帮助下我意识到可能的原因是生产者 - 电梯之间处理 <code>notifyAll()</code> 的速度差异。</p><p>在我的架构中，对于一个读入的请求会计算其搭乘的电梯 ID ，同时根据 ID 去唤醒指定的电梯，具体来说就是在黑板的一块<strong>公共空间</strong>写下电梯号，每个电梯按顺序查看是不是自己，再决定会不会醒来。但如果生产者的运转速度过快，有可能导致 A 乘客的 ID 还没有被所有电梯看完， B 乘客的 ID 就覆盖了旧 ID ，有可能A的电梯就醒不过来了。但当时采用了一种不合适的修改思路：使用 <code>sleep()</code> 降低生产者速度。</p><p>因为这次修改不够充分，类似的问题出现在第三次作业中，最后的bug修复我把公共的空间改为了每个电梯只查看自己的一小块私有黑板，这样不会频繁更改，才是最好的办法。</p><h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h3><blockquote><p>一定要多 <code>println()</code> .jpg</p></blockquote><p>打印共享数据类的各个所需状态都是debug的一种选择。其中我认为最好用的是根据可能出错的电梯ID和乘客ID，直接输出当时电梯内外的所有状态，大体为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elevator.getId() == specialEid &amp;&amp; request.getId() == specialRid) &#123;</span><br><span class="line">    System.println(<span class="string">&quot;message you want to see&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的 specialId 都是具体的数字</span></span><br></pre></td></tr></table></figure><p>其次就是多做<strong>场景复原</strong>，回溯错误发生前的一段时间，看一看错误电梯的行为。通过配合前面的特定print效果还是挺不错的，因为既不会打印出满屏输出，同时也能看到一些关键的信息。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li>  心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>这单元的作业中，很多同学都出现了<strong>死锁</strong>的状况，原因大部分是复杂的<strong>线程间信息交互</strong>。而且都是在持有锁的同步块内索取其他对象的锁，确实容易出错（）规范信息交互方式、合理使用同步块和锁，注意单个函数逻辑，我认为是处理交互的重中之重。</p><p>再比如有佬采用了每个请求的每秒都生成一个线程，我觉得这是对自己架构设计的磨练与宝贵经验；虽然我距离这样把线程用活的程度还有很远，但我觉得这样架构中的信息交互与安全性实在值得我们学习。</p><p>其次是保证读写操作不会被其他操作干扰，实际上这个还比较好处理，需要注意<strong>一次</strong>读写操作的范围，对于单个对象来说可能是一个 <code>return</code> ，一个赋值；而对于容器来说，一次读写就应该对应着一次遍历了，在遍历途中实际上都不应该允许容器被改变。</p><h2 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h2><p>在考虑线程之间的协作时，为了避免线程本身拥有太多信息导致交互臃肿，我选择了一个单独的电梯信息类对单个电梯所拥有的一系列属性进行包装，并且把这个信息类放在黑板中。电梯线程类本身不具有太多信息，查询、更新状态都需要去黑板查看，这样保证了线程交互的简便性。</p><p>其余的层次化主要体现在调度器类这个黑板上，黑板拥有不同的字段，这些字段是对应的下一级的类，它们分别代表着黑板上的不同种类信息。总的来说层次化设计在本次作业架构中不是很明显。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>oo最让人难熬的电梯月到这里就算告一段落了，我认为这个单元学到的线程协作知识很有价值，不仅在学习过程中了解到了更多的设计模式，同时也知晓了线程/进程的概念、线程间信息传递的安全问题，是十分宝贵的经验。还有两个单元，不要懈怠就好了。</p><p>能看到最后的我觉得大概率是助教giegie吧，在这我想对每一位助教说声谢谢，在电梯月的摸爬滚打少了你们的帮助真的会寸步难行。接下来两个单元也要救救我哦（逃</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab2</title>
      <link href="/2023/03/os/buaa-os-probe-lab2/"/>
      <url>/2023/03/os/buaa-os-probe-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><p>在进行实验前，建议通读<code>mmu.h</code>和<code>pmap.h</code>文件，了解一些宏定义，对后续工作很有帮助</p><p>名称</p><p>参数</p><p>作用</p><p>PADDR</p><p>内核<strong>虚拟地址</strong>kva</p><p>将内核虚拟地址kva转成对应的物理地址</p><p>KADDR</p><p><strong>物理地址</strong>pa</p><p>将物理地址pa转化为内核虚拟地址</p><p>page2pa</p><p>页信息结构<strong>struct Page</strong></p><p>通过空闲页结构得到这一页起始位置的物理地址</p><p>pa2page</p><p><strong>物理地址</strong>pa</p><p>通过物理地址pa获取这一页对应的页结构体struct Page</p><p>page2kva</p><p>页信息结构<strong>struct PageInfo</strong></p><p>通过空闲页结构得到这一页起始位置的虚拟地址</p><p>PDX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la对应的页目录项索引</p><p>PTX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la在二级页表中对应的页表项索引</p><p>PTE_ADDR(pte)</p><p>页表项或页目录项的<strong>值</strong></p><p>获得对应的页表/地址基址(低12位为0，并均为<strong>物理地址</strong>)</p><h3 id="内核启动后的内存分配-2-1"><a href="#内核启动后的内存分配-2-1" class="headerlink" title="内核启动后的内存分配 - 2.1"></a>内核启动后的内存分配 - 2.1</h3><ul><li>我们的操作系统内核启动后需要执行下列三个函数完成内存分配机制的建立<ul><li>  <code>mips_detect_memory()</code>：探测硬件可用内存，初始化内存基本变量</li><li>  <code>mips_vm_init()</code>：建立用于管理内存的数据结构</li><li>  <code>page_init()</code>：初始化结构<code>Page</code>与空闲链表<code>page_free_list</code></li></ul></li></ul><h4 id="mips-detect-memory-Exercise-2-1"><a href="#mips-detect-memory-Exercise-2-1" class="headerlink" title="mips_detect_memory() - Exercise 2.1"></a><code>mips_detect_memory()</code> - Exercise 2.1</h4><ul><li>本函数的作用是探测硬件可用内存，并初始化两个变量：<ul><li>  <code>memsize</code>：物理内存对应的字节数（实验中从外设中读取）</li><li>  <code>npage</code>：物理内存对应的页数</li></ul></li></ul><h5 id="Exercise-2-1"><a href="#Exercise-2-1" class="headerlink" title="Exercise 2.1"></a>Exercise 2.1</h5><ul><li>  请参考代码注释，补全<code>mips_detect_memory</code>函数。 在实验中，从外设中获取了硬件可用内存大小<code>memsize</code>，请你用内存大小<code>memsize</code>完成总物理页数<code>npage</code>的初始化</li></ul><p>相对简单的一题，<code>memsize</code>已知，只需要除以每页的大小即可（<code>BY2PG = 4096</code>定义在<code>mmu.h</code>中）</p><p>在这里要留意一下<code>npage</code>这个变量，后面的练习中会用到几次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">()</span> &#123;</span><br><span class="line">    memsize = *(<span class="keyword">volatile</span> u_int *)(KSEG1  DEV_MP_ADDRESS  DEV_MP_MEMORY);</span><br><span class="line">    <span class="comment">/* Exercise 2.1 Your code here. */</span></span><br><span class="line">    npage = memsize / BY2PG;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;Memory size: %lu KiB, number of pages: %lu\n&quot;</span>, memsize / <span class="number">1024</span>, npage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mips-vm-init"><a href="#mips-vm-init" class="headerlink" title="mips_vm_init()"></a><code>mips_vm_init()</code></h4><ul><li>  本函数通过一次性调用<code>alloc()</code>函数完成对内存管理结构（<strong>页控制块</strong>）所在空间的初步分配，实现的关键在<code>alloc()</code>中。这个函数只在系统初始化、尚未生成页式管理机制时才会被调用。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在建立页式存储机制前，使用alloc函数进行内存空间的分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">    <span class="comment">/* Initialize &#x27;freemem&#x27; if this is the first time. */</span></span><br><span class="line">    <span class="keyword">if</span> (freemem == <span class="number">0</span>) &#123;</span><br><span class="line">        freemem = (u_long)end;<span class="comment">/* 明确 freemem 指向虚拟地址 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    freemem = ROUND(freemem, align);<span class="comment">/* 按大小向上取整，保证此时freemem表示</span></span><br><span class="line"><span class="comment">     * 空闲空间的起始地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloced_mem = freemem;<span class="comment">/* freemem 以下空间均被分配 */</span></span><br><span class="line">    freemem = freemem + n;<span class="comment">/* 分配出 n 个字节大小的空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (PADDR(freemem) &gt;= memsize) &#123;<span class="comment">/* 物理地址越界，无足够空闲空间 */</span></span><br><span class="line">        panic(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clear) &#123;<span class="comment">/* clear 是分配内存清零的标志位 */</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)alloced_mem, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) alloced_mem;<span class="comment">/* 返回被分配空间的起始**虚拟**地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> &#123;</span><br><span class="line">    pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 分配了一块大小为 (npage * 页表项) 字节的空间并清空，用于存放所有的页表项</span></span><br><span class="line"><span class="comment">     * 起始地址为 pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>freemem</code>：在这里我们通过使用虚拟内存的<code>kseg0</code>段来操作内存，但实际上它可以直接映射到指定的物理地址（去掉最高位），不需要额外的映射逻辑</li><li>  <code>extern char end[]</code>：在lab1中分配段加载地址用到的<code>kernel.lds</code>已经声明过，可以直接使用表示地址</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80400000;// 相当于物理内存的0x400000</span><br><span class="line">end = . ;</span><br></pre></td></tr></table></figure><h3 id="物理内存管理-2-2-2-5"><a href="#物理内存管理-2-2-2-5" class="headerlink" title="物理内存管理 - 2.2 ~ 2.5"></a>物理内存管理 - 2.2 ~ 2.5</h3><ul><li>  MOS系统使用页式内存管理物理内存，使用链表管理页表，重要代码位于<code>kern/pmap.c</code>中</li></ul><h4 id="链表宏-Exercise-2-2"><a href="#链表宏-Exercise-2-2" class="headerlink" title="链表宏 - Exercise 2.2"></a>链表宏 - Exercise 2.2</h4><p>更具体的链表宏其实在Thinking部分已经提到了，这里不再过多展开。</p><p>在这里出现的链表形式与常见的双向链表有些不同，每一个链表项含有一个<code>field* le_next</code>，还有一个<code>field** le_prev</code>，其中的<code>le_next</code>很好理解，就正常指向下一个链表项，但是这个<code>le_prev</code>则是指向<strong>上一个</strong>链表项的<code>le_next</code>域：更直观地来说就是这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first-&gt;field.le_next = second</span><br><span class="line">second-&gt;field.le_prev = &amp;(first-&gt;field.le_next)</span><br><span class="line"><span class="comment">// **类型 = 给*类型取地址</span></span><br><span class="line">*(second-&gt;field.le_prev) = first-&gt;field.le_next = second</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.2已经可以完成了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)\</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != NULL)          \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.le_next-&gt;field.le_prev =                           \</span></span><br><span class="line"><span class="meta">            &amp;((elm)-&gt;field.le_next);                                        \</span></span><br><span class="line"><span class="meta">    (listelm)-&gt;field.le_next = (elm);                                       \</span></span><br><span class="line"><span class="meta">    (elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;                       \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>再有一个注意点就是，各个宏定义传入参数时要求的是什么类型：</p><p><code>head</code>参数就要求传入的是链表头的指针<code>&amp;</code>（本实验中指<code>Page_List *</code>）</p><p><code>elm</code>参数要传入链表项的指针<code>&amp;</code>（本实验中指<code>Page *</code>）</p><p><code>field</code>参数则传入的是链表项的指针（本实验中指的是<code>pp_link</code>）</p><blockquote><p>接下来的三个练习（2.3-2.5）针对的是在建立页式内存管理后中/后所需要用到的一些函数，这些函数的正确与否直接决定了分页管理能否正常运行（虽然<code>init</code>那里错了也会寄就是了，哈哈比如我）</p></blockquote><h4 id="page-init-Exercise-2-3"><a href="#page-init-Exercise-2-3" class="headerlink" title="page_init() - Exercise 2.3"></a><code>page_init()</code> - Exercise 2.3</h4><ul><li>  <code>page_init()</code>函数用于初始化空闲链表<code>page_free_list</code></li></ul><p>任务要求为完成函数：</p><ol><li> 使用链表初始化宏<code>LIST_INIT</code>。</li><li> 将<code>freemem</code>按照<code>BY2PG</code>进行对齐（使用<code>ROUND</code>宏为<code>freemem</code>赋值）。</li><li> 将<code>freemem</code>以下页面对应的页控制块中的<code>pp_ref</code>标为1。</li><li> 将其它页面对应的页控制块中的<code>pp_ref</code>标为0 并使用<code>LIST_INSERT_HEAD</code>将其插入空闲链表。</li></ol><p>还可以这样把任务具体化：</p><ol><li>对<code>free_page_list</code>初始化，使用<code>LIST_INIT()</code>宏</li><li>将<code>freemem</code>按<code>BY2PG</code>对齐，使用<code>ROUND()</code>宏</li><li>从划分的页表项指针<code>pages</code>开始，按照地址由低到高遍历：<ol><li> <code>virtual address &lt; freemem</code>：令<code>pp_ref = 1</code></li><li> <code>else</code>：令<code>pp_ref = 0</code>、使用<code>LIST_INSERT_HEAD()</code>宏插入<code>free_page_list</code>中</li></ol></li></ol><p>将任务具体化后，发现实际上前两步的实现相对简单，使用了头文件定义好的宏，或是复现之前出现过的操作，就不多展开了。重点在最后一步的遍历<code>Page *pages</code>上：</p><p>首先，循环可以使用<code>pages++</code>方法（<code>+</code>运算符重载），同样也可以使用<code>pages[i], i++</code>的做法，这样都能表示单次大小为<code>page</code>的地址位移</p><p>其次，直观地想要实现<code>virtual address &lt; freemem</code>的比较，需要获取到每一页的虚拟地址，实际上<code>pmap.h</code>提供了<code>page2kva</code>这个返回虚拟地址的宏</p><p>当然在这里也可以换个思路，不去转换<code>PPN</code>和<code>pages</code>，而把<code>freemem</code>这个虚拟地址转化为页表项相关的值，也就是找到<code>freemem</code>对应的<code>PPN</code>号：<code>PPN(KADDR(freemem))</code>，然后进行循环边界的判断即可</p><p>具体实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">  <span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">  LIST_INIT(&amp;page_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: Align `freemem` up to multiple of BY2PG. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">  freemem = ROUND(freemem, BY2PG);</span><br><span class="line">  <span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pages;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> freePPN = PPN(PADDR(freemem));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freePPN; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; npage; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;page_free_list, (pages + i), pp_link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-alloc-Exercise-2-4"><a href="#page-alloc-Exercise-2-4" class="headerlink" title="page_alloc - Exercise 2.4"></a><code>page_alloc</code> - Exercise 2.4</h4><ul><li>  如果能顺利完成并理解前面练习的话，这个也理应算是个水题了（</li></ul><p>任务要求为完成<code>page_alloc()</code>函数，这个函数取代了最初的<code>alloc()</code>函数，成为页式内存管理中申请内存时调用的函数</p><ol><li> 如果空闲链表没有可用页了，返回异常返回值。</li><li> 如果空闲链表有可用的页，取出第一页；初始化后，将该页对应的<strong>页控制块的地址</strong>放到调用者指定的地方。</li><li> 可能需要使用链表宏<code>LIST_EMPTY</code>或函数<code>page2kva</code></li><li> 实际上Use <code>LIST_FIRST</code> and <code>LIST_REMOVE</code>也在函数前面的注释里当作HINT了（</li><li> 顺带提一嘴，异常返回值也在那个注释写了，叫<code>-E_NO_MEM</code></li></ol><p>这个也就做一下空链表判断返回值，再取出<strong>第一页</strong>并清空即可，<strong>不要忘记清空的区域大小是多少</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">  &#125;</span><br><span class="line">  pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line">  LIST_REMOVE(pp, pp_link);</span><br><span class="line">  <span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">   * Hint: use `memset`. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line">  *new = pp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-decref"><a href="#page-decref" class="headerlink" title="page_decref()"></a><code>page_decref()</code></h4><ul><li>  函数作用是通过页控制块改变页框的引用次数，若出现空闲页则调用回收函数<code>page_free()</code>回收内存</li></ul><h4 id="page-free-Exercise-2-5"><a href="#page-free-Exercise-2-5" class="headerlink" title="page_free() - Exercise 2.5"></a><code>page_free()</code> - Exercise 2.5</h4><ul><li>  非常好水题，多来点（</li><li>  任务要求为完成<code>page_free()</code>函数，该函数回收空闲页面（判定方式为<code>pp_ref == 0</code>），插入<code>page_free_list</code>中</li><li>  提示：使用链表宏<code>LIST_INSERT_HEAD</code>，将页结构体插入空闲页结构体链表</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">  assert(pp-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Just insert it into &#x27;page_free_list&#x27;. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.5: Your code here. */</span></span><br><span class="line">  LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.1-2.5顺利结束，<strong>物理内存管理</strong>模块练习完成</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>在开始后续练习前，我们先了解一下实验环境中的虚拟地址分配：</p><h4 id="虚拟内存结构"><a href="#虚拟内存结构" class="headerlink" title="虚拟内存结构"></a>虚拟内存结构</h4><ul><li>32位虚拟内存：<code>PDX(va)PTX(va)offset (10 + 10 + 12)</code></li><li>页表项结构：<ul><li>  一级页表项<code>Pde = u_long = 物理页号权限位</code></li><li>  二级页表项<code>Pte = u_long = 物理页号权限位</code></li><li>  权限位与<code>EntryLo</code>寄存器的标志位排布一致：<code>NDVG0[7:0]</code>，具体内容我们放到后面的<code>TLB</code>部分再详细说</li></ul></li><li>二级页表系统的作用：<strong>虚拟地址\to物理地址</strong></li><li>一/二级页表偏移量（<code>PDX(va)/PTX(va)</code>）：从一/二级页表基地址出发，移动n个单位到达</li><li>一级页表<strong>项</strong>包含的<strong>页号</strong>是其对应的二级页表<strong>页</strong>的<strong>物理页号</strong></li></ul><blockquote><p>访问虚拟地址时，先通过一级页表基地址和一级页表项的偏移量，找到对应的一级页表项，得到对应的二级页表的物理页号，再根据二级页表项的偏移量找到所需的二级页表项，进而得到该虚拟地址对应的物理页号</p></blockquote><ul><li>  这个过程中需要将二级页表的物理页转换为物理地址，再转换为虚拟地址返回：<code>pgdir -&gt; PTE_ADDR(pgdir) -&gt; KADDR(PTE_ADDR(pgdir))</code>，<code>Pde* pgdir</code>是偏移后得到的一级页表项</li></ul><h4 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h4><ul><li><code>kseg0/kseg1</code>使用<code>PADDR/KADDR</code>进行物理/虚拟地址的转换，而<code>kuseg</code>使用<code>TLB</code>（实际上是页表项）进行转换</li><li>在创建页表时，可以使用<code>KADDR</code>进行转换（处于内核态 存疑 通过<code>kseg0</code>读取）</li><li><code>memset</code>等函数操控的都是虚拟内存，不能直接访问物理内存</li><li><strong>页表项与页控制块</strong><ul><li>  页控制块是内存管理最开始初始化的<code>pages</code>变量，它管理物理页面的属性（前驱后继、引用次数等）</li><li>  页表项是虚拟页管理中最小的映射单元，它管理虚拟页面映射相关的属性（有效与否等）</li><li>  页控制块\to页表项的高位值：<code>*pte = page2pa(pp)</code></li><li>  页表项\to页控制块：<code>pp = pa2page(*pte)</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/mmu.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096<span class="comment">// 定义了页面字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDMAP (4 * 1024 * 1024)<span class="comment">// 定义了一个一级页表页能管理的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12<span class="comment">// 移动获得二级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22<span class="comment">// 移动获得一级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03ff)<span class="comment">// 获取31-22位，一级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03ff)<span class="comment">// 获取21-12位，二级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xfff)<span class="comment">// 获得对应的页表基址或者物理地址基址(低12位为0)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的物理页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的虚拟页号</span></span></span><br></pre></td></tr></table></figure><h4 id="pgdir-walk-Exercise-2-6"><a href="#pgdir-walk-Exercise-2-6" class="headerlink" title="pgdir_walk() - Exercise 2.6"></a><code>pgdir_walk()</code> - Exercise 2.6</h4><ul><li>该函数的作用是：给定一个虚拟地址，在给定的页目录中查找这个虚拟地址对应的物理地址<ul><li>  如存在：返回页表项所在的<strong>虚拟</strong>地址</li><li>  如不存在：连对应页表项都不存在（PDX指向的<strong>页目录项</strong>为<strong>空或无效</strong>），则根据传入的参数进行创建二级页表，或返回空指针。</li></ul></li><li>注意，这里可能会在页目录表项无效且<code>create</code> 为真的情况，需要使用<code>page_alloc</code> 创建一个二级页表页，并应维护申请得到的物理页的<code>pp_ref</code> 字段</li></ul><p>（查物理地址）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pgdir_walk</span><span class="params">(Pde *pgdir, u_long va, <span class="type">int</span> create, Pte **ppte)</span> &#123;</span><br><span class="line">  Pde *pgdir_entryp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (1/3) */</span></span><br><span class="line">  pgdir_entryp = pgdir + PDX(va);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (2/3) */</span></span><br><span class="line">  <span class="keyword">if</span> ((*pgdir_entryp &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// not existent</span></span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">      <span class="keyword">if</span> (-E_NO_MEM == page_alloc(&amp;pp)) &#123;<span class="comment">// fail to collect a page to Page *pp</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">      &#125;</span><br><span class="line">      pp-&gt;pp_ref++;</span><br><span class="line">      *pgdir_entryp = page2pa(pp)  PTE_V  PTE_D;<span class="comment">// set Physical address of pp to it, and init 页表项</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *ppte = <span class="literal">NULL</span>;<span class="comment">// no need to create a page</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (3/3) */</span></span><br><span class="line">  <span class="comment">// Pte *pte_location = (Pte *)(*pgdir_entryp &gt;&gt; 12 &lt;&lt; 12) + PTX(va);</span></span><br><span class="line">  <span class="comment">// physical</span></span><br><span class="line">  Pte *pte_location = (Pte *)(KADDR(PTE_ADDR(*pgdir_entryp))) +</span><br><span class="line">                      PTX(va); <span class="comment">// get pte virtual address</span></span><br><span class="line">  *ppte = (pte_location);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>(*pgdir_entryp &amp; PTE_V)</code>是为了获取把目标一级页表项的有效位（使用位运算）</p><p><code>(KADDR(PTE_ADDR(*pgdir_entryp)))</code>获取目标一级页表项的虚拟地址，后面的加法表示二级页表偏移量，获得的是二级页表项地址</p><h4 id="page-insert-Exercise-2-7"><a href="#page-insert-Exercise-2-7" class="headerlink" title="page_insert() - Exercise 2.7"></a><code>page_insert()</code> - Exercise 2.7</h4><ul><li>  该函数的作用是将一级页表基地址<code>pgdir</code>中虚拟地址<code>va</code>所在<strong>虚拟页面</strong>指向页控制块<code>pp</code>对应的<strong>物理页面</strong>，并将页表项权限为设置为<code>perm</code>。</li></ul><p>（改变页表指的页面）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va,u_int perm)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) &#123;<span class="comment">// 页表项有效</span></span><br><span class="line">        <span class="keyword">if</span> (pa2page(*pte) != pp) &#123;<span class="comment">// 指向的物理页不同，删除页表项</span></span><br><span class="line">            page_remove(pgdir, asid, va);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tlb_invalidate(asid, va);<span class="comment">// 物理页相同，删除过时的 tlb 映射</span></span><br><span class="line">            *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 更新为 pp 所在物理页并置有效位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 va 所在的 tlb 表项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line">    <span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line">    <span class="type">int</span> temp = pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (-E_NO_MEM == temp) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Insert the page to the page table entry with &#x27;perm  PTE_V&#x27; and</span></span><br><span class="line"><span class="comment">     * increase its &#x27;pp_ref&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">    *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 同上，更新为 pp 所在物理页并置有效位</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  <code>pa2page(*pte)</code>：取得二级页表项具体值，并取高位（物理页号）转换为<code>page</code>类指针，这里就是取得虚拟地址指的物理页的<strong>page</strong>结构体</li><li>  <code>page2pa(pp)permPTE_V</code>：pp对应的物理地址基址（物理页号，低位为0），并增添<code>perm</code>与有效位</li></ul><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a><code>page_lookup()</code></h4><ul><li>  该函数的作用是返回虚拟地址<code>va</code>映射物理页的页控制块<code>Page</code>，并将<code>ppte</code>指向的空间设为<strong>二级页表项</strong>地址</li></ul><p>（查va对应的Page和Pte）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    Pte *pte;</span><br><span class="line">    </span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);<span class="comment">// 获取 va 对应的二级页表项</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp;&amp; (*pte &amp; PTE_V))) &#123;<span class="comment">// 页表项无效，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pp = pa2page(*pte);<span class="comment">// 由 *pte 取出对应物理页块</span></span><br><span class="line">    <span class="keyword">if</span> (ppte) &#123;</span><br><span class="line">        *ppte = pte;<span class="comment">// 写入二级页表项地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp;<span class="comment">// 返回页控制块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a><code>page_remove()</code></h4><ul><li>  删除虚拟地址<code>va</code>在指定程序中所对应的<strong>物理页面</strong>映射</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    pp = pgdir(pgdir, va, &amp;pte);<span class="comment">// 查找对应的页控制块</span></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 没有映射，返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pp);<span class="comment">// 减少物理页引用次数</span></span><br><span class="line">    *pte = <span class="number">0</span>;<span class="comment">// 清楚原有页表映射</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 tlb 中的页表映射</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟内存与-TLB"><a href="#虚拟内存与-TLB" class="headerlink" title="虚拟内存与 TLB"></a>虚拟内存与 TLB</h3><h4 id="CP0-寄存器-EntryHi、EntryLo、Index"><a href="#CP0-寄存器-EntryHi、EntryLo、Index" class="headerlink" title="CP0 寄存器 - EntryHi、EntryLo、Index"></a>CP0 寄存器 - EntryHi、EntryLo、Index</h4><ul><li>  CP0 寄存器 EntryHi 与 EntryLo 分别对应到 TLB 的 Key 与 Data ，是 TLB 映射信息的来源</li><li>  ASID 与<strong>虚拟页号</strong>位于 EntryHi 中</li><li>  有效位、可写位等标记位与<strong>物理页号</strong>在 EntryLo 中</li><li>  <code>Index</code>寄存器中存放访问的 TLB 的标号</li><li>  TLB 相当于一小段常用的<strong>直接映射页表</strong>，使用虚拟页号 + ASID 直接得到物理页号及相关信息</li></ul><p>软件通过使用 CP0 寄存器和下面的汇编指令，把两个寄存器中分别存放的页号形成映射，存入 TLB 内部</p><h4 id="TLB-相关汇编指令"><a href="#TLB-相关汇编指令" class="headerlink" title="TLB 相关汇编指令"></a>TLB 相关汇编指令</h4><p><code>tlbr</code>：将<code>Index</code>的值作为索引，将当前索引指向的 TLB 表项<strong>读出</strong>至 CP0 寄存器</p><p><code>tibwi</code>：将 CP0 寄存器的值回写入 TLB 索引的表项内</p><p><code>tlbwr</code>：<strong>randomly</strong> 写入 TLB 表项内</p><p><code>tlbp</code>：根据 EntryHi 查询 TLB 内的表项，并将查找到的索引存入 Index 内（若不存在则将 Index 最高位置为1）</p><h4 id="TLB-维护与更新"><a href="#TLB-维护与更新" class="headerlink" title="TLB 维护与更新"></a>TLB 维护与更新</h4><ol><li> 更新页表中虚拟地址对应的页表项的同时，将 TLB 中对应的<strong>旧表项无效化</strong></li><li> 在下一次访问该虚拟地址时触发 <strong>TLB 重填异常</strong>，对 TLB 进行重填</li></ol><h4 id="tlb-invalidate-Exercise-2-8"><a href="#tlb-invalidate-Exercise-2-8" class="headerlink" title="tlb_invalidate() - Exercise 2.8"></a><code>tlb_invalidate()</code> - Exercise 2.8</h4><p>填空上毫无难度，汇编函数相关过程需要进行一些思考，详细可以参考 Thinking 2.5内容</p><h4 id="do-tlb-refill-Exercise-2-9-2-10"><a href="#do-tlb-refill-Exercise-2-9-2-10" class="headerlink" title="do_tlb_refill() - Exercise 2.9 ~ 2.10"></a><code>do_tlb_refill()</code> - Exercise 2.9 ~ 2.10</h4><p>2.10类似于2.8，填空无难度，2.9的<code>do_tlb_refill</code>函数机制如下：</p><ol><li> 进入函数，取出<code>TLB</code>缺失的<strong>虚拟地址</strong>（<code>BADVADDR</code>）和当前进程的<code>asid</code>（<code>EntryHi[11:6]</code>）</li><li> 调用C语言函数 Exercise 2.10 的<code>_do_tlb_refill()</code>（<code>jal _do_tlb_refill</code>），获取虚拟地址对应的<strong>页表项</strong>（<code>Pte *</code>）</li><li> 填空指令<code>tlbwr</code>随机地把保存在<code>EntryHi</code>和<code>EntryLo</code>中的信息写入一条<code>TLB</code>中</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pte _do_tlb_refill(u_long va, u_int asid) &#123;</span><br><span class="line">  Pte *pte;</span><br><span class="line">  <span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">   *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry</span></span><br><span class="line"><span class="comment">   * &#x27;pte&#x27; associated with the virtual address &#x27;va&#x27; in the current address space</span></span><br><span class="line"><span class="comment">   * &#x27;cur_pgdir&#x27;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;pte&#x27; could</span></span><br><span class="line"><span class="comment">   * not be found, allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27;</span></span><br><span class="line"><span class="comment">   * succeeds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.9: Your code here. */</span></span><br><span class="line">  <span class="comment">// Page *pp = page_lookup(cur_pgdir, va, &amp;pte);</span></span><br><span class="line">  <span class="keyword">while</span> (page_lookup(cur_pgdir, va, &amp;pte) == <span class="literal">NULL</span>) &#123;<span class="comment">// 查询 va 的页表项和物理页</span></span><br><span class="line">    passive_alloc(va, cur_pgdir, asid);<span class="comment">// 调用被动分配函数分配物理页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG) = 4 * 1024 * 1024 - 2 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;address too low&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= USTACKTOP &amp;&amp; va &lt; USTACKTOP + BY2PG) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG) = 0x80000000 - 5 * 4 * 1024 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;invalid memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UENVS &amp;&amp; va &lt; UPAGES) &#123;</span><br><span class="line">        panic(<span class="string">&quot;envs zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UPAGES &amp;&amp; va &lt; UVPT) &#123;</span><br><span class="line">        panic(<span class="string">&quot;pages zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= ULIM) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kernel address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    panic_on(page_alloc(&amp;p));</span><br><span class="line">    panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), PTE_D));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80010000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP (ULIM + PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM 0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT (ULIM - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPAGES (UVPT - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENVS (UPAGES - PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTOP UENVS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UXSTACKTOP UTOP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEXT PDMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOW (UTEXT - BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="SLIST宏代码"><a href="#SLIST宏代码" class="headerlink" title="SLIST宏代码"></a><code>SLIST</code>宏代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#defineSLIST_HEAD(name, type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">slh_first</span>;</span><span class="comment">/* first element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_HEAD_INITIALIZER(head)\</span><br><span class="line">&#123; <span class="literal">NULL</span> &#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#defineSLIST_INIT(head) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = <span class="literal">NULL</span>;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (slistelm)-&gt;field.sle_next;\</span><br><span class="line">(slistelm)-&gt;field.sle_next = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (head)-&gt;slh_first;\</span><br><span class="line">(head)-&gt;slh_first = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = (head)-&gt;slh_first-&gt;field.sle_next;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">if</span> ((head)-&gt;slh_first == (elm)) &#123;\</span><br><span class="line">SLIST_REMOVE_HEAD((head), field);\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">else</span> &#123;\</span><br><span class="line"><span class="keyword">struct</span> type *curelm = (head)-&gt;slh_first;\</span><br><span class="line"><span class="keyword">while</span>(curelm-&gt;field.sle_next != (elm))\</span><br><span class="line">curelm = curelm-&gt;field.sle_next;\</span><br><span class="line">curelm-&gt;field.sle_next =\</span><br><span class="line">    curelm-&gt;field.sle_next-&gt;field.sle_next;\</span><br><span class="line">&#125;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_FOREACH(var, head, field)\</span><br><span class="line"><span class="keyword">for</span>((var) = (head)-&gt;slh_first; (var); (var) = (var)-&gt;field.sle_next)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_EMPTY(head)((head)-&gt;slh_first == <span class="literal">NULL</span>)</span><br><span class="line">#defineSLIST_FIRST(head)((head)-&gt;slh_first)</span><br><span class="line">#defineSLIST_NEXT(elm, field)((elm)-&gt;field.sle_next)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab2-Report</title>
      <link href="/2023/03/os/buaa-os-report-lab2/"/>
      <url>/2023/03/os/buaa-os-report-lab2/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab2-Report"><a href="#BUAA-OS-2023-Lab2-Report" class="headerlink" title="BUAA-OS-2023-Lab2-Report"></a>BUAA-OS-2023-Lab2-Report</h1><h1 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h1><blockquote><p>虚拟地址在系统中的使用</p></blockquote><p>根据指导书说明：</p><blockquote><p>而在实际程序中，访存、跳转等<strong>指令</strong>以及用于取指的<strong>PC寄存器</strong>中的访存地址都是<strong>虚拟地址</strong>。 我们编写的C程序中也经常通过对指针解引用来进行访存，其中<strong>指针的值</strong>也会被视为<strong>虚拟地址</strong>，经过编译后生成相应的访存指令。</p></blockquote><p>故在编写的C程序中指针存储的地址和汇编程序中<code>lw</code>和<code>sw</code>使用的值都是<strong>虚拟地址</strong>。</p><h1 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h1><blockquote><p>链表宏与对应的链表结构</p></blockquote><ul><li>  从可重用性的角度，阐述用宏来实现链表的好处。</li></ul><p>使用宏进行链表实现，一方面能够规范系统内所有链表的存在形式，达成结构上的统一，易于编码与链表维护； 链表宏中大部分传入的参数并不是链表项整体，而是不包含链表具体存放信息的一个<strong>结构体</strong>，这个结构体只负责管理链表指针。 我们利用宏对这个结构体进行处理，一方面统一链表操作，不限制可以使用链表的结构类型；另一方面能够降低链表指针与链表内容间不必要的耦合性，维护数据安全；使用预设结构还能保证链表结构的正确性。 查阅资料后得知，除了重用性角度外，使用宏定义还意味着放置在<code>queue.h</code>内的所有宏都是完整的，不需要编译为<strong>库文件</strong></p><ul><li>  分析<strong>单向链表</strong>、<strong>循环链表</strong>和实验中使用的<strong>双向链表</strong>在插入与删除操作上的性能差异。</li></ul><blockquote><p>头文件<code>queue.h</code>为C语言中的链表提供了更加标准规范的编程接口。如今的版本多为伯克利加州大学1994年8月的8.5版本。 每种结构都支持基本的操作：</p><ol><li> 在链表头插入节点</li><li> 在任意的节点后插入节点</li><li> 移除链表头后的节点</li><li> 前向迭代遍历链表</li></ol></blockquote><p>我们打开对应的文件<code>/usr/include/sys/queue.h</code>，可以发现其中不仅仅包含了我们使用的双向链表<code>LIST</code>、待分析的单向链表<code>SLIST</code>和循环链表<code>CIRCLEQ</code>，还有两个有尾链表结构<code>TAILQ</code>和<code>SIMPLEQ</code>（双向有尾/单向有尾），这5个数据结构共同构成了<code>LINUX</code>的链表宏定义（为节省空间，下文只拿出所需的定义进行解释，其他定义便不再详述<strong>，完整定义会贴在全文最后</strong>）</p><ol><li> 单向链表<code>SLIST</code>：</li></ol><p>单向链表（<code>Singly-linked List</code>）在结构上较为简单，链表项只包含一个指向下一个元素的指针 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260156076.png" alt="单向链表">  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入操作：<ul><li>  链表中插入（已知前驱元素指针）需要修改被插入项<code>slistelm</code>和自身<code>elm</code>的指针，即需要两条指令；</li><li>  插入第一个元素需要修改自身<code>elm</code>的指针指向原有的第一项，同时还需要修改<strong>链表头项</strong>的<code>slh_first</code>指向自身，也需要两条指令</li></ul></li><li>删除操作：<ul><li>  链表中删除（无前驱元素指针）需要判断是否前驱元素为链表第一个元素，是则归入第二类，不是则需要从头部开始遍历得到前驱元素，并修改前驱指针指向自身的后继元素，需要2n+2条指令</li><li>  删除第一个元素只需要修改链表头指向的链表项即可，即一条指令</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1或2n+2条语句</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 循环链表<code>CIRCLEQ</code>：</li></ol><p><code>LINUX</code>宏定义下的循环链表只存在双向循环链表<code>CIRCLEQ</code>一种，它是<code>Circular queue</code>的简写 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260200417.png" alt="循环链表"> 由于循环链表有头有尾，故链表头项包含两个指针：<code>cqe_first</code>和<code>cqe_last</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_HEAD(name, type)                                            \</span></span><br><span class="line"><span class="meta">struct name &#123;                                                               \</span></span><br><span class="line"><span class="meta">    struct type *cqh_first;     <span class="comment">/* first element */</span>                         \</span></span><br><span class="line"><span class="meta">    struct type *cqh_last;      <span class="comment">/* last element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时每个链表项与双向无尾链表<code>LIST</code>结构稍有不同，它有两个指向链表项的指针:<code>cqe_next</code>和<code>cqe_prev</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_ENTRY(type)                                                 \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *cqe_next;      <span class="comment">/* next element */</span>                          \</span></span><br><span class="line"><span class="meta">    struct type *cqe_prev;      <span class="comment">/* previous element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>由于可以提供双向+头尾指针，所以循环链表可以有多种插入方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do &#123;                \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do &#123;               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_HEAD(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_TAIL(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_REMOVE(head, elm, field) do &#123;                               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句，但需要进行额外的两次if分支判断</span></span></span><br></pre></td></tr></table></figure><p>在进行插入操作时，需要考虑到是否仅含一个元素的情况，这时需要对链表头项进行修改，与其他情况稍有不同（以INSERT_HEAD为例）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((head)-&gt;cqh_last == (<span class="type">void</span> *)(head))                              \</span><br><span class="line">        (head)-&gt;cqh_last = (elm);                                           \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;cqh_first-&gt;field.cqe_prev = (elm);                          \</span><br><span class="line">    (head)-&gt;cqh_first = (elm);  </span><br></pre></td></tr></table></figure><ol start="3"><li> 双向链表<code>LIST</code>：</li></ol><p>然后就是我们在实验中使用到的双向链表<code>LIST</code>，它与其他内置链表宏的最大区别就是链表项：<code>LIST</code>含有一个指针和一个<strong>二重指针</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *le_next;   <span class="comment">/* next element */</span>                              \</span></span><br><span class="line"><span class="meta">    struct type **le_prev;  <span class="comment">/* address of previous next element */</span>          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>也因为其能够进行双向操作，插入的方法也有多种</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field) do &#123;                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_HEAD(head, elm, field) do &#123;                             \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_REMOVE(elm, field) do &#123;                                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句</span></span></span><br></pre></td></tr></table></figure><p>这里需要注意执行向后插入的<code>INSERT_AFTER</code>和<code>INSERT_HEAD</code>都需要判断是否为最后一个元素，决定是否需要调整后继元素的<code>le_prev</code>指针 分析后可以看出，</p><ul><li>  单项链表<code>SLIST</code>执行插入的效率最高，但是删除时需要进行遍历操作以防止后续链表元素丢失，性能较差；</li><li>  循环链表<code>CIRCLEQ</code>执行插入的效率稍低于单项链表，删除效率要高于单向链表，但需要进行分支判断，也为常数级</li><li>  双向链表<code>LIST</code>插入效率与循环链表类似，删除效率略高于循环链表</li></ul><h1 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h1><p>查看<code>pmap.h</code>得知<code>Page_list</code>结构调用了<code>LIST_HEAD()</code>宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(Page_list, Page)                                               \</span></span><br><span class="line"><span class="meta">struct Page_list &#123;                                                             \</span></span><br><span class="line"><span class="meta">struct Page *lh_first; <span class="comment">/* first element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时还定义了<code>Page</code>结构体和<code>Page_LIST_entry_t</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(Page)                                                                   \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                               \</span></span><br><span class="line"><span class="meta">struct Page *le_next;  <span class="comment">/* next element */</span>                                          \</span></span><br><span class="line"><span class="meta">struct Page **le_prev; <span class="comment">/* address of previous next element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>于是可以得出完整结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page_LIST_entry_t</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">        </span><br><span class="line">        u_short pp_ref;</span><br><span class="line">    &#125;* lh_first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故选择C选项  </p><h1 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h1><ul><li>  请阅读上面有关R3000-TLB 的描述，从虚拟内存的实现角度，阐述ASID 的必要性。</li></ul><blockquote><p>ASID，Address Space IDentifier 用于区分不同的地址空间，同一虚拟地址通常在不同的地址空间中映射到不同的物理地址。</p></blockquote><p>也就是说，ASID用来标记当前虚拟地址所归属的程序号，如果访问的是其他程序的虚拟地址，通常会指向一个错误的物理地址。因此需要确保访问的请求来自特定的程序，于是采用了ASID作为保险，确定虚拟地址请求的来源。</p><ul><li>  请阅读《IDT R30xx Family Software Reference Manual》的Chapter 6，结合ASID段的位数，说明R3000 中可容纳不同的地址空间的最大数量。</li></ul><p>ASID段占用的数据位为[11, 6]，共6位，则意味着R3000中可容纳不同的地址空间的最大数量为64。</p><h1 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h1><ul><li>  tlb_invalidate 和tlb_out 的调用关系？</li></ul><p>打开<code>kern/pmap.c</code>文件并找到<code>tlb_invalidate</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">    tlb_out(PTR_ADDR(va)  (asid &lt;&lt; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知C语言函数<code>tlb_invalidate</code>调用了汇编函数<code>tlb_out</code></p><ul><li>  请用一句话概括tlb_invalidate 的作用。</li></ul><p>删除在序号为<code>ASID</code>的程序规划的虚拟空间中，虚拟地址<code>va</code>所在页在<code>TLB</code>中的页表项</p><ul><li>  逐行解释tlb_out 中的汇编代码。</li></ul><p><code>tlb_out</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mfc0 t0, CP0_ENTRYHI# 从CP0_ENTRYHI寄存器取值至$t0</span><br><span class="line">mtc0 a0, CP0_ENTRYHI# 将$a0的值存入CP0_ENTRYHI中</span><br><span class="line">nop</span><br><span class="line">tlbp# 查找 TLB 表项，将索引存入 Index 寄存器</span><br><span class="line">nop</span><br><span class="line">mfc0 t1, CP0_INDEX# 将索引取值至$t1寄存器</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line">bltz t1, NO_SUCH_ENTRY# 索引空，准备退出</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mtc0 zero, CP0_ENTRYHI# 清空ENTRYHI和ENTRYLO</span><br><span class="line">mtc0 zero, CP0_ENTRYLO0</span><br><span class="line">nop</span><br><span class="line">tlbwi# 清空 Index 对应的 TLB 项</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">mtc0 t0, CP0_ENTRYHI# 把ENTRYHI的值回存</span><br><span class="line">j ra</span><br><span class="line">END(tlb_out)# 结束 tlb_out 函数</span><br></pre></td></tr></table></figure><p> </p><h1 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h1><ul><li>  简单了解并叙述X86 体系结构中的内存管理机制，比较X86 和MIPS 在内存管理上的区别。</li></ul><p>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。其中分段可以将逻辑地址转换为线性地址，而分页可以将线性地址转换为物理地址。 并且x86允许存在不分页的情况，但不允许程序不分段 <strong>MIPS 与 X86 的 TLB 差别</strong> 其在于对 TLB 不命中时的处理上： MIPS 会触发TLB Refill 异常，内核的 tlb_refill_handler 会以 pgd_current 为当前进程的 PGD 基址，索引获得转换失败的虚址对应的 PTE，并将其填入 TLB，完了CPU 把刚刚转换失败的虚地址再走一下 TLB 就OK了。 而 X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。 </p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Exam</title>
      <link href="/2023/03/os/buaa-os-lab1-exam/"/>
      <url>/2023/03/os/buaa-os-lab1-exam/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-Exam"><a href="#lab1-Exam" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h1><blockquote><p>课下一时爽，课上<code>debug</code>火葬场</p></blockquote><h2 id="课下出锅力！"><a href="#课下出锅力！" class="headerlink" title="课下出锅力！"></a>课下出锅力！</h2><p>问题出在<code>%ld/%d</code>时负数的判定上（也就是判定<code>neg_flag</code>上）:我的判定方法是，<code>if (num &lt; 0)</code>则<code>neg_flag = 1; num = -num;</code>，这样对<code>ld</code>来说还说得过去，但是对于<code>int</code>类型就出问题了，<code>long</code>类型的<code>num</code>变量装了一个<code>int</code>的值，然后取相反数的时候却按着<code>long</code>类型跑的，然后补码尊贵的符号位就登场搞事情了（寄），还好课上一个多小时修出来了，要不然计组<code>P7</code>历史重演力！</p><h2 id="lab1-Exam-1"><a href="#lab1-Exam-1" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h2><blockquote><p>题目要求：修改我们课下编写的<code>vprintfmt</code>函数，使其能够支持新格式符（<code>format specifiers</code>） range ：<code>R</code>，同时要求格式符<code>R</code>也能使用与其他格式符同等的副格式符：即<code>&lt;flag&gt;</code>、<code>&lt;width&gt;</code>、<code>&lt;length&gt;</code>三个副格式符。 格式符<code>Range</code>的作用为：使用函数中接下来的两个<strong>整数参数</strong><code>a, b</code>，输出<code>(&lt;a&gt;,&lt;b&gt;)</code>字符串。这两个参数共用一组副格式符，受到的修饰相同。</p></blockquote><ul><li>  样例：对于下面的函数<code>range_1_check</code>，应该有其之后的输出：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">range_1_check</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;%s%R%s&quot;</span>, <span class="string">&quot;This is a testcase: &quot;</span>, <span class="number">2023</span>, <span class="number">2023</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;the range is %R, size = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This is a testcase: (2023,2023)</span></span><br><span class="line"><span class="comment">//the range is (1,9), size = 8</span></span><br></pre></td></tr></table></figure><ul><li>  解题流程：仔细看下来其实就是要在<code>vprintfmt()</code>函数里增加一种格式符的判断：<code>case &#39;R&#39;:</code>，作用是输出三个字符和两个整数（<code>%c%d%c%d%c</code>，当然这个<code>%d</code>是可能有副格式符的）；只需要判断一下输出的整数是<code>int</code>还是<code>long</code>就解决了，（然后课下出锅寄了一个多小时）</li><li>  BUG与坑点：课下对了就是对了，剩下的都可以抄<code>%c</code>和<code>%d</code>那里的</li></ul><h2 id="lab1-Extra"><a href="#lab1-Extra" class="headerlink" title="lab1-Extra"></a>lab1-Extra</h2><blockquote><p>题目要求：实现一个类似<code>fprintf</code>的函数<code>int sprintf(char *buf, const char *fmt, ...);</code>，将<code>fmt</code>字符串格式化输出到<code>buf</code>所在的内存空间中，且返回值应是<code>buf</code>中存放字符串的长度。 <strong>提示</strong>：可以调用<code>vprintfmt</code>函数进行协助输出</p></blockquote><ul><li>  样例：就不写了，可以拿个<code>fprintf</code>逝逝，效果一样的</li><li>这个考题完美回答了对于<code>vprintfmt</code>函数中不起作用的<code>void *data</code>形参和看起来有点复杂的函数形参<code>fmt_callback_t out</code>的问题：<ul><li>  函数中的<code>data</code>可以承载输出的目的地指针，在<code>printk</code>中我们输出至控制台，所以<code>data</code>的取值并不重要（最终以调用了<code>printcharc</code>函数作为具体输出）；但在这里实现的<code>sprintf</code>函数含有一个<strong>目的地</strong><code>buf</code>，所以我们需要把<code>buf</code>传入，负责接收所有需要输出的字符（写入<code>buf</code>指向的内存）</li><li>  函数中的<code>out</code>被称为回调函数参数，不过这个概念在这里并不重要，我们在解完题之后再来回顾。</li></ul></li><li>解题流程：实现思路与<code>printk</code>类似，顶层和中间层的调用都相同，不同的是最底层的输出方式：<ul><li>  <code>printk</code>使用<code>printcharc</code>写入控制台</li><li>  <code>sprintf</code>需要写入<code>buf</code>指向的内存</li><li>  （这是不是刚说过一遍）所以顶层函数照抄，我们重点实现这个替代原有<code>outputk</code>的新函数<code>outputbuf</code>（忘了啥是<code>outputk</code>的快回去看<code>lab1</code>讲解那篇文！）</li></ul></li><li>  <code>outputbuf</code>的实现：<code>void outputbuf(void *data, const char *buf, size_t len);</code></li></ul><p>如果能把<code>vprintfmt</code>整明白也挺容易看的，本函数应输出的字符串序列已经被安放在<code>buf</code>内，需要输出的长度为<code>len</code>，目的地为<code>data</code>；需要做的就是一个循环把字符搬运过去（记得末尾加一个<code>\0</code>） 这里的<code>\0</code>不需要考虑是否会导致下次再调用时没法接上，先取一下当前<code>data</code>的<code>strlen</code>，再从下一位（实际上是上一次写进去的<code>\0</code>）开始继续拼就可以了，最后又会是一个<code>\0</code>结束 附一种可能可行的实现方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *temp = (<span class="type">char</span> *)data + <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        *temp = buf[i];</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    *temp = <span class="string">&#x27;\0;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我课上的实现方法严格意义上不符合要求，因为传入的参数形式不同，但是给了警告也能照样跑（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> **data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    **(<span class="type">char</span> **)data = buf[i];</span><br><span class="line">    (*data) = (*data) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    **(<span class="type">char</span> **)data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主要不同体现在没有充当临时变量的char *temp，全程都是void **data取一层值后*data这个char *的自由移动，效果类似，不使用strlen也许效率会高一点？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于outputbuf传参不同，所以这里给vprintfmt传参也需要发生改变，所以说这样的做法不太合适，相当于改变了函数结构</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *place = buf;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  vprintfmt(outputbuf, &amp;buf, fmt, ap);</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)(buf - place - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>好了，课上的部分大概就是这些了，现在我们回来谈谈这个回调函数<code>fmt_callback_t</code>到底是个买</p><blockquote><p>回调函数，是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，并且被传参的函数<strong>使用了这个函数指针</strong>，我们就认为这是一个回调函数。 回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另一方（被传参函数）调用的，用于对某事件或条件进行响应。</p></blockquote><p>说白了，回调函数就是一个只能被他人调用的函数，而回调函数参数就是某个函数中已经<strong>固定好返回值、自身形参</strong>的参数（类型是函数指针） 那我们还拿<code>vprintfmt</code>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>fmt_callback_t out</code>，就是一个回调参数，实际类型是一个函数指针，接收者<code>vprintfmt</code>在自身内部对<code>out</code>函数进行调用，用于处理某些事件（这个例子中就是输出处理好的字符串），这样的处理虽然看起来有些繁琐，但是实际上给了<code>vprintfmt</code>函数非常强的<strong>可拓展性</strong>，输出函数的接口化，意味着它可以通过传入不同的输出函数，完成更复杂情况下、更多种类的输出任务（就比如<code>lab1-extra</code>这个输出到内存）。 如果只考虑输出控制台，实际上完全可以不传入<code>out</code>参数，直接使用<code>printcharc</code>函数完成任务。但强拓展性可不是一个简简单单的<code>printcharc</code>能受的住的（） 顺便提一嘴最好让同一个回调参数对应的函数类型都一致，否则可不一定能保证功能正确（反正编译器会先给你个难看的警告.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303202324203.png" alt="image-20230320232412341"> 实际上，在C语言库中还有很多这样的<strong>回调函数</strong>，其中我们用的相当多的一个就是<code>qsort</code>中的第四个参数：<code>cmp</code>。每次我们调用<code>qsort</code>，都需要事先写好<code>cmp</code>函数，并且传入<code>qsort</code>中，让其按照我们程序员事先设定好的规则进行排序。 写到这里我也才注意到，当时程设 + DS绕的一圈一圈的<code>cmp</code>参数格式，实际上正是C库的高拓展性所在：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先为了符合回调函数要求，无论编写怎样的<code>cmp</code>函数都要保证参数类型一致；而为了能够处理更多种类的数据（甚至结构体），形参被设置成了<code>const void*</code>，这样不管比较的是什么结构，传入形参后强制类型转换把引用解开就可以进一步处理了。所以虽然程序员用起来有点绕，但对C库来说，这样写绝对是件好事。 在编程过程中使用回调机制，可以更好地分离代码，使得应用层和驱动层尽可能分离，降低总代码的耦合性。 受教了。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT1-Summary</title>
      <link href="/2023/03/buaa-oo-unit1-summary/"/>
      <url>/2023/03/buaa-oo-unit1-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>UNIT1-递归下降 因为想把作业比较完整地记录下来，而不仅仅是提交一份作业、交差完事，所以会写的相对多一点（ 可能刚敲完报告的同学 or 已经看了 n 份报告的助教看这篇答辩会觉得很臃肿，但这就不关我事了（？） <strong>博客作业要求部分</strong> 包含在 <strong>作业完成情况</strong> 标题下</p></blockquote><h1 id="作业内容及完成情况"><a href="#作业内容及完成情况" class="headerlink" title="作业内容及完成情况"></a>作业内容及完成情况</h1><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><blockquote><p>指导书总结搬运，回顾用</p></blockquote><h3 id="三次作业任务描述"><a href="#三次作业任务描述" class="headerlink" title="三次作业任务描述"></a>三次作业任务描述</h3><ul><li>  第一次作业任务：读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>多变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。 在本次作业中，<strong>展开所有括号</strong>的定义是：对原输入表达式E做<strong>恒等变形</strong>，得到新表达式E，且E中不含有字符 <code>(</code> 和 <code>)</code> 。</li><li>  第二次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。 本次作业起，不再限制表达式内的括号层数</li><li>  第三次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用、求导算子的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。</li></ul><h3 id="设定的形式化表述"><a href="#设定的形式化表述" class="headerlink" title="设定的形式化表述"></a>设定的形式化表述</h3><blockquote><p>本节按不同作业中课程组的条目标定进行整合； 其中，条目前标定**[2]<strong>的是第二次作业的新增项目，</strong>[3]**同理</p></blockquote><ul><li>  表达式 → 空白项 [加减 空白项] 项 空白项 表达式 加减 空白项 项 空白项</li><li>  项 → [加减 空白项] 因子 项 空白项 ‘*‘ 空白项 因子</li><li>  因子 → 变量因子 常数因子 表达式因子｜[3]求导因子</li><li>  变量因子 → 幂函数 **[2]**三角函数 <strong>[2]<strong>自定义函数</strong>调用</strong></li><li>  常数因子 → 带符号的整数</li><li>  表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</li><li>  幂函数 → 自变量 [空白项 指数]</li><li>  自变量 → ‘x’ ‘y’ ‘z’</li><li>**[2]**三角函数 → ‘sin’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数] ‘cos’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数]<ul><li>  <strong>请注意输出三角函数时需要满足的形式化表述：内部元素为因子</strong></li></ul></li><li>指数 → ‘**‘ 空白项 [‘+’] 允许前导零的整数<ul><li>  <strong>指数一定不是负数，且输入的指数不得超过8</strong></li></ul></li><li>  带符号的整数 → [加减] 允许前导零的整数</li><li>  允许前导零的整数 → (‘0’’1’’2’…’9’){‘0’’1’’2’…’9’}</li><li>  空白项 → {空白字符}</li><li>  空白字符 → （空格） <code>\t</code></li><li>  加减 → ‘+’ ‘-‘</li><li><strong>[2]<strong>自定义函数</strong>定义</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项]] ‘)’ 空白项 ‘=’ 空白项 函数表达式<ul><li>  <strong>规定自定义函数在表达式输入前进行输入，需要预先输入自定义函数数量，且0\le num\le3</strong></li></ul></li><li>  <strong>[2]<strong>自定义函数</strong>调用</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项]] ‘)’</li><li>  **[2]**自定义函数名 →→ ‘f’ ‘g’ ‘h’</li><li>**[2]**函数表达式 →→ 表达式<ul><li>  <strong>第三次作业函数表达式中可以调用其他自定义函数，但保证不会出现递归调用的情况；同时调用自变量为常数的自身也不被允许)</strong></li></ul></li><li>  **[3]**求导因子 →→ 求导算子 空白项 ‘(‘ 空白项 表达式 空白项 ‘)’</li><li>  **[3]**求导算子 →→ ‘dx’ ｜’dy’ ｜’dz’</li></ul><h2 id="作业完成情况"><a href="#作业完成情况" class="headerlink" title="作业完成情况"></a>作业完成情况</h2><blockquote><p>虽然笨人很喜欢写东西，但耐不住笨人就是<strong>菜</strong>，三次作业全有bug（寄）</p></blockquote><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>简单分析过题面之后，可以分析出一个初步的构造顺序： 表达式项因子表达式\to项\to因子 再进行进一步分析后，可以发现题目中最基础的<strong>单元</strong>就是一个形如a*x^b*y^c*z^d形式的<strong>单项式</strong>，而无论是题干中出现的任何一种构成成分，都由<strong>一个或多个</strong>这样的单项式构成：</p><ul><li>  常数因子\to带符号整数：b=c=d=0</li><li>  变量因子\to幂函数：a\ne0\ \&amp;\&amp;\ bcd中仅存在一个值\ne0</li><li>  表达式：<strong>若干</strong>单项式相加</li><li>  <strong>因子</strong>：<strong>若干</strong>单项式相加</li><li>  <strong>项</strong>：<strong>若干</strong>单项式相加 前三个条目的安排相对直观，<strong>那为什么因子也需要用若干单项式相加来表示呢？</strong>原因在于这里没有写下的一条构成路线：</li></ul><p>因子表达式因子表达式</p><p>也就是说，表达式的组成也可以成为因子的一种，也容易理解： (2x+y+1)按照形式化表述显然属于因子，然而很明显其无法用<strong>一个单项式</strong>表示 而对于<strong>项</strong>，则由组合规则同理可知，不再赘述 于是第一次设计采用了：</p><ul><li>数据结构：统一的<code>HashSet&amp;lt;Values&amp;gt; values</code>字段存储对应条目的值，每一个<code>Values</code>都表达一个单项式；<ul><li>  使用<code>HashSet</code>这种不能便利取值的容器是第二次的罪魁祸首</li></ul></li><li>  计算方法：<code>HashSet.add()</code>方法表示相加，创建一个两重遍历容器的方法表示相乘</li><li>  类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192152189.png" alt="name"></li></ul><h4 id="实现过程-难点"><a href="#实现过程-难点" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h4><ul><li>  词法分析器<code>Lexer</code>：构建思路来自单元训练栏目，根据当前字符判断元素种类，再决定<code>Paser</code>的解析逻辑，考虑各种可能出现的字符才能避免解析时出现<code>Runtime Error</code>（换句话说，一般<code>RE</code>的话就是解析错了，或者是爆递归栈、爆堆等，结构不是很怪的话比较少见）</li><li>  <strong>符号与减法</strong>：直到很靠后的时候才想出去解析<strong>可能出现</strong>负号位置（共三个）的解决方案：先查询一下是不是负号，然后给一个标记位，控制到最后返回的表达式/项/因子的系数正负</li><li>  乘法实现：开始直接把两项<code>add</code>到一个容器了，后来才意识到需要<strong>按照分配律</strong>一项一项的加指数再<code>add</code></li><li>指数与 **0：n次方就把前面的元素乘个n次<ul><li>  特判0**0=1（三角函数特判，易锅）</li></ul></li><li>  化简-合并同类项：每次<code>add</code>时，遍历所有容器内已有元素，如指数完全一致则进行系数运算并放弃<code>add</code>操作；否则直接<code>add</code></li><li>  输出：为<code>Values</code>类配置了<code>ttoString()</code>方法，不重写原有的<code>toString</code>方法（出过锅），输出最终表达式中所有<code>Values</code>的<code>ttoString()</code>字符串</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192156742.jpg" alt="img"></li></ul><h4 id="debug与测试"><a href="#debug与测试" class="headerlink" title="debug与测试"></a>debug与测试</h4><ul><li>  强测得分/互测失分/互测得分：100/1(1bug)/0.75(1bug)</li><li>互测锅是后导空白字符，会一直解析直到<code>OutofIndex</code>报<code>RE</code>，挑战最短hack数据之：<code>x&amp;lt;space&amp;gt;</code><ul><li>  解决方案是预处理所有空白字符，忍痛在递归下降里用<strong>字符串处理</strong>，写了<code>replaceAll</code></li></ul></li><li>  互测刀到的是如果有形如factor*a，且a.length\ge2时，会只乘以贴近乘号的值</li><li>性能方面：x*x要比x**2短一个字符，x-1要比-1+x短一个字符，处理好这个优化点就能强测100了（确信<ul><li>  不要随便对输出用正则：</li><li>  消去1*x的无用系数，导致21*x\to 2x</li><li>  替换长的x**2为等价描述，导致x**21\to x*x1</li></ul></li></ul><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h4><p><strong>TLE，遂重构。</strong> 很遗憾，对于上一次的遍历查询值的操作来说，2s的CPU时间很明显不够祸祸的，所以只能换成<code>Map</code>类型便于查询 <code>Map</code>类型就要考虑采用什么作为<code>key/value</code>进行匹配，我采用了<code>&amp;lt;String, Values&amp;gt;</code>的键值对进行适配，为每一个项创建一个独特的字符串，且<strong>能够合并</strong>的项需要保证字符串相同（合并同类项时使用） 于是增添了一个新的<code>hashString()</code>方法，为每个<code>Values</code>创建字符串（生成<code>key</code>），这样其中的键值对都是<code>&amp;lt;Values.hashString(), Values&amp;gt;</code>形式的了；具体而言需要输出除了系数外的所有信息（xyz指数，<strong>三角函数</strong>的种类、指数、内部表达式、数量）。这也是这次重构中<strong>我遇到的的主要难点</strong> 其次是三角函数引入对<code>Values</code>类造成的改变，为了保证项中仅含单个三角函数时也能进行合并，故也采用类似<code>Values</code>的结构构建，键值对类型相同，此处的<code>String</code>则指三角内<code>expr</code>的<code>hashStringInValues()</code>（必须保证系数也一并输出，否则sin(x)和sin(2*x)将能合并） 最终结构为</p><h4 id="实现过程-难点-1"><a href="#实现过程-难点-1" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h4><ul><li>  <code>hashString()</code>方法：由于采用字符串比较，所以需要严格保证<strong>能够合并的项需要保证字符串相同</strong>这一要求，否则无法合并。那么就需要避免出现2*cos(x-1)和-3*cos(-1+x)不能合并的惨案。最简单有效的办法就是保证<code>expr</code>有序，这也是为什么最后架构采用了<code>TreeMap&lt;String, Values&gt;</code>（其实这里同时做了诱导公式，保证三角内<code>expr</code>第一项恒为正，避免了上述无法合并的情况）</li><li>  三角函数化简 - 特殊值：对于特殊值，也就是cos(0)=1、sin(0)=0；务必注意(sin(0))**0=1，不过我是在创建三角函数时就进行了其中<code>expr</code>特判，如果<code>expr.values = 0</code>就会返回0/1，而不是<code>sincos</code>，转化计算的优先度要高于乘方</li><li>  三角函数化简 - 诱导公式：已在<code>hashString()</code>方法中进行了解释</li><li>  三角函数化简 - 二倍角：对于二倍角优化比较复杂，简化下只处理了指数为1的sin二倍角和指数为2的cos二倍角/平方和</li><li>自定义函数与调用：创建类<code>ArtiFunc</code>用于存储函数相关数据，在自定义函数<strong>调用时解析</strong>对应函数名、因子，同时使用字符串替换原公式形参后直接进行完整公式的解析，并返回<code>TreeMap &lt;String, Values&gt;</code><ul><li>  在调用时才进行解析的做法可以有效避免被<strong>根本不调用</strong>的超高cost自定义函数刀掉</li></ul></li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192158265.jpg" alt="img"></li></ul><h4 id="debug与测试-1"><a href="#debug与测试-1" class="headerlink" title="debug与测试"></a>debug与测试</h4><ul><li>bug点：<ul><li>  自定义函数实参因子替换后，需要给因子加一层括号，否则可能会出现sin(f(x))\to sin(x*y)这样不符合形式表达的bug</li><li>  三角函数优化太容易出锅了，尤其是引入了新的机制<code>hashString()</code>，即使二倍角优化更改的是三角函数中某一个<code>expr</code>的值，但最后需要把整个<code>Values</code>的<code>hashString()</code>再存一遍（更新），经常在运算忘记更新导致合并出锅，反向优化甚至错误输出</li><li>  在优化过程中需要不断把合并掉的三角函数从容器中取出、运算、装入，这个过程需对元素进行深克隆，出锅后细化了<code>Calculator</code>类，支持了各种元素的深克隆方法（尽可能同名以减轻记忆压力）</li><li>  输出时，三角函数套括号的层数判断出了问题，具体为编写的<code>hasOneFactor()</code>判断不严谨，没有考虑到a*sin(a^{‘})的情况，仍然会输出一层括号，导致格式不合法</li></ul></li><li>  强测得分/互测失分/互测得分：88.7/1(1bug)/4.75(4bug)</li><li>  强测（20测试点）2×0分，4×性能非满分</li><li>  互测则全是优化的问题，bug修复就注释了四行优化函数摆了烂，下来还是好好修了修；</li><li>  刀到的是自己写了随机数据的测评姬，同时<code>SymPy</code>房里所有人的输出，谁不一样就拎出来批（×），bug还算比较多的</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181203783.png" alt="《你在强测中得到了 88.7702 分。》"></li></ul><p>《你在强测中得到了 88.7702 分。》 <strong>架构设计</strong> 第三次作业的实现在上一次作业的合理基础上反而更加简单，只需要实现求导功能和自定义函数相互调用两点即可 求导方法函数增添在原有的计算类<code>Caluculator</code>中，接受<code>TreeMap&lt;String, Values&gt;</code>，对每个单项的<code>Values</code>求导后返回一个盛放导数的新容器 自定义函数由于支持了声明时嵌套，所以为了使用简洁，改成了在声明时<strong>预解析</strong>的方式处理，但这样虽然方便处理函数，但没法解决第二次作业提到的高cost互测数据，有<code>TLE/MLE</code>风险 类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192214859.png" alt="name"> <strong>实现过程/难点</strong></p><ul><li>求导功能：修改<code>Lexer</code>支持解析求导文法，并在<code>Calculator</code>类中创建求导方法，返回输入<code>TreeMap&lt;String, Values&gt;</code>的导数；<ul><li>  为便于实现，我将求导功能分类，分别实现基础项a、a*x^b、sincos(expr)和可递归项的求导(sincos(expr))**e、sincos(expr1)*sincos(expr2)、x^b*sincos(expr1)[*sincos(expr)]?</li></ul></li><li>  自定义函数：只需提前解析自定义函数内容即可，注意替换调用时的因子对应</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192215413.jpg" alt="img"></li></ul><p><strong>debug与测试</strong></p><ul><li>bug点：<ul><li>  递归部分的求导函数，复杂的判断条件以及繁琐的操作（取出、运算、更新、放回等）使得方法复杂度远超其他方法，回想起来，编写的时候实际上也很头疼，出错其实也不出意外</li><li>  三角函数因子内含有自定义函数调用，这种组合可能会出现仅用一层括号就包住一个表达式的情况，然后在解析过程中就会因为文法问题出锅；解决方案是在输出自定义函数调用结果时也用一层括号包起来，表达式\to表达式因子，使其符合三角函数形式化表述</li></ul></li><li>  强测得分/互测失分/互测得分：85.7/3(2bug)/1(1bug)</li><li>  强测（15测试点）2×0分，1×性能非满分</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181202787.png" alt="image-20230318120226762"></li></ul><p>《你在强测中得到了 85.72 分。》</p><h2 id="作业总结"><a href="#作业总结" class="headerlink" title="作业总结"></a><strong>作业总结</strong></h2><p>首先要感谢上学期的先导课，有先导课做Java语言的基础极大地便利了我对基础语法的理解与运用，尤其是在第一次作业上，没有犹豫太多就选择了相对能够满足当前要求的架构（虽然后续需要重构，但完成了当时任务的要求）。其次，本单元作业通过构造一系列类间关系进行表达式的解析，使用了部分接口、继承、重写等Java语言特性。再其次，这次作业为<strong>递归下降</strong>的原理做了引入和解释，对之后的编译原理也许有一定助力作用</p><h3 id="设计模式思考"><a href="#设计模式思考" class="headerlink" title="设计模式思考"></a>设计模式思考</h3><p>在第一次作业中因为实现的功能比较简单，就没有涉及到深/浅克隆的处理；但是随着计算功能复杂化、容器深度变深（<code>Values</code>内又存放了<code>Map</code>类），深克隆逐渐重要了起来。虽然应该写序列化深克隆方法，但是当时完全忘记了<code>clone</code>方法能重写（），然后又造了轮子 功能类（计算类）与数据类（表达式组件类）要进行明确划分，避免一个类同时运行多种复杂函数。从第二次作业重构起，创建了一个单独的运算类<code>Calculator</code>，用于执行乘法、乘方功能，并在第三次作业中把求导功能也一并集成，反思这个设定应该为每一种运算创建一个类，避免<code>Calculator</code>类过于复杂。同时写的东西实际上没有写成<strong>静态方法</strong>（知识储备不足），导致每次计算都要<code>new</code>一个对象，虽然没有字段但也对运行时间、空间有一定的影响。</p><h3 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h3><p>肉眼可见的，复杂度飘红的方法都是功能复杂的方法，如[1]中的<code>toString</code>、<code>pow</code>方法；[2]中的<code>doubleSin</code>、<code>mergeInduction</code>方法、[3]中的<code>qiuDao</code>方法。同时，出锅的实际上也正是这几个方法，几乎无一幸免。 所以在编写代码的过程中要尤其注意行数多、判断循环条件复杂、功能复杂的方法，尽量将其功能<strong>分散</strong>、模块化，或者说可以方法多，别让方法难，否则单个复杂方法debug过于折磨，而多设方法、接口处还能进行调试检测，方便缩小错误范围。</p><h3 id="互测总结"><a href="#互测总结" class="headerlink" title="互测总结"></a>互测总结</h3><p>各次作业中强测出现的bug已在各自的<strong>debug与测试</strong>栏目中进行分析。对于互测部分，<code>hack</code>他人代码主要依靠自己随机递归思路生成数据+借助<code>SymPy</code>库实现的校对测评姬。</p><ul><li>  纯多项式使用<code>expand</code>进行比对、含三角函数则输出式相减与0比较，如遇合并项则选择人工核对（这里其实可以代入变量值进行比对，不过没写.jpg） 只能说自己写的逻辑确实不容易<code>hack</code>到自己，第一次作业的测评姬甚至<strong>不支持生成</strong>末尾空格，所以根本测不出来自己的bug；</li></ul><p>前期的数据空有一番大体量，但是覆盖度并不好，总有组合测试不到；后面改良版本则更多侧重0、±1等<strong>边界</strong>小数据是否会出现错误。 对于三角函数合并、求导，以及求导后再进行的合并化简，我设计了一个占比不同的导数内表达式生成机制，能够较充分地覆盖各类情况进行测试（能出现含<strong>0</strong>层三角函数的项，同时也按照等比的概率考虑到了多重三角函数嵌套的可能性和概率的合理性） 对于导数，应该生成：</p><ul><li>  5\% a</li><li>  5\% a*x^b</li><li>  10\% a*x^b*y^c</li><li>  15\% a*sincos(expr)</li><li>  15\% a*x^b*sincos(expr)</li><li>  25\% a*sincos(expr1)*sincos(expr2)</li><li>  25\% a*x^b*y^c*sincos(expr1)*sincos(expr2)\ expr1 =? expr2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Report</title>
      <link href="/2023/03/os/buaa-os-report-lab1/"/>
      <url>/2023/03/os/buaa-os-report-lab1/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab1-Report"><a href="#BUAA-OS-2023-Lab1-Report" class="headerlink" title="BUAA-OS-2023-Lab1-Report"></a>BUAA-OS-2023-Lab1-Report</h1><h1 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h1><p>不使用交叉编译，使用<code>gcc -c</code>对文件进行编译，对编译而尚未链接的文件进行反汇编可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc -c hello.c </span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;</span><br><span class="line">  17:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  1c:   5d                      pop    %rbp</span><br><span class="line">  1d:   c3                      ret    </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>不使用交叉编译，对编译出的可执行文件直接进行<code>objdump -DS</code>指令，可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc hello.c -o hello2</span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello2</span><br><span class="line"></span><br><span class="line">hello2：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .interp:</span><br><span class="line"></span><br><span class="line">0000000000000318 &lt;.interp&gt;:</span><br><span class="line"> 318:   2f                      (bad)  </span><br><span class="line"> 319:   6c                      insb   (%dx),%es:(%rdi)</span><br><span class="line"> 31a:   69 62 36 34 2f 6c 64    imul   <span class="variable">$0x646c2f34</span>,0x36(%rdx),%esp</span><br><span class="line"> 321:   2d 6c 69 6e 75          sub    <span class="variable">$0x756e696c</span>,%eax</span><br><span class="line"> 326:   78 2d                   js     355 &lt;__abi_tag-0x37&gt;</span><br><span class="line"> 328:   78 38                   js     362 &lt;__abi_tag-0x2a&gt;</span><br><span class="line"> 32a:   36 2d 36 34 2e 73       ss sub <span class="variable">$0x732e3436</span>,%eax</span><br><span class="line"> 330:   6f                      outsl  %ds:(%rsi),(%dx)</span><br><span class="line"> 331:   2e 32 00                cs xor (%rax),%al</span><br><span class="line"></span><br><span class="line">Disassembly of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line">0000000000000338 &lt;.note.gnu.property&gt;:</span><br><span class="line"> 338:   04 00                   add    <span class="variable">$0x0</span>,%al</span><br><span class="line"> 33a:   00 00                   add    %al,(%rax)</span><br><span class="line"> 33c:   20 00                   and    %al,(%rax)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如使用交叉编译<code>mips-linux-gnu-gcc hello.c</code>进行编译链接，并直接使用<code>objdump -DS</code>进行反汇编，则会返回如下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump a.out -DS</span><br><span class="line"></span><br><span class="line">a.out：     文件格式 elf32-big</span><br><span class="line"></span><br><span class="line">objdump: can<span class="string">&#x27;t disassemble for architecture UNKNOWN!</span></span><br></pre></td></tr></table></figure><p>出现如上错误是因为，需要使用交叉编译链所对应的反汇编工具才能解析，在我们的实验环境下就是<code>mips-linux-gnu-objdump</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ mips-linux-gnu-objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf32-tradbigmips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   27bdffe0        addiu   sp,sp,-32</span><br><span class="line">   4:   afbf001c        sw      ra,28(sp)</span><br><span class="line">   8:   afbe0018        sw      s8,24(sp)</span><br><span class="line">   c:   03a0f025        move    s8,sp</span><br><span class="line">  10:   3c1c0000        lui     gp,0x0</span><br><span class="line">  14:   279c0000        addiu   gp,gp,0</span><br><span class="line">  18:   afbc0010        sw      gp,16(sp)</span><br><span class="line">  1c:   3c020000        lui     v0,0x0</span><br><span class="line">  20:   24440000        addiu   a0,v0,0</span><br><span class="line">  24:   8f820000        lw      v0,0(gp)</span><br><span class="line">  28:   0040c825        move    t9,v0</span><br><span class="line">  2c:   0320f809        jalr    t9</span><br><span class="line">  30:   00000000        nop</span><br><span class="line">  34:   8fdc0010        lw      gp,16(s8)</span><br><span class="line">  38:   00001025        move    v0,zero</span><br><span class="line">  3c:   03c0e825        move    sp,s8</span><br><span class="line">  40:   8fbf001c        lw      ra,28(sp)</span><br><span class="line">  44:   8fbe0018        lw      s8,24(sp)</span><br><span class="line">  48:   27bd0020        addiu   sp,sp,32</span><br><span class="line">  4c:   03e00008        jr      ra</span><br><span class="line">  50:   00000000        nop</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="objdump参数意义"><a href="#objdump参数意义" class="headerlink" title="objdump参数意义"></a><code>objdump</code>参数意义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-D  反汇编文件中的所有section(节)</span><br><span class="line">-S  输出时按照C语言与汇编代码相对应的格式输出</span><br></pre></td></tr></table></figure><h1 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h1><p>使用我们编写的<code>readelf</code>程序对内核文件检查后得到的视图如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122303933.png" alt="image-20230312230359908"></p><p>使用<code>Linux</code>系统内自带的<code>readelf</code>指令对<code>readelf</code>文件和<code>hello</code>文件进行分析（使用<code>readelf -h readelf/hello</code>指令）可以发现两个文件的类型不同：<code>hello</code>是<code>ELF32</code>类型，而<code>readelf</code>是<code>ELF64</code>类型</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122307115.png" alt="image-20230312230745084"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122308042.png" alt="image-20230312230826009"></p><p>这说明我们的<code>hello</code>文件是32位的格式，而<code>readelf</code>则是64位的。我们打开<code>readelf.c</code>文件，发现其中的的数据类型前缀都是<code>ELF32</code>，也正是说明了这个程序负责分析32位的<code>ELF</code>文件。所以它不能分析身为64位格式程序的自己。</p><p>进入同目录下的<code>Makefile</code>文件查看，发现了两个文件在编译方式上的不同：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303130009343.png" alt="image-20230313000915321"></p><p>查阅相关资料后得知参数<code>-m32</code>：编译出来的是32位程序，既可以在32位操作系统运行，又可以在64位操作系统运行。这也恰好印证了<code>readelf</code>指令对于这两个文件的类型判定。</p><h2 id="补充：大小端转换"><a href="#补充：大小端转换" class="headerlink" title="补充：大小端转换"></a>补充：大小端转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小端-&gt;大端：</span></span><br><span class="line">UINT <span class="title function_">EndianConvertLToB</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p&lt;&lt;<span class="number">24</span>)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">8</span>)+(UINT)*(p+<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大端-&gt;小端</span></span><br><span class="line">UINT <span class="title function_">EndianConvertBToL</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">16</span>)+(UINT)*(p+<span class="number">3</span>)&lt;&lt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h1><p>在我们的实验中，系统启动被简化成了把内核加载到指定内存位置。</p><p>MIPS系统启动时首先接管的是<code>bootloader</code>，随后<code>Linker Script</code>把各个节映射到对应的段上，内核文件也在这时被加载到合适的地址空间中。</p><p>在<code>Exercise 1.2</code>中，我们补全了<code>kernel.lds</code>文件，把<code>.text</code>、<code>.data</code>、<code>.bss</code>三个段映射到了合理空间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Exercise 1.2 Your code here. */</span><br><span class="line"></span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = .;</span><br></pre></td></tr></table></figure><p>经过<code>Linker Script</code>文件的引导，内核代码就会被加载到<code>0x80010000</code>这段地址。再通过<code>ENTRY(_start)</code>的入口规定，如此便保证了我们能够跳转到内核入口</p><h1 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1.1"></a>Exercise 1.1</h1><h2 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h2><p>在<code>Exercise 1.1</code>中，我们需要使用指针对ELF头进行寻址后取值，那么这时使用指针取得合适的地址就是重点了</p><blockquote><p>C语言对指针的加法运算符进行了重载</p></blockquote><p>如果使用了<code>+</code>对地址进行运算，地址的位移量会自动根据加号前的数据结构调整。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Struct st * p = (Struct st*)p + a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体为：地址会向后移动<code>a*sizeof(Struct st)</code>字节</p><p>在我们的实验中需要在ELF头中寻找到节头表的入口，需要的行为是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line"><span class="comment">//binary、ehdr为ELF头地址；e_shoff为节头表入口偏移</span></span><br></pre></td></tr></table></figure><p>但是有的同学写成了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(ehdr + ehdr-&gt;e_shoff);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原本的<code>binary</code>类型为<code>const void *</code>，它的加法运算符向后移动的单位为1字节；而已经转型为<code>Elf32_Ehdr</code>的<code>ehdr</code>重载后则会向后移动一个<code>Elf32_Ehdr</code>大小的地址空间。于是虽然两个指针指向了同一个地址，<code>+</code>后的值也相同，但是运算后得到的结果却截然不同</p><h2 id="readelf-c文件的补全"><a href="#readelf-c文件的补全" class="headerlink" title="readelf.c文件的补全"></a><code>readelf.c</code>文件的补全</h2><p>实验目的为输出ELF文件的节头地址信息。</p><p>首先需要明确，我们需要的节头地址信息保存在节头表中每个项目的特定字段中（<code>Elf32_Shdr -&gt; sh_addr</code>）。并且这个<code>sh_addr</code>指向ELF文件中的每个节头所在地址。那么就需要我们从ELF表头访问到节头表，并对每一项遍历即可。</p><blockquote><p><strong>遍历每一个节头</strong>的方法是：先读取节头的大小，随后以指向第一个节头的指针（即节头表第一项的地址）为基地址，不断累加得到每个节头的地址。</p></blockquote><p>具体实现为根据<code>Elf32_Edhr -&gt; e_shoff</code>寻找到节头表入口地址、根据<code>Elf32_Edhr -&gt; e_shnum</code>获取节头表中所含有项的个数，并根据<code>Elf32_Edhr -&gt; e_shentsize</code>获取节头表长度，便于位移</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table;</span><br><span class="line">Elf32_Half sh_entry_count;</span><br><span class="line">Elf32_Half sh_entry_size;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (1/2) */</span></span><br><span class="line">sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line">sh_entry_count = ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size = ehdr-&gt;e_shentsize;</span><br><span class="line"><span class="comment">// For each section header, output its index and the section address.</span></span><br><span class="line"><span class="comment">// The index should start from 0.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sh_entry_count; i++) &#123;</span><br><span class="line"><span class="type">const</span> Elf32_Shdr *shdr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (2/2) */</span></span><br><span class="line">shdr = sh_table + i * sh_entry_size;</span><br><span class="line">addr = (<span class="type">unsigned</span> <span class="type">int</span>)(shdr-&gt;sh_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:0x%x\n&quot;</span>, i, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Exercise-1-2"><a href="#Exercise-1-2" class="headerlink" title="Exercise 1.2"></a>Exercise 1.2</h1><h2 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a><code>Linker Script</code></h2><blockquote><p><code>Linker Script</code>中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。</p></blockquote><p>在<code>Exercise 1.2</code>中，我们就要利用<code>Linker Script</code>，对内核文件的各节进行内存指派，找到对应节的地址。段是由节所结合组成的，因为节的位置改变了，所以段的地址也会相应地发生移动，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/* fill in the correct address of the key sections: text, data, bss. */</span><br><span class="line">/* Exercise 1.2: Your code here. */</span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>.</code>号用作<strong>定位计数器</strong>，通过设置<code>.</code>的地址，声明接下来的节会被按序安放在该地址后。（在<code>SECTIONS</code>中，默认初始的地址为0地址，所以需要先修改地址然后再安排节文件）</p><p>后面的代码如<code>.bss:&#123;*(.bss)&#125;</code>，表示将所有输入文件中的<code>.bss</code>节（右边<br>的<code>.bss</code>）都放到输出的<code>.bss</code>节（左边的<code>.bss</code>）中。</p><p>观察<code>kernel.lds</code>的其他代码，还能发现这个文件规定了程序的入口地址。我们的实验程序通过<code>ENTRY(_start)</code>设置<code>_start</code>函数作为入口地址开始运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Set the ENTRY point of the program to _start.</span><br><span class="line"> */</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure><p>而<code>_start</code>函数被安放在<code>/init/start.S</code>文件中</p><h1 id="Exercise-1-3"><a href="#Exercise-1-3" class="headerlink" title="Exercise 1.3"></a>Exercise 1.3</h1><h2 id="start函数的设置"><a href="#start函数的设置" class="headerlink" title="_start函数的设置"></a><code>_start</code>函数的设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">EXPORT(_start)</span><br><span class="line">.set at</span><br><span class="line">.set reorder</span><br><span class="line">/* disable interrupts */</span><br><span class="line">mtc0    zero, CP0_STATUS</span><br><span class="line">/* hint: you can reference the memory layout in include/mmu.h */</span><br><span class="line">/* set up the kernel stack */</span><br><span class="line">/* Exercise 1.3: Your code here. (1/2) */</span><br><span class="line">li sp, 0x80400000</span><br><span class="line">/* jump to mips_init */</span><br><span class="line">/* Exercise 1.3: Your code here. (2/2) */</span><br><span class="line">jal mips_init</span><br></pre></td></tr></table></figure><p>在<code>mmu.h</code>文件中我们可以查询到系统内核各部分内存分配情况，这里就能找到栈顶地址为<code>0x80400000</code></p><p>设置结束后汇编程序完成，就可以跳转入C语言的函数入口<code>mips_init</code>了</p><blockquote><p>我们使用<code>jal</code>、<code>j</code>指令进行函数的跳转。在不同文件链接时，链接器回对目标文件中的符号（包括函数名）进行重定位，修改跳向这些函数的地址，实现跨文件的函数调用</p></blockquote><h2 id="printk函数的实现"><a href="#printk函数的实现" class="headerlink" title="printk函数的实现"></a><code>printk</code>函数的实现</h2><p><code>printk</code>函数实现功能，底层上依靠的是<code>console.c</code>文件中<code>printcharc</code>函数对控制台进行字符的输出；</p><p>向上一层，<code>print.c</code>中的<code>vprintfmt</code>函数则通过<strong>格式化字符</strong>的形式对<code>console.c</code>中的函数进行合理调用，实现输出；</p><p>再向上一层，就是<code>printk.c</code>这个文件，它接收输出参数，并把<strong>变长参数表</strong>和传递给<code>vprintfmt</code>函数，最终实现字符的输出。</p><h3 id="变长参数表"><a href="#变长参数表" class="headerlink" title="变长参数表"></a>变长参数表</h3><blockquote><p><code>stdarg.h</code>头文件对变长参数表定义了一系列宏变量与变量类型：</p></blockquote><ul><li>  <code>va_list</code>：变长参数表对应的变量类型</li><li>  <code>va_start(va_list ap, lastarg)</code>：初始化变长参数表</li><li>  <code>va_arg(ca_list ap, 类型)</code>：去除变长参数表的下一个参数</li><li>  <code>va_end(va_list ap)</code>：结束变长参数表的使用</li></ul><p>声明方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list ap;<span class="comment">// 声明变长参数表</span></span><br><span class="line">va_start(ap, lastarg);<span class="comment">// 初始化参数表</span></span><br><span class="line"><span class="type">int</span> var = va_arg(ap, <span class="type">int</span>);<span class="comment">// 取出一个int类型的变量</span></span><br><span class="line">...</span><br><span class="line">va_end(ap);<span class="comment">// 结束当前的变长参数表</span></span><br></pre></td></tr></table></figure><p>回到我们的<code>printk</code>函数：<code>printk</code>本身接受了外部传入的不定长参数，创建了一个变长参数表，传入了<code>vprintfmt</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printcharc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        *((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outputk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputk</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="comment">// buf：输出的字符串指针；len：输出的字符长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                printcharc(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vprintfmt</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// 此处传入的out，实际上是outputk的函数指针，内部实际上在调用outputk函数进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line"><span class="comment">// fmt：传递的主字符串指针</span></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        vprintfmt(outputk, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自顶向下地：</span></span><br><span class="line"><span class="comment">// printk函数创建变长参数表，调用vprintfmt</span></span><br><span class="line"><span class="comment">// vprintfmt格式化参数表，调用outputk；</span></span><br><span class="line"><span class="comment">// outputk接收数据直接调用printcharc，实现功能</span></span><br></pre></td></tr></table></figure><p>具体实现不再说明</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol><li> 第一次完成<code>lab1</code>内容时还不能理解内核为什么能正常工作、函数为何能正常运行，只是按照指导书的说明进行补充而已。而恰是这个不理解，成了实验过程中的最大难题。只有完成内容后，再重新回过头来审视每一步，才能知道每一步的具体功效，明白实验过程中“那里”为什么要“那么做”。经常性的回顾对实验过程理解很有必要。</li><li> 完成实验过程中并没有查看除了需要填写代码文件以外的文件，然而，各个函数的实现过程与相关信息其实都藏在课程组为我们写好的其他文件中，读过一遍其他函数的定义、调用与功能，才让实验过程中填写的代码有理可据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 3</title>
      <link href="/2023/03/reading/response-paper-for-positive-psychology-lecture-3/"/>
      <url>/2023/03/reading/response-paper-for-positive-psychology-lecture-3/</url>
      
        <content type="html"><![CDATA[<p>“Marva Collins comes along and reframes the question. And her question becomes ‘how can we cultivate the seed of greatness in our students.” (0:04:52)</p><p>If a student has depression or other mental illness, we can’t just tell him that depression is wrong, you can’t do that. This method of correcting errors from the negative side cannot always be used. Instead, like the teacher, tell him what is right and what is beautiful and shining in life. In this way, students can understand the beauty of themselves and the world from a positive perspective, and can really help them out of difficulties.</p><p>“Happiness does not just come spontaneously when we negate unhappiness.” (0:25:34)</p><p>This sentence is very reasonable. From my perspective, life is like a ruler with scale. It is not enough to just go back to the origin from the negative half. To get real happiness, we must make changes and move forward to the positive side. These methods of change are what we really need in life. I think it is also very useful  to call on universities to teach these courses to discover the shining points of people, which was just like the author said.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 4</title>
      <link href="/2023/03/reading/response-paper-for-positive-psychology-lecture-4/"/>
      <url>/2023/03/reading/response-paper-for-positive-psychology-lecture-4/</url>
      
        <content type="html"><![CDATA[<p>“The problem is not lower these high expectations—that doesn’t matter. The problem is right versus wrong expectations. Not high or low, that won’t make a difference to our level of wellbeing. It is if we have right vs. wrong expectations.   </p><p>Hoping for changes created by one or two things happen in life probably cannot make us happier. The right expectation is to believe in change from within. Sometimes there is a huge barrier between the actual gain from one thing and our mental expectation. It’s the wrong expectation that make our mood upside down. However, the changes made by yourself when you absorbing the environment could help you last the sense of fulfilling. And it’s a critical way to bring happy from the outer life.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Record()</title>
      <link href="/2023/03/record/"/>
      <url>/2023/03/record/</url>
      
        <content type="html"><![CDATA[<p>23/03/09<br>网站正式启动，不过还只能通过IP访问。挂载了Sakurairo主题，也试着把两篇文章从公众号里搬了过来。不得不说wordpress这个写作后台还是不太适应</p><p>23/03/10 update<br>上军理课的时候接到邮件说，域名模板审批下来了，我直接放下手里的java开始搞解析。现在终于可以通过<a href="http://cookedbear.top/">cookedbear.top</a>访问啦！配置好之后也把站点里的分类随便写了写</p><p>23/03/11 update<br>今天申请了免费的SSL证书，现在访问支持https了，Chrome终于不再提示我“不安全”力！<br>之后可能会改改CDN给图片加个速之类的。还有个问题就是，首页这个图只要还在浏览器可见范围内，就会疯狂掉帧（</p><p>23/03/15 update<br>甲了，暂缓相关更新<br>同时发现评论的时区也得调一下</p><p>23/03/17 update<br>好点了，爬回来改网站，改了评论的时区了（大概），同时优化了一下缓存机制<br>红烧天堂真好玩（bushi</p><p>23/03/20 update<br>甲流那劲差不多过去了，还是有点咳嗽等等症状，问题不大了，等过十天半个月的冯如杯过去，就可以大张旗鼓回来写文了<br>lab1上机发现课下大锅，幸亏de出来了（）</p><p>23/03/26 update<br>学习暂告一段落，回来把主题改成了Sakura，至少现在自己电脑跑起来不会卡顿了。调了一下图床，给Gravatar改了一个代理，顺便在页首加了一个最后一次更新时间的显示。但是发布时间还是会显示8小时前，头大.jpg</p><p>23/04/14 update<br>发布时间和更新时间现在都能正常显示了， TOC 换了一个更好用的插件，基本上算成型了吧，有时间加一个分类页</p><p>23/04/16 update<br>前天加的灯箱插件寄了，点开一次灯箱之后图片就丢了，属实是逆天，回头再禁用掉吧。</p><p>23/05/05 update<br>在考虑需不需要转成 hexo 建站，wordpress 的写作风格有点难受，后台和主题也不太好管理。hexo 体验了一下，感觉特点就是轻量化，如果不加入新功能的话，静态站点应该是够用了。择日再议。</p><p>23/05/13 update<br>说到做到，直接迁移到 hexo 上了，之后慢慢来重新做一下配置吧。感觉比 wordpress 现有的主题灵活性要强不少，而且好歹有灯箱了（</p><p>现在问题就是：之前买了的服务器怎么整（）</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 5</title>
      <link href="/2023/03/reading/positive-psychology-5/"/>
      <url>/2023/03/reading/positive-psychology-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Just take some notes down. I didn’t follow the video all the time.</p></blockquote><p>The video first stated the question about the importance of happiness. Not only happiness can make us feel good, it can also contribute to our life, relationships, and other people.</p><p>Barbara Fredrickson says is that positive emotion has a revolutionary reason, beyond making us feel good.(0:26:35) Enjoying the happiness is quite excellent experience. When I was suffering from some bad messages, trying to find some joy, and happiness can pull me out of there for a while indeed. It’s useful to help us overcome the negative emotions(just work as positive side).</p><p>Positive emotions broad and build, which can lead to more positive emotions. Then the positive emotions continue to broad and build. So they function as a virtuous cycle, which is completely contrast to the situation negative emotions do. Hopefully, if we are, unfortunately, trapped in the cycle created by the bad emotions, just think about the happiness things, which can help us get out of the narrow and constrict to the broad and build.</p><p>Being put into a positive mood is a win-win situation, for who experiences it and who give. Feeling positive can surely give us more motivation and energy to work further.</p><hr><p>The NO.1 causes of unhappiness is “equating to selfishness and immorality”, because people feel guilty for their own happiness. I think it’s quite suitable for me. When I gain something brilliant every time, I would think about the people around me. Is it <strong>fair</strong> for them? Can I take the joy just for myself? However the lecture told me that gain happiness for your self is a contribution indirect to other people’s happiness.</p><blockquote><p>Be the change you want to see in the world.</p></blockquote><p>People do what you do, more than what you say. The professor showed us that by a little experiment: ask students to put your hand on their cheek, while put his own hand on the chin. Amusingly, many students put their hands on their chin, including me. Cause I didn’t hear the actual word “chin” (lol). So quite right, the professor then add that, the optimal way spreading happiness is to work on your own happiness. Looking at your happiness, the people around you would surely influenced by your actions, cuz you are leading examples.</p><h2 id="Beliefs-as-Self-fulfilling-Prophecies"><a href="#Beliefs-as-Self-fulfilling-Prophecies" class="headerlink" title="Beliefs as Self-fulfilling Prophecies"></a>Beliefs as Self-fulfilling Prophecies</h2><p>Beliefs are self-fulfilling prophecies. Some time, subconsciousness stops us from moving forward. The barriers are not made by physical, medical, but mental.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延绵不绝的纯粹爱恋——观《相逢于明月映照的彼方》</title>
      <link href="/2023/03/galgame/rainbow-of-kanata/"/>
      <url>/2023/03/galgame/rainbow-of-kanata/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2697字</p><p>预计阅读时间：7分钟</p></blockquote><p>各位好，这次带来的是关于上次提到的补坑作品<strong>《相逢于明月映照的彼方》</strong>（偷懒下面就叫月彼了）的一些想法，作为tone work’s的第四作，游戏的整体内容配得上终极纯爱战士tone的一贯作风了（雨音线糖度拉满）；个人线路也各有千秋，但灯华线的表现实在让人……不好接受。在此处不做展开，来看下文罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-1.png"></p><h2 id="Part-1-tone-work’s"><a href="#Part-1-tone-work’s" class="headerlink" title="Part 1 tone work’s"></a><strong>Part 1 tone work’s</strong></h2><p>先来介绍一下tone work’s（tone社）吧 到现在为止tone社总共有4部作品：《初恋1/1》、《星织梦未来》、《银色遥远》还有这次提到的月彼。个人感觉tone的原画、音乐和系统演出基本无可挑剔，半清新画风的background图也称得上是壁纸级别了，不过你社真的缺一个把剧本写好的写手哇。总的来说，已经完成的后三部作品都属于高质量作，均可放心食用（1/1我没玩过就尴尬了）。话说回来，每次打开tone社的游戏，听到欢迎界面的7个单音（欢迎音）都感觉很安心，就和即将要玩的作品一样。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-2.png"></p><p>tone社社标</p><p>好闲话少说进入下一部分（</p><h2 id="Part-2-剧情介绍"><a href="#Part-2-剧情介绍" class="headerlink" title="Part 2 剧情介绍"></a><strong>Part 2 剧情介绍</strong></h2><p>如果，未来与过去被手机连接</p><p>你有什么后悔的事情选择重来？</p><p>高二那年的暑假</p><p>她们比谁都反复无常，比谁都不可捉摸</p><p>而且比谁，都楚楚动人。</p><p>第一次的恋爱。酸甜的回忆。</p><p>依依不舍，那是夏季的日子。</p><p>25岁的夏天</p><p>突然发现自己变成了上班族。</p><p>一边仰望天空，一边回想起梦一般的日子。</p><p>就像怀旧一般，把学生时代没用过的</p><p>智能手机启动了。启动短信应用程序后，</p><p>给自己发送短信。</p><p>后悔了吧</p><p>致过去的自己，无法传达的想法。</p><p>然而，智能手机振动了。</p><p>突如其来的事情</p><p>那是过去自己发来的邮件……</p><p>——来自萌娘百科相关页面</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-3.png"></p><p>游戏海报</p><p>不同于前几作的单纯学园纯爱作品，这次tone社加入了超自然因素（啊对就是你灯华手里拿着的恩底弥翁）以及数量众多的个人线，海报里出现的女主角都是有个人线的（右侧三位是在after篇社畜生活后开放的路线），所以游戏的体量也不小（但好像比银遥体积小不少欸）。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-4.png"></p><p>左起：新谷灯华、日紫喜うぐいす、佐仓雨音、<br>仓桥圣衣良、岬栞菜、松宫雾子、月ヶ洞きらり</p><p>作为社畜后选择的三人组路线和圣衣良线并没有对手机有过多的涉及，和核心故事的关联也不密切，这里就不再着笔叙述了（绝对不是因为二刷的时候没玩然后已经忘了内容了）关于游戏的配乐我就不多说什么了直接上图吧（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-5.png"></p><p>喵？</p><p>游戏的系统制作也很精良，动态效果等等都十分顺滑，顺带一提，第一次看到过场动画都这么艺术的我实在是叹为观止  </p><h2 id="Part-3-人物线浅析"><a href="#Part-3-人物线浅析" class="headerlink" title="Part 3 人物线浅析"></a><strong>Part 3 人物线浅析</strong></h2><h3 id="Rein-Side"><a href="#Rein-Side" class="headerlink" title="Rein Side"></a><strong>Rein Side</strong></h3><p>先看雨音线吧，作为官方认定的亲女儿，雨音在游戏发售的不久就增加了个人FanDisk（Sweet Summer Rainbow），全程发糖，糖度过高（大喜），在游戏本体的表现也算不错，虽然没有FD里的心态变化那么丰满自然，但是本体好好地承担了推进核心剧情的任务，没有把游戏玩成谜语真是太好了（</p><p>无论是恩底弥翁的本意，还是Rainbow与Kanata这样文字的小小解密；是雨音与父母短暂地相见，抑或是接受现状后的继续前行，都把游戏想传达出的点给到了。虽然说部分玩家评论雨音这个角色媚宅元素浓，但我在这一点保留一个中立态度，正因为是游戏，所以保有一些幻想的观点我认为无可厚非；削减糖度柔化人设让剧情故事更加平衡这种想法我更是表示欢迎。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-6.png"></p><p>但无论如何，感动永远是雨音线中不可或缺的重要组成部分，过多的不再言及，请诸位自行品味罢，如果想要深入了解雨音这个人设定位的话，强烈建议再补一下FD，失去了高度集中主线的约束，雨音的心理成长算是成为了其中聚焦的重点，嘛，反正不玩也不会怎样就是了。   </p><h3 id="U-guisu-Side"><a href="#U-guisu-Side" class="headerlink" title="_U_guisu Side"></a>_U_guisu Side</h3><p>学姐线走的是一种扑面而来的文艺风，始终是一首不浓不烈的爱情诗，没有一种喧宾夺主的色彩，通线的时候就很舒服，我也很喜欢学姐线的主题曲《月之钟》</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-7.png"></p><p>（每当钟声响起的时候/我想起的 是二人如诗般的过往）<br>哇我真的爱死这句</p><p>两人第一次在湖心岛许下诺言时确实心旷神怡。虽然这部作品刻画的学姐形象不很戳我，但是这种青涩、文艺、甚至可以称作优雅的恋爱经历却是令我向往的。本篇写下的是学姐虽然患病不久于人世但仍旧选择与奏汰共度剩余的时光。</p><p>但after篇接续的却是学姐的绝症可以治疗，但学姐已经因为自己患病离去的消息，意识到这一点的奏汰充满了痛苦与自我厌恶，但多亏恩底弥翁给了他重新选择的机会——让学姐前往国外医治疾病，重写这段历史，也因此他不得不对过去的自己出违心的主意，为的就是让莺学姐远离自己出国医治，而自己独自承受着内心的愧疚和来自过去的自己的埋怨。所幸在故事的最后满月之时，修正过的历史同步，两人重新在月之钟下约定诺言，故事驶向终章。 </p><h3 id="Duca-Side"><a href="#Duca-Side" class="headerlink" title="Duca Side"></a>Duca Side</h3><p>灯华在海报里这C位可不是白占的，本篇的表现确实不错，留下的观感很好，第一次推的时候还留了一个挺好的印象，结果进了after篇就开始拉大胯，剧本直接放弃了在成年后的时间线中推动剧情，索性让成年奏汰借助手机跨越时空起了一个远程军师的作用，但归根到底还是高中那点事，更类似于一种if线的展开，而且剧情衔接上总感觉莫名其妙，说不出的怪异点，怎么看怎么不舒服。如果只看本篇，甚至灯华的消失我都可以当成结局，但是这after的下饭操作我是真不太懂。</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>游戏的缺点不多但也明显，有一部分对手机必要的解释被放置在了雨音线里，如果没有先通雨音线的话在其他路线中感觉起来会有些牵强，以及灯华线这莫名其妙的塞粪感emmm ，其他方面都可圈可点，仍值得一试。  </p><p>其中特别要说的就是tone社特有的分段式恋爱了，不同于窗社等同样注重校园恋爱的会社，tone更倾向于抓住“生活”，没有用一句话勾勒几年，也不会对一个节点过度过度地抒写，这样的优点就让tone社作品地节奏很舒服，并没有赶着人往前走的急迫感，也能切实地感受到情感的变化、剧情的推进等。</p><p>但相对而言，这类“陪伴”型作品的剧本通常要长上不少，有时生活琐事都会成为游玩时的一大感触，可以说，有着这类特征的作品更像是散文诗篇，不进行浓墨重彩的挥洒，而是把情感放在平时不断地氤氲。个人认为这类用文本量换节奏的交换算是值得的，也正是如此，tone社的作品才会有这种悠长的回味，有更深的共感和感动罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-8.png"></p><blockquote><p>长久的陪伴，</p><p>才是这世上最深情的告白  </p></blockquote><p>谢谢谢谢你看到这里，因为咱小订阅号嘛看的人也不多，资源就送给关注我的大家啦 后台回复<strong>月彼</strong>或者<strong>相逢于明月映照的彼方</strong>就可以取本体和FD的链接了顺带一提里面攻略都做（翻译）好了，不给个赞鼓励鼓励？（逃）</p><p>再次感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天你学数分了吗？（1）</title>
      <link href="/2023/03/learning/engineering-mathematical-analysis/"/>
      <url>/2023/03/learning/engineering-mathematical-analysis/</url>
      
        <content type="html"><![CDATA[<p>近日来数分课程学习了数项级数（11章）和函数项级数（12章），倍感学习之苦（逃），所以就花了些功夫整理了下基础的笔记和定理之类的，当作个备忘录，也拿出来和大家分享分享，和同志们一起进步。其实11章算是为12章做下铺垫把，其中的重难点并不多，大部分是延续上学期末尾讲述的无穷积分部分，两者有相似之处。而12章的函数项级数相当于给数项级数多加了一个自由变化的未知量，虽然前面的题目也出现过类似的情况，不过当时是把它当作恒定不变的参数，而这里则成了探讨的一大重点。<br>类似的，12.4的幂函数内容也是对前面内容的一个拓延，把泰勒展开的完全形式搬了出来，让整个体系更加的完整。（也给我整不会了）</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/5.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/6.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/7.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/8.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/9.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/10.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/1.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/2.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/3.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Fundamental </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Fundamental </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于悲剧之下抗争，于星光之下颂歌——浅谈《水葬银货的Istria》</title>
      <link href="/2023/03/galgame/suisoginka-no-istria/"/>
      <url>/2023/03/galgame/suisoginka-no-istria/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共4099字</p><p>预计阅读时间：17分钟</p></blockquote><p><strong>『抛弃某人获得的未来，在我眼里已经失去了幸福的色彩』</strong></p><p>朋友们你们好啊，这是第二篇杂谈，今日也请多多指教。 </p><p>请注意：本文谈及的游戏包含少部分心理崩坏、监禁、血腥、欺诈等悲剧色彩的消极内容，同时也用那些不幸来衬托了真实与美好，在写作时我也尽量减少消极方面的涉及，如果您在我分享完杂谈过后对它还有兴趣的话，请来文末寻找回复词去体验，之后的分享估计也会提供相应资源吧（不咕的话）。</p><h2 id="Part-0-序言"><a href="#Part-0-序言" class="headerlink" title="Part 0 序言"></a><strong>Part 0 序言</strong></h2><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-9.png"></p><p>今天我们来谈谈发生在ルクル笔下架空世界的故事吧——那是一个关于眼泪、牺牲与恶意的故事、一部裹挟着英雄星光与向恶意反抗的<strong>正剧——《水葬银货的Istria》</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-10.png"></p><p>起初见到这部作品的时候，我并没有意识到它的杀伤力（哎你看回想里总共20个Hcg你告诉我这怎么输，怎么输啊哈哈哈哈哈），然后Episode1还没结束我就放弃了那个愚蠢的想法，至少没法笑着推进剩余的剧情了。 </p><p>为什么？ </p><p>因为这个故事的起源本就是一场悲剧，孕育自悲剧的故事自然难有完美的结局啊kora（无emo意，这里代指游戏）。</p><h2 id="Part-1-相关信息"><a href="#Part-1-相关信息" class="headerlink" title="Part 1 相关信息"></a><strong>Part 1 相关信息</strong></h2><p><strong>日文名称</strong>：水葬銀貨のイストリア</p><p><strong>品牌</strong>：ウグイスカグラ</p><p><strong>剧本</strong>： ルクル</p><p><strong>又名</strong>：水葬银货、水葬银币的Istoria </p><h3 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h3><p>水上都城 · アメマドイ。<br>这座建于海上的人工岛是秀丽多姿的花锦之地。<br>住在此处的我们——身负着种种烦恼。礼仪端正、心地善良的青梅竹马、煤谷小夜。<br>异想天开的妹妹、茅崎 夕桜。<br>憧憬英雄的后辈、小不動ゆるぎ。<br>卡在小巷里的垃圾箱之中的、汐入玖々里。<br>还有本人、茅崎英士。<br>一连串的阴谋、事件在等待着心灵受创的我们。<br>时而赌上部室来玩神经衰落（卡牌游戏）。<br>又或与被抛弃的少女一起玩抽鬼牌。<br>在倾心于夜空中绽放的礼花时、又不禁想要填补残缺的空洞。<br>以自己的做法、为成事而努力拼搏。<br>这样的我、若能帮到谁的话——<br>「——向你约定、幸福的结局」<br>愿所有人都能露出笑容。<br>在这遗失了泪水的都市里、我们的成长物语拉开了帷幕——</p><p>（以上内容摘自网站2dfan<strong>）</strong> </p><h3 id="人物出场表"><a href="#人物出场表" class="headerlink" title="人物出场表"></a>人物出场表</h3><p>茅崎英士：男主，背负着事实的真相和许多重担，想要保护身边的一切。</p><p>汐入玖玖里：英士在垃圾桶中捡到的少女。</p><p>煤谷小夜：英士的青梅竹马，总是叫英士“哥哥”，有很强的依恋感。</p><p>茅崎夕樱：英士的一抹多，性格古怪离奇。</p><p>小不动摇：后辈学妹，正义感十足。  </p><p>井土谷祈吏：小夜的幼年玩伴、青梅竹马。</p><p>C·A：杀死小夜父亲的凶手（实为茅崎英士）。</p><p>八椚红叶：C·A的主人。</p><p>神峰灯：红叶的手下，C·A的同伙，英士的朋友。</p><p>久末紫子：久末家（最大势力）的现任当家，红叶的对手。</p><p>久末紫乃：紫子的妹妹，第三代人鱼姬。</p><p>茅崎征士：英士、夕樱的父亲，老坏蛋了（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-11.png"></p><p>茅崎英士</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-12.png"></p><p>汐入玖玖里</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-13.png"></p><p>煤谷小夜</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-14.png"></p><p>茅崎夕樱</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-15.png"></p><p>小不动摇</p><p>主线故事建立在一个架空的<strong>人鱼公主童话</strong>的基础上：很久以前，有一名无私为他人奉献的少女，她的泪水能够治愈一切伤病。她不断地为他人的幸福流泪，村民们也非常感激她，大家过着安定而平和的生活。</p><p>然而某日，少女意识到自己的泪水将折损寿命，于是便不再为村民流泪。贪婪的村民们对此毫不在意，仍然强迫少女为自己流泪，柔弱的少女只能在悲伤中不断消耗着所剩无几的生命，渐渐滋生了怨恨。最终，少女的生命走到尽头，化作泡沫回归大海。</p><p>临终前，她含恨诅咒这些没有血与泪的村民们永远无法流泪，而这竟成为了现实。惊慌失措的村民们为了赎罪，求得这位人鱼公主的原谅，将她生前最喜欢的苹果投入大海。</p><p>然而少女的怨恨并未因此消除，村民们世世代代失去了流泪的能力，无论遭到怎样的痛苦与悲伤，都无法流出一滴眼泪。</p><p><strong>Amemadoi</strong>，就是一座如此诅咒缠身的小岛。人人都向往其上久末医院传说中能够瞬间治疗任何创伤的魔术，可却不知道这辉煌的魔术是用一代代人鱼姬的性命与泪水堆砌而来的。而人鱼公主又难以寻觅，但当一个人心中充斥的只是为他人奉献的情感时，或许会有奇迹发生（？）。巧合的是，故事中的主人公或多或少都与人鱼姬有着不可割舍的联系。</p><p><strong>『鸟笼事件』</strong>，岛上的居民这样称呼它，那个彻底改变两个少女和一个少年命运的悲剧事件：</p><p>茅崎征士绑架了三人并实施了非法监禁，而且还施加了精神上的折磨。茅崎夕樱不再表露真实的情感，煤谷小夜成了没有“哥哥”就活不下去的依恋症患者，而英士不得不背负痛苦与真相前进。 </p><p>过多剧情不再在此讲述，文章已经很拖沓了（）顺带一提一个小点：赌场的Ace公子哥C·A，正是茅崎英士的日语发音的前两个音节（Chigasaki Eishi），背负着这样罪名前行的他，实在是可笑啊。</p><h2 id="Part-2-不足在何"><a href="#Part-2-不足在何" class="headerlink" title="Part 2 不足在何"></a><strong>Part 2 不足在何</strong></h2><p>先来说说差的地方吧：水葬银货中的败笔当为个人线的塑造。说实话，太不走心了：没有铺垫的冲突像是生硬补充出来的；离谱的剧情好像故意为了r18场景和选择个人线而准备，甚至。。。小不动摇这条线甚至还没让人回过味来，就在『我们舍弃了一切，自私地获得幸福』『爱之花，肆意怒放』这样自甘堕落的话语中落幕。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-16.png"></p><p>等会等会，请允许我来个问号❓</p><p>共通章中向往正义的小不动摇怎么最后反而选了最自私的一种ending方式？这不白塑造形象了？亏我还对这个阳光学妹有所好感（） </p><h2 id="Part-3-扑克与选择"><a href="#Part-3-扑克与选择" class="headerlink" title="Part 3 扑克与选择"></a><strong>Part 3 扑克与选择</strong></h2><p>主人公英士自小就用扑克战斗，所以选择肢的外观也像扑克一样，而这内容嘛。。。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-17.png"></p><p>这，这tm是人能想出来的阴间说法？不是说你打算拯救谁，那种成为英雄但整个故事差一点点圆满、只能保护一个人的遗憾；</p><p>而是说你打算抛弃谁，“见死不救”，把加害者的名头安在英士头上，让他永远无法逃离这个痛苦的选择。</p><p>真不愧是极恶啊，把绝望如此肆意播撒，确实符合痛苦这个关键词了。</p><p>而『都不抛弃』，却是直指TrueEnding的一个选择，很简单啊，选择其中的任何一方都代表着妥协，放弃了赢下去的希望。红叶也都会对英士表示“放弃你”的态度。</p><p>都不放弃，虽然意味着结局未知，但这种前路飘渺的感觉才给人以动力。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-18.png"></p><p>——在通往成功的赌桌前，最终的选项如上</p><p>是一鼓作气，选择Call（跟注）迎来逆转；还是冷静处事，选择Fold（弃牌）明哲保身呢？</p><p>『无论如何都不能放弃，开阔视野，保持冷静』</p><p>这是宗名教给他的原则，</p><blockquote><p>我不能放弃——所以『都不抛弃』</p><p>保持冷静——所以『Fold』</p></blockquote><p>正是在这种选择过后，英士才能以自己的真面目回应小夜，继续前行。</p><h2 id="Part-4-品鉴"><a href="#Part-4-品鉴" class="headerlink" title="Part 4 品鉴"></a><strong>Part 4 品鉴</strong></h2><p>啊终于来到了我最喜欢的音乐鉴赏环节</p><p>这次的配乐我久违的想打出满分，虽然所有的24首乐曲没有一首铿锵有力能够鼓舞人，但是大部分曲子也能在柔和的曲风中给人以力量。。。令人敬佩呐。</p><p>尤其是OP《アズライトの棺》，悲伤而悠扬的女高音孤独的歌颂着人鱼公主的故事，即使沉入海底，也会有人来将你守护。再配上MV的视觉效果，耀眼流转的微小光束与大体深蓝的背景色相互映衬，可以说是一种微弱的壮观吧。</p><p>而去除人声的Inst Ver更利用弦乐营造了更加深邃的意境，高低声部的糅合流畅而自然，连升近一个八度的副歌把前一秒的悲伤倏地放大，仿佛自己也沉没海底、想要挣扎。</p><p>综上，建议欣赏MV！（<strong>底端阅读原文一键享受！！</strong>）</p><p>啊什么你说CG？啊说实话有部分CG实在是比例崩坏严重，这边不放了，影响观感（） </p><h3 id="有关故事核心的一些想法"><a href="#有关故事核心的一些想法" class="headerlink" title="有关故事核心的一些想法"></a><strong>有关故事核心的一些想法</strong></h3><p>人鱼姬为什么能够流泪？是因为内心深处的悲伤？或是因为难以忍受的苦痛？我想，眼泪在Istria中象征的大概是一种无私，一种甘愿奉献的精神吧。</p><p><strong>玖玖里</strong>虽然遭受了姐姐的折磨，但她在姐姐生命危急时刻依旧想要救她，所以她成为了人鱼姬；</p><p><strong>夕樱</strong>和英士一同遭受了鸟笼事件，她可以为自己的哥哥奉献自己的一切，但相对的，她无法对其他人流泪，因为她并不能对所有人温柔；</p><p><strong>久末紫乃</strong>是故事中难得的、纯粹的善，相信着向阳的正义，即使化为泡沫死去也没有怨言；</p><p><strong>紫子</strong>既接受了紫乃的善意，也经历了久末家、茅崎征士的恶意，她在善与恶的夹缝之中走向了自我，但又难逃其重。</p><p><strong>茅崎英士</strong>的本质是温柔的，这毫无异议，但在鸟笼事件之后这份温柔则被恶意扭曲，成了无法宽容自己的枷锁，也成了他逃避和选择的借口。</p><p>所幸，故事最终迎来结局，他也能安心的放下虚伪的面具，让满是苦楚的温柔氤氲临终的紫子，了却掉她一桩心愿了啊。<br>鸟笼事件的受害者、加害者的家属、小夜的弑父凶手、紫子和红叶的C·A、夕樱和小夜的哥哥、摇的可靠前辈、祈使无法原谅的仇人——</p><p>难以想象吧，这些名号都是那个少年——茅崎英士肩上所背负的，他无法摆脱，更无法逃离；他一次次地被打倒，又一次次狼狈起身；他渴望反击，却又如此弱小。我相信结局的那一刻是他的经历和为他付出过的人鱼公主们的眼泪，真正的给了他勇气吧——那可贵的、抗争到底的勇气。  </p><blockquote><p>『当弱者怀抱正义，便可称之为英雄；当英雄开始抗争，他便开始闪耀光芒。』</p></blockquote><p>抗争作为本作的主旋律，从未停止过高鸣。抗争不是做做样子的口头抗议，而是要勇敢地选择艰辛的道路。仅仅是在抉择面前徘徊后选择放弃的行为是不足以称为抗争的，<strong>真正的抗争是在绝望的深渊中重新挺身，再次踏向失败与悲伤的漩涡。</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-19.png"></p><p>英士无法放弃，但他选择了<strong>放下</strong>；英士无法成为光鲜的英雄，但他依旧<strong>像英雄一般战斗</strong>；英士身上的身份是那么沉重，但他<strong>决意抗争</strong>，选择了走下去。 面对渺小的希望，他没有放弃，在胜负难料的赌桌上搏来了胜利。 </p><h2 id="Part-5-尾声"><a href="#Part-5-尾声" class="headerlink" title="Part 5 尾声"></a><strong>Part 5 尾声</strong></h2><p>虽然水葬银货TE走到最后一幕令人痛苦，但也处在能够接受的范畴之内，不过最后一幕我还是有所失望。并没有皆大欢喜的完美团圆结局，而是采用了英士与红叶继续周旋下去的留白作为结尾，这种结局也许难以让人——至少不能让我满意。很浅显，万物的团圆固然飘渺，但是在苦难的最后，迎接我们的还是苦难吗，最好不是，我相信这也不是水葬这部作品想要传达给我们的。 </p><p>生活不易，但我们仍要一步步向前走去，尽管我们是弱者，也要心怀正义，去做某人的英雄——即使英雄不过是个自我安慰的梦，我们还是要为某人，为那些为我们牺牲过的人们成为英雄，这便是在绝境中重新奋起的勇气。</p><p> 最后的最后，分享游戏OP的一段歌词吧：  </p><p>蒼く深い海の底から</p><p>从苍蓝幽深的海底</p><p>君を連れ出して　光を求める</p><p>将你救出  追寻着光芒</p><p>もう二度と離れてしまわぬように</p><p>为了不让你再次与我分离</p><p>この手伸ばして　護り続ける</p><p>我将伸出这只手  持续着守护</p><p>暗く冷たい海の底へと</p><p>逐渐沉入昏暗冰冷的海底</p><p>光を求めながら　泡となって消える</p><p>一边追寻着光芒  一边化为泡沫消失</p><p>辛辛苦苦写了这么多，求赞求关注求在看捏–后台发送 水葬银货 资源自提捏（</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那是将我们三色交织在一起的绘卷——聊聊《三色绘恋》</title>
      <link href="/2023/03/galgame/tricolour-lovestory/"/>
      <url>/2023/03/galgame/tricolour-lovestory/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2797字</p><p>预计阅读时间：12分钟</p></blockquote><h2 id="Part-1-序言"><a href="#Part-1-序言" class="headerlink" title="Part 1 序言"></a><strong>Part 1 序言</strong></h2><p>第一次写杂谈，各种想法肯定不够成熟，还请见谅。<br>第一篇，我们来谈谈国Gal<strong>《三色绘恋》</strong>(Tricolour Lovestory)。游戏发行于STEAM，以其超低的定价、庞大的文字量和CG数、刻画高中生活等等特点保有不错的口碑，前段时间公司也因为续集《三色绘恋S》因为版号问题被罚受玩家同情和支持。啊当然指的是在三色TrueEnd发行之前了。现在的情况确是一言难尽，我们之后再聊。</p><p>其实在推完序章之后就一直有为三色想写些什么的想法了，也许故事结构和剧本有不讨巧的地方，或许结局并不尽如人意，但它可以说是我玩过的最贴近日常生活的一款Galgame了。不同于美好的幻想故事、也不同于日G那活跃的校园生活，朋友、成绩、考试、升学，这些无趣的词充斥了我的高中生活，所以在玩到三色之后，便自然会有一种熟悉感和亲近感，就仿佛“啊，当时好像的确是这样过来的啊”，也会不自主地追忆一些东西吧。  </p><h2 id="Part-2-简介"><a href="#Part-2-简介" class="headerlink" title="Part 2 简介"></a><strong>Part 2 简介</strong></h2><p><strong>（可能没多少严重的剧透）</strong></p><p> 2005年，江城的暖秋。 童年有如被铁笼囚住一般，早已自觉为灰色浸染的男孩，第一次走进名为”艺术班”的教室之中。 </p><p>恰巧在同桌的位置上出现的，宛若冰山，却又似轻风薄雾的朝霞一般，紫水晶色的她…… </p><p>被”他们”焚毁象征着同那女孩回忆的画卷时，在炽热的火光下啜泣的，那一抹橘色的她…… </p><p>两个色彩截然不同的少女，同时伸出双手–相会、再会、交织、着色…… </p><p>是墨小菊十年的坚持为自己青涩的青春谱写的画卷， 还是文芷勾勒出梦中那被黑暗枷锁所束缚的世界。 </p><p>梦初醒已十年。 </p><p>三色，是梦中的绘恋。</p><p>故事发生在2005年的“江城武汉”（游戏开发山百合文化公司地址就在武汉，合理），游戏过程中也或多或少地体现了那个时代的小小标签。</p><p>从故事的第一幕开始算起，整个游戏剧情的时间轴（尾声就不计算在内了）总共覆盖了五个月，说长不长，说短也不算短。从盛夏到初冬、从重新和好到再度出发、从初次相识到决意前行，这三个人，这三抹颜色缓缓纠缠混杂，走向了两种截然不同的结局。</p><p>说邱诚“被灰色浸染”，是因为他的童年并不寻常，家长对他严加管教、大打出手，没有丝毫“自由”，但幸而他遇到了墨小菊，他童年里唯一的、不同于灰白的颜色，她一直温暖着他，帮助着他，默默地在后面支持着他，直到十年后，邱诚近乎毫无意义的“反抗”居然真的为他带来了意想不到的自由。不过换下这摇摇欲坠自由的代价，是他和墨小菊之间的关系。</p><p>在艺术班他遇到了“另一个她”，同为插班生，邱诚总是想要接近她，“保护”她，而文芷也承受不住那连绵不断从城墙外递来的善意，缓缓地降下了心防。“我们，真是一模一样呢”，是啊，都是一个人生活，都想寻求自由，都想回报温柔，他们看起来确实很像啊，不过，只是看起来而已吗。。。</p><h2 id="Part-3-浅析"><a href="#Part-3-浅析" class="headerlink" title="Part 3 浅析"></a><strong>Part 3 浅析</strong></h2><p>可以说，Ep0和Ep1的略显紧张的校园喜剧结束过后，邱诚的灰色便一直笼罩在我的心头，每一句台本下我都害怕会出现意料外的状况，这种微妙的平衡便会被一不留神地打破事实证明，也确实如此。</p><p>邱诚度过了一个扭曲的童年，所以他的很多观点和做法都被一并扭曲了；墨小菊伸出手去温柔地安慰他，所以他面对一切一切都想报以温柔。也正是这种扭曲了的温柔，把他们三人紧紧地束缚在这片灰暗的泥沼，难寻出路。</p><p>面对文芷，他仿佛看到了自己以前难获自由的影子，不断地想去帮助她、保护她，却总是忽视掉些什么，总是无功而返；面对墨小菊，他害怕自己的离开会伤害到她，所以他不断地隐瞒、不断地撒谎，播下一个谎言的种子，为的是阻止另一个谎言的破土而出。</p><p>但他没有想到，这所有的谎言都被墨小菊看在眼里；他更没有想到，这些谎言会在那一刻一齐盛开，把他和他的自以为是，统统绞杀在密不透风的“谎言之林”中。</p><p>“我没有一次怪过你，也没有一次觉得你有错，— —那为什么你就非得向我撒谎不可啊！”</p><p>之后的剧情我便不再多说，玩过的朋友可以回忆一下，没玩过的朋友，强烈建议你入一下，新年促只要5块啊，补库存都血赚的好吧（</p><hr><p>很明显，无论选谁，都是不可弥补的伤害，而且越是考虑到第三个人的心情，就越会把事情搞砸。“越是想完美的解决掉所有事情，越是连一件事情都做不好。”好友迟耀曾这么劝告，我深以为然。</p><p>后半程的游戏中，邱诚一直在做这样的工作，把一切抉择和责任都放在自己身上，两边都不想放手，自顾自地朝着自己心目中的方向前进，还会时不时地找借口安慰自己，可最终呢？只能让自己陷得越来越深，直到自己承受不住肩上的重量，才想要放下，但能和他并肩的人早已被他拖拽地伤痕累累，回天乏术。</p><p>因为我是菊党，所以我把墨小菊放在了最后，而过完文芷线后，我却愣是两天没敢动小菊线（刀麻了）。</p><h3 id="Violet-Side"><a href="#Violet-Side" class="headerlink" title="Violet Side"></a>Violet Side</h3><p>“人们总对触手可及的关怀置若罔闻，却好高骛远地追求海市蜃楼般的美好。”骆衍曾经这么说过。</p><p>也正是如此，相遇两个月的文芷教会了邱诚十年来相濡以沫的墨小菊都没办法教会的东西——爱。</p><p>虽然知道自己的父亲会影响他，但文芷还是没办法放弃邱诚的邀请，就算是在聚光灯下戴着镣铐起舞，就算是逃避过后如梦似幻的三天，也足以让文芷明白了邱诚和他的自由是多么的宝贵：“尝到这样甜头的她，还会愿意回去，回到那个冰冷的家吗？”所以他们没有过分停留，而是舔舐伤口过后一同径直走向了violet的终章。</p><h3 id="Orange-Side"><a href="#Orange-Side" class="headerlink" title="Orange Side"></a>Orange Side</h3><p>“墨小菊姐姐是大家的后盾，文芷姐姐带着大家一起往前走。”迟菓这样劝说文芷。</p><p>起初我不理解为什么在小菊线里依旧有这么多文芷的戏份，直到我再次读到这份剧情，邱诚和墨小菊两个人是不会前进的，只有文芷的加入，才让原本的两色转变为三色，未来更添变数。只有先解决文芷在邱诚心中迟迟纠结的问题，邱诚才能完全地接受墨小菊，不是因为青梅竹马，不是因为其他原因，而是对墨小菊十年的付出的响应，所以邱诚和墨小菊在心意相通后依旧优先解决的是文芷的考试，最终邱诚也狠下心来拒绝了文芷。也正是这些改变了文芷，让她反抗父亲“给我留下”的命令，明白了自己的追求、自己的自由。</p><p>“</p><p>先是试探，再是猜测。——最后庆幸不已，抑或大失所望。</p><p>我们如同植在裂纹的两端。随着地壳的迸裂，慢慢地越离越远。</p><p>尽力向彼此伸出的枝芽，慢慢地也因为不停地碰触，而磨损得圆滑而迟钝。</p><p>”</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>所幸，他们走了出来，从灰黑的泥沼中爬出，在千辛万苦确认到的信任中蹒跚向着Orange的终章。</p><p>这故事原本就不是对等的啊，哪会有完美的结局呢？那个说“我没关系的”女孩和那个说“我相信你”的女孩，她们又是怎么想的呢？对我来说，我想做的又是什么呢？回头望向那个等了你十年的女孩子吧，去感受她不离不弃的温柔触碰吧，去回应她十年来的妥协与支持吧，去让她变得幸福吧</p><p>毕竟，那可是黯淡无光的灰色和乐观活力的橙色交织的十年啊。</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab0-Report</title>
      <link href="/2023/03/os/buaa-os-report-lab0/"/>
      <url>/2023/03/os/buaa-os-report-lab0/</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab0-Report"><a href="#BUAA-OS-2023-Lab0-Report" class="headerlink" title="BUAA-OS-2023-Lab0-Report"></a>BUAA-OS-2023-Lab0-Report</h1><blockquote><p>写这一篇的时候还没准备要开博客，所以也就没想就直接截图了</p><p>算了盒了就盒了吧</p></blockquote><h1 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h1><blockquote><ul><li>  <code>git</code>中的<code>status</code>信息提示</li><li>  工作区、暂存区与文件树</li></ul></blockquote><p>首先使用<code>git checkout -b learnGit</code>，在本地创建并检出一个新的分支 然后再根据<code>Thinking</code>中给出的要求对<code>README.txt</code>文件进行一系列操作，并在操作后进行提交</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530699.png" alt="image-20230305153053676"></p><p>然后观察目录中的<code>Untracked.txt</code>、<code>Stage.txt</code>，其区别在于把<code>README.txt</code>移动到了暂存区，git显示的说明不同</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530519.png" alt="image-20230305152953421"></p><p>提交后再次修改文件，最终的<code>Modified.txt</code>内容如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051537728.png" alt="image-20230305153714706"></p><ul><li>  <code>add</code>前，<code>README.txt</code>文件不处于仓库跟踪范围内，在“未跟踪的文件：”分类中；<code>add</code>后被git追踪到修改记录，提示有修改、暂未提交</li></ul><p> </p><h1 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h1><blockquote><ul><li>  常见<code>git</code>指令：<code>add</code>、<code>commit</code></li></ul></blockquote><ul><li>  <code>add the file</code>：使git开始追踪某个文件，即<code>git add filename</code>指令</li><li>  <code>stage the file</code>：把修改过的文件加入暂存区，即<code>git add filename</code>指令</li><li>  <code>commit</code>：提交本次暂存区里保存的内容，回到初始状态，即<code>git commit</code>指令</li></ul><p> </p><h1 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h1><blockquote><ul><li>  使用<code>git rm</code>进行<strong>工作区</strong>文件删除</li><li>  <code>git checkout</code>使得<strong>暂存区</strong>文件回退至工作区</li><li>  使用<code>git checkout &lt;版本&gt; filename</code>进行其他版本的文件拉取</li></ul></blockquote><ol><li> 当本地文件被删除，但还没有提交时，可以使用<code>git checkout print.c</code>指令，把暂存区中的<code>print.c</code>文件拉到工作区</li><li> 执行<code>git rm print.c</code>后，不仅删除了工作区的文件，还把这次删除<code>add</code>到了暂存区，此时工作区和暂存区都不存在需要的文件了，可以使用<code>git restore --staged print.c</code>再把<code>print.c</code>的修改拉回工作区 （如果<code>commit</code>了还可以使用<code>git checkout HEAD^ &lt;filename&gt;</code>从上一个提交版本处把删除前的文件拉回本地）</li><li> 执行<code>git rm --cached &lt;filename&gt;</code>指令，可以只删去暂存区的文件内容，而不对本地的文件进行删除（与不加<code>--cached</code>对比）。可以使用这条指令，把文件从跟踪目录里移出</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051600387.png" alt="image-20230305160023353"></p><blockquote><p>进行实验时的部分操作</p></blockquote><p> </p><h1 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h1><blockquote><ul><li>使用<code>git reset --hard</code>进行git版本回退<ul><li>  可以回退<code>HEAD^^^^</code>或<code>HEAD~4</code>，也可以根据已知的<code>hash</code>值进行任意的跳转</li><li>  <code>--hard</code>会强制把工作目录中未提交的文件数据删除，<strong>并不做保留</strong>，使用前注意暂存区、工作区内容</li></ul></li><li>  <code>git log</code>信息与<code>git reset</code></li></ul></blockquote><ol><li> 先进行三次文件修改与<code>commit</code>操作：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051602484.png" alt="image-20230305160255454"></p><ol start="2"><li> 记录下的<code>git log</code>如下：提交3的hash值为<code>8974e1e6e98f726886103a13cba43fcd4fa08acf</code></li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051604438.png" alt="image-20230305160406404"></p><ol start="3"><li> 版本回退后查看log发现最近一次提交记录消失了：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051606728.png" alt="image-20230305160621703"></p><ol start="4"><li> 使用<code>git reset --hard &lt;hashcode&gt;</code>（hashcode填入提交“1”时的）回到了版本”1”；再把hashcode换成版本”3”的值，会切换回版本”3”</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051609979.png" alt="image-20230305160955957"></p><p> </p><h1 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h1><blockquote><ul><li>  重定向与管道</li></ul></blockquote><ol><li> 操作指令执行后显示如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051615424.png" alt="image-20230305161546400"></p><ol start="2"><li> <code>echo</code>指令向标准输出中输出后续内容，使用<code>&gt;</code>可把输出定向到符号后的文件（重写）；使用<code>&gt;&gt;</code>符号可把输出<strong>追加</strong>到目标文件中</li></ol><p> </p><h1 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h1><blockquote><ul><li>  重定向与文件</li><li>  <code>echo</code>指令与输出转义</li></ul></blockquote><ol><li> <code>command</code>文件使用了<code>echo</code>指令将每一行指令都输出到标准输出，再使用<code>&gt;&gt;</code>把输出重定向到<code>test</code>文件中，文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051639790.png" alt="image-20230305163906756"></p><blockquote><p>使用<code>echo</code>指令输出时需要注意转义字符的使用，如<code>$</code>、<code>&gt;</code>等字符都需要转义，否则会起到错误的效果 转义字符是<code>\</code>，不是<code>$</code>（后者是取值的意思）</p></blockquote><ol start="2"><li> <code>test</code>执行后的<code>result</code>文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051638470.png" alt="image-20230305163845452"></p><ol start="3"><li>结果说明：<ol><li> <code>test</code>文件中的所有没有重定向输出的<code>echo</code>语句都是提示性信息，并输出至控制台界面</li><li> 文件创建了三个变量，并分别对其进行赋值（其中变量<code>c</code>的值来自<code>ab</code>两变量的值之和）</li><li> 三个变量的值在有重定向的<code>echo</code>命令下被输出到对应的文件（<code>file1</code>、<code>file2</code>、<code>file3</code>）中，最终结果被连接并借助<code>file4</code>存入<code>result</code>中</li></ol></li><li><code>echo echo Shell Start</code> 与<code>echo `echo Shell Start` </code>效果是否有区别<ol><li> 没有区别，效果都是向控制台输出<code>echo Shell Start</code></li></ol></li><li><code>echo echo $c&gt;file1</code> 与<code>echo`echo $c&gt;file1` </code>效果是否有区别<ol><li> 有区别，前者向<code>file1</code>中写入了<code>echo \$c</code>信息；后者在控制台中输出了<code>echo \$c&gt;file1</code></li></ol></li></ol><p> </p><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><ul><li>  在<code>git</code>上，如果只按照最简单的操作去做的话目前还能正常使用，但如果出现版本选择、文件回退等操作就会因为许多指令不易区分而犯难，之后需要把各指令意义进行划分，匹配在图中便于记忆</li><li>  <code>awk</code>指令的使用，正则表达式该如何在<code>awk</code>中使用也是指令实现的一大难点</li></ul><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在lab0的课下实验中，我不仅复习了在<code>pre</code>阶段学到的知识：如git、makefile、文本处理、重定向，还对它们的具体实现有了更深的了解。在刚开始的学习过程中，<code>CLI</code>的使用、Linux基础命令、命令行参数的选取都是学习路上的困难，也是后面lab的基础。这些点需要勤练常用才能更好地运用在之后的实验中，便利之后的实验。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界，您好！</title>
      <link href="/2023/03/hello-world-1/"/>
      <url>/2023/03/hello-world-1/</url>
      
        <content type="html"><![CDATA[<p>欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
