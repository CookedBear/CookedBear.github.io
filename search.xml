<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>first temp</title>
      <link href="/2023/05/first-temp/"/>
      <url>/2023/05/first-temp/</url>
      
        <content type="html"><![CDATA[<p>wuhu</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/hello-world/"/>
      <url>/2023/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab4</title>
      <link href="/2023/05/buaa-os-probe-lab4/"/>
      <url>/2023/05/buaa-os-probe-lab4/</url>
      
        <content type="html"><![CDATA[<h1 id="Lab4-系统调用与进程创建"><a href="#Lab4-系统调用与进程创建" class="headerlink" title="Lab4 - 系统调用与进程创建"></a>Lab4 - 系统调用与进程创建</h1><p>Lab4 中主要涉及到以下内容：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><blockquote><p>首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，<strong>请善用目录！</strong> 其实最不好理解的部分是在汇编代码和C代码之间切换的部分，可能一些宏定义、编译器的一些操作就会漏掉很多细节。 所以，时不时用用 <code>make objdump</code> 吧！努力成为 buaa-os 领域大神（？</p></blockquote><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在计算机组成原理实验 P7 与 Lab3 中，我们大致已经能够理清异常的原因、怎样产生与处理的方式了，但在 MOS 之前提到的异常大多不能由用户主动触发（时钟中断、TLB MISS 等），接下来我们就要深入了解一种特殊的、可以<strong>由用户主动发起的异常</strong>：系统调用 <code>syscall</code></p><ul><li>  异常发生的原因：出现某些不符合操作规范的指令、外部中断、syscall 指令</li><li>  产生地点（硬件）：指令流水至（M级）时 CP0 协处理器分析异常，修改 SR、Cause 等寄存器，使得当前 PC 跳转至异常处理程序入口（<code>0x80000000</code>）</li><li>  异常处理（软件）：异常处理程序对 CP0 记录的信息进行分析，选择对应的 handler 函数并跳转；对应 handler 处理结束后通过 ret_from_exception 汇编函数返回 EPC，程序继续执行</li></ul><p>我们想要使用 syscall 指令，为的就是<strong>进入内核态</strong>，让操作系统为用户执行某些任务，这些任务出于安全等考虑，只有内核才能完成，所以在调用 syscall 时，就不可避免地要进行 CPU 状态的切换（标记于 SR 寄存器的 KUc 位中）</p><h2 id="系统调用在干啥（）"><a href="#系统调用在干啥（）" class="headerlink" title="系统调用在干啥（）"></a>系统调用在干啥（）</h2><p>在详细了解系统调用前，还有必要再补充一下进程运行时的虚拟空间知识（<strong>可以补充在Lab3中？</strong>） 每个进程，都有相同的虚拟地址划分方式，并按照 mmu.h 文件中所示进行排布。每个进程都具有一张这样的表。同时每个进程的 kseg0、kseg1 段也都存放（或者说映射）着内核相关的数据结构，存在于所有进程的虚拟空间中，相当于被所有进程<strong>只读共享</strong>。所以为了方便使用，它们被整体映射到物理地址的固定区域；对于 kuseg 段，用户的页表和虚拟地址相结合，会指向物理内存中的某些空间，不同进程可能对物理空间进行共享。 执行系统调用，<strong>汇编层面上</strong>就是从 kuseg 段的汇编指令跳转至 kseg0 段，（进入内核态）并执行特定序列（系统调用函数），最后返回用户态 EPC 。<strong>C层面上</strong>就是用户态函数和内核态的系统调用函数之间的调用跳转。</p><h2 id="系统调用过程概览"><a href="#系统调用过程概览" class="headerlink" title="系统调用过程概览"></a>系统调用过程概览</h2><p>我觉得 os 学的就是一个全局观，先把需求和路线理清了，细节咱们随后再细说（</p><ul><li>  用户提出请求：<code>syscall_</code> 函数</li></ul><p>在 MOS 中，操作系统为用户准备了一系列可以在用户态调用的函数： <code>syscall_*</code> 系列函数，他们每个函数都对应一个可以通过系统调用完成的任务，用户通过调用这些函数，向操作系统传达信息：<strong>我要使用系统调用完成某个功能</strong></p><ul><li>  进入内核态：汇编函数 <code>msyscall</code></li></ul><p>在刚提到的 <code>syscall_*</code> 函数中，存在一个 <code>msyscall</code> 函数，在这个汇编写成的 <code>msyscall</code> 中，才出现了真正的 <code>syscall</code> 汇编指令，也就是在这里正式地进入了内核态，准备使用异常处理程序解决 <code>syscall</code></p><ul><li>  用户态保存：<code>exc_gen_entry</code></li></ul><p>在异常处理程序中，调用 SAVE_ALL 保存当前现场为内核栈中的 trapframe ，并将当前使用栈转换为内核栈。</p><ul><li>  接收请求并分类：<code>handle_sys</code></li></ul><p>通过异常处理程序判断为系统调用后，转入 handler 这个函数创建了一个size = TFSIZE + 8 大小的栈帧，8byte 为了保存参数 *tf（函数开始后会写回 a0 寄存器）</p><ul><li>  参数预处理调用处理函数：<code>do_syscall</code></li></ul><p>在这个函数中，我们通过分析用户传入的信息（<code>syscall_*</code> 的类型和用户现场）来响应系统调用。 分析主要凭借 tf-&gt;regs[29] 获取用户 trapframe 状态，通过sp访问内核栈获取参数等</p><ul><li>  响应完毕，返回用户态：<code>ret_from_exception</code></li></ul><p>在从 <code>do_syscall</code> 跳出并执行完对应处理函数，并返回至 <code>handle_sys</code> 后，最后会和其他异常一样，执行 <code>ret_from_exception</code>，还原现场，返回用户态，整个系统调用的过程结束   至此，整个执行流程可以总结为这张图片： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304231627668.png" alt="image-20230423162717568"></p><h2 id="发起系统调用-syscall"><a href="#发起系统调用-syscall" class="headerlink" title="发起系统调用 - syscall_*"></a>发起系统调用 - syscall_*</h2><p>上面提到，可由用户调用、距离内核态最近的函数就是这一系列 <code>syscall_*</code> 函数了。它们作为用户可调用的函数，位于 <code>user/lib/syscall_lib.c</code> 文件中，现在来看看它们的具体内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为节省空间仅保留了部分函数，反正差不多里面所有函数都长这样()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_putchar</span><span class="params">(<span class="type">int</span> ch)</span> &#123;</span><br><span class="line">    msyscall(SYS_putchar, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">syscall_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_getenvid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_mem_map</span><span class="params">(u_int srcid, <span class="type">void</span> *srcva, u_int dstid, <span class="type">void</span> *dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_mem_map, srcid, srcva, dstid, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它们都只调用了<strong>不同参数</strong>的 <code>msyscall</code> 函数，然后早早跑路（x）。这里还需要注意，<code>syscall_putchar</code>、<code>syscall_yield</code>、<code>syscall_panic</code> 这几个函数没有以”return“的方式调用 <code>msyscall</code> ，因为他们不是 <code>void</code> 的，就是 <code>noreturn</code> 的，憋憋 可以发现每个不同的函数，第一个参数一定不同，并且都代表了这个函数。也就是说， <code>msyscall</code> 通过接收这系列函数传入的第一个参数，决定最后响应的内核函数是谁，而后续的参数充当信息，用于辅助处理。  </p><h2 id="转入内核态-msyscall-Exercise-4-1"><a href="#转入内核态-msyscall-Exercise-4-1" class="headerlink" title="转入内核态 - msyscall - Exercise 4.1"></a>转入内核态 - msyscall - Exercise 4.1</h2><p>这个在用户态执行的最后一个函数（但用户编程过程中实际上不用），位于 <code>user/lib/syscall_wrap.S</code> 中，这个函数很简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;asm/asm.h&gt;</span><br><span class="line"></span><br><span class="line">LEAF(msyscall)</span><br><span class="line">    // Just use &#x27;syscall&#x27; instruction and return.</span><br><span class="line"></span><br><span class="line">    /* Exercise 4.1: Your code here. */</span><br><span class="line">    syscall</span><br><span class="line">    jr ra</span><br><span class="line">END(msyscall)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数实际上充当了用户态、内核态的转接口：执行 <code>syscall</code> 进入内核态，从调用返回后执行 <code>jr ra</code> ，十分简洁，分工明确 我们可能注意到了不同的 <code>msyscall</code> 调用可能有不同的参数数量，他们都被保存在堆栈中为函数创造的 stack frame 空间中，与 sp 相邻。 下一步，内核就会接收到由硬件产生的 8 号异常，通过处在 <code>kern/entry.S</code> 的异常分发程序 <code>exc_gen_entry</code> 跳转到 handler 函数： <code>do_syscall</code>  </p><h2 id="分发系统调用-do-syscall"><a href="#分发系统调用-do-syscall" class="headerlink" title="分发系统调用 - do_syscall"></a>分发系统调用 - do_syscall</h2><p>首先需要注意，在跳转至 <code>do_syscall</code> 前，我们在异常分发程序中向内核栈（SAVE_ALL）压入了用户态 trapframe 的信息。随后又通过 move 指令把 a0 寄存器复制成了 trapframe 的地址（SAVE_ALL 中 move sp 的值） 所以 <code>do_syscall</code> 在调用时就会自动地带有一个参数，它就是存放在 a0 寄存器中的用户态 <code>trackframe</code> <strong>指针</strong>（为什么是指针？因为传入的 sp 的值实际上指向了存放 tf 的地址）  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];    <span class="comment">// sysno 是 msyscall 的第一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (sysno &lt; <span class="number">0</span>  sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 移动 EPC，使得syscall返回后执行下一条指令 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/* Step 2: 通过 sysno 获得使用的处理函数 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">    func = syscall_table[sysno];</span><br><span class="line">    <span class="comment">/* Step 3: 获取前三个参数 $a1, $a2, $a3. */</span></span><br><span class="line">    u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">    u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">    u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 获取后两个参数 [$sp + 16 bytes], [$sp + 20 bytes] */</span></span><br><span class="line">    u_int arg4, arg5;</span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">    arg4 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>));</span><br><span class="line">    arg5 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>));</span><br><span class="line">    <span class="comment">/* Step 5: 调用处理函数，返回值保存在用户态的 v0 中 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h3><ul><li>  这里 sysno 取自 a0 寄存器，那前面说的 tf 地址保存在 a0 寄存器又是什么呢，不会互相覆盖吗？</li><li>  首先结论很明显，不会。这里的两个 a0 指的不是同样的东西</li></ul><p>首先我们需要明确一点：当进程运行在用户态时，使用的是用户栈，栈指针也指向用户栈；每当进程<strong>通过异常</strong>从用户态切换到内核态时，handler 会执行汇编函数 <code>SAVE_ALL</code>。 它的具体作用是把用户态的所有寄存器都保存到一个 trapframe 中，同时这个 tf 会被放置在内核栈中，同时还会切换当前使用的栈空间为<strong>内核栈</strong>。并且<strong>切换时内核栈总是空的</strong>。内核栈此时就保存了进程在进入内核态前的相关信息。重回到用户态时，再通过 ret_from_exception 中的 RESTORE_SOME 将内核栈中保存的信息恢复，再切回用户栈。 因为内核栈在切换后总是空的，每次又只会传入一个 trapframe ，所以这个 trapframe 实际上每次都占用的是 KSTACKTOP 向下的一个 sizeof(trapframe) 大小的空间 所以会出现这样的空间图：</p><ul><li>  stackframe：调用函数时创建，保存函数的参数、临时变量与相关跳转指针</li><li>  trapframe：陷入内核时使用 <code>SAVE_ALL</code> 创建，保存用户态寄存器</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012029029.png" alt="image-20230501202927787"> 新的内核栈 sp 指向 trapframe，旧的用户栈 sp 指向 arg0</p><ul><li>  使用当前（内核栈）的 sp，能访问到 trapframe 的信息；使用 tf 中 sp （用户栈）的信息，能访问到最近的 stackframe 的信息</li></ul><p>回到我们的 sysno，它是 <code>msyscall</code> 的第一个参数（<strong>用户态</strong>函数），也就是在分发异常调用 SAVE_ALL 时保存的 a0 寄存器，来源是用户态，所以要从用户态的 tf 里取 a0 寄存器（tf-&gt;regs[4]）；而参数 *tf 是保存在了调用 <code>do_syscall</code> 时的内核态 a0 中，并不干扰</p><ul><li>  后面的 arg4 类似，同样来源于用户态，但由于寄存器内没有保存，所以不能直接从 tf 里取得，需要通过用户栈指针回到 stackframe 中获取(tf-&gt;regs[29] + 16)</li></ul><h3 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 - stack frame"></a>栈帧 - stack frame</h3><p>这里是实际在网站里的教程里有讲过了，当时没有仔细理解，感觉还是再说说吧。 昨天有同学问我说为啥NESTED(handler_sys, TFSIZE + 8, 0)提示编译器共有 TFSIZE + 8 字节的栈帧，但是 ra 却只移动了 8Byte。然后我就发现，我确实没理解栈帧。。 存疑：栈帧在C语言函数中自动创建，汇编函数中需要手动创建 以下内容根据 R3000 手册筛选，但不能保证正确性，为了讨论，这里就只涉及到非叶函数，也就是一般函数的栈情况</p><ul><li>  栈帧 stackframe 创建于刚刚进入函数时：编译器会令 sp 指针向下移动一定空间，并使得这段空间成为该函数栈帧（大小由编译器通过函数变量、子函数参数、临时变量等指标确定；需要<strong>注意双字对齐</strong>，所以在没对齐时需要补充空白的单字（称作pad））</li><li>  随即，编译器调用 sw 指令，把 a0 - a3 寄存器中存放的本函数前四个参数填充到紧邻本栈帧的<strong>上方的空间</strong>里，不够四个就有几个补几个</li><li>  栈内高地址存放函数的临时变量等，低地址预留本函数可能调用的<strong>子函数的参数</strong>的空间，这部分空间在进入子函数时又会成为子函数第二步填充参数的地方</li></ul><p>那回来说这个 handler_sys，它通过NESTED宏中的.frame向编译器声明自己需要 TFSIZE+8 字节的栈帧，但是自己却只移动了 8 字节的 sp。 我感觉是因为 TFSIZE 实际上是上面调用 SAVE_ALL 时移动的一个 TFSIZE，这里为了避免覆盖掉就把它看成了栈的一部分（<strong>小孩子瞎猜的</strong>）。真正有用的是那8个字节：4字节的arg1和4字节的pad，而arg1又是在进入子函数do_syscall内，才从 a0 寄存器中填充的</p><h2 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h2><p>了解完系统调用的流程后，下一步就是填写具体用于处理系统调用的函数了，可能会把能写的都写一下，<strong>建议是跳着看</strong>。  </p><h3 id="获取进程块-envid2env-Exercise-4-3"><a href="#获取进程块-envid2env-Exercise-4-3" class="headerlink" title="获取进程块 - envid2env -Exercise 4.3"></a>获取进程块 - envid2env -Exercise 4.3</h3><p>首先是 envid2env 这个函数，它用来获取id对应的进程控制块。虽然它不是系统调用的一部分，但在进行交互、系统调用时，经常使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 赋值，当 envid == 0 时返回当前进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *penv = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE  e-&gt;env_id != envid) &#123;  <span class="comment">// double check: invaild env_id</span></span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 当 checkperm != 1 时，要求查询的 env 必须是当前运行进程块**本身或父亲**</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; (e-&gt;env_id != curenv-&gt;env_id &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)) &#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;E_BAD_ENV: %x, %x, %x\n&quot;</span>, e-&gt;env_id, curenv-&gt;env_id, e-&gt;env_parent_id);</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 向 *penv 中赋值 */</span></span><br><span class="line">    *penv = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身没什么问题，但要注意 <code>envid == 0</code> 时必须提前退出函数，否则会一直运行到最后，返回 envs 内的第一个进程控制块</p><ul><li>  当 checkperm == 0 时，不需处理进程块与当前进程之间的关系，反之则需要确保调用本函数的进程是被调用者的<strong>直接父亲或本身</strong>，否则返回错误。值得一提的是，除了在进行 ipc 通讯的过程外，所有 syscall 函数都需要令 checkperm != 0（传信息不用限定在父子进程中）</li></ul><p> </p><h3 id="强制进行进程切换-sys-yield-Exercise-4-7"><a href="#强制进行进程切换-sys-yield-Exercise-4-7" class="headerlink" title="强制进行进程切换 - sys_yield - Exercise 4.7"></a>强制进行进程切换 - sys_yield - Exercise 4.7</h3><p>具体而言就是调用一次 <code>schedule</code> 函数，使得运行的进程交出 CPU 时间片，记得 yield 别传 0（）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// Hint: Just use &#x27;schedule&#x27; with &#x27;yield&#x27; set.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.7: Your code here. */</span></span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这里函数 <code>noreturn</code> ，也就是说会直接开始运行下一个进程块  </p><h3 id="指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4"><a href="#指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4" class="headerlink" title="指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4"></a>指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4</h3><ul><li>函数作用：为指定进程的 va 申请一个物理页面并形成映射<ul><li>  类似于跨进程的 page_insert</li></ul></li><li>操作：<ul><li>  确认 va 和 env 的合法性，如有错误则直接返回错误值</li><li>  申请一个物理页，调用 page_insert 生成映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 envid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Hint: **Always** validate the permission in syscalls! except for in function sys_ipc_try_send */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;env, <span class="number">1</span>)) &#123;<span class="comment">// test 4-2: !envid2env() or 0 != envid2env())</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 申请物理页 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (3/3) */</span></span><br><span class="line">    try(page_alloc(&amp;pp));</span><br><span class="line">    <span class="comment">/* Step 4: 将 va 映射入指定进程 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这不就是一个 page_insert 吗，仔细一看确实。但是用户态的 page_insert 无法<strong>帮</strong>其他进程申请一个映射，因为根本看不到其他进程的进程块，所以原则上需要看得见所有东西的内核态来帮忙  </p><h3 id="在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5"><a href="#在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5" class="headerlink" title="在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5"></a>在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5</h3><ul><li>  函数作用：说白了就是把 src 进程 va 所在的物理页，在 dst 进程中找了指定位置形成了映射（insert）</li><li>操作：<ul><li>  检验传入的两个 va 合法性</li><li>  获取 srcid 和 dstid 的进程控制块</li><li>  page_lookup 获得 srcva 在 srcid 中映射的<strong>物理页</strong></li><li>  page_insert 让物理页在 dstid 中也形成一个映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="comment">//printk(&quot;mem_map:va is %x\n&quot;, srcva);</span></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (1/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(srcva)  is_illegal_va(dstva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;invaild va: %x or %x\n&quot;, srcva, dstva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 srcid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (2/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcid, &amp;srcenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;srcenv, 1)\n&quot;, srcid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 获取 dstid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (3/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(dstid, &amp;dstenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;dstenv, 1)\n&quot;, dstid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 找到 srcid + srcva 指向的物理页 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (4/4) */</span></span><br><span class="line">    <span class="keyword">if</span> ((pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 最终在 dst 中形成映射 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="解除指定进程的映射-sys-mem-unmap-Exercise-4-6"><a href="#解除指定进程的映射-sys-mem-unmap-Exercise-4-6" class="headerlink" title="解除指定进程的映射 - sys_mem_unmap - Exercise 4.6"></a>解除指定进程的映射 - sys_mem_unmap - Exercise 4.6</h3><ul><li>  函数作用：上一行就是.jpg</li><li>操作：<ul><li>  检验 va 有效性</li><li>  获取 envid 的进程块</li><li>  直接调用 page_remove 进行映射的删除</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取对应的进程控制块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 解除 env 中 va 的映射 */</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较好写，但是 MOS 也没调用过，之后可能会有用处吧  </p><h3 id="为当前进程创建一个子进程-sys-exofork-Exercise-4-9"><a href="#为当前进程创建一个子进程-sys-exofork-Exercise-4-9" class="headerlink" title="为当前进程创建一个子进程 - sys_exofork - Exercise 4.9"></a>为当前进程创建一个子进程 - sys_exofork - Exercise 4.9</h3><p> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 使用 env_alloc 申请新进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把当前进程存入的 trapframe 复制给子进程 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// e-&gt;env_tf = curenv-&gt;env_tf;</span></span><br><span class="line">    <span class="comment">/* Step 3: 把子进程的 v0 寄存器置0，即函数返回值为0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 设置子进程状态，继承优先级  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="设置进程块-status-sys-set-env-status"><a href="#设置进程块-status-sys-set-env-status" class="headerlink" title="设置进程块 status - sys_set_env_status"></a>设置进程块 status - sys_set_env_status</h3><p>见 fork 部分  </p><h3 id="设置-trapframe-sys-set-trapframe"><a href="#设置-trapframe-sys-set-trapframe" class="headerlink" title="设置 trapframe - sys_set_trapframe"></a>设置 trapframe - sys_set_trapframe</h3><p>见 fork 部分  </p><h3 id="ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8"><a href="#ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8" class="headerlink" title="ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8"></a>ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8</h3><ul><li>  函数作用：主动将当前进程<strong>阻塞</strong>，等待 send 信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 非 0 va 意味着传输页面，此时需检测 va 是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;<span class="comment">// test 4-3: English &quot;either or&quot;</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 标记：允许接收数据 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (1/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 3: 设置接收的指定va */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (2/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    <span class="comment">/* Step 4: 移出调度队列，进入阻塞态 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (3/8) */</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line">    <span class="comment">/* Step 5: schedule(1) 令当前进程开摆，设置返回值为0 */</span></span><br><span class="line">    ((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里最后一块：<code>((struct Trapframe *)KSTACKTOP - 1)</code> 指的就是 <code>do_syscall</code> 那之前创建的用户态 Trapframe，这里把用户态的 v0 寄存器值设为了0，用来代表用户态<strong>最初</strong>调用的 <code>syscall_ipc_recv</code> 的返回值为 0</li></ul><h3 id="ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8"><a href="#ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8" class="headerlink" title="ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8"></a>ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8</h3><ul><li>  函数作用：和 recv 配套使用，向<strong>已准备好</strong>的进程发送信息</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检测 va 有效性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (4/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;srcva is bad! %x\n&quot;, srcva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取进程块，无需令 perm = 1，非父子进程也可传输信息 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (5/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;envid is bad! %x\n&quot;, envid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 检测目标进程是否处于可接受状态(env_ipc_recving = 1) */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (6/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 设置目标进程字段 */</span></span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">    e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 恢复目标进程状态为可运行 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (7/8) */</span></span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    <span class="comment">/* Only link page while srcva != 0, to save running time */</span></span><br><span class="line">    <span class="comment">/* Step 6: va != 0 则传输页面 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">        <span class="comment">// printk(&quot;4.8 is sys_mem_map(%x, %x, %x, %x, %x));\n&quot;, curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm);</span></span><br><span class="line">        <span class="comment">// try(sys_mem_map(curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm));</span></span><br><span class="line">        <span class="comment">/* Test 4-5: do not use sys_mem_map because it call function envid2env with perm == 1; */</span></span><br><span class="line">        <span class="comment">// because two communicating env may not have parent relatioinship</span></span><br><span class="line">        p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="ipc-进程通信-ipc-c"><a href="#ipc-进程通信-ipc-c" class="headerlink" title="ipc 进程通信 - ipc.c"></a>ipc 进程通信 - ipc.c</h1><p>为了在进程间进行数据的传输，我们在 MOS 操作系统中设置了两种传输方式：传输单个 int，共享内存；并且两种方式都集成在了同一个系统调用，也即 <code>sys_ipc_send</code> 和 <code>sys_ipc_recv</code> 两个函数完成，并且两个函数执行时需要先 recv，声明自己已准备好，再调用 send，进行信息的发送。 但是，只设置好了系统调用函数还不足以让我们完成进程间的通信，因为系统需要对发送过程是否成功进行检测，若目标进程未准备好还需要等待，也有许多诸如此类的情况。所以为了方便使用，MOS 在用户态中封装了两个完整的函数用于进行信息传递的全流程，它们位于 <code>user/lib/ipc.c</code> 中，当有通信需求时，直接调用它们就能直观地完成进程通信。 <code>ipc.c</code> 文件开头就有一句这样的注释：<code>User-level IPC library routines</code>，也正好说明了下面两个函数在用户态服务</p><h2 id="用户态发送函数-ipc-send"><a href="#用户态发送函数-ipc-send" class="headerlink" title="用户态发送函数 - ipc_send"></a>用户态发送函数 - ipc_send</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hint: use syscall_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 持续查询是否能进行传输 */</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_send(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 如果只因为对方未就绪，自身也停止这个 while 导致的忙等待，交出 CPU */</span></span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 如果 r != 0，说明退出 while 循环的原因是 -E_INVAL，说明出现错误 */</span></span><br><span class="line">    user_assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  这里使用的 <code>syscall_yield</code> 非常巧妙：如果对方进程未就绪，那在这个时间片中也不可能转换为就绪状态（本时间片一直是本进程运行），那为了避免当前时间片忙等，索性直接归还 CPU，等下一次调度到自己之后再查</li></ul><p> </p><h2 id="用户态接收函数-ipc-recv"><a href="#用户态接收函数-ipc-recv" class="headerlink" title="用户态接收函数 - ipc_recv"></a>用户态接收函数 - ipc_recv</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hint: use env to discover the value and who sent it.</span></span><br><span class="line">u_int <span class="title function_">ipc_recv</span><span class="params">(u_int *whom, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 直接进系统调用，因为 recv 是先执行的，不用等 */</span></span><br><span class="line">    <span class="comment">/* 需要注意进程在下一条语句中调用了 schedule，传输完毕后才跳出 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_ipc_recv(dstva);</span><br><span class="line">    <span class="comment">/* Step 2: 检查返回值，错误值则 panic */</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;syscall_ipc_recv err: %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 返回发送者的 env_id */</span></span><br><span class="line">    <span class="keyword">if</span> (whom) &#123;</span><br><span class="line">        *whom = env-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 返回映射页权限位 */</span></span><br><span class="line">    <span class="keyword">if</span> (perm) &#123;</span><br><span class="line">        *perm = env-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 返回传输的单个 int */</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  相比之下，recv 函数内赋值语句较多，因为需要接收一些信息，系统调用函数倒比较简单，单纯调用一次 syscall_ipc_recv 就完事了</li></ul><p> </p><h1 id="用户进程的创建-fork-c"><a href="#用户进程的创建-fork-c" class="headerlink" title="用户进程的创建 - fork.c"></a>用户进程的创建 - fork.c</h1><p>用户进程调用 <code>fork</code> 函数时，将会创建一个<strong>和当前一模一样</strong>的新进程：父进程进行一次函数调用，父、子进程都产生一个返回值。父进程返回值为子进程的 <code>env_id</code>，子进程返回值是0，通过返回值不同来标定谁是子进程。 为了实现 <code>fork</code> 函数，我们主要需要补充<code>user/lib/fork.c</code> 中的函数。 实现 <code>fork</code> 的主要流程如下，我们接下来会按顺序介绍（感谢指导书的图.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011703551.png" alt="image-20230501170305441">  </p><h2 id="写时复制-COW-与页写入异常"><a href="#写时复制-COW-与页写入异常" class="headerlink" title="写时复制 COW 与页写入异常"></a>写时复制 COW 与页写入异常</h2><p>在通过后文提到的 <code>fork</code> 函数创建进程时，父子进程间会暂时共享内存空间，但实际上在<strong>写入</strong>这两个进程空间时，它们应该互不干扰。那一种直观的做法就是把父进程的<strong>所占用的物理页面</strong>全都复制一遍插入进子进程中。然而这么做会造成很大的内存开销，同时那些本身不可写的页面还需要白复制一遍。 所以我们引入了一种写时复制机制 <strong>COW</strong>，用来解决进程创建后的内存共享问题。COW 的解决思路：当父子进程需要修改可写页面内容（<code>PTE_COW = 1</code>）时产生一种异常，它只新复制出该页的内容以供修改，没用到的页面仍旧保持原状。 考虑到给 <code>PTE_D = 0</code> 的页面写入时会产生 TLB_MOD 异常，我们就顺便把 COW 需要的页面标记为 <code>PTE_D = 0, PTE_COW = 1</code>，也进入 TLB_MOD，并在其中中判断是真正的错误写入，还是 COW 触发。<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012033983.png" alt="image-20230501203319024">    </p><h2 id="申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9"><a href="#申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9" class="headerlink" title="申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9"></a>申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9</h2><ul><li>  函数作用：为子进程申请一个进程块，并把父进程的内容拷贝</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 通过 env_alloc 申请进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把 KSTACKTOP 下一个 tf 内容拷贝给子进程，tf 内放的是父进程调用 fork 前的用户态 TrapFrame */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Step 3: 子进程 v0 寄存器(env_tf.regs[2]) 设为 0，说明返回值为 0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 进程块初始化  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id; <span class="comment">// 这里返回实际上是父进程的返回值，返回子进程 env_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  为了避免 <code>syscall_exofork</code> 的栈帧在后续写时复制机制建立好<strong>之前</strong>被错误地更改，导致返回地址被覆盖，我们把 <code>syscall_exofork</code> 设置为了内联函数，不再创建栈帧，保护了进程地址跳转的正确性。</li></ul><h3 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd: 23.5.4"></a>Upd: 23.5.4</h3><ul><li>  在父进程执行这个函数的过程中，会把子进程的 v0 寄存器设置为 0；随后父进程从系统调用中返回并恢复现场，<code>syscall_exofork</code> 的返回值为子进程 env_id，而子进程<strong>并没有执行这个函数</strong>，只是在被调度时才首次开始运行，恢复进程控制块中存放的 trapFrame，其中的 EPC 也令进程从 fork 函数中的 <code>syscall_exofork</code> 结束后运行，这时存放于 v0 寄存器的返回值是 0，<strong>看起来好像子进程执行了</strong>这个函数并返回了 0。这就是 <code>syscall_exofork</code> 实现两个不同返回值的过程。</li></ul><p> </p><h2 id="写时保护函数-duppage-Exercise-4-10"><a href="#写时保护函数-duppage-Exercise-4-10" class="headerlink" title="写时保护函数 - duppage - Exercise 4.10"></a>写时保护函数 - duppage - Exercise 4.10</h2><ul><li>  这个函数功能比较单一，但考虑的情况比较多</li><li>  函数功能：将符合要求的页面 <code>PTE_D</code> 置0，<code>PTE_COW</code> 置1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   若含有 PTE_LIBRARY 则说明该页面是共享页面，不做处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only the father env can call this function, &#x27;envid&#x27; in args is the child&#x27;s envid */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int addr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vpt is the 自映射页表 in env&#x27;s virtual memory */</span></span><br><span class="line">    <span class="comment">/* Step 1: 获得当前页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (1/2) */</span></span><br><span class="line">    perm = (vpt)[vpn];</span><br><span class="line">    addr = vpn * BY2PG;</span><br><span class="line">    <span class="comment">/* Step 2: 若页面可写，同时非共享，则标记为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: 先在子进程中映射、后更新父进程的权限位，原因见下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (((perm &amp; PTE_D)  (perm &amp; PTE_COW)) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;<span class="comment">// need to change perm and remap</span></span><br><span class="line">        perm = (perm &amp; ~(PTE_D))  PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 1!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, syscall_getenvid(), (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 2!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 3!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  先给子进程映射的原因可以看<a href="https://www.cnblogs.com/CindyZhou/p/12858468.html">这里</a></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011737320.png" alt="image-20230501173715236"></p><blockquote><p>如果先给父进程加PTE_COW，然后修改了该页，该页将进行写时复制，父进程指向新的页，而新页没有被加上PTE_COW。此时再map子进程，子进程该页加上PTE_COW位而父进程没有。在随后程序运行中，若父进程进行修改，由于缺失PTE_COW，导致无法进行写时复制，因此子进程的运行出现错误（子进程该页本来不该被改，但却由于父进程被改而一起改了）。</p></blockquote><p> </p><h2 id="设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12"><a href="#设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12" class="headerlink" title="设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12"></a>设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12</h2><p>在 “写时复制 COW 与页写入异常” 一节中，我们已经知道，MOS 处理<strong>写时复制</strong>的时间是在进入 TLB_Mod 异常之后的，现在我们需要先设置 TLB_Mod 的处理函数。注意这里的处理函数可以来自<strong>用户态</strong>。 这样，在后续触发写时复制机制时，就能直接从用户给出的函数开始执行，处理异常了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取目标进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (1/2) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 2: 给函数入口字段赋值 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (2/2) */</span></span><br><span class="line">    env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里的 func 指的实际是异常处理函数的入口地址，当触发异常时，<code>do_tlb_mod</code> 会将 EPC 设置为 func 的值，同时退出异常，借此执行 Mod 异常的处理。</li></ul><h2 id="TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11"><a href="#TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11" class="headerlink" title="TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11"></a>TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11</h2><ul><li>  当系统发生 TLB_Mod 异常后，首先进入这里的 handler，设置好跳转后再 <code>ret_from_exception</code> 回到用户态，执行真正响应异常的用户态函数，最后再从该函数中返回受害指令</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   This is the TLB Mod exception handler in kernel.</span></span><br><span class="line"><span class="comment"> *   Our kernel allows user programs to handle TLB Mod exception in user mode,</span></span><br><span class="line"><span class="comment"> * so we copy its context &#x27;tf&#x27; into UXSTACK and modify the EPC to the registered</span></span><br><span class="line"><span class="comment"> * user exception entry.</span></span><br><span class="line"><span class="comment"> *   The user entry should handle this TLB Mod exception and restore the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 置位用户异常栈指针，并将当前异常 TrapFrame 复制到用户异常栈中 */</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">    *(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 存在用户的异常处理函数，手动设置处理函数的参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];           <span class="comment">// a0 = 用户异常栈地址</span></span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);  <span class="comment">// 移动异常栈指针，为函数调用保存参数留出空间</span></span><br><span class="line">        <span class="comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to</span></span><br><span class="line">        <span class="comment">// &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span></span><br><span class="line">        <span class="comment">/* Exercise 4.11: Your code here. */</span></span><br><span class="line">        tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> </p><h3 id="用户异常栈"><a href="#用户异常栈" class="headerlink" title="用户异常栈"></a>用户异常栈</h3><ul><li>  前面在栈帧一小节中已经提到了用户栈、内核栈和他们的作用，这里还要提到一个新的栈帧：用户异常栈（<code>va = UXSTACKTOP</code>），它充当在用户态中处理异常所用到的函数的栈，这里就是页写入异常处理函数的栈</li><li>  用户异常栈和内核栈功能类似，都是在发生异常时开始使用，同时都从对应栈的 TOP 开始记录，看起来用户异常栈应该也允许异常重入。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果 regs[29] 在用户异常栈中，应该就不需要再次赋值了</span></span><br></pre></td></tr></table></figure><ul><li>  这里的 Step2 为什么要做这样一系列操作呢？因为这个C语言函数结束后，会通过汇编语言的 <code>ret_from_exception</code> 直接返回 EPC。因为没有显式的函数调用，所以编译器并不会为后续跳转到的处理函数创建栈帧，这里我们需要手动创建<strong>用户异常栈</strong>中的函数栈帧，供异常处理函数使用</li></ul><p> </p><h2 id="TLB-Mod-的实际处理-cow-entry-Exercise-4-13"><a href="#TLB-Mod-的实际处理-cow-entry-Exercise-4-13" class="headerlink" title="TLB_Mod 的实际处理 - cow_entry - Exercise 4.13"></a>TLB_Mod 的实际处理 - cow_entry - Exercise 4.13</h2><p>没错，这个函数就是刚才提到的用户态异常处理函数，执行 <code>ret_from_exception</code> 后会从这里继续执行。最终在这里完成写时复制页面的复制，并返回用户态继续执行受害指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the faulting page to a private writable copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;va&#x27; 为受害的虚拟地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">    u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取受害页面的标志位，判断是否为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27; doesn&#x27;t have</span></span><br><span class="line"><span class="comment">     * &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (1/6) */</span></span><br><span class="line">    u_int envid = syscall_getenvid();</span><br><span class="line">    perm = ((Pte *)(vpt))[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;?&quot;</span>);   <span class="comment">// 不是写时复制，意味着就是访问错了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 写时复制，设置新页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (2/6) */</span></span><br><span class="line">    perm = (perm &amp; ~(PTE_COW))  PTE_D;</span><br><span class="line">    <span class="comment">/* Step 3: 在 UCOW 空间申请一个临时页面，并建立映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (3/6) */</span></span><br><span class="line">    syscall_mem_alloc(envid, (<span class="type">void</span> *) UCOW, perm);</span><br><span class="line">    <span class="comment">/* Step 4: 把 va 那个页面内容复制过去 */</span></span><br><span class="line">    <span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (4/6) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) UCOW, (<span class="type">void</span> *) ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line">    <span class="comment">/* Step 5: 用 Step2 的 perm 新建了一个 va 的新映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (5/6) */</span></span><br><span class="line">    syscall_mem_map(envid, (<span class="type">void</span> *) UCOW, envid, (<span class="type">void</span> *) va, perm);</span><br><span class="line">    <span class="comment">/* Step 6: 解除 UCOW 的占用 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (6/6) */</span></span><br><span class="line">    syscall_mem_unmap(envid, (<span class="type">void</span> *) UCOW);</span><br><span class="line">    <span class="comment">// Step 7: 恢复栈帧，彻底退出异常 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">    user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>cow_entry</code> 的实际作用就是建立了一个<strong>受害页面在页表中的新映射</strong>。这个映射只有权限位不同，当再次写入受害 va 所在的页面时，会得到正确的 perm。</li><li>  旧：UCOW 空，va 会触发写时复制（申请物理页面，复制va-&gt; UCOW） 过程中：UCOW va内容，va会触发写时复制 结束：UCOW 空，va不会触发写时复制，指向UCOW 申请得到的那个物理页面</li></ul><p> </p><h2 id="子进程控制块设置-sys-env-set-status-Exercise-4-14"><a href="#子进程控制块设置-sys-env-set-status-Exercise-4-14" class="headerlink" title="子进程控制块设置 - sys_env_set_status - Exercise 4.14"></a>子进程控制块设置 - sys_env_set_status - Exercise 4.14</h2><ul><li>  启动新进程的最后一步：执行完所有的设置后，最后通过这个函数将子进程插入待调度队列，正式启动子进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;status&#x27; is valid. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (2/3) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 4: Update &#x27;env_sched_list&#x27; if the &#x27;env_status&#x27; of &#x27;env&#x27; is being changed. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (3/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status == ENV_RUNNABLE) &#123;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: Set the &#x27;env_status&#x27; of &#x27;env&#x27;. */</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Upd-23-5-5"><a href="#Upd-23-5-5" class="headerlink" title="Upd: 23.5.5"></a>Upd: 23.5.5</h3><p>需要在 Step4 中额外留意 <code>status</code> 的变化，如果变为 RUNNABLE 则需要加入至调度队列，如果 NOT_RUNNABLE 则需要<strong>移出</strong>，因为在 Lab3 的 <code>schedule</code> 函数中，我们已经要求所有变化进程状态的函数需要负责维护 <code>env_sched_list</code>，在这里就需要将 NOT_RUNNABLE 的函数移除。感谢芬海哥哥捏，指出了这里的错误 以上，就是创建一个子进程所需要的全部步骤，那么 fork 函数，实际上就是这些函数的结合  </p><h2 id="子进程的创建-fork-Exercise-4-15"><a href="#子进程的创建-fork-Exercise-4-15" class="headerlink" title="子进程的创建 - fork - Exercise 4.15"></a>子进程的创建 - fork - Exercise 4.15</h2><p> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    u_int child;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line">    <span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix it to the</span></span><br><span class="line">    <span class="comment">// correct value.</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line">    <span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">for</span> (i = UTEMP &gt;&gt; <span class="number">12</span>; i * BY2PG &lt; USTACKTOP; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((vpd[i / <span class="number">1024</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;</span><br><span class="line">            duppage(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">     *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment">     *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (2/2) */</span></span><br><span class="line">    syscall_set_tlb_mod_entry(child, cow_entry);</span><br><span class="line">    syscall_set_env_status(child, ENV_RUNNABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在这里唯一需要考虑的点就是 Step3 中 for 循环的起止条件、if 的判断条件</li><li>  i 在这里表示的是<strong>用户态可用虚拟内存的页号</strong>： <code>UTEMP &gt;&gt; 12</code> ，是正式可以被用户态使用的第一个页面，而 <code>USTACKTOP &gt;&gt; 12</code> 则是最后一个</li><li>  if 的判断条件则是：i 对应的虚拟页面是否能在页表中查到有效的映射，如果有，说明它需要考虑是否需要标记 <code>PTE_COW</code>。</li></ul><p> </p><h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>Lab4 到这里可算是结束了，这个 Lab 给人最直观的感受就是码量的上升与内核态/用户态函数的协同更复杂了。这篇文章唠唠叨叨说了这么多，也是想尝试从更深一层去了解 MOS 运作的机理，而不是简单的完成几个填空，知晓表象就弃若敝履罢了。文章实际上没有想做什么分享，算是自我总结吧，因为自己都不知道对不对（笑 还剩两个 Lab，希望能把习惯保持下去  </p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>一些没用上的函数，贴一下</p><h2 id="syscall-all-c"><a href="#syscall-all-c" class="headerlink" title="syscall_all.c"></a>syscall_all.c</h2><h3 id="打印字符至控制台-sys-putchar"><a href="#打印字符至控制台-sys-putchar" class="headerlink" title="打印字符至控制台 - sys_putchar"></a>打印字符至控制台 - sys_putchar</h3><p>直接调用了 <code>printcharc</code> 函数，和 <code>printk</code> 效果类似吧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_putchar</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    printcharc((<span class="type">char</span>)c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="打印用户空间的定长字符串-sys-print-cons"><a href="#打印用户空间的定长字符串-sys-print-cons" class="headerlink" title="打印用户空间的定长字符串 - sys_print_cons"></a>打印用户空间的定长字符串 - sys_print_cons</h3><p>先检查了地址是否位于用户区域，然后检查了长度是不是正的，最后循环调用了 <code>printcharc</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_print_cons</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s, u_int num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (((u_int)s + num) &gt; UTOP  ((u_int)s) &gt;= UTOP  (s &gt; s + num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        printcharc(((<span class="type">char</span> *)s)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="获得运行中进程块的-id-sys-getenvid"><a href="#获得运行中进程块的-id-sys-getenvid" class="headerlink" title="获得运行中进程块的 id - sys_getenvid"></a>获得运行中进程块的 id - sys_getenvid</h3><p>就一句话，但是好像还没有在 MOS 中使用过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">u_int <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="销毁进程-sys-env-destroy"><a href="#销毁进程-sys-env-destroy" class="headerlink" title="销毁进程 - sys_env_destroy"></a>销毁进程 - sys_env_destroy</h3><p>只有直系进程才能进行销毁（自己也行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">    env_destroy(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="读入字符-sys-cgetc"><a href="#读入字符-sys-cgetc" class="headerlink" title="读入字符 - sys_cgetc"></a>读入字符 - sys_cgetc</h3><p>直接调用了函数 <code>scancharc</code> ，此时会让系统处于忙等状态，直至接收到字符返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Galgame Timeline</title>
      <link href="/2023/05/galgame-timeline/"/>
      <url>/2023/05/galgame-timeline/</url>
      
        <content type="html"><![CDATA[<h1 id="2023年"><a href="#2023年" class="headerlink" title="2023年"></a>2023年</h1><h2 id="23-4"><a href="#23-4" class="headerlink" title="23.4"></a>23.4</h2><h3 id="4-30-天使☆骚骚-RE-BOOT"><a href="#4-30-天使☆骚骚-RE-BOOT" class="headerlink" title="4.30 天使☆骚骚 RE-BOOT!"></a>4.30 天使☆骚骚 RE-BOOT!</h3><p>好久没玩柚子的游戏了，上次玩还是上次大概前年吧，当成放松读物得了（  </p><h2 id="23-5"><a href="#23-5" class="headerlink" title="23.5"></a>23.5</h2><h3 id="5-2-End-共通线"><a href="#5-2-End-共通线" class="headerlink" title="5.2 End: 共通线"></a>5.2 End: 共通线</h3><p>共通线感觉还可以，没什么大病，不过打架的部分太少以至于根本没什么印象，感觉日常的质量距离 Kinkoi 还有点差距。草草把外界危机解除了之后就进个人线了，姑且先进了 noa 线，之后再看吧 顺带一提找到了<a href="https://kannagi35.com/x/tenshi-souzou-re-boot-walkthrough">攻略</a>，虽然是日文，不过估计也不影响。</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame() </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-1-Exam</title>
      <link href="/2023/04/buaa-os-2023-lab4-1-exam/"/>
      <url>/2023/04/buaa-os-2023-lab4-1-exam/</url>
      
        <content type="html"><![CDATA[<p>中途脑梗了好几次，差点寄了，不过好在这次把题留下来了（</p><h1 id="Exam-进程组-ipc-通信"><a href="#Exam-进程组-ipc-通信" class="headerlink" title="Exam - 进程组 ipc 通信"></a>Exam - 进程组 ipc 通信</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><blockquote><p>在 Linux 中，进程理论上所拥有的权限与执行它的用户的权限相同。进程运行时能够访问哪些资源或文件，不取决于进程文件的属主属组，而是取决于<strong>运行该命令的用户身份的 uid/gid</strong>，以该身份获取各种系统资源。</p></blockquote><p>所以我们需要完成同一个进程组ID的不同进程的通信。具体而言，需要做到：</p><ol><li> 在 Env 结构体中添加 <code>u_int env_gid</code> 字段代表进程所在的进程组，初始值为 0。</li><li> 实现一个修改 <code>gid</code> 字段的<strong>用户态函数</strong>：<code>void set_gid(u_int gid);</code></li><li> 实现一个<strong>仅能</strong>向同组块发送消息的<strong>用户态函数</strong>：<code>int ipc_group_send(u_int whom, u_int val, const void *srcva, u_int perm);</code></li><li> 实现 2、3 两点中对应的<strong>系统调用函数</strong>和调用接口</li></ol><p>教程组已经把两个用户态函数实现了，我们只需要考虑系统调用函数 <code>syscall_set_gid</code> 和 <code>syscall_ipc_try_group</code> 即可</p><h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><ol><li>在内核中为每个进程维护<strong>进程组ID</strong>，并保证每个进程<strong>创建时的的组ID为0</strong>。</li><li>在 <code>user/include/lib.h</code> 中：<ul><li>  添加以下两个用户函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure><ul><li>  添加以下两个系统调用函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure></li><li>在 <code>include/error.h</code> 中，增加以下新错误码 <code>E_IPC_NOT_GROUP</code> ，表示组间通信时通信双方进程的组ID不匹配。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E_IPC_NOT_GROUP 14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>两个用户态函数的<strong>实现已经给出（请参看实验提供代码部分），你需要将其复制到 <code>user/lib/ipc.c</code> *_，具体代码的解释在*_提示</strong>部分给出。</li><li>在 <code>include/syscall.h</code> 中：定义两个新的系统调用号。请注意新增系统调用号的位置，应当位于 <code>MAX_SYSNO</code> 之前。</li><li>在 <code>user/lib/syscall_lib.c</code> 中：实现上述两个系统调用函数，发起系统调用。</li><li>在 <code>kern/syscall_all.c</code> 中：添加两个系统调用在内核中的实现函数。请保证两个函数的定义位于系统调用函数表 <code>void *syscall_table[MAX_SYSNO]</code> 之前。</li><li>在 <code>kern/syscall_all.c</code> 中的 <code>void *syscall_table[MAX_SYSNO]</code> 系统调用函数表中，为你定义的系统调用号添加对应的内核函数指针。</li><li>编写 <code>syscall_ipc_try_group_send</code> 系统调用<strong>在内核中的实现函数</strong>时，判断 <code>-E_IPC_NOT_RECV</code> 错误的<strong>优先级</strong>高于 <code>-E_IPC_NOT_GROUP</code></li></ol><h2 id="实验提供代码"><a href="#实验提供代码" class="headerlink" title="实验提供代码"></a>实验提供代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* copy to user/lib/ipc.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span> &#123;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_set_gid 系统调用</span></span><br><span class="line">    syscall_set_gid(gid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_ipc_try_group_send 系统调用</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_group_send(whom, val, srcva, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受方进程尚未准备好接受消息，进程切换，后续继续轮询尝试发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_RECV) syscall_yield();</span><br><span class="line">        <span class="comment">// 接收方进程准备好接收消息，但非同组通信，消息发送失败，停止轮询，返回错误码 -E_IPC_NOT_GROUP</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_GROUP) <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数返回0，告知用户成功发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>课上写了半天总是说函数名找不到，仔细一看写了一半的 <code>group_send</code>，写了一半的 <code>send_group</code>，难绷</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">                           u_int perm)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != envid2env(whom, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_gid != curenv-&gt;env_gid) &#123; <span class="comment">// 唯一与 ipc_send 不同的地方就在这了</span></span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e-&gt;env_ipc_value = val;</span><br><span class="line">  e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">  e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">  e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">    p = page_lookup(curenv-&gt;env_pgdir, (u_int)srcva, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_set_gid</span><span class="params">(u_int gid)</span> &#123; <span class="comment">// 简单赋值</span></span><br><span class="line">  curenv-&gt;env_gid = gid;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题目给的思路顺下来其实很容易就能写完，顺便也可以用这个题回顾一下系统调用：怎样添加一个新的、可用的系统调用？</p><ul><li>  首先从内核态出发，编写一个能够完成功能的函数，看一下它都需要什么参数 - <code>kern/syscall_all.c</code></li><li>  然后在 <code>void *syscall_table[MAX_SYSNO]</code> 把函数添加进去，使得 <code>do_syscall</code> 函数能跳到这个新函数里：这需要随便写一个字符串当成<strong>系统调用号</strong>，无所谓了 - <code>kern/syscall_all.c</code></li><li>  找到刚才那个系统调用号的枚举类，把定义加上 - <code>include/syscall.h</code></li><li>  <code>do_syscall</code> 不需要变化，然后再上一层是 <code>msyscall</code>，它需要一个 <code>syscall_</code> 开头的函数进行调用。到这里我们就完成了内核态中所需要做的所有改动</li><li>  回到用户态，编写一个用户态的 <code>syscall_new</code> 函数调用 <code>msyscall</code>，同时需要注意参数的第一个参数需要是刚才加进去的调用号 - <code>users/lib/syscall_lib.c</code></li><li>  最后编写顶层的用户态函数，其中调用 <code>syscall_new</code> 函数，用户态工作也就完成了 - <code>users/某个文件</code></li><li>  最最后别忘了<strong>加上函数声明</strong>：内核态不需要，用户态加在 <code>users/include/lib.h</code> 即可</li></ul><h1 id="Extra-家族-ipc-广播"><a href="#Extra-家族-ipc-广播" class="headerlink" title="Extra - 家族 ipc 广播"></a>Extra - 家族 ipc 广播</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>课下我们在 MOS 系统中实现了进程间通信。</p><p>现在你需要仿照 <code>ipc_send</code> 函数在 <code>user/lib/ipc.c</code> 中实现 <code>ipc_broadcast</code> 函数，使得调用 <code>ipc_broadcast</code> 可以使当前进程向其后代进程（也即当前广播进程的子进程、子进程的子进程、子进程的子进程的子进程…以此类推）发起广播消息，当后代进程进入 recv 后进行发送。</p><h3 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h3><p><strong><code>ipc_broadcast</code></strong></p><p>需要在 <code>user/lib/ipc.c</code> 新增：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> * srcva, u_int perm)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>  <code>val</code> ：进程广播传递的具体数值, 与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>srcva</code> ：进程广播发送页的对应用户虚地址，与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>perm</code> : 传递的页面的权限位设置，与 <code>ipc_send</code> 函数中的定义相同。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>  你可以实现 <code>syscall_ipc_try_broadcast</code> 系统调用，使其行为类似于 <code>syscall_ipc_try_send</code>，但尝试发送给当前进程的所有后代进程。</li><li>  你也可以尝试在用户空间利用 <code>envs</code> 实现相关行为。</li><li>  发送广播消息时，你可以先等待所有后代进程进入接受状态，再统一进行实际传输，也可以依次等待每个后代进程，一旦其处于接受状态，当即对其进行实际传输。</li></ul><p>也就是说可以在用户态使用这些已有的调用函数完成目标，也可以像 Exam 中添加一种新的系统调用处理这种请求。</p><p>如果注意到原来提供的 <code>ipc_send</code> 函数能使用 bfs 操作进程块数组，那实际上难度就会降低很多。无所谓，我没看出来</p><h2 id="两种可行的做法"><a href="#两种可行的做法" class="headerlink" title="两种可行的做法"></a>两种可行的做法</h2><h3 id="新建系统调用-sys-ipc-broadcast"><a href="#新建系统调用-sys-ipc-broadcast" class="headerlink" title="新建系统调用 - sys_ipc_broadcast"></a>新建系统调用 - <code>sys_ipc_broadcast</code></h3><p>类似在刚才 Exam 中提到的思路，加一个新的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">  u_int childs[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    childs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// printk(&quot;childs ready!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step1: 找到直系的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_parent_id == curenv-&gt;env_id) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childs[j] == <span class="number">0</span>) &#123;</span><br><span class="line">          childs[j] = envs[i].env_id;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step2: 通过 bfs 找到所有子进程的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NENV; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envs[j].env_parent_id == childs[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == envs[j].env_id) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            childs[k] = envs[j].env_id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step3: 对所有待发送的进程进行发送 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// printk(&quot;%d: %x\n&quot;, i, childs[i]);</span></span><br><span class="line">      sys_ipc_try_send(childs[i], val, srcva, perm);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户态通过已有函数处理"><a href="#用户态通过已有函数处理" class="headerlink" title="用户态通过已有函数处理"></a>用户态通过已有函数处理</h3><p>因为代码不是我的，所以我就不贴了，说一说思路吧</p><p>首先和第一种做法一样，需要用循环和队列 bfs 出所有满足条件的进程 <code>env_id</code>，最后实际上可以直接用 <code>ipc_send</code> 解决，太快了。</p><h2 id="一点废话"><a href="#一点废话" class="headerlink" title="一点废话"></a>一点废话</h2><p>其实一开始读这个题我理解成调用 <code>env_alloc</code> 函数来创建进程了，然后就在 Env 里面加了一个数组字段保存自己的孩子，同时在 <code>env_alloc</code> 里通过 <code>env_parent_id</code> 更新<strong>所有</strong>祖宗进程的字段，最后在系统调用进行 send 的时候直接查一下自己的字段就能跑了</p><p>结果这个题它创建进程最后用的是宏 <code>ENV_CREATE_PRIORITY</code>，也就是调用了 <code>env_create</code> 函数。甚至 <code>parent_id</code> 是下面这么加进去的！看起来两个函数好像没啥差别，但是 <code>env_create</code> 函数只能产生 <code>parent_id = 0</code> 的新进程，我这一套直接寄了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa1</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa2</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa3</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa4</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">ppa2-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa3-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa4-&gt;env_parent_id = ppa3-&gt;env_id;</span><br></pre></td></tr></table></figure><p>幸亏看了一眼测试代码，要不寄大发了。不过反正写完这一版才发现写的不对，实际上已经寄了。</p><p>不然我觉得我那个做法将能算得上是绝杀（可能吧）</p><p>总之 lab4 这样就算结束一半了，之后再看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Exam</title>
      <link href="/2023/04/buaa-os-2023-lab3-exam/"/>
      <url>/2023/04/buaa-os-2023-lab3-exam/</url>
      
        <content type="html"><![CDATA[<p>这次比较尴尬，做完了忘记保存题目了，结果复盘的时候全程想不起来题目写的是啥</p><h1 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>我们提出了一种基于多个用户而平均分配的时间片轮转调度算法。对于每个进程来说，它的拥有者（用户，用 0 \sim 4 的数字表示）用一个新增字段 <code>u_int env_user</code>表示。我们要改进的这个调度算法，每次都会运行<strong>已经使用过的时间片最少的</strong>用户的进程（相同时<strong>取 id 小者</strong>），进程按在<code>env_sched_list</code> 中的顺序取出，每次运行该用户的第一个进程。</p><p>为了记录每个用户已经使用的时间片，我们设置了一个全局数组 <code>static int user_time[]</code>，当每次进程时间片耗尽时，对数组进行更新（对应用户加 pri即可）。例如对于如下的三个用户和三个进程，应该有这样的调度顺序（没保存所以只能上手绘图力！）</p><p>假装有图.jpg</p><p>请你按照这样的提示修改 <code>schedule</code> 函数，使其能满足刚才解释的按用户使用分配的时间片轮转算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (需要更换 e 的条件) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e 不为 <span class="literal">NULL</span> &amp;&amp; e 处在 ENV_RUNNABLE 状态) &#123;</span><br><span class="line">      移动 e 进程块</span><br><span class="line">      修改 user_time 数组（加对应的 env_pri 即可）</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (无调度进程块) &#123;</span><br><span class="line">      panic</span><br><span class="line">    &#125;</span><br><span class="line">遍历调度列表，查询列表中有哪些用户的进程块</span><br><span class="line"></span><br><span class="line">遍历每个有进程块的用户，哪个用户用过的时间片最少（user_time 最小）</span><br><span class="line"></span><br><span class="line">遍历调度列表，取出第一个该用户的进程块，e = env，count = env_pri</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  count--</span><br><span class="line">  env_run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  教程组给出的伪代码大致如上，可惜这次没有把题目记下来，只能靠记忆来了</li><li>  给的解释实际上已经足够清晰了，只需要按着步骤走就行。</li></ul><p>要注意<strong>额外声明变量时要考虑初始化</strong>的问题，有同学没初始化导致数组内的值反复横跳，根本没法debug（</p><h2 id="一种可行的解答"><a href="#一种可行的解答" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>贴一下我的做法，比较水，仅供参考</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> able[<span class="number">5</span>];   <span class="comment">// 额外声明了一个数组，当列表中存在该用户进程块时就置 1 ，否则保持 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 数组初始化</span></span><br><span class="line">    able[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">      TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">      <span class="comment">// 记得 + env_pri，有笨比上来直接丢了这一句，根本调度不起来</span></span><br><span class="line">      user_time[e-&gt;env_user] += e-&gt;env_pri;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">      panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">    count = e-&gt;env_pri;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">en</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用了 TAILQ_FOREACH 宏进行循环包装，循环查询有哪个用户在队列里，更新 able 数组</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (able[en-&gt;env_user] == <span class="number">0</span>) &#123;</span><br><span class="line">        able[en-&gt;env_user] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查看哪个用户使用的时间片最少（user_time 最小）</span></span><br><span class="line">    <span class="type">int</span> user = <span class="number">-1</span>;</span><br><span class="line">    u_int times = <span class="number">111111111</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (user_time[j] &lt; times &amp;&amp; able[j] == <span class="number">1</span>) &#123;</span><br><span class="line">        user = j;</span><br><span class="line">        times = user_time[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再循环调度链表，取出第一个目标用户的进程块，准备调度</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (en-&gt;env_user == user) &#123;</span><br><span class="line">        e = en;               <span class="comment">// 更换调度块</span></span><br><span class="line">        count = e-&gt;env_pri;   <span class="comment">// 重置时间片 count</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">  env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>在 Lab3/4 中，我们已经处理了若干种异常，但在 CO 学习中经常出现的一种异常我们还没有处理，就是<strong>数值溢出</strong>（Ov）。在 R3000 中，硬件已经把溢出设置为 <strong>12 号异常</strong>，也就是说，只要设置对应的 <strong>handle 函数</strong>、<strong>异常向量</strong>与<strong>异常处理函数</strong>，我们就能顺利响应这个异常了。 Extra 的任务，就是响应 addi、add、sub 这三类指令可能产生的<strong>溢出异常</strong>。</p><p>这三类溢出的处理规则如下：</p><ul><li>  <code>add</code>：将指令修改为 <code>addu</code>，直接返回原 EPC</li><li>  <code>sub</code>：将指令修改为 <code>subu</code>，直接返回原 EPC</li><li>  <code>addi</code>：令 RF[rt]=RF[rs]/2+imm/2 ，返回至 EPC + 4 继续执行</li></ul><p>下面还有很多提示，能想起来的就直接放下一部分了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>  首先需要明确我们需要做的有三件事：</li><li>  注册 handle 函数</li><li>  更新异常向量组，使其支持跳转至 Ov 的异常处理函数</li><li>  编写异常处理函数逻辑</li></ul><p>前两步很简单，只要仿照对应文件中其他异常的处理方式来就可以了</p><h3 id="注册-handle-函数"><a href="#注册-handle-函数" class="headerlink" title="注册 handle 函数"></a>注册 handle 函数</h3><ul><li>  在 <code>kern/genex.S</code> 中，增加处理 Ov 的 <code>handle_ov</code> ，可以命名其异常处理函数名为 <code>do_ov</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BUILD_HANDLER ov do_ov</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新异常向量组"><a href="#更新异常向量组" class="headerlink" title="更新异常向量组"></a>更新异常向量组</h3><ul><li>  开始没看见直接写了溢出是12号异常，我直接当场下载 See Mips Run Linux 开始查（）</li><li>  在 <code>kern/traps.c</code> 中，更新异常向量：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line">    [<span class="number">12</span>] = handle_ov,        <span class="comment">// 支持 handle_ov 以处理 ov</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异常处理函数-do-ov"><a href="#异常处理函数-do-ov" class="headerlink" title="异常处理函数 do_ov"></a>异常处理函数 <code>do_ov</code></h3><ul><li>  这个函数的核心就是<strong>分析 EPC</strong> 这条指令的内容并加以修改。</li></ul><p>但由于一些我忘了的原因（有笨比），我们不能在内核态中直接通过用户态的虚拟地址获得地址上的值，所以如何访存就又成了一个问题。</p><p>题目提示：可以从 EPC 的 va 出发，找到它所对应的 pa，再将 pa 转换为 kseg0 区域的 va ，这样就能不通过页表之类的操作直接访问到了。所以大致的处理思路如下：</p><p>EPC(va)\to pa\to va(kseg0)\to *va(code)</p><p>许多同学在第一步转化物理地址时使用了宏 <code>va2pa</code> ，但是这玩意它只能找到 pa 所在页框的<strong>基地址</strong>，<strong>页内偏移它没有！</strong>然后好多人就绷了（）</p><p>还好我根本没想起来有这么个宏，还好我机智地使用了 <code>page_lookup</code> 老老实实地从<strong>页控制块</strong>出发找物理地址，这样就很轻松地记住了要加偏移，要不然直接用了 <code>page2pa(p)</code>，看过去就显然没有页内偏移（）</p><p>然后就很轻松地得到了目标指令。</p><ul><li>  随后要分析指令类型进行异常处理</li></ul><p><code>add</code> 和 <code>sub</code> 两个指令修改太简单了，直接给指令值+1就能用了，在 <code>addi</code> 中要稍微多想一点。</p><p><code>addi</code> 需要更新寄存器的值，同时也需要更新 EPC，这时就要从传入的用户栈中修改信息。修改过程中需要注意从指令里取出寄存器号之后要<strong>移动到最低位</strong>才能使用，有人 <code>addi</code> 了半天 0 号寄存器，才发现原来寄存器号还在高位呆着（）</p><p>最最后，调用一下 <code>printk</code>，异常统计变量自增，结束力！</p><h2 id="一种可行的解答-1"><a href="#一种可行的解答-1" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>直接上代码了，依然是一坨不可名状的东西</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_ov</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">  <span class="comment">// printk(&quot;Got an ov\n&quot;);</span></span><br><span class="line">  u_int badva = tf-&gt;cp0_epc;</span><br><span class="line">  Pde *pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">  Pte **ppte = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page_lookup(pgdir, badva, ppte);</span><br><span class="line">  <span class="comment">// pgdir_walk(pgdir, badva, 0, &amp;p);</span></span><br><span class="line">  u_int badpa = page2pa(p) + (badva &amp; <span class="number">0xfff</span>);</span><br><span class="line">  u_int *badk0va = <span class="number">0x80000000</span>  badpa;</span><br><span class="line">  u_int code = *badk0va;</span><br><span class="line">  <span class="comment">// printk(&quot;got code %x\n&quot;, code);</span></span><br><span class="line">  <span class="keyword">if</span> (code &amp; <span class="number">0x20000000</span>) &#123; <span class="comment">// addi</span></span><br><span class="line">    u_int s = (code &amp; <span class="number">0x3e00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    u_int t = (code &amp; <span class="number">0x1f0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    u_int svalue = tf-&gt;regs[s];</span><br><span class="line">    u_int imm = code &amp; <span class="number">0xffff</span>;</span><br><span class="line">    tf-&gt;regs[t] = svalue / <span class="number">2</span> + imm / <span class="number">2</span>;</span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// printk(&quot;inform:%x %d %d %x %x\n&quot;, code, s, t, svalue, tf-&gt;regs[t]);</span></span><br><span class="line">    printk(<span class="string">&quot;addi ov handled\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((code &amp; <span class="number">0x1f</span>) == <span class="number">0</span>) &#123; <span class="comment">// add</span></span><br><span class="line">    printk(<span class="string">&quot;add ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// sub</span></span><br><span class="line">    printk(<span class="string">&quot;sub ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  curenv-&gt;env_ov_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="debug-思路"><a href="#debug-思路" class="headerlink" title="debug 思路"></a>debug 思路</h2><p>在第一次写完之后，测试很华丽地给我返回了错误值：<code>$v0 = 0xffffffff</code>（-1），这是测试程序提示处理有误的返回值。想要de出来bug在哪出现的，自然需要回到那个返回错误值的地方看一眼。所以我就在函数里打了几个 <code>printk</code>，现在还在注释里（）。 同时把三个会 <code>return -1</code> 的地方修改成了返回<strong>不同的值</strong>，然后看看到底是哪里寄了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* tests/lab3_ov/test_ov.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> src1, src2, dst;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 add, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 + src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果异常处理结果不正确进程将运行结束并返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 sub, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 - src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// change the return value to figure the error place</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 addi, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 / <span class="number">2</span> + <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// change too</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一看，哈哈 <code>return -3</code> ，<code>addi</code> 我来辣（×）</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-Report</title>
      <link href="/2023/04/trashed-2/"/>
      <url>/2023/04/trashed-2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-Report</title>
      <link href="/2023/04/buaa-os-2023-lab4-report/"/>
      <url>/2023/04/buaa-os-2023-lab4-report/</url>
      
        <content type="html"><![CDATA[<p> </p><h1 id="Lab4-实验报告"><a href="#Lab4-实验报告" class="headerlink" title="Lab4 实验报告"></a>Lab4 实验报告</h1><p> </p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p> </p><h2 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h2><ul><li>  思考并回答下面的问题：</li><li>  内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>  系统陷入内核调用后可以直接从当时的$a0-$a3 参数寄存器中得到用户调用msyscall留下的信息吗？</li><li>  我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？</li><li>  内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul><ol><li> 在系统发生异常时跳入异常分发程序时，会先调用 <code>SAVE_ALL</code> 宏定义，把所有寄存器（用户态现场）保存在内核栈 KSTACKTOP 下。最后将 sp寄存器指向保存的这个栈帧。这样既能保护用户态时通用寄存器的值不被改变，同样也能在内核态中便捷地调用每个寄存器的值</li><li> 可以直接调用。系统调用 <code>msyscall</code> 时只通过 <code>SAVE_ALL</code>将寄存器的值复制到了内核栈中，但对寄存器中的值没有做任何处理，仍然保持着用户态进入时的状态。所以这时参数寄存器内数值仍然可用。</li><li> 在 <code>do_syscall</code> 函数中，我们通过系统调用向量 <code>syscall_table</code> 选择系统调用函数后，在函数内调用了 <code>func(arg1, arg2, arg3, arg4, arg5);</code> ，此处的 <code>arg</code>都来源于用户态中保存的参数寄存器和栈帧内。所以相当于调用了相同参数的函数。</li><li>系统调用过程中：<ul><li>  <code>tf-&gt;regs[2] = func(arg1, arg2, arg3, arg4, arg5);</code> 更改了 v0 寄存器以保存系统调用执行后的返回值；</li><li>  <code>tf-&gt;cp0_epc += 4;</code> 更改了 cp0_epc 寄存器以使得返回用户态的执行语句变为执行系统调用的后一条指令</li></ul></li></ol><h2 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h2><ul><li>  思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</li></ul><p>在产生 <code>env_id</code> 的函数 <code>mkenvid</code> 中，id 的低10位会保留为该 env 块在 envs 中的序号，高位是一个按序增大的数。当再次申请一个曾经被调度过的 env 块时，<strong>两次获取的 <code>env_id</code> 低10位相同，高位不同</strong>。 我们在 <code>envid2env</code> 中直接用 <code>e = &amp;envs[ENVX(envid)];</code> 选取了 env 块，实际上此时只能保证取出的块与 id 的低10位一定相同，没有对10位以上进行检验。为了避免出现高位不同而无效的 <code>env_id</code> ，我们需要再判断一次 <code>e-&gt;env_id != envid</code> 。 如果没有这步判断，可能会导致<strong>之前申请这个 env 产生的</strong> <code>env_id</code> 再次获取到这个 env 块。（然而实际上旧 id 已经失效了）</p><h2 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h2><ul><li>  思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释</li></ul><p>首先在 <code>envid2env</code> 函数中，为了进程能够便利地获得自身进程的 <code>env</code> ，我们规定了当输入 ID = 0 时，会返回当前进程的控制块。如果 <code>mkenvid</code> 函数产生了一个 ID = 0 的进程块，那么这个功能将无法判断当前是在查询 <code>ID = 0</code> 的进程块，还是在查询当前进程的进程块了 在 <code>sys_ipc_send</code> 中更新接收者信息时也会发生这样的状况，若发送者 <code>env_id</code> 为 0，那么接收者将混淆发送者，有可能会是自己发给自己的（）</p><h2 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h2><ul><li>  关于fork 函数的两个返回值，下面说法正确的是： A、fork 在父进程中被调用两次，产生两个返回值 B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回</li></ul><p>选 C 。 <code>fork</code> 函数在父进程想要创建子进程时被执行，在执行过程中创建了一个新的进程。同时子进程会返回 0 ，父进程将会返回子进程的 id，方便父进程进行规划。</p><h2 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h2><ul><li>  我们并不应该对所有的用户空间页都使用duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合kern/env.c 中env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考</li></ul><p><code>UTEXT</code> 之下的无效内存、<code>USTACKTOP</code> 之上的空白区与用户异常栈都不需要进行页面映射。在进入 <code>duppage</code> 函数内，只读页面与共享同写页面都不需要进行映射。除此之外，用户区的其他页面都需要进行映射。</p><h2 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h2><ul><li>  在遍历地址空间存取页表项时你需要使用到vpd 和vpt 这两个指针，请参考user/include/lib.h 中的相关定义，思考并回答这几个问题：</li><li>  vpt 和vpd 的作用是什么？怎样使用它们？</li><li>  从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>  它们是如何体现自映射设计的？</li><li>  进程能够通过这种方式来修改自己的页表项吗？</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure><p>  <code>vpt</code> 指向了用户进程自身的<strong>用户页表基址</strong>； <code>vpd</code> 指向了用户进程的<strong>用户页目录基址</strong>。<code>vpd</code> 可以视作用户的 <code>cur_pgdir</code>，<code>vpt</code>则可以看作 <code>cur_pgdir[0]</code> 这是两个系统定义的便于读取用户态页表的宏，它们指向了位于 kuseg 中的页表虚拟地址。程序允许访问 kuseg 中的虚拟地址，从过 vpt 和 vpd ，用户就能获取自身的页表。 UVPT 本身就是用户页表的基地址，vpt 自然是页表基址。<code>(PDX(UVPT) &lt;&lt; PGSHIFT))</code> 指向了用户页表所在的页目录项，这里的取法来自页表的自映射。 进程页表在这种情况下应当只允许读取，不允许这样修改，否则可能会出现错误的访问。</p><h2 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h2><ul><li>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：<ul><li>  这里实现了一个支持类似于“<strong>异常重入</strong>”的机制，而在什么时候会出现这种“异常重 入”？</li><li>  内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></li></ul><p>当处理 <code>tlb_mod</code> 时，可能会发生<strong>用户异常处理函数出错</strong>导致的异常，这时需要重入处理；同时由于没有关闭中断，所以若再次发生外部中断（时钟中断），也会触发异常的重入 如果在这里不保存 Trapframe 的话，do_tlb_mod 函数会跳转至用户设置的异常处理函数 <code>env_user_tlb_mod_entry</code> 中，但当该函数执行结束后，将无法恢复 EPC，所以需要先保存用户现场再返回  </p><h2 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h2><ul><li>  在用户态处理页写入异常，相比于在内核态处理有什么优势？</li></ul><p>在用户态处理，相较于内核态处理最明显的区别就在于其省去了跳转进入内核态的繁琐操作，为频繁的跳转省去了大量时间。 其次在用户态处理，给用户自定义页写入异常处理函数的入口，使得操作系统的处理更多样性、更灵活。  </p><h2 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h2><p>请思考并回答以下几个问题：</p><ul><li>  为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li><li>  如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul><h3 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd:23.5.4"></a>Upd:23.5.4</h3><p>前两年的这个题好像放的是缺页中断的处理函数？我们这里变成了设置页写入异常的处理函数。如果在 syscall_exofork 中，写入了某个曾经被标记为 TLB_COW 的页面，此时的 tlb_Mod 将无法处理。虽然我觉得这种情况应该不会发生？确实不太明白 其实我觉得如果我们的 syscall_exofork 不是一个内联函数的话，这里就有点意义了，可以防止 syscall_exofork 的栈帧被父进程覆盖，导致子进程无法返回（但是做法也不对，应该把duppage也移动过来，实际上更寄） 如果放在写时复制机制完成后设置，一旦在这两步操作中出现了进程的 TLB_Mod，进程就会因为无法处理异常而 panic 对于第二问，如果先执行完写时复制机制，这时的所有原本可写 &amp; 非共享的用户页都成为写时复制页，这就导致了 USTACKTOP 这一页也变成了写时复制页，在此之后的任意一个会创建栈帧的函数都不能执行了，因为这样会写入用户栈，并进入 TLB_Mod，此时又会因为没有设置 handler 导致 panic 可能是因为，如果先fork的话，还需要给子进程设置一下cow_entry；但如果先给父进程设置entry的话，生成子进程的exofork过程中调用了env_alloc，会自动复制父进程的cow_entry，就省去了额外在子进程中设置entry的步骤，写时复制机制可以直接运行（大概） 因为在 fork 函数中调用的 duppage 函数中也会发生页写入异常。如果不设置 mod_entry 就先进行 fork，会导致无法响应页写入异常。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在 Lab4 中，我们学习了：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><p>主要实现了用户进程的创建，完善了不同进程间内存空间的处理机制。完成进程创建，尤其是进程内存的使用后， Lab5 中，基于进程的文件系统才能更好实现。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab3</title>
      <link href="/2023/04/buaa-os-probe-lab3/"/>
      <url>/2023/04/buaa-os-probe-lab3/</url>
      
        <content type="html"><![CDATA[<p> </p><h1 id="Lab3-进程与异常"><a href="#Lab3-进程与异常" class="headerlink" title="Lab3 - 进程与异常"></a>Lab3 - 进程与异常</h1><p>Lab3 中主要涉及到以下内容：</p><ul><li>  进程的创建</li><li>  时钟中断与内核态</li><li>  进程调度与进程切换</li><li>  <strong>数据进程控制块</strong> <code>Env</code></li></ul><h1 id="进程控制块与初始化"><a href="#进程控制块与初始化" class="headerlink" title="进程控制块与初始化"></a>进程控制块与初始化</h1><ul><li>  由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。</li><li>  进程是一个活动中的实体，拥有自己的虚拟地址空间。</li><li>  程序是非活动的实体，<strong>执行中</strong>的程序就是<strong>进程</strong></li></ul><h2 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 - PCB"></a>进程控制块 - PCB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// 保存上下文环境，定义于 trap.h 中</span></span><br><span class="line">    LIST_ENTRY(Env) env_link;<span class="comment">// 构建空闲进程链表 env_free_link</span></span><br><span class="line">    u_int env_id;<span class="comment">// 进程标识符</span></span><br><span class="line">    u_int env_parent_id;<span class="comment">// 父进程的进程 id</span></span><br><span class="line">    u_int env_status;<span class="comment">// 进程块状态位</span></span><br><span class="line">    Pde *env_pgdir;<span class="comment">// 进程页目录的虚拟地址</span></span><br><span class="line">    TAILQ_ENTRY(Env) env_sched_link;<span class="comment">// 构造调度队列 env_sched_list</span></span><br><span class="line">    u_int env_pri;<span class="comment">// 进程优先级，与后续时间片调度进程相关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>env_status</code>：<ul><li>  <code>ENV_FREE</code>：进程控制块处于空闲链表中，值为0</li><li>  <code>ENV_NOT_RUNNABLE</code>：<strong>阻塞态</strong>，可转变为就绪状态，值为1</li><li>  <code>ENV_RUNNABLE</code>：就绪、执行状态（等待调度/运行中），值为2</li></ul></li><li>  在 MOS 中，进程控制块的<strong>物理地址</strong>已经被分配好了（<code>envs</code>数组）</li></ul><p>这里的初始化使用了__attribute__函数，做完再看 其中的结构体 <code>TrapFrame</code> 在 Lab4 中作用比较大，但在 Lab3 中没有必要过于关注，结构就不再过多介绍了 Env 块中存在两个链表（<code>env_free_list</code>和<code>env_sched_list</code>），<code>TAILQ</code> 结构在 Lab2 的 Probe 中已经提过了，该结构为双向的有尾列表，支持在头尾进行元素增删操作。</p><h2 id="跨页地址映射-map-segment-Exercise-3-2"><a href="#跨页地址映射-map-segment-Exercise-3-2" class="headerlink" title="跨页地址映射 - map_segment - Exercise 3.2"></a>跨页地址映射 - <code>map_segment</code> - Exercise 3.2</h2><ul><li>  函数作用如下：物理地址映射到指定进程的虚拟地址中（更大的 <code>page_insert</code>）</li><li>将物理地址 pa <strong>按页映射</strong>到指定进程页表中（va）<ul><li>  映射大小 size 必须是<strong>页面大小的整数倍</strong></li></ul></li><li>  设置用到的页表项权限位为 perm</li></ul><p>这个函数在上面的 <code>env_init()</code>中使用过，其将内核中 pages 与 envs 所在的物理地址映射到内核页表中，我们可以根据下面这个实例补充代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), </span><br><span class="line">BY2PG), PTE_G);</span><br></pre></td></tr></table></figure><p>代码中注释已经给好方向，使用<code>page_insert()</code>，将 <code>[va, va+size)</code> 所涉及到的每个页面都映射到 pa 开始的页面中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 将 pa 地址内容映射到指定页目录中的虚拟地址 va</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">map_segment</span><span class="params">(Pde *pgdir, u_int asid, u_long pa, u_long va,</span></span><br><span class="line"><span class="params">                        u_int size, u_int perm)</span> &#123;</span><br><span class="line">  <span class="comment">/* 预先确保地址对齐 */</span></span><br><span class="line">  assert(pa % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(va % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(size % BY2PG == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 循环对应的每一页形成映射 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123; </span><br><span class="line">    <span class="comment">/*  使用 pa2page 获取物理地址 pa 对应的页控制块</span></span><br><span class="line"><span class="comment">     * va + i 表示每个虚拟页的基地址，pa + i 表示页框基地址</span></span><br><span class="line"><span class="comment">     * 使用 page_insert 形成新映射，**权限**设置为 perm</span></span><br><span class="line"><span class="comment">     * Exercise 3.2: Your code here. */</span></span><br><span class="line">    page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程块队列初始化-env-init-Exercise-3-1"><a href="#进程块队列初始化-env-init-Exercise-3-1" class="headerlink" title="进程块队列初始化 - env_init - Exercise 3.1"></a>进程块队列初始化 - <code>env_init</code> - Exercise 3.1</h2><ul><li>  函数功能：初始化 envs 链表</li><li>  完成 <strong>Env 控制块</strong>的空闲队列、调度队列的<strong>初始化功能</strong></li><li>  空闲队列需要<strong>倒序插入</strong>，用来优先分配小序号的进程控制块 Env</li><li>  临时存放 内核结构 ‘pages’ 与 ‘envs’ ，为后续映射做准备（详见 Exercise 3.3）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">/* Step 1: 初始化 `env_free_list` 与 `env_sched_list` 两个调度队列 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (1/2) */</span></span><br><span class="line">  LIST_INIT(&amp;env_free_list);</span><br><span class="line">  TAILQ_INIT(&amp;env_sched_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 将所有进程控制块插入空闲队列中，注意需要 **倒序** 插入 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (2/2) */</span></span><br><span class="line">  <span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;env_free_list, &amp;envs[i], env_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将内核结构 &#x27;pages&#x27; 与 &#x27;envs&#x27; 映射到每个用户空间的虚拟地址（UPAGES </span></span><br><span class="line"><span class="comment">   * 和 UENVS）中，并要求只读，这里先暂时把两个内容存在一个临时页目录 &#x27;base_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   * 中，并建立映射，直至 `env_setup_vm&#x27; 中再将其拷贝进用户页目录 &#x27;env_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  panic_on(page_alloc(&amp;p));</span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">  base_pgdir = (Pde *)page2kva(p);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES,</span><br><span class="line">              ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG), PTE_G);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS,</span><br><span class="line">              ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG), PTE_G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现较简单，注意要区分 Env 结构体中存在的链表，env_free_list 链表需要使用 env_link 连接，使用LIST类宏操作；而 env_sched_list 需要使用 env_sched_link 连接，使用 TAILQ 类宏操作</p><h2 id="env-id-与进程表示"><a href="#env-id-与进程表示" class="headerlink" title="env_id 与进程表示"></a>env_id 与进程表示</h2><p>在进程管理块 Env 中，有三个与 <code>id</code> 相关的字段，它们从不同的方式代表进程</p><ul><li>  <code>env_id</code> ：（进程标识符，unique environment identifier）MOS 操作系统中使用 <code>env_id</code> <strong>唯一地</strong>表示不同进程，在创建进程时被 <code>mkenvid</code> 函数赋值</li><li><code>env_asid</code> ：（地址空间标识符，Address-Space IDentifier）ASID也可以<strong>唯一地</strong>标记进程，同时为进程提供相应的<strong>地址保护</strong><ul><li>  在 MOS 实验系统中使用 &lt;VirtualPageNumber, ASID&gt; 作为索引在 TLB 中查询映射</li><li>  在 MOS 中，使用了<strong>位图法</strong>管理了64个 ASID ，具体位于 asid_alloc 函数中</li></ul></li><li>  <code>env_parentid</code> ：（env_id of this env’s parent）顾名思义是创建本进程的父进程的 <code>env_id</code></li></ul><p>对于<code>id</code>与<code>asid</code>：<code>id</code>指的是控制块和线程自己的属性；<code>asid</code>则在 TLB 、地址管理上用的比较多 <code>env_id</code> 的值从同文件中的 <code>mkenvid()</code> 函数中得来，asid由同文件中的 <code>asid_alloc()</code> 得到</p><h2 id="Linux-中的-ASID-分代机制-（有空再补）"><a href="#Linux-中的-ASID-分代机制-（有空再补）" class="headerlink" title="Linux 中的 ASID 分代机制 （有空再补）"></a>Linux 中的 ASID 分代机制 （有空再补）</h2><p>   </p><h1 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h1><p>程序想要成为进程，必须要把对应的的 ELF 文件（此处为<strong>可执行文件</strong>）中所有需要加载的 <strong>程序段(Segment)</strong> 分配进虚拟内存空间中。但在 lab3 中我们还不能直接操作磁盘中的文件，所以 ELF 文件被转化为C数组的形式，再通过编译到内核完成加载 这里可以使用部分函数操作 ELF 文件，加载整个文件进入内存、获取其文件头、加载 segment 至内存</p><h2 id="ELF-文件函数"><a href="#ELF-文件函数" class="headerlink" title="ELF 文件函数"></a>ELF 文件函数</h2><ul><li>  <code>load_icode()</code>：加载可执行文件至指定进程内存（调用的最外层函数）</li><li>  <code>elf_from()</code>：解析 ELF 文件头，获取段位置</li><li>  <code>elf_load_seg()</code>：加载 ELF 程序段</li><li><code>load_icode_mapper()</code>：分配一页物理页，在 env 块对应的页表中建立映射<ul><li>  可能需要复制 src 处的数据到该物理页面中</li></ul></li></ul><h2 id="加载-ELF-文件-load-icode-Exercise-3-6"><a href="#加载-ELF-文件-load-icode-Exercise-3-6" class="headerlink" title="加载 ELF 文件 - load_icode - Exercise 3.6"></a>加载 ELF 文件 - <code>load_icode</code> - Exercise 3.6</h2><ul><li>  函数作用：调用相关函数，将 ELF 文件加载进指定进程中</li><li>  解析 ELF 头获取段信息</li><li>  使用 <code>elf_load_seg</code> 加载每个程序段</li><li>  初始化 EPC 指向程序入口点地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: 解析 ELF 头 */</span></span><br><span class="line">  <span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size);</span><br><span class="line">  <span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 循环加载每个程序段</span></span><br><span class="line"><span class="comment">   * 循环：使用 ELF_FOREACH_PHDR_OFF</span></span><br><span class="line"><span class="comment">   * 加载：使用 elf_load_seg</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">size_t</span> ph_off;</span><br><span class="line">  ELF_FOREACH_PHDR_OFF(ph_off, ehdr) &#123;</span><br><span class="line">    Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">      <span class="comment">// &#x27;load_icode_mapper&#x27; 指定了用户的加载方式</span></span><br><span class="line">      panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将进程起始地址 EPC 指向 ELF 入口 e_entry ，执行程序入口点指令 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.6: Your code here. */</span></span><br><span class="line">  e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">  <span class="comment">/* env_tf.cp0_epc 字段指示了进程运行时PC 应指向的位置,说明其为连续的虚拟地址中</span></span><br><span class="line"><span class="comment">     的某一个值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ELF_FOREACH_PHDR_OFF</code>：在上述的顶层函数中，调用了一个宏，其展开后对 ELF 程序段进行循环：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_FOREACH_PHDR_OFF(ph_off, ehdr)        \</span></span><br><span class="line"><span class="meta">(ph_off) = (ehdr)-&gt;e_phoff;                   \</span></span><br><span class="line"><span class="meta">for (int _ph_idx = 0; _ph_idx <span class="string">&lt; (ehdr)-&gt;</span>e_phnum; ++_ph_idx, (ph_off) += (ehdr)-&gt;e_phentsize)</span></span><br></pre></td></tr></table></figure><h2 id="elf-load-seg"><a href="#elf-load-seg" class="headerlink" title="elf_load_seg"></a><code>elf_load_seg</code></h2><ul><li>  函数作用：把 ELF 程序段加载到 <code>data</code> 处； MOS 中在 <code>load_icode</code> 内配合 <code>load_icode_mapper</code> 调用，也就是<strong>把程序段加载到进程内存里</strong></li><li>  按页划分，分别映射每一页至 data 中</li><li>  回调函数 <code>map_page</code> 决定映射的方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 加载 ELF 文件的段至 data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   bin != NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 if success. Otherwise return &lt; 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">u_long va = ph-&gt;p_vaddr;</span><br><span class="line"><span class="type">size_t</span> bin_size = ph-&gt;p_filesz;<span class="comment">// 文件大小</span></span><br><span class="line"><span class="type">size_t</span> sgsize = ph-&gt;p_memsz;<span class="comment">// 内存大小，需要补齐这一段差值</span></span><br><span class="line">u_int perm = PTE_V;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">perm = PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;              <span class="comment">// 起始地址未页对齐，映射第一页</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: 映射 p_filesz 至指定区中 */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 补全空白页至 p_memsz */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">i += BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页映射回调函数-load-icode-mapper-Exercise-3-5"><a href="#页映射回调函数-load-icode-mapper-Exercise-3-5" class="headerlink" title="页映射回调函数 - load_icode_mapper - Exercise 3.5"></a>页映射回调函数 - <code>load_icode_mapper</code> - Exercise 3.5</h2><ul><li>  函数作用：作为 <code>load_icode</code> 中使用的回调函数，它决定了页映射的方式</li><li>  申请一个物理页 <code>page_alloc</code></li><li>  复制一下src内容（注意不要复制多/少了） <code>memcpy</code></li><li>  把这个复制好的物理页映射到目标 env 里 <code>page_insert</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 把 src 处数据映射到进程 data 的va 处，更新 perm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;offset + len&#x27; &lt;= &#x27;BY2PG&#x27;.</span></span><br><span class="line"><span class="comment"> * 换句话说就是复制过去后也只在**同一个**虚拟页里面，不会跨页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个装内容的物理页 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 2: 复制 src 内容 */</span></span><br><span class="line">  <span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) (page2kva(p) + offset), src, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 把物理页插进 env 进程页表，创建映射，完成复制 */</span></span><br><span class="line">  <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>创建进程的过程主要由 <code>env_alloc</code> 函数实现，其步骤大致如下：</p><ul><li>  申请一个空闲的进程控制块</li><li>  初始化这个空白的控制块</li><li>  初始化进程<strong>页目录</strong></li><li>  从 env_free_list 中取出该控制块</li></ul><p><strong>用户栈</strong>是在使用过程中动态分配的</p><h2 id="进程页目录初始化-env-setup-vm-Exercise-3-3"><a href="#进程页目录初始化-env-setup-vm-Exercise-3-3" class="headerlink" title="进程页目录初始化 - env_setup_vm - Exercise 3.3"></a>进程页目录初始化 - <code>env_setup_vm</code> - Exercise 3.3</h2><ul><li>  函数作用：初始化进程页目录（共享只读段映射和自映射）</li><li>  <strong>形成进程页表</strong>，初始化新进程的虚拟地址空间</li><li>  把 UTOP 至 UVPT 两段地址间的内核页表 base_pgdir 拷贝到进程页表中，借此暴露这段由<strong>所有进程共享</strong>的只读空间（ Exercise 3.1完成了 base_pgdir 的建立与映射）</li></ul><p>关于共享只读的空间，指导书这样解释：</p><blockquote><p>在MOS 操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这是MOS 特有的设计。在Lab4 和Lab6 中将用到此机制。而这里我们要暴露是<strong>UTOP 往上到UVPT 之间所有进程共享的只读空间</strong>，也就是把这部分内存对应的内核页表base_pgdir 拷贝到进程页表中。从UVPT 往上到ULIM 之间则是进程自己的页表。</p></blockquote><p>拷贝的这一段空间，具体来说存放的是 envs 和 pages 两个经常使用的结构体，使其共享只读确实能够减少大量对内核空间的访问；不然用户进程申请个物理页都要进内核看 pages 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 初始化进程的**用户内存（虚拟地址）空间**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 1: 使用 page_alloc 申请一页物理页框存放进程页目录 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  try(page_alloc(&amp;p));</span><br><span class="line">  <span class="comment">/* Exercise 3.3: Your code here. */</span></span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line">  e-&gt;env_pgdir = (Pde *) page2kva(p);</span><br><span class="line">  <span class="comment">/* Step 2: 将 &#x27;base_pgdir&#x27; 页目录内容拷贝至 &#x27;e-&gt;env_pgdir&#x27; 中 */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">         <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 设置页表自映射：令对应的页目录项指向页目录物理基地址 */</span></span><br><span class="line">  e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir)  PTE_V;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  使用 memcpy 时虽然只进行了页目录的拷贝，但两个页目录此时指向了相同的二级页表（物理页），之后再寻址就一样了</li><li>  页表自映射细节在 Thinking 3.1 中，可以回 Report 看一眼</li></ul><h2 id="申请并初始化进程块-env-alloc-Exercise-3-4"><a href="#申请并初始化进程块-env-alloc-Exercise-3-4" class="headerlink" title="申请并初始化进程块 - env_alloc - Exercise 3.4"></a>申请并初始化进程块 - <code>env_alloc</code> - Exercise 3.4</h2><ul><li>  函数作用如下：</li><li>  从空闲控制块链表中申请一个<strong>进程控制块</strong>（类似于 <code>page_alloc</code> 申请页）</li><li>  使用 <code>env_setup_vm</code> 函数和赋值语句对控制块进行初始化</li><li>  把申请好的控制块从链表中摘除并返回</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   申请并初始化进程块，存放在 &#x27;*new&#x27; 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   无父进程时 parent_id = 0</span></span><br><span class="line"><span class="comment"> *   需要初始化 envs（使用 env_init 函数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 on success</span></span><br><span class="line"><span class="comment"> *   return &lt; 0 on error：无空闲进程、ASID 或 &#x27;env_setup_vm&#x27; 失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   可能需要初始化下列字段:</span></span><br><span class="line"><span class="comment"> *     &#x27;env_id&#x27;, &#x27;env_asid&#x27;, &#x27;env_parent_id&#x27;, &#x27;env_tf.regs[29]&#x27;,</span></span><br><span class="line"><span class="comment"> * &#x27;env_tf.cp0_status&#x27;, &#x27;env_user_tlb_mod_entry&#x27;, &#x27;env_runs&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请空闲块，存放在 e 里 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (1/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e = LIST_FIRST(&amp;env_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: 使用 &#x27;env_setup_vm&#x27; 初始化用户空间 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (2/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (env_setup_vm(e)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 3: 初始化字段：</span></span><br><span class="line"><span class="comment">   *   &#x27;env_user_tlb_mod_entry&#x27; (lab4), &#x27;env_runs&#x27; (lab6), &#x27;env_id&#x27; (lab3),</span></span><br><span class="line"><span class="comment">   * &#x27;env_asid&#x27; (lab3), &#x27;env_parent_id&#x27; (lab3)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Hint:</span></span><br><span class="line"><span class="comment">   *   asid: asid_alloc</span></span><br><span class="line"><span class="comment">   *   envid: mkenvid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  e-&gt;env_user_tlb_mod_entry = <span class="number">0</span>; <span class="comment">// for lab4</span></span><br><span class="line">  e-&gt;env_runs = <span class="number">0</span>;               <span class="comment">// for lab6</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (3/4) */</span></span><br><span class="line">  e-&gt;env_id = mkenvid(e);</span><br><span class="line">  <span class="keyword">if</span> (asid_alloc(&amp;(e-&gt;env_asid)) == -E_NO_FREE_ENV) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;env_parent_id = parent_id;</span><br><span class="line">  <span class="comment">/* Step 4: 初始化 CP0 寄存器与栈顶寄存器 sp */</span></span><br><span class="line">  <span class="comment">// Timer interrupt (STATUS_IM4) will be enabled.</span></span><br><span class="line">  e-&gt;env_tf.cp0_status = STATUS_IM4  STATUS_KUp  STATUS_IEp;</span><br><span class="line">  <span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">  e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 5: 移出控制块并赋值 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (4/4) */</span></span><br><span class="line">  LIST_REMOVE(e, env_link);</span><br><span class="line">  *new = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化两个 ID 时，使用了两个不需要填空的函数，体现了操作系统生成不重复的 ID 的方式和位图法保存 ASID 的应用，这边也来看一下吧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算一个 ASID 并存入参数指针内</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">asid_alloc</span><span class="params">(u_int *asid)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NASID; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> index = i &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> inner = i &amp; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> ((asid_bitmap[index] &amp; (<span class="number">1</span> &lt;&lt; inner)) == <span class="number">0</span>) &#123;</span><br><span class="line">      asid_bitmap[index] = <span class="number">1</span> &lt;&lt; inner;</span><br><span class="line">      *asid = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据当前 env ，计算其 env_id</span></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV))  (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在设置<strong>寄存器初始化</strong>时，我们使用了两个赋值语句，这两句关键语句需要解释一下：</p><ul><li><code>e-&gt;env_tf.cp0_status = STATUS_IM4 STATUS_KUp STATUS_IEp</code><ul><li>  初始化 CP0 的 SR 寄存器， IM4 代表允许响应4号中断、 KUp 代表处于用户态、 IEp 代表允许中断，这里实际上是初始化了<strong>中断响应机制</strong>所需的寄存器条件</li></ul></li><li><code>e-&gt;env_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **)</code><ul><li>  在 USTACKTOP 下存放的实际上就是用户栈，还记得倒置的 mips 栈吗，这里就是栈顶</li></ul></li></ul><p>对于 SR 寄存器，更具体的解释如下： 指导书P66  </p><h2 id="创建内核进程-env-create-Exercise-3-7"><a href="#创建内核进程-env-create-Exercise-3-7" class="headerlink" title="创建内核进程 - env_create -Exercise 3.7"></a>创建内核进程 - <code>env_create</code> -Exercise 3.7</h2><ul><li>  函数作用：创建一个内核进程，并加载 ELF 文件</li><li>  申请没有父进程的进程控制块</li><li>  初始化 priority 和 ENV_RUNNABLE</li><li>  加载 ELF 文件并插入调度队列</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  使用 &#x27;binary&#x27; 与 &#x27;priority&#x27; 字段创建一个进程</span></span><br><span class="line"><span class="comment"> *  在进程调度开始之前创建**内核**进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> Env *<span class="title function_">env_create</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个进程控制块，因为没有父进程所以 parent_id = 0,  &#x27;env_alloc&#x27; */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (1/3) */</span></span><br><span class="line">  env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Step 2: 标记 &#x27;priority&#x27; 并设置为 ENV_RUNNABLE，表示可以运行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (2/3) */</span></span><br><span class="line">  e-&gt;env_pri = (u_int) priority;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  <span class="comment">/* Step 3: 加载 ELF 文件，并插入 &#x27;env_sched_list&#x27; 头，表示允许调度 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (3/3) */</span></span><br><span class="line">  load_icode(e, binary, size);</span><br><span class="line">  TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ENV_CREATE_PRIORITY</code>：MOS 创建内核<strong>示例</strong>进程时使用的宏，定义在 <code>include/env.h</code> 中</li></ul><p>这里用到的 <code>##x##</code> 可以理解成变量替换后的字符串拼接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// priority = y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE_PRIORITY(x, y)                                             \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, y);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// priority = 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE(x)                                                         \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, 1);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 创建进程，binary字段来自名为 binary_user_bare_loop_start 的外部数组，定义在 user/bare/loop.b.c 中</span></span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p> </p><h2 id="再探-mmu-h"><a href="#再探-mmu-h" class="headerlink" title="再探 mmu.h"></a>再探 <code>mmu.h</code></h2><p>至此，一个新的<strong>内核进程</strong>创建过程就结束了，在 Lab4 中还会用部分函数创建<strong>用户进程</strong>。回顾一下。在申请进程之前，我们先初始化了进程控制块链表(<code>env_init</code>)，在申请过程中初始化了它的内存空间、页表(<code>env_setup_vm</code>)与进程控制块字段，最后返回(<code>env_alloc</code>)。 借助 Lab2 已有的布局和进程建立的过程，我们可以大致构建起一个不断完善的内存体系，这时候 <code>include/mmu.h</code> 内的内存布局图就可以再拿出来用了。不过实际上，仍有一些字段我们没有使用，这些字段在 Lab4 中会再加以利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Part 2.  Our conventions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> o 4G -----------&gt;  +----------------------------+------------0x100000000</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg2</span></span><br><span class="line"><span class="comment"> o  KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span></span><br><span class="line"><span class="comment"> o                            Devices             kseg1</span></span><br><span class="line"><span class="comment"> o  KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span></span><br><span class="line"><span class="comment"> o                        Invalid Memory           /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+-----------Physical Memory Max</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg0</span></span><br><span class="line"><span class="comment"> o  KSTACKTOP-----&gt; +----------------------------+-----------0x8040 0000---end</span></span><br><span class="line"><span class="comment"> o                         Kernel Stack              KSTKSIZE            /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+----------                </span></span><br><span class="line"><span class="comment"> o                         Kernel Text                                  PDMAP</span></span><br><span class="line"><span class="comment"> o  KERNBASE -----&gt; +----------------------------+-----------0x8001 0000    </span></span><br><span class="line"><span class="comment"> o                        Exception Entry          \/                    \/</span></span><br><span class="line"><span class="comment"> o  ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span></span><br><span class="line"><span class="comment"> o                           User VPT                PDMAP                /\</span></span><br><span class="line"><span class="comment"> o  UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span></span><br><span class="line"><span class="comment"> o                             pages                 PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    </span></span><br><span class="line"><span class="comment"> o                             envs                  PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UTOP,UENVS ---&gt; +----------------------------+------------0x7f40 0000    </span></span><br><span class="line"><span class="comment"> o  UXSTACKTOP -/        user exception stack        BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f f000    </span></span><br><span class="line"><span class="comment"> o                                                   BY2PG                 </span></span><br><span class="line"><span class="comment"> o  USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    </span></span><br><span class="line"><span class="comment"> o                       normal user stack           BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f d000    </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                         kuseg</span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> o   UTEXT   -----&gt; +----------------------------+------------0x0040 0000    </span></span><br><span class="line"><span class="comment"> o                        reserved for COW           BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UCOW    -----&gt; +----------------------------+------------0x003f f000    </span></span><br><span class="line"><span class="comment"> o                     reversed for temporary        BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UTEMP   -----&gt; +----------------------------+------------0x003f e000    </span></span><br><span class="line"><span class="comment"> o                         invalid memory                                 \/</span></span><br><span class="line"><span class="comment"> a 0 ------------&gt;  +----------------------------+ ----------------------------</span></span><br><span class="line"><span class="comment"> o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> </p><ul><li>  UPAGES 和 UENVS 处于用户可见区内，包含内核的页面控制块和进程控制块，每个进程拷贝成了相同的内容</li></ul><h2 id="执行进程-env-run-Exercise-3-8"><a href="#执行进程-env-run-Exercise-3-8" class="headerlink" title="执行进程 - env_run - Exercise 3.8"></a>执行进程 - <code>env_run</code> - Exercise 3.8</h2><ul><li>  函数作用：切换并运行指定进程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 切换当前运行进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   使用 &#x27;env_pop_tf&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  assert(e-&gt;env_status == ENV_RUNNABLE);</span><br><span class="line">  pre_env_run(e); <span class="comment">// WARNING: DO NOT MODIFY THIS LINE!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 保存当前运行栈 */</span></span><br><span class="line">  <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">    curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 变更全局变量 curenv */</span></span><br><span class="line">  curenv = e;</span><br><span class="line">  curenv-&gt;env_runs++; <span class="comment">// lab6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 更改当前运行进程的页目录 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (1/2) */</span></span><br><span class="line">  cur_pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 4: 使用 &#x27;env_pop_tf&#x27; 更新寄存器，并返回用户态 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (2/2) */</span></span><br><span class="line">  env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  返回用户态，实际上是个精妙的过程，只不过我们的填空不需要完成这部分，但实在是值得研究研究</li></ul><h2 id="env-pop-tf"><a href="#env-pop-tf" class="headerlink" title="env_pop_tf"></a><code>env_pop_tf</code></h2><ul><li>  修改 CP0 寄存器和 sp 寄存器，为跳回用户态提供数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LEAF(env_pop_tf)</span><br><span class="line">.set reorder</span><br><span class="line">.set at</span><br><span class="line">sll     a1, a1, 6</span><br><span class="line">mtc0    a1, CP0_ENTRYHI    # 把 ENTRYHI 中保存 ASID 的部分改为 curenv-&gt;env_asid</span><br><span class="line">move    sp, a0             # 把栈指针变更为 &amp;curenv-&gt;env_tf</span><br><span class="line">j       ret_from_exception # 离开异常处理程序，返回用户态</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure><h2 id="ret-from-exception"><a href="#ret-from-exception" class="headerlink" title="ret_from_exception"></a><code>ret_from_exception</code></h2><ul><li>  刚才在 <code>env_pop_tf</code> 的最后一句中，我们跳转到了这个汇编函数，它的作用是离开异常处理程序，回到用户态，虽然当前调用不算是异常处理，但是想要完成的作用都一样：<strong>恢复用户态现场，返回用户态执行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">RESTORE_SOME         # 从 sp（视作 tf）中恢复除了 sp 以外的大部分寄存器</span><br><span class="line">lw      k0, TF_EPC(sp)   # 从 tf 中取出 EPC </span><br><span class="line">lw      sp, TF_REG29(sp) # 从 env_tf 中取得用户栈指针，赋值给 sp ，即切换到用户栈</span><br><span class="line">.set noreorder</span><br><span class="line">jr      k0               # 跳转至用户态 EPC ，离开异常处理程序</span><br><span class="line">rfe                      # 调用 rfe，使 SR 寄存器中的二重栈出栈一层</span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure><ul><li>  这里的 EPC 在初始化进程块时就被赋值成了 <strong>ELF 程序入口点</strong>，也就是说会直接 jr 到加载的 ELF 程序开始</li><li>  其中最关键的是 lw sp这一句，把用户栈指针从 tf 中取出，恢复了用户栈</li><li>  最后使用的 rfe 指令也刚好把 <code>env_alloc</code> 时初始化的二重栈用上了。每个进程都需要由此启动，所以确实<strong>都需要执行一次 rfe 指令</strong></li><li>  md，太妙了</li></ul><p> </p><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>P7 的痛苦回忆又回来了.jpg</p><blockquote><p>我们实验里认为中断是异常的一种，并且是仅有的一种<strong>异步异常</strong>。</p></blockquote><h2 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h2><ul><li>  设置 <strong>EPC</strong> 指向返回地址</li><li>  设置 SR 寄存器，强制 CPU 进入内核态</li><li>  设置 Cause 寄存器记录异常原因</li><li>  跳转到异常处理程序入口，执行处理</li></ul><p> </p><h2 id="异常分发程序-exc-gen-entry-Exercise-3-9"><a href="#异常分发程序-exc-gen-entry-Exercise-3-9" class="headerlink" title="异常分发程序 - exc_gen_entry - Exercise 3.9"></a>异常分发程序 - <code>exc_gen_entry</code> - Exercise 3.9</h2><ul><li>  异常分发程序：根据发生的异常跳转到异常处理程序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">SAVE_ALL                      # 将当前寄存器形成 TrapFrame 保存在内核栈 KSTACKTOP 内</span><br><span class="line">/* Exercise 3.9: Your code here. */</span><br><span class="line">mfc0 t0, CP0_CAUSE</span><br><span class="line">andi t0, 0x7c                 # 获取 Cause 寄存器中的 ExcCode</span><br><span class="line">lw t0, exception_handlers(t0) # 通过 handler 获取分发的处理函数入口</span><br><span class="line">jr t0                         # 跳转到对应的异常处理入口，响应异常</span><br></pre></td></tr></table></figure><ul><li>  <code>lw t0, exception_handlers(t0)</code> 指令明明是个访存指令，如何做到获取处理函数地址的呢？</li></ul><p>实际上这是由于 <code>exception_handlers</code> 这个异常向量组以数组的形式保存在内存中。只需要将 t0 寄存器作为下标，我们就能直接访问了这个数组的对应内容（这个内容存放的就是处理函数的地址） 为了程序能找到这个分发程序和处理 TLB Miss 的程序，我们在 <code>kernal.lds</code> 中放置了它们所在的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.tlb_miss_entry : &#123;</span><br><span class="line">*(.text.tlb_miss_entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">= 0x80000080;</span><br><span class="line">.exc_gen_entry : &#123;</span><br><span class="line">*(.text.exc_gen_entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（虽然处理 TLB 的函数会直接跳到主异常分发程序，没啥用（</p><h2 id="异常向量组-exception-handlers"><a href="#异常向量组-exception-handlers" class="headerlink" title="异常向量组 - exception_handlers"></a>异常向量组 - <code>exception_handlers</code></h2><ul><li>  异常分发程序通过 <code>exception_handlers</code> 数组定位中断处理程序，而定义在 <code>kern/traps.c</code> 中的 <code>exception_handlers</code> 就称作<strong>异常向量组</strong>。</li></ul><p>这部分指导书的逻辑很明确，就直接借用了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_tlb</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_sys</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_mod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_reserved</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义在哪个文件可以参考 Report 内容，在思考题中出现过</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读 2 号异常的处理函数为handle_tlb，表示TLB load 异常 3 号异常的处理函数为handle_tlb，表示TLB store 异常 8 号异常的处理函数为handle_sys，表示系统调用，用户进程通过执行syscall 指令陷 入内核</p></blockquote><p>通过访问对应的异常下标，就能在异常分发程序中进入对应的处理函数（目前中断还不行），最后调用 <code>ret_from_exception</code> 返回用户态</p><h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><ul><li>  中断处理的流程</li><li>  进入异常分发程序，判断为中断</li><li>  进入<strong>中断处理程序</strong> <code>handle_int</code>，判断中断种类，再进行分发</li><li>  处理中断结束后，进入 <code>ret_from_exception</code> 返回用户态</li></ul><p>目前我们的 MOS 只能处理一种<strong>时钟中断</strong>，所以中断处理就只有一种选择（）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2              # 获取可以处理的时钟中断</span><br><span class="line">andi    t1, t0, STATUS_IM4  # 中断号 4 号：时钟中断</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0               # 将时钟响应位置0</span><br><span class="line">j       schedule            # 执行 schedule(0)</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><h2 id="时钟中断-kclock-init-Exercise-3-11"><a href="#时钟中断-kclock-init-Exercise-3-11" class="headerlink" title="时钟中断 - kclock_init - Exercise 3.11"></a>时钟中断 - <code>kclock_init</code> - Exercise 3.11</h2><p>MOS 系统产生定时的时钟中断，并根据这些中断分配每个进程运行的时间片（限制进程一次性运行的时间长度）</p><ul><li>  初始化并启用时钟中断</li></ul><p><code>kern/kclock.S</code> 中的 <code>kclock_init</code> 函数完成了时钟中断的初始化，该函数向 <code>KSEG1 DEV_RTC_ADDRESS DEV_RTC_HZ</code> 位置写入200，其中 <code>KSEG1 DEV_RTC_ADDRESS</code> 是模拟器（GXemul）映射<strong>实时钟</strong>的位置。偏移量为 <code>DEV_RTC_HZ</code> 表示设置实时钟中断的频率，200 表示1 秒钟中断200 次。 随后再调用 <code>kern/env_asm.S</code> 中的 <code>enable_irq</code> 函数开启中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">LEAF(kclock_init)</span><br><span class="line">li      t0, 200 // the timer interrupt frequency in Hz</span><br><span class="line"></span><br><span class="line">/* Write &#x27;t0&#x27; into the timer (RTC) frequency register.</span><br><span class="line"> *</span><br><span class="line"> * Hint:</span><br><span class="line"> *   To access device through mmio, a physical address must be converted to a</span><br><span class="line"> *   kseg1 address.</span><br><span class="line"> * #define DEV_RTC_HZ 0x0100</span><br><span class="line"> * #define DEV_RTC_ADDRESS 0x15000000</span><br><span class="line"> *  #define KSEG1 0xA0000000U</span><br><span class="line"> */</span><br><span class="line">/* Exercise 3.11: Your code here. */</span><br><span class="line">sw t0 , (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_HZ)</span><br><span class="line">jr      ra</span><br><span class="line">END(kclock_init)</span><br></pre></td></tr></table></figure><p><code>enable_irq</code> 函数在 Report 里也有，文章太长就不写力</p><ul><li>  时钟中断的处理</li><li><ol><li> 中断产生，进入异常分发程序</li><li> 判断为中断，进入中断处理程序</li><li> 判断为时钟中断，执行处理函数</li><li> 执行 <code>schedule(0)</code>，进行进程调度</li></ol></li></ul><h2 id="进程调度-schedule-Exercise-3-12"><a href="#进程调度-schedule-Exercise-3-12" class="headerlink" title="进程调度 - schedule - Exercise 3.12"></a>进程调度 - <code>schedule</code> - Exercise 3.12</h2><ul><li>  函数功能：根据参数 <code>yield</code> 和当前进程状态进行进程调度</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment"> *   1. 使用 static 变量 count 记录剩余时间片</span></span><br><span class="line"><span class="comment"> *   2. 不需要在 &#x27;noreturn&#x27; 函数中使用 return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always decrease the &#x27;count&#x27; by 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span></span><br><span class="line"><span class="comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span></span><br><span class="line"><span class="comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span></span><br><span class="line"><span class="comment"> * if that list is empty**.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 3.12: Your code here. */</span></span><br><span class="line"><span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在 <code>schedule</code> 函数中，我们没有使用 <code>return</code>，而直接进入了新一轮的 <code>env_run</code>，保存当前已运行的部分内容，开始新的进程。</li><li>  这也说明了为什么只有 <code>timer_irq</code> 没有调用 <code>ret_from_exceprion</code> 函数，因为<strong>不用回到原本执行进程</strong>的用户态了</li></ul><p>  Lab3 大体到这里就结束了，要写的要看的也太多了，有点逆天。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Report</title>
      <link href="/2023/04/buaa-os-2023-lab3-report/"/>
      <url>/2023/04/buaa-os-2023-lab3-report/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h3><ul><li>  Thinking 3.1 请结合MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) PTE_V</code> 的含义</li></ul><p>根据自映射机制可知， <code>e-&gt;env_pgdir[PDX(UVPT)]</code> 指的是进程块 <code>e</code> 的<strong>指向用户页表</strong>的页目录项，又根据页表映射的要求，这一项的内容应该是用户页表的物理地址，即<code>PADDR(e-&gt;env_pgdir)</code> ，再为其置有效位为1，初始化用户页表</p><h3 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h3><ul><li><p>  <code>elf_load_seg()</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code> 。请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></li><li><p>  <code>elf_load_seg()</code> 函数定义位于 <code>lib/elfloader.c</code> 中；使用仅有一处，位于 <code>kern/env.c</code> 的 <code>load_icode()</code> 函数中</p></li></ul><p>首先这里的回调函数是定义在 <code>kern/env.c</code> 的 <code>load_icode_mapper()</code> 函数，作用是把一段虚拟地址的内容<strong>加载</strong>到<strong>某个进程管理块对应进程</strong>的虚拟内存中（通过申请物理页面并建立页表映射）。这两个函数中的 <code>data</code> 参数相同，其来源是待加载的进程管理块指针，它用来告知 <code>load_icode_mapper()</code> 函数加载到哪个进程。所以<strong>不可以</strong>没有这个参数，如果没有这个参数，将无法确定加载到哪个进程的虚拟内存中。</p><p>在 <code>elf_load_seg()</code> 中使用回调函数，可以令用户自定义加载段中各个待加载页面的方式</p><h3 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h3><ul><li>  结合 <code>elf_load_seg()</code> 的参数和实现，考虑该函数需要处理哪些页面加载的情况</li></ul><p>考虑情况如下：</p><ul><li>  段起始地址未页面对齐</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  复制段大小不足一个页面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))</span><br><span class="line"><span class="comment">// MIN(bin_size, BY2PG - offset) 选择了待复制段与页面偏移后</span></span><br><span class="line"><span class="comment">// 剩余空间中更小的值进行复制，避免复制不必要的内容</span></span><br></pre></td></tr></table></figure><ul><li>  为 <code>.bss</code> 段预留空间：文件大小与程序大小不同需要补充空页面</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  i += BY2PG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h3><blockquote><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code>，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。</p></blockquote><ul><li>  思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</li></ul><p>显然， PC 值应该在程序运行过程中<strong>保持连续</strong>，而程序运行时的物理地址应该是<strong>经过页表映射后</strong>不连续的，虚拟地址可以则保证其连续性。所以这里的 <code>env_tf.cp0_epc</code> 应该保存的是<strong>虚拟地址</strong></p><h3 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h3><blockquote><p>在<strong>异常向量组</strong>中，通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为 <code>handle_int</code> ，表示<strong>中断</strong>，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为 <code>handle_mod</code> ，表示<strong>存储异常</strong>，进行存储操作时该页被标记为只读 2 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB load</strong> 异常 3 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB store</strong> 异常 8 号异常的处理函数为 <code>handle_sys</code> ，表示<strong>系统调用</strong>，用户进程通过执行 <code>syscall</code> 指令陷 入内核</p></blockquote><ul><li>  试找出上述 5 个异常处理函数的<strong>具体实现位置</strong>。</li></ul><p>在 <code>kern/genex.S</code> 文件中，我们可以先找到其上声明的 <code>handle_int</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)# handle_int 实现</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM4</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><p>其余的四个函数通过同文件的宏 <code>BUILD_HANDLER exception handler</code> 定义在其后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.macro BUILD_HANDLER exception handler</span><br><span class="line">NESTED(handle_\exception, TF_SIZE + 8, zero)</span><br><span class="line">move    a0, sp</span><br><span class="line">addiu   sp, sp, -8</span><br><span class="line">jal     \handler</span><br><span class="line">addiu   sp, sp, 8</span><br><span class="line">j       ret_from_exception</span><br><span class="line">END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill# do_tlb_refill 实现于 kern/tlbex.c</span><br><span class="line"></span><br><span class="line">#if !defined(LAB)  LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod# do_tlb_mod 实现于 kern/tlbex.c</span><br><span class="line">BUILD_HANDLER sys do_syscall# do_syscall 实现于 kern/syscall_all.c</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved# do_reserved 实现于 kern/traps.c</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h3><ul><li>  阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出 <code>enable_irq</code> 和 <code>timer_irq</code> 中每行汇编代码的作用</li></ul><h4 id="enable-irq"><a href="#enable-irq" class="headerlink" title="enable_irq"></a><code>enable_irq</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">li      t0, (STATUS_CU0  STATUS_IM4  STATUS_IEc)  # 允许用户态使用 CP0 寄存器 + 允许4号中断响应 + </span><br><span class="line">                                                            # 开启当前状态CPU中断</span><br><span class="line">mtc0    t0, CP0_STATUS                              # 将 CPU 状态保存在 CP0 的 STATUS 寄存器</span><br><span class="line">jr      ra                                          # 返回调用者函数</span><br><span class="line">END(enable_irq)</span><br></pre></td></tr></table></figure><h4 id="timer-irq"><a href="#timer-irq" class="headerlink" title="timer_irq"></a><code>timer_irq</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">                                                            # 将 GXemul 时钟响应位置 0</span><br><span class="line">li      a0, 0                                       # 令 schedule 参数 yield = 0</span><br><span class="line">j       schedule                                    # 进入 schedule 函数进行进程块队列调度</span><br></pre></td></tr></table></figure><h3 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h3><ul><li>  阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的</li></ul><p>首先，我们在kern/kclock.S 中的kclock_init 函数完成了时钟中断的初始化，并在 genex.S 中的 enable_irq 中设置允许响应该中断</p><p>当时钟计时归零（时间片耗尽），产生时钟中断，进入<strong>异常处理程序</strong>，并跳转到 handle_int 处理中断。</p><p>当前我们的系统只能处理 <code>timer_irq</code> 一种时钟中断，所以直接进入 <code>timer_irq</code> 函数，恢复时钟，并执行 <code>schedule(0);</code></p><p>在 <code>schedule()</code> 中，我们根据当前进程块状态进行进程块队列调度，实现进程切换或进程的舍弃，至此完成时钟中断响应</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Untitled Post - 1</title>
      <link href="/2023/04/trashed/"/>
      <url>/2023/04/trashed/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cookedbear.top/wp-content/uploads/2023/03/bef11be4c0d609160edabed40fe06823.png"><img src="https://cookedbear.top/wp-content/uploads/2023/03/bef11be4c0d609160edabed40fe06823.png"></a></p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT2-Summary</title>
      <link href="/2023/04/buaa-oo-unit2-summary/"/>
      <url>/2023/04/buaa-oo-unit2-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，多线程要多测试</p></blockquote><ul><li><strong>博客撰写基本要求：</strong><ul><li>总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li><li>总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的<ul><li>结合线程协同的架构模式（如流水线架构），分析和总结自己<ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul></li></ul></li><li>分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li><li>心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul></li></ul><p><strong>注意：</strong>在编写完博客并发布在CSDN之后，请在选择要作为作业提交的博客，点击提交。</p><h2 id="架构思路总结"><a href="#架构思路总结" class="headerlink" title="架构思路总结"></a>架构思路总结</h2><p>本单元作业，我采取了一种专精调度器的路线，调度器知晓程序内几乎所有类、线程的数据，并根据这些数据进行全局的调度，其包括：</p><ul><li>  为指定请求分派特定的电梯</li><li>  唤醒、终止<strong>特定的</strong>电梯线程</li><li>  指定电梯运行的掉头楼层（抵达该楼层就进行转向）</li><li>  拆解不可直达请求为局部最优路线并分配电梯</li></ul><p>实现这样一个看起来全能全知的调度器就意味着它需要掌握大量数据，否则很难做出合理的调度。所以设计模式上我采取了一种”一家独大“的<strong>黑板模式</strong>：电梯类与生产者类持续进行数据的实时更新，调度器则根据这些实时数据做出判断。</p><p>为了减少死锁的发生，我限制了所有信息的流动方向：仅允许调度器这块黑板被外界访问，调度器只能向黑板上写数据，不能主动申请获取外界信息。<strong>单方向的信息传递</strong>保证死锁不会在这样的架构中产生。同时我并没有将调度器类转变为线程，而是以数据字段与众多处理方法组成，不同的数据更改会使用调度器类的不同方法，从而进行下一步的调度。</p><h2 id="同步块的设置与锁的选择"><a href="#同步块的设置与锁的选择" class="headerlink" title="同步块的设置与锁的选择"></a>同步块的设置与锁的选择</h2><ul><li>  总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li></ul><p>在三次作业中，我均使用了互斥锁 <code>synchronized</code> 进行代码同步块的保护。原有想重构为效率更高的 <code>ReentrantLock</code> 或可释放指定线程便于高效调度的 <code>LockSupport</code> 或更高端的读写锁 <code>ReentrantReadWriteLock</code> ，但是最后都因为原来架构压得有点死而放弃（</p><p>在本轮作业迭代中，我在生产者类、调度器类与电梯类中都出现了锁，但这些锁<strong>全部指向调度器类</strong>，并且只设置了一个调度器。也就是说，无论发生怎样的线程交互，都只能申请访问一个锁，所以根本不可能出现死锁状况，大家都在等着调度器那一把锁而已。</p><p>为了保证线程安全，我将调度器内的所有方法都使用了 <code>synchronized</code> 关键字进行包装，但其他的类除了电梯类 <code>wait()</code> 调度器锁时需要同步外，均未出现同步方法/同步块。</p><h3 id="各个类获取锁的目的"><a href="#各个类获取锁的目的" class="headerlink" title="各个类获取锁的目的"></a>各个类获取锁的目的</h3><ul><li>生产者类：<ul><li>  向调度器中的请求队列中添加新的请求（乘客请求）</li><li>  更新调度器类中的电梯集合（ADD、MAINTAIN）</li></ul></li><li>电梯类：<ul><li>  向调度器中<strong>写入</strong>当前自身状态（楼层、方向、运行与否等）</li><li>  从调度器中<strong>读取</strong>自身的下一步状态（运动方向/状态、MAINTAIN等）</li><li>  更新调度器中的请求队列（MAINTAIN、换乘下客）</li></ul></li></ul><h2 id="调度器设计与线程交互"><a href="#调度器设计与线程交互" class="headerlink" title="调度器设计与线程交互"></a>调度器设计与线程交互</h2><ul><li>  总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的</li></ul><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><p>本单元采用黑板模式进行设计。各个类都将信息交互集中于黑板之上，生产者写入请求，调度器调度请求，电梯获取自身预定的运动细节。由此，黑板便成了整个程序最大的、也是唯一的<strong>共享数据类</strong>。</p><p>三次作业中，调度器都建立在提到的共享数据类 “黑板” 之上。通过生产者和电梯的数据更新，调度器能够掌握全部线程的几乎全部信息，并根据信息设计调度策略。</p><h3 id="线程交互与信息传递"><a href="#线程交互与信息传递" class="headerlink" title="线程交互与信息传递"></a>线程交互与信息传递</h3><p>由于有且仅有一个共享数据类——黑板，所以程序内的信息流动都与这个数据类相关。</p><p>在设计本单元架构时，我考虑的第一个问题实际上是<strong>死锁</strong>，不知道同学们有没有因为程序死锁而难以推进的时候。为了解决这种困扰，我直接简单粗暴的将所有<strong>信息访问</strong>的方向固定为单向：生产者、电梯只能更新调度器内数据，或读取调度器产生的信息，正如在前面锁的部分提到的一样。这样做线程交互的难度能有所降低。</p><p>其实当时还并不理解这样做的原理是什么，直到第八周理论课上，我才发现自己采取的架构和老师谈到的黑板模式十分相近。具体的信息流动如下：</p><p>假装有图.jpg</p><p>但实际上，随着工程代码量与类的增多，黑板上记录的东西会越来越复杂，想来看黑板的人也会越来越多，这样必然会导致多线程交互效率下降，同时也会导致黑板与离着黑板最近的调度器类复杂度升高。</p><h3 id="调度策略与性能指标"><a href="#调度策略与性能指标" class="headerlink" title="调度策略与性能指标"></a>调度策略与性能指标</h3><p>在单元初就被告知今年的性能指标增加了一个用电量的限制。旨在加重调度器在程序设计中的地位，弱化所有电梯饿虎扑食的自由竞争的使用。这更加坚定了我要写一个全局调度器的决心，主要是不觉得写调度器优质规划是一件很酷的事情吗（并不）</p><p>再加上原本的传统性能指标：运行时间和等待时间。多数情况下，电梯移动更少的楼层能消耗更少的时间，所以我希望电梯能少跑一层就少跑一层（省电）；乘客能早接一下就早接一下（省时间）。</p><p>由此确定了基本的思路为：</p><blockquote><p>能近就近，能省就省</p><p>（乘客选用距离最近的电梯，电梯运行中考虑移动最少的楼层数）</p></blockquote><p>决定采用调度器全局调度的方式后，实际上后续迭代的请求分配策略几乎没有发生改变：</p><ul><li>准备工作：电梯在移动/休息过程中将自身状态实时写到黑板上</li><li>调度启动：生产者向黑板写入请求，告知调度器开始规划</li><li>规划思路：为请求分配等待最短时间就能搭上的电梯<ul><li>  遍历所有电梯，能否装下这个乘客（过程中会不会超载），若超载则被筛除</li><li>  根据 请求楼层/运动方向、电梯楼层/运动方向、电梯掉头时预计抵达的楼层，计算当前电梯接收请求所用的时间</li><li>  将请求分配给所需时间最短者（保证局部最优），并更新电梯掉头预计抵达的楼层（请求终点站与原本预计抵达楼层间的比较），以便电梯掌握运动路线，同时便利下次分配</li></ul></li></ul><p>这种做法，实际上和往年学长们的影子电梯/模拟做法类似，只不过这种做法精确度不如纯模拟，但是实现难度要比复制一遍电梯内容并全局模拟的难度还是要低不少的。这里唯一需要比模拟做法多考虑的点就是<strong>电梯超载</strong>：</p><p>试考虑以下场景：电梯停靠于1层，首先为其分配6个5-11层的请求令电梯满载，在电梯运行到2层时再输入一个3-11层的请求，显然电梯此刻为空，同时显然把7个请求全部分给这台电梯，会超载，或剩下一个请求等这台电梯回来接他。</p><p>假装有图.jpg</p><p>这样做的效果显然不如第一次就把请求分配给另一台电梯，那么如何表示<strong>当前有空间</strong>的电梯，在<strong>未来某一刻</strong>会满载呢？我使用了两个数组代表上行/下行过程中电梯在某个楼层时的人数，然后根据分配的请求进行动态变化，如果某一层达到capacity说明电梯在该层会出现满员状态。具体细节就不展开说了，有了思路后实现还是很轻松的。</p><p>在第三次作业中，加入了<strong>强制换乘</strong>请求，我的处理方式是将所有可联通（换乘）的电梯当作图中的两个连接的节点，然后从请求起始楼层所有可达的电梯出发，求到终止楼层所有可达电梯的<strong>多源对多源可达路径</strong>（全部可达路径，做法可参考<a href="https://blog.csdn.net/spnooyseed/article/details/106957325">这一篇文章</a>）。再按照换乘次数递增的方式排序路线并拆分每一个请求的第一次<strong>换乘段</strong>，查看能否分配。</p><p>总体来说性能还是蛮不错了，至少有人上来错仨点还能拿84+（</p><h2 id="架构分析与协作图"><a href="#架构分析与协作图" class="headerlink" title="架构分析与协作图"></a>架构分析与协作图</h2><p>结合线程协同的架构模式（如流水线架构），分析和总结自己</p><ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><ul><li>  类图中不包含<code>[]</code>标记的是第一次第一次的架构，方括号内数字代表这个字段/方法在第几次作业中加入</li></ul><p>通过三次迭代作业的类图可以发现，迭代过程中并没有增添过多的类，处理方式大多为增添函数以满足请求。</p><p>在拓展方面上，可以考虑迭代前两年作业中出现过的横向电梯，为此可能需要做出以下调整：</p><ul><li>  改良电梯间的图结构，使其能支持更复杂的换乘需求</li><li>  增添新的横向电梯类，优化电梯信息类以兼容两类电梯</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752603.jpg" alt="ClassUML3.jpg"></p><h3 id="UML-协作图"><a href="#UML-协作图" class="headerlink" title="UML 协作图"></a>UML 协作图</h3><p>UML 协作图如下，本架构中，调度器 Manager 并不属于运行中的线程，只不过因为方法与交互太多，导致它看起来好像在持续运行一样（）</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752093.jpg" alt="ProcessUML"></p><h3 id="代码中稳定-易变的内容"><a href="#代码中稳定-易变的内容" class="headerlink" title="代码中稳定/易变的内容"></a>代码中稳定/易变的内容</h3><ul><li>稳定内容：<ul><li>  电梯运行逻辑：在三次作业中，电梯都采用了 检查方向 - 移动 - 上下客 - 检查方向 的循环进行电梯的移动，同时电梯 MAINTAIN 逻辑也只在添加时进行了编写，后续没有改动</li><li>  电梯上下客逻辑：电梯检测每个请求是否标记为自身携带，如果是则进入电梯；检查自身队列，如果目的地是当前楼层则释放；这部分逻辑也没有发生过改变</li><li>  计算最优电梯逻辑：针对每一个请求，每台电梯都会计算接收请求所用时间长短，并分配电梯，这个逻辑也大致没有变化，只在第二次作业中<strong>将时间由固定值改为电梯属性</strong></li></ul></li><li>易变内容：<ul><li>请求读入逻辑：在第一次作业中请求只有 <code>PersonRequest</code> 一种，只需要考虑读取乘客请求并更新队列即可；在第二次作业中，增加了 <code>ADD</code> 、 <code>MAINTAIN</code> 请求，需要分类并处理增删电梯逻辑与对应的方法；在第三次作业中， <code>ADD</code> 电梯的逻辑更加复杂，需要额外考虑电梯的可达楼层。每次作业迭代都发生了改变。</li><li>线程终止逻辑：与请求输入相关的终止逻辑变更也较大。第一次作业中只要输入停止，就一定意味着线程可以处理完当前请求后结束；第二次作业中，必须考虑 <code>MAINTAIN</code> 电梯仍然会在输入结束后释放乘客，而这部分乘客需要回填请求队列，这就产生了新的请求；第三次作业中回填的情况也发生在不可直达请求的换乘过程中：换乘请求下车后仍需要回填请求序列。</li><li>第三次作业中的请求拆分逻辑：虽然这部分逻辑只在最后一次作业出现，但是我尝试过各种不同的方法，感觉也有必要做一些总结：<ul><li>  “<strong>电梯井</strong>”逻辑：按照 电梯ID + 楼层号 的方式创建节点，同时创建一个只连接<strong>可停靠在该层</strong>电梯的<strong>换乘大厅</strong>， dfs 找出所有可行路线，并排序最少换乘路线；但这个做法时间复杂度过高，处理单个请求都可能 CTLE ，无奈不得不放弃</li><li>  电梯邻接链表：同学分享的思路，将每一层构建一个节点，各层能停的电梯划分在楼层后，再根据所有能上的电梯继续寻找下一个能上的电梯，直至能够抵达最终目的楼层，回溯路径</li><li>  多源 - 多源 dfs：最后采用的方法，之前在前面写过了就不水了</li></ul></li></ul></li></ul><h2 id="bug-记录与多线程-bug-修复"><a href="#bug-记录与多线程-bug-修复" class="headerlink" title="bug 记录与多线程 bug 修复"></a>bug 记录与多线程 bug 修复</h2><ul><li>  分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li></ul><h3 id="bug记录"><a href="#bug记录" class="headerlink" title="bug记录"></a>bug记录</h3><p>在第一单元互测中，大家的常用攻击方式都是短时间大量投喂1 - 11之类的请求卡 RTLE。本地测试没出现过被卡的情况，但在互测中还真被刀了。在助教的帮助下我意识到可能的原因是生产者 - 电梯之间处理 <code>notifyAll()</code> 的速度差异。</p><p>在我的架构中，对于一个读入的请求会计算其搭乘的电梯 ID ，同时根据 ID 去唤醒指定的电梯，具体来说就是在黑板的一块<strong>公共空间</strong>写下电梯号，每个电梯按顺序查看是不是自己，再决定会不会醒来。但如果生产者的运转速度过快，有可能导致 A 乘客的 ID 还没有被所有电梯看完， B 乘客的 ID 就覆盖了旧 ID ，有可能A的电梯就醒不过来了。但当时采用了一种不合适的修改思路：使用 <code>sleep()</code> 降低生产者速度。</p><p>因为这次修改不够充分，类似的问题出现在第三次作业中，最后的bug修复我把公共的空间改为了每个电梯只查看自己的一小块私有黑板，这样不会频繁更改，才是最好的办法。</p><h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h3><blockquote><p>一定要多 <code>println()</code> .jpg</p></blockquote><p>打印共享数据类的各个所需状态都是debug的一种选择。其中我认为最好用的是根据可能出错的电梯ID和乘客ID，直接输出当时电梯内外的所有状态，大体为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (elevator.getId() == specialEid &amp;&amp; request.getId() == specialRid) &#123;</span><br><span class="line">    System.println(<span class="string">&quot;message you want to see&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的 specialId 都是具体的数字</span></span><br></pre></td></tr></table></figure><p>其次就是多做<strong>场景复原</strong>，回溯错误发生前的一段时间，看一看错误电梯的行为。通过配合前面的特定print效果还是挺不错的，因为既不会打印出满屏输出，同时也能看到一些关键的信息。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ul><li>  心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>这单元的作业中，很多同学都出现了<strong>死锁</strong>的状况，原因大部分是复杂的<strong>线程间信息交互</strong>。而且都是在持有锁的同步块内索取其他对象的锁，确实容易出错（）规范信息交互方式、合理使用同步块和锁，注意单个函数逻辑，我认为是处理交互的重中之重。</p><p>再比如有佬采用了每个请求的每秒都生成一个线程，我觉得这是对自己架构设计的磨练与宝贵经验；虽然我距离这样把线程用活的程度还有很远，但我觉得这样架构中的信息交互与安全性实在值得我们学习。</p><p>其次是保证读写操作不会被其他操作干扰，实际上这个还比较好处理，需要注意<strong>一次</strong>读写操作的范围，对于单个对象来说可能是一个 <code>return</code> ，一个赋值；而对于容器来说，一次读写就应该对应着一次遍历了，在遍历途中实际上都不应该允许容器被改变。</p><h3 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h3><p>在考虑线程之间的协作时，为了避免线程本身拥有太多信息导致交互臃肿，我选择了一个单独的电梯信息类对单个电梯所拥有的一系列属性进行包装，并且把这个信息类放在黑板中。电梯线程类本身不具有太多信息，查询、更新状态都需要去黑板查看，这样保证了线程交互的简便性。</p><p>其余的层次化主要体现在调度器类这个黑板上，黑板拥有不同的字段，这些字段是对应的下一级的类，它们分别代表着黑板上的不同种类信息。总的来说层次化设计在本次作业架构中不是很明显。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>oo最让人难熬的电梯月到这里就算告一段落了，我认为这个单元学到的线程协作知识很有价值，不仅在学习过程中了解到了更多的设计模式，同时也知晓了线程/进程的概念、线程间信息传递的安全问题，是十分宝贵的经验。还有两个单元，不要懈怠就好了。</p><p>能看到最后的我觉得大概率是助教giegie吧，在这我想对每一位助教说声谢谢，在电梯月的摸爬滚打少了你们的帮助真的会寸步难行。接下来两个单元也要救救我哦（逃</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab2</title>
      <link href="/2023/03/buaa-os-probe-lab2/"/>
      <url>/2023/03/buaa-os-probe-lab2/</url>
      
        <content type="html"><![CDATA[<h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><p>在进行实验前，建议通读<code>mmu.h</code>和<code>pmap.h</code>文件，了解一些宏定义，对后续工作很有帮助</p><p>名称</p><p>参数</p><p>作用</p><p>PADDR</p><p>内核<strong>虚拟地址</strong>kva</p><p>将内核虚拟地址kva转成对应的物理地址</p><p>KADDR</p><p><strong>物理地址</strong>pa</p><p>将物理地址pa转化为内核虚拟地址</p><p>page2pa</p><p>页信息结构<strong>struct Page</strong></p><p>通过空闲页结构得到这一页起始位置的物理地址</p><p>pa2page</p><p><strong>物理地址</strong>pa</p><p>通过物理地址pa获取这一页对应的页结构体struct Page</p><p>page2kva</p><p>页信息结构<strong>struct PageInfo</strong></p><p>通过空闲页结构得到这一页起始位置的虚拟地址</p><p>PDX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la对应的页目录项索引</p><p>PTX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la在二级页表中对应的页表项索引</p><p>PTE_ADDR(pte)</p><p>页表项或页目录项的<strong>值</strong></p><p>获得对应的页表/地址基址(低12位为0，并均为<strong>物理地址</strong>)</p><h3 id="内核启动后的内存分配-2-1"><a href="#内核启动后的内存分配-2-1" class="headerlink" title="内核启动后的内存分配 - 2.1"></a>内核启动后的内存分配 - 2.1</h3><ul><li>我们的操作系统内核启动后需要执行下列三个函数完成内存分配机制的建立<ul><li>  <code>mips_detect_memory()</code>：探测硬件可用内存，初始化内存基本变量</li><li>  <code>mips_vm_init()</code>：建立用于管理内存的数据结构</li><li>  <code>page_init()</code>：初始化结构<code>Page</code>与空闲链表<code>page_free_list</code></li></ul></li></ul><h4 id="mips-detect-memory-Exercise-2-1"><a href="#mips-detect-memory-Exercise-2-1" class="headerlink" title="mips_detect_memory() - Exercise 2.1"></a><code>mips_detect_memory()</code> - Exercise 2.1</h4><ul><li>本函数的作用是探测硬件可用内存，并初始化两个变量：<ul><li>  <code>memsize</code>：物理内存对应的字节数（实验中从外设中读取）</li><li>  <code>npage</code>：物理内存对应的页数</li></ul></li></ul><h5 id="Exercise-2-1"><a href="#Exercise-2-1" class="headerlink" title="Exercise 2.1"></a>Exercise 2.1</h5><ul><li>  请参考代码注释，补全<code>mips_detect_memory</code>函数。 在实验中，从外设中获取了硬件可用内存大小<code>memsize</code>，请你用内存大小<code>memsize</code>完成总物理页数<code>npage</code>的初始化</li></ul><p>相对简单的一题，<code>memsize</code>已知，只需要除以每页的大小即可（<code>BY2PG = 4096</code>定义在<code>mmu.h</code>中）</p><p>在这里要留意一下<code>npage</code>这个变量，后面的练习中会用到几次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">()</span> &#123;</span><br><span class="line">    memsize = *(<span class="keyword">volatile</span> u_int *)(KSEG1  DEV_MP_ADDRESS  DEV_MP_MEMORY);</span><br><span class="line">    <span class="comment">/* Exercise 2.1 Your code here. */</span></span><br><span class="line">    npage = memsize / BY2PG;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;Memory size: %lu KiB, number of pages: %lu\n&quot;</span>, memsize / <span class="number">1024</span>, npage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mips-vm-init"><a href="#mips-vm-init" class="headerlink" title="mips_vm_init()"></a><code>mips_vm_init()</code></h4><ul><li>  本函数通过一次性调用<code>alloc()</code>函数完成对内存管理结构（<strong>页控制块</strong>）所在空间的初步分配，实现的关键在<code>alloc()</code>中。这个函数只在系统初始化、尚未生成页式管理机制时才会被调用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在建立页式存储机制前，使用alloc函数进行内存空间的分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">    <span class="comment">/* Initialize &#x27;freemem&#x27; if this is the first time. */</span></span><br><span class="line">    <span class="keyword">if</span> (freemem == <span class="number">0</span>) &#123;</span><br><span class="line">        freemem = (u_long)end;<span class="comment">/* 明确 freemem 指向虚拟地址 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    freemem = ROUND(freemem, align);<span class="comment">/* 按大小向上取整，保证此时freemem表示</span></span><br><span class="line"><span class="comment">     * 空闲空间的起始地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloced_mem = freemem;<span class="comment">/* freemem 以下空间均被分配 */</span></span><br><span class="line">    freemem = freemem + n;<span class="comment">/* 分配出 n 个字节大小的空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (PADDR(freemem) &gt;= memsize) &#123;<span class="comment">/* 物理地址越界，无足够空闲空间 */</span></span><br><span class="line">        panic(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clear) &#123;<span class="comment">/* clear 是分配内存清零的标志位 */</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)alloced_mem, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) alloced_mem;<span class="comment">/* 返回被分配空间的起始**虚拟**地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> &#123;</span><br><span class="line">    pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 分配了一块大小为 (npage * 页表项) 字节的空间并清空，用于存放所有的页表项</span></span><br><span class="line"><span class="comment">     * 起始地址为 pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>freemem</code>：在这里我们通过使用虚拟内存的<code>kseg0</code>段来操作内存，但实际上它可以直接映射到指定的物理地址（去掉最高位），不需要额外的映射逻辑</li><li>  <code>extern char end[]</code>：在lab1中分配段加载地址用到的<code>kernel.lds</code>已经声明过，可以直接使用表示地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">. = 0x80400000;// 相当于物理内存的0x400000</span><br><span class="line">end = . ;</span><br></pre></td></tr></table></figure><h3 id="物理内存管理-2-2-2-5"><a href="#物理内存管理-2-2-2-5" class="headerlink" title="物理内存管理 - 2.2 ~ 2.5"></a>物理内存管理 - 2.2 ~ 2.5</h3><ul><li>  MOS系统使用页式内存管理物理内存，使用链表管理页表，重要代码位于<code>kern/pmap.c</code>中</li></ul><h4 id="链表宏-Exercise-2-2"><a href="#链表宏-Exercise-2-2" class="headerlink" title="链表宏 - Exercise 2.2"></a>链表宏 - Exercise 2.2</h4><p>更具体的链表宏其实在Thinking部分已经提到了，这里不再过多展开。</p><p>在这里出现的链表形式与常见的双向链表有些不同，每一个链表项含有一个<code>field* le_next</code>，还有一个<code>field** le_prev</code>，其中的<code>le_next</code>很好理解，就正常指向下一个链表项，但是这个<code>le_prev</code>则是指向<strong>上一个</strong>链表项的<code>le_next</code>域：更直观地来说就是这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first-&gt;field.le_next = second</span><br><span class="line">second-&gt;field.le_prev = &amp;(first-&gt;field.le_next)</span><br><span class="line"><span class="comment">// **类型 = 给*类型取地址</span></span><br><span class="line">*(second-&gt;field.le_prev) = first-&gt;field.le_next = second</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.2已经可以完成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)\</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != NULL)          \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.le_next-&gt;field.le_prev =                           \</span></span><br><span class="line"><span class="meta">            &amp;((elm)-&gt;field.le_next);                                        \</span></span><br><span class="line"><span class="meta">    (listelm)-&gt;field.le_next = (elm);                                       \</span></span><br><span class="line"><span class="meta">    (elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;                       \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>再有一个注意点就是，各个宏定义传入参数时要求的是什么类型：</p><p><code>head</code>参数就要求传入的是链表头的指针<code>&amp;</code>（本实验中指<code>Page_List *</code>）</p><p><code>elm</code>参数要传入链表项的指针<code>&amp;</code>（本实验中指<code>Page *</code>）</p><p><code>field</code>参数则传入的是链表项的指针（本实验中指的是<code>pp_link</code>）</p><blockquote><p>接下来的三个练习（2.3-2.5）针对的是在建立页式内存管理后中/后所需要用到的一些函数，这些函数的正确与否直接决定了分页管理能否正常运行（虽然<code>init</code>那里错了也会寄就是了，哈哈比如我）</p></blockquote><h4 id="page-init-Exercise-2-3"><a href="#page-init-Exercise-2-3" class="headerlink" title="page_init() - Exercise 2.3"></a><code>page_init()</code> - Exercise 2.3</h4><ul><li>  <code>page_init()</code>函数用于初始化空闲链表<code>page_free_list</code></li></ul><p>任务要求为完成函数：</p><ol><li> 使用链表初始化宏<code>LIST_INIT</code>。</li><li> 将<code>freemem</code>按照<code>BY2PG</code>进行对齐（使用<code>ROUND</code>宏为<code>freemem</code>赋值）。</li><li> 将<code>freemem</code>以下页面对应的页控制块中的<code>pp_ref</code>标为1。</li><li> 将其它页面对应的页控制块中的<code>pp_ref</code>标为0 并使用<code>LIST_INSERT_HEAD</code>将其插入空闲链表。</li></ol><p>还可以这样把任务具体化：</p><ol><li>对<code>free_page_list</code>初始化，使用<code>LIST_INIT()</code>宏</li><li>将<code>freemem</code>按<code>BY2PG</code>对齐，使用<code>ROUND()</code>宏</li><li>从划分的页表项指针<code>pages</code>开始，按照地址由低到高遍历：<ol><li> <code>virtual address &lt; freemem</code>：令<code>pp_ref = 1</code></li><li> <code>else</code>：令<code>pp_ref = 0</code>、使用<code>LIST_INSERT_HEAD()</code>宏插入<code>free_page_list</code>中</li></ol></li></ol><p>将任务具体化后，发现实际上前两步的实现相对简单，使用了头文件定义好的宏，或是复现之前出现过的操作，就不多展开了。重点在最后一步的遍历<code>Page *pages</code>上：</p><p>首先，循环可以使用<code>pages++</code>方法（<code>+</code>运算符重载），同样也可以使用<code>pages[i], i++</code>的做法，这样都能表示单次大小为<code>page</code>的地址位移</p><p>其次，直观地想要实现<code>virtual address &lt; freemem</code>的比较，需要获取到每一页的虚拟地址，实际上<code>pmap.h</code>提供了<code>page2kva</code>这个返回虚拟地址的宏</p><p>当然在这里也可以换个思路，不去转换<code>PPN</code>和<code>pages</code>，而把<code>freemem</code>这个虚拟地址转化为页表项相关的值，也就是找到<code>freemem</code>对应的<code>PPN</code>号：<code>PPN(KADDR(freemem))</code>，然后进行循环边界的判断即可</p><p>具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">  <span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">  LIST_INIT(&amp;page_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: Align `freemem` up to multiple of BY2PG. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">  freemem = ROUND(freemem, BY2PG);</span><br><span class="line">  <span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pages;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> freePPN = PPN(PADDR(freemem));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freePPN; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; npage; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;page_free_list, (pages + i), pp_link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-alloc-Exercise-2-4"><a href="#page-alloc-Exercise-2-4" class="headerlink" title="page_alloc - Exercise 2.4"></a><code>page_alloc</code> - Exercise 2.4</h4><ul><li>  如果能顺利完成并理解前面练习的话，这个也理应算是个水题了（</li></ul><p>任务要求为完成<code>page_alloc()</code>函数，这个函数取代了最初的<code>alloc()</code>函数，成为页式内存管理中申请内存时调用的函数</p><ol><li> 如果空闲链表没有可用页了，返回异常返回值。</li><li> 如果空闲链表有可用的页，取出第一页；初始化后，将该页对应的<strong>页控制块的地址</strong>放到调用者指定的地方。</li><li> 可能需要使用链表宏<code>LIST_EMPTY</code>或函数<code>page2kva</code></li><li> 实际上Use <code>LIST_FIRST</code> and <code>LIST_REMOVE</code>也在函数前面的注释里当作HINT了（</li><li> 顺带提一嘴，异常返回值也在那个注释写了，叫<code>-E_NO_MEM</code></li></ol><p>这个也就做一下空链表判断返回值，再取出<strong>第一页</strong>并清空即可，<strong>不要忘记清空的区域大小是多少</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">  &#125;</span><br><span class="line">  pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line">  LIST_REMOVE(pp, pp_link);</span><br><span class="line">  <span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">   * Hint: use `memset`. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line">  *new = pp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-decref"><a href="#page-decref" class="headerlink" title="page_decref()"></a><code>page_decref()</code></h4><ul><li>  函数作用是通过页控制块改变页框的引用次数，若出现空闲页则调用回收函数<code>page_free()</code>回收内存</li></ul><h4 id="page-free-Exercise-2-5"><a href="#page-free-Exercise-2-5" class="headerlink" title="page_free() - Exercise 2.5"></a><code>page_free()</code> - Exercise 2.5</h4><ul><li>  非常好水题，多来点（</li><li>  任务要求为完成<code>page_free()</code>函数，该函数回收空闲页面（判定方式为<code>pp_ref == 0</code>），插入<code>page_free_list</code>中</li><li>  提示：使用链表宏<code>LIST_INSERT_HEAD</code>，将页结构体插入空闲页结构体链表</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">  assert(pp-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Just insert it into &#x27;page_free_list&#x27;. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.5: Your code here. */</span></span><br><span class="line">  LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.1-2.5顺利结束，<strong>物理内存管理</strong>模块练习完成</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>在开始后续练习前，我们先了解一下实验环境中的虚拟地址分配：</p><h4 id="虚拟内存结构"><a href="#虚拟内存结构" class="headerlink" title="虚拟内存结构"></a>虚拟内存结构</h4><ul><li>32位虚拟内存：<code>PDX(va)PTX(va)offset (10 + 10 + 12)</code></li><li>页表项结构：<ul><li>  一级页表项<code>Pde = u_long = 物理页号权限位</code></li><li>  二级页表项<code>Pte = u_long = 物理页号权限位</code></li><li>  权限位与<code>EntryLo</code>寄存器的标志位排布一致：<code>NDVG0[7:0]</code>，具体内容我们放到后面的<code>TLB</code>部分再详细说</li></ul></li><li>二级页表系统的作用：<strong>虚拟地址\to物理地址</strong></li><li>一/二级页表偏移量（<code>PDX(va)/PTX(va)</code>）：从一/二级页表基地址出发，移动n个单位到达</li><li>一级页表<strong>项</strong>包含的<strong>页号</strong>是其对应的二级页表<strong>页</strong>的<strong>物理页号</strong></li></ul><blockquote><p>访问虚拟地址时，先通过一级页表基地址和一级页表项的偏移量，找到对应的一级页表项，得到对应的二级页表的物理页号，再根据二级页表项的偏移量找到所需的二级页表项，进而得到该虚拟地址对应的物理页号</p></blockquote><ul><li>  这个过程中需要将二级页表的物理页转换为物理地址，再转换为虚拟地址返回：<code>pgdir -&gt; PTE_ADDR(pgdir) -&gt; KADDR(PTE_ADDR(pgdir))</code>，<code>Pde* pgdir</code>是偏移后得到的一级页表项</li></ul><h4 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h4><ul><li><code>kseg0/kseg1</code>使用<code>PADDR/KADDR</code>进行物理/虚拟地址的转换，而<code>kuseg</code>使用<code>TLB</code>（实际上是页表项）进行转换</li><li>在创建页表时，可以使用<code>KADDR</code>进行转换（处于内核态 存疑 通过<code>kseg0</code>读取）</li><li><code>memset</code>等函数操控的都是虚拟内存，不能直接访问物理内存</li><li><strong>页表项与页控制块</strong><ul><li>  页控制块是内存管理最开始初始化的<code>pages</code>变量，它管理物理页面的属性（前驱后继、引用次数等）</li><li>  页表项是虚拟页管理中最小的映射单元，它管理虚拟页面映射相关的属性（有效与否等）</li><li>  页控制块\to页表项的高位值：<code>*pte = page2pa(pp)</code></li><li>  页表项\to页控制块：<code>pp = pa2page(*pte)</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/mmu.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096<span class="comment">// 定义了页面字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDMAP (4 * 1024 * 1024)<span class="comment">// 定义了一个一级页表页能管理的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12<span class="comment">// 移动获得二级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22<span class="comment">// 移动获得一级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03ff)<span class="comment">// 获取31-22位，一级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03ff)<span class="comment">// 获取21-12位，二级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xfff)<span class="comment">// 获得对应的页表基址或者物理地址基址(低12位为0)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的物理页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的虚拟页号</span></span></span><br></pre></td></tr></table></figure><h4 id="pgdir-walk-Exercise-2-6"><a href="#pgdir-walk-Exercise-2-6" class="headerlink" title="pgdir_walk() - Exercise 2.6"></a><code>pgdir_walk()</code> - Exercise 2.6</h4><ul><li>该函数的作用是：给定一个虚拟地址，在给定的页目录中查找这个虚拟地址对应的物理地址<ul><li>  如存在：返回页表项所在的<strong>虚拟</strong>地址</li><li>  如不存在：连对应页表项都不存在（PDX指向的<strong>页目录项</strong>为<strong>空或无效</strong>），则根据传入的参数进行创建二级页表，或返回空指针。</li></ul></li><li>注意，这里可能会在页目录表项无效且<code>create</code> 为真的情况，需要使用<code>page_alloc</code> 创建一个二级页表页，并应维护申请得到的物理页的<code>pp_ref</code> 字段</li></ul><p>（查物理地址）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pgdir_walk</span><span class="params">(Pde *pgdir, u_long va, <span class="type">int</span> create, Pte **ppte)</span> &#123;</span><br><span class="line">  Pde *pgdir_entryp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (1/3) */</span></span><br><span class="line">  pgdir_entryp = pgdir + PDX(va);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (2/3) */</span></span><br><span class="line">  <span class="keyword">if</span> ((*pgdir_entryp &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// not existent</span></span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">      <span class="keyword">if</span> (-E_NO_MEM == page_alloc(&amp;pp)) &#123;<span class="comment">// fail to collect a page to Page *pp</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">      &#125;</span><br><span class="line">      pp-&gt;pp_ref++;</span><br><span class="line">      *pgdir_entryp = page2pa(pp)  PTE_V  PTE_D;<span class="comment">// set Physical address of pp to it, and init 页表项</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *ppte = <span class="literal">NULL</span>;<span class="comment">// no need to create a page</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (3/3) */</span></span><br><span class="line">  <span class="comment">// Pte *pte_location = (Pte *)(*pgdir_entryp &gt;&gt; 12 &lt;&lt; 12) + PTX(va);</span></span><br><span class="line">  <span class="comment">// physical</span></span><br><span class="line">  Pte *pte_location = (Pte *)(KADDR(PTE_ADDR(*pgdir_entryp))) +</span><br><span class="line">                      PTX(va); <span class="comment">// get pte virtual address</span></span><br><span class="line">  *ppte = (pte_location);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>(*pgdir_entryp &amp; PTE_V)</code>是为了获取把目标一级页表项的有效位（使用位运算）</p><p><code>(KADDR(PTE_ADDR(*pgdir_entryp)))</code>获取目标一级页表项的虚拟地址，后面的加法表示二级页表偏移量，获得的是二级页表项地址</p><h4 id="page-insert-Exercise-2-7"><a href="#page-insert-Exercise-2-7" class="headerlink" title="page_insert() - Exercise 2.7"></a><code>page_insert()</code> - Exercise 2.7</h4><ul><li>  该函数的作用是将一级页表基地址<code>pgdir</code>中虚拟地址<code>va</code>所在<strong>虚拟页面</strong>指向页控制块<code>pp</code>对应的<strong>物理页面</strong>，并将页表项权限为设置为<code>perm</code>。</li></ul><p>（改变页表指的页面）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va,u_int perm)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) &#123;<span class="comment">// 页表项有效</span></span><br><span class="line">        <span class="keyword">if</span> (pa2page(*pte) != pp) &#123;<span class="comment">// 指向的物理页不同，删除页表项</span></span><br><span class="line">            page_remove(pgdir, asid, va);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tlb_invalidate(asid, va);<span class="comment">// 物理页相同，删除过时的 tlb 映射</span></span><br><span class="line">            *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 更新为 pp 所在物理页并置有效位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 va 所在的 tlb 表项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line">    <span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line">    <span class="type">int</span> temp = pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (-E_NO_MEM == temp) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Insert the page to the page table entry with &#x27;perm  PTE_V&#x27; and</span></span><br><span class="line"><span class="comment">     * increase its &#x27;pp_ref&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">    *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 同上，更新为 pp 所在物理页并置有效位</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  <code>pa2page(*pte)</code>：取得二级页表项具体值，并取高位（物理页号）转换为<code>page</code>类指针，这里就是取得虚拟地址指的物理页的<strong>page</strong>结构体</li><li>  <code>page2pa(pp)permPTE_V</code>：pp对应的物理地址基址（物理页号，低位为0），并增添<code>perm</code>与有效位</li></ul><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a><code>page_lookup()</code></h4><ul><li>  该函数的作用是返回虚拟地址<code>va</code>映射物理页的页控制块<code>Page</code>，并将<code>ppte</code>指向的空间设为<strong>二级页表项</strong>地址</li></ul><p>（查va对应的Page和Pte）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    Pte *pte;</span><br><span class="line">    </span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);<span class="comment">// 获取 va 对应的二级页表项</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp;&amp; (*pte &amp; PTE_V))) &#123;<span class="comment">// 页表项无效，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pp = pa2page(*pte);<span class="comment">// 由 *pte 取出对应物理页块</span></span><br><span class="line">    <span class="keyword">if</span> (ppte) &#123;</span><br><span class="line">        *ppte = pte;<span class="comment">// 写入二级页表项地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp;<span class="comment">// 返回页控制块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a><code>page_remove()</code></h4><ul><li>  删除虚拟地址<code>va</code>在指定程序中所对应的<strong>物理页面</strong>映射</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    pp = pgdir(pgdir, va, &amp;pte);<span class="comment">// 查找对应的页控制块</span></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 没有映射，返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pp);<span class="comment">// 减少物理页引用次数</span></span><br><span class="line">    *pte = <span class="number">0</span>;<span class="comment">// 清楚原有页表映射</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 tlb 中的页表映射</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟内存与-TLB"><a href="#虚拟内存与-TLB" class="headerlink" title="虚拟内存与 TLB"></a>虚拟内存与 TLB</h3><h4 id="CP0-寄存器-EntryHi、EntryLo、Index"><a href="#CP0-寄存器-EntryHi、EntryLo、Index" class="headerlink" title="CP0 寄存器 - EntryHi、EntryLo、Index"></a>CP0 寄存器 - EntryHi、EntryLo、Index</h4><ul><li>  CP0 寄存器 EntryHi 与 EntryLo 分别对应到 TLB 的 Key 与 Data ，是 TLB 映射信息的来源</li><li>  ASID 与<strong>虚拟页号</strong>位于 EntryHi 中</li><li>  有效位、可写位等标记位与<strong>物理页号</strong>在 EntryLo 中</li><li>  <code>Index</code>寄存器中存放访问的 TLB 的标号</li><li>  TLB 相当于一小段常用的<strong>直接映射页表</strong>，使用虚拟页号 + ASID 直接得到物理页号及相关信息</li></ul><p>软件通过使用 CP0 寄存器和下面的汇编指令，把两个寄存器中分别存放的页号形成映射，存入 TLB 内部</p><h4 id="TLB-相关汇编指令"><a href="#TLB-相关汇编指令" class="headerlink" title="TLB 相关汇编指令"></a>TLB 相关汇编指令</h4><p><code>tlbr</code>：将<code>Index</code>的值作为索引，将当前索引指向的 TLB 表项<strong>读出</strong>至 CP0 寄存器</p><p><code>tibwi</code>：将 CP0 寄存器的值回写入 TLB 索引的表项内</p><p><code>tlbwr</code>：<strong>randomly</strong> 写入 TLB 表项内</p><p><code>tlbp</code>：根据 EntryHi 查询 TLB 内的表项，并将查找到的索引存入 Index 内（若不存在则将 Index 最高位置为1）</p><h4 id="TLB-维护与更新"><a href="#TLB-维护与更新" class="headerlink" title="TLB 维护与更新"></a>TLB 维护与更新</h4><ol><li> 更新页表中虚拟地址对应的页表项的同时，将 TLB 中对应的<strong>旧表项无效化</strong></li><li> 在下一次访问该虚拟地址时触发 <strong>TLB 重填异常</strong>，对 TLB 进行重填</li></ol><h4 id="tlb-invalidate-Exercise-2-8"><a href="#tlb-invalidate-Exercise-2-8" class="headerlink" title="tlb_invalidate() - Exercise 2.8"></a><code>tlb_invalidate()</code> - Exercise 2.8</h4><p>填空上毫无难度，汇编函数相关过程需要进行一些思考，详细可以参考 Thinking 2.5内容</p><h4 id="do-tlb-refill-Exercise-2-9-2-10"><a href="#do-tlb-refill-Exercise-2-9-2-10" class="headerlink" title="do_tlb_refill() - Exercise 2.9 ~ 2.10"></a><code>do_tlb_refill()</code> - Exercise 2.9 ~ 2.10</h4><p>2.10类似于2.8，填空无难度，2.9的<code>do_tlb_refill</code>函数机制如下：</p><ol><li> 进入函数，取出<code>TLB</code>缺失的<strong>虚拟地址</strong>（<code>BADVADDR</code>）和当前进程的<code>asid</code>（<code>EntryHi[11:6]</code>）</li><li> 调用C语言函数 Exercise 2.10 的<code>_do_tlb_refill()</code>（<code>jal _do_tlb_refill</code>），获取虚拟地址对应的<strong>页表项</strong>（<code>Pte *</code>）</li><li> 填空指令<code>tlbwr</code>随机地把保存在<code>EntryHi</code>和<code>EntryLo</code>中的信息写入一条<code>TLB</code>中</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Pte _do_tlb_refill(u_long va, u_int asid) &#123;</span><br><span class="line">  Pte *pte;</span><br><span class="line">  <span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">   *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry</span></span><br><span class="line"><span class="comment">   * &#x27;pte&#x27; associated with the virtual address &#x27;va&#x27; in the current address space</span></span><br><span class="line"><span class="comment">   * &#x27;cur_pgdir&#x27;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;pte&#x27; could</span></span><br><span class="line"><span class="comment">   * not be found, allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27;</span></span><br><span class="line"><span class="comment">   * succeeds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.9: Your code here. */</span></span><br><span class="line">  <span class="comment">// Page *pp = page_lookup(cur_pgdir, va, &amp;pte);</span></span><br><span class="line">  <span class="keyword">while</span> (page_lookup(cur_pgdir, va, &amp;pte) == <span class="literal">NULL</span>) &#123;<span class="comment">// 查询 va 的页表项和物理页</span></span><br><span class="line">    passive_alloc(va, cur_pgdir, asid);<span class="comment">// 调用被动分配函数分配物理页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG) = 4 * 1024 * 1024 - 2 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;address too low&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= USTACKTOP &amp;&amp; va &lt; USTACKTOP + BY2PG) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG) = 0x80000000 - 5 * 4 * 1024 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;invalid memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UENVS &amp;&amp; va &lt; UPAGES) &#123;</span><br><span class="line">        panic(<span class="string">&quot;envs zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UPAGES &amp;&amp; va &lt; UVPT) &#123;</span><br><span class="line">        panic(<span class="string">&quot;pages zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= ULIM) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kernel address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    panic_on(page_alloc(&amp;p));</span><br><span class="line">    panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), PTE_D));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80010000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP (ULIM + PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM 0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT (ULIM - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPAGES (UVPT - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENVS (UPAGES - PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTOP UENVS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UXSTACKTOP UTOP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEXT PDMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOW (UTEXT - BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="SLIST宏代码"><a href="#SLIST宏代码" class="headerlink" title="SLIST宏代码"></a><code>SLIST</code>宏代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#defineSLIST_HEAD(name, type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">slh_first</span>;</span><span class="comment">/* first element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_HEAD_INITIALIZER(head)\</span><br><span class="line">&#123; <span class="literal">NULL</span> &#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#defineSLIST_INIT(head) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = <span class="literal">NULL</span>;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (slistelm)-&gt;field.sle_next;\</span><br><span class="line">(slistelm)-&gt;field.sle_next = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (head)-&gt;slh_first;\</span><br><span class="line">(head)-&gt;slh_first = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = (head)-&gt;slh_first-&gt;field.sle_next;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">if</span> ((head)-&gt;slh_first == (elm)) &#123;\</span><br><span class="line">SLIST_REMOVE_HEAD((head), field);\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">else</span> &#123;\</span><br><span class="line"><span class="keyword">struct</span> type *curelm = (head)-&gt;slh_first;\</span><br><span class="line"><span class="keyword">while</span>(curelm-&gt;field.sle_next != (elm))\</span><br><span class="line">curelm = curelm-&gt;field.sle_next;\</span><br><span class="line">curelm-&gt;field.sle_next =\</span><br><span class="line">    curelm-&gt;field.sle_next-&gt;field.sle_next;\</span><br><span class="line">&#125;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_FOREACH(var, head, field)\</span><br><span class="line"><span class="keyword">for</span>((var) = (head)-&gt;slh_first; (var); (var) = (var)-&gt;field.sle_next)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_EMPTY(head)((head)-&gt;slh_first == <span class="literal">NULL</span>)</span><br><span class="line">#defineSLIST_FIRST(head)((head)-&gt;slh_first)</span><br><span class="line">#defineSLIST_NEXT(elm, field)((elm)-&gt;field.sle_next)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab2-Report</title>
      <link href="/2023/03/buaa-os-2023-lab2-report/"/>
      <url>/2023/03/buaa-os-2023-lab2-report/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p> </p><h3 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h3><blockquote><p>虚拟地址在系统中的使用</p></blockquote><p>根据指导书说明：</p><blockquote><p>而在实际程序中，访存、跳转等<strong>指令</strong>以及用于取指的<strong>PC寄存器</strong>中的访存地址都是<strong>虚拟地址</strong>。 我们编写的C程序中也经常通过对指针解引用来进行访存，其中<strong>指针的值</strong>也会被视为<strong>虚拟地址</strong>，经过编译后生成相应的访存指令。</p></blockquote><p>故在编写的C程序中指针存储的地址和汇编程序中<code>lw</code>和<code>sw</code>使用的值都是<strong>虚拟地址</strong>。</p><h3 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h3><blockquote><p>链表宏与对应的链表结构</p></blockquote><ul><li>  从可重用性的角度，阐述用宏来实现链表的好处。</li></ul><p>使用宏进行链表实现，一方面能够规范系统内所有链表的存在形式，达成结构上的统一，易于编码与链表维护； 链表宏中大部分传入的参数并不是链表项整体，而是不包含链表具体存放信息的一个<strong>结构体</strong>，这个结构体只负责管理链表指针。 我们利用宏对这个结构体进行处理，一方面统一链表操作，不限制可以使用链表的结构类型；另一方面能够降低链表指针与链表内容间不必要的耦合性，维护数据安全；使用预设结构还能保证链表结构的正确性。 查阅资料后得知，除了重用性角度外，使用宏定义还意味着放置在<code>queue.h</code>内的所有宏都是完整的，不需要编译为<strong>库文件</strong></p><ul><li>  分析<strong>单向链表</strong>、<strong>循环链表</strong>和实验中使用的<strong>双向链表</strong>在插入与删除操作上的性能差异。</li></ul><blockquote><p>头文件<code>queue.h</code>为C语言中的链表提供了更加标准规范的编程接口。如今的版本多为伯克利加州大学1994年8月的8.5版本。 每种结构都支持基本的操作：</p><ol><li> 在链表头插入节点</li><li> 在任意的节点后插入节点</li><li> 移除链表头后的节点</li><li> 前向迭代遍历链表</li></ol></blockquote><p>我们打开对应的文件<code>/usr/include/sys/queue.h</code>，可以发现其中不仅仅包含了我们使用的双向链表<code>LIST</code>、待分析的单向链表<code>SLIST</code>和循环链表<code>CIRCLEQ</code>，还有两个有尾链表结构<code>TAILQ</code>和<code>SIMPLEQ</code>（双向有尾/单向有尾），这5个数据结构共同构成了<code>LINUX</code>的链表宏定义（为节省空间，下文只拿出所需的定义进行解释，其他定义便不再详述<strong>，完整定义会贴在全文最后</strong>）</p><ol><li> 单向链表<code>SLIST</code>：</li></ol><p>单向链表（<code>Singly-linked List</code>）在结构上较为简单，链表项只包含一个指向下一个元素的指针 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260156076.png" alt="单向链表">  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入操作：<ul><li>  链表中插入（已知前驱元素指针）需要修改被插入项<code>slistelm</code>和自身<code>elm</code>的指针，即需要两条指令；</li><li>  插入第一个元素需要修改自身<code>elm</code>的指针指向原有的第一项，同时还需要修改<strong>链表头项</strong>的<code>slh_first</code>指向自身，也需要两条指令</li></ul></li><li>删除操作：<ul><li>  链表中删除（无前驱元素指针）需要判断是否前驱元素为链表第一个元素，是则归入第二类，不是则需要从头部开始遍历得到前驱元素，并修改前驱指针指向自身的后继元素，需要2n+2条指令</li><li>  删除第一个元素只需要修改链表头指向的链表项即可，即一条指令</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1或2n+2条语句</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 循环链表<code>CIRCLEQ</code>：</li></ol><p><code>LINUX</code>宏定义下的循环链表只存在双向循环链表<code>CIRCLEQ</code>一种，它是<code>Circular queue</code>的简写 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260200417.png" alt="循环链表"> 由于循环链表有头有尾，故链表头项包含两个指针：<code>cqe_first</code>和<code>cqe_last</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_HEAD(name, type)                                            \</span></span><br><span class="line"><span class="meta">struct name &#123;                                                               \</span></span><br><span class="line"><span class="meta">    struct type *cqh_first;     <span class="comment">/* first element */</span>                         \</span></span><br><span class="line"><span class="meta">    struct type *cqh_last;      <span class="comment">/* last element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时每个链表项与双向无尾链表<code>LIST</code>结构稍有不同，它有两个指向链表项的指针:<code>cqe_next</code>和<code>cqe_prev</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_ENTRY(type)                                                 \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *cqe_next;      <span class="comment">/* next element */</span>                          \</span></span><br><span class="line"><span class="meta">    struct type *cqe_prev;      <span class="comment">/* previous element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>由于可以提供双向+头尾指针，所以循环链表可以有多种插入方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do &#123;                \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do &#123;               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_HEAD(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_TAIL(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_REMOVE(head, elm, field) do &#123;                               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句，但需要进行额外的两次if分支判断</span></span></span><br></pre></td></tr></table></figure><p>在进行插入操作时，需要考虑到是否仅含一个元素的情况，这时需要对链表头项进行修改，与其他情况稍有不同（以INSERT_HEAD为例）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((head)-&gt;cqh_last == (<span class="type">void</span> *)(head))                              \</span><br><span class="line">        (head)-&gt;cqh_last = (elm);                                           \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;cqh_first-&gt;field.cqe_prev = (elm);                          \</span><br><span class="line">    (head)-&gt;cqh_first = (elm);  </span><br></pre></td></tr></table></figure><ol start="3"><li> 双向链表<code>LIST</code>：</li></ol><p>然后就是我们在实验中使用到的双向链表<code>LIST</code>，它与其他内置链表宏的最大区别就是链表项：<code>LIST</code>含有一个指针和一个<strong>二重指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *le_next;   <span class="comment">/* next element */</span>                              \</span></span><br><span class="line"><span class="meta">    struct type **le_prev;  <span class="comment">/* address of previous next element */</span>          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>也因为其能够进行双向操作，插入的方法也有多种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field) do &#123;                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_HEAD(head, elm, field) do &#123;                             \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_REMOVE(elm, field) do &#123;                                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句</span></span></span><br></pre></td></tr></table></figure><p>这里需要注意执行向后插入的<code>INSERT_AFTER</code>和<code>INSERT_HEAD</code>都需要判断是否为最后一个元素，决定是否需要调整后继元素的<code>le_prev</code>指针 分析后可以看出，</p><ul><li>  单项链表<code>SLIST</code>执行插入的效率最高，但是删除时需要进行遍历操作以防止后续链表元素丢失，性能较差；</li><li>  循环链表<code>CIRCLEQ</code>执行插入的效率稍低于单项链表，删除效率要高于单向链表，但需要进行分支判断，也为常数级</li><li>  双向链表<code>LIST</code>插入效率与循环链表类似，删除效率略高于循环链表</li></ul><h3 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h3><p>查看<code>pmap.h</code>得知<code>Page_list</code>结构调用了<code>LIST_HEAD()</code>宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(Page_list, Page)                                               \</span></span><br><span class="line"><span class="meta">struct Page_list &#123;                                                             \</span></span><br><span class="line"><span class="meta">struct Page *lh_first; <span class="comment">/* first element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时还定义了<code>Page</code>结构体和<code>Page_LIST_entry_t</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(Page)                                                                   \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                               \</span></span><br><span class="line"><span class="meta">struct Page *le_next;  <span class="comment">/* next element */</span>                                          \</span></span><br><span class="line"><span class="meta">struct Page **le_prev; <span class="comment">/* address of previous next element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>于是可以得出完整结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page_LIST_entry_t</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">        </span><br><span class="line">        u_short pp_ref;</span><br><span class="line">    &#125;* lh_first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故选择C选项  </p><h3 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h3><ul><li>  请阅读上面有关R3000-TLB 的描述，从虚拟内存的实现角度，阐述ASID 的必要性。</li></ul><blockquote><p>ASID，Address Space IDentifier 用于区分不同的地址空间，同一虚拟地址通常在不同的地址空间中映射到不同的物理地址。</p></blockquote><p>也就是说，ASID用来标记当前虚拟地址所归属的程序号，如果访问的是其他程序的虚拟地址，通常会指向一个错误的物理地址。因此需要确保访问的请求来自特定的程序，于是采用了ASID作为保险，确定虚拟地址请求的来源。</p><ul><li>  请阅读《IDT R30xx Family Software Reference Manual》的Chapter 6，结合ASID段的位数，说明R3000 中可容纳不同的地址空间的最大数量。</li></ul><p>ASID段占用的数据位为[11, 6]，共6位，则意味着R3000中可容纳不同的地址空间的最大数量为64。</p><h3 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h3><ul><li>  tlb_invalidate 和tlb_out 的调用关系？</li></ul><p>打开<code>kern/pmap.c</code>文件并找到<code>tlb_invalidate</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">    tlb_out(PTR_ADDR(va)  (asid &lt;&lt; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知C语言函数<code>tlb_invalidate</code>调用了汇编函数<code>tlb_out</code></p><ul><li>  请用一句话概括tlb_invalidate 的作用。</li></ul><p>删除在序号为<code>ASID</code>的程序规划的虚拟空间中，虚拟地址<code>va</code>所在页在<code>TLB</code>中的页表项</p><ul><li>  逐行解释tlb_out 中的汇编代码。</li></ul><p><code>tlb_out</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mfc0 t0, CP0_ENTRYHI# 从CP0_ENTRYHI寄存器取值至$t0</span><br><span class="line">mtc0 a0, CP0_ENTRYHI# 将$a0的值存入CP0_ENTRYHI中</span><br><span class="line">nop</span><br><span class="line">tlbp# 查找 TLB 表项，将索引存入 Index 寄存器</span><br><span class="line">nop</span><br><span class="line">mfc0 t1, CP0_INDEX# 将索引取值至$t1寄存器</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line">bltz t1, NO_SUCH_ENTRY# 索引空，准备退出</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mtc0 zero, CP0_ENTRYHI# 清空ENTRYHI和ENTRYLO</span><br><span class="line">mtc0 zero, CP0_ENTRYLO0</span><br><span class="line">nop</span><br><span class="line">tlbwi# 清空 Index 对应的 TLB 项</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">mtc0 t0, CP0_ENTRYHI# 把ENTRYHI的值回存</span><br><span class="line">j ra</span><br><span class="line">END(tlb_out)# 结束 tlb_out 函数</span><br></pre></td></tr></table></figure><p> </p><h3 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h3><ul><li>  简单了解并叙述X86 体系结构中的内存管理机制，比较X86 和MIPS 在内存管理上的区别。</li></ul><p>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。其中分段可以将逻辑地址转换为线性地址，而分页可以将线性地址转换为物理地址。 并且x86允许存在不分页的情况，但不允许程序不分段 <strong>MIPS 与 X86 的 TLB 差别</strong> 其在于对 TLB 不命中时的处理上： MIPS 会触发TLB Refill 异常，内核的 tlb_refill_handler 会以 pgd_current 为当前进程的 PGD 基址，索引获得转换失败的虚址对应的 PTE，并将其填入 TLB，完了CPU 把刚刚转换失败的虚地址再走一下 TLB 就OK了。 而 X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303261712115.png" alt="image-20230326171214176"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Exam</title>
      <link href="/2023/03/buaa-os-lab1-exam/"/>
      <url>/2023/03/buaa-os-lab1-exam/</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-Exam"><a href="#lab1-Exam" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h1><blockquote><p>课下一时爽，课上<code>debug</code>火葬场</p></blockquote><h2 id="课下出锅力！"><a href="#课下出锅力！" class="headerlink" title="课下出锅力！"></a>课下出锅力！</h2><p>问题出在<code>%ld/%d</code>时负数的判定上（也就是判定<code>neg_flag</code>上）:我的判定方法是，<code>if (num &lt; 0)</code>则<code>neg_flag = 1; num = -num;</code>，这样对<code>ld</code>来说还说得过去，但是对于<code>int</code>类型就出问题了，<code>long</code>类型的<code>num</code>变量装了一个<code>int</code>的值，然后取相反数的时候却按着<code>long</code>类型跑的，然后补码尊贵的符号位就登场搞事情了（寄），还好课上一个多小时修出来了，要不然计组<code>P7</code>历史重演力！</p><h2 id="lab1-Exam-1"><a href="#lab1-Exam-1" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h2><blockquote><p>题目要求：修改我们课下编写的<code>vprintfmt</code>函数，使其能够支持新格式符（<code>format specifiers</code>） range ：<code>R</code>，同时要求格式符<code>R</code>也能使用与其他格式符同等的副格式符：即<code>&lt;flag&gt;</code>、<code>&lt;width&gt;</code>、<code>&lt;length&gt;</code>三个副格式符。 格式符<code>Range</code>的作用为：使用函数中接下来的两个<strong>整数参数</strong><code>a, b</code>，输出<code>(&lt;a&gt;,&lt;b&gt;)</code>字符串。这两个参数共用一组副格式符，受到的修饰相同。</p></blockquote><ul><li>  样例：对于下面的函数<code>range_1_check</code>，应该有其之后的输出：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">range_1_check</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;%s%R%s&quot;</span>, <span class="string">&quot;This is a testcase: &quot;</span>, <span class="number">2023</span>, <span class="number">2023</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;the range is %R, size = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This is a testcase: (2023,2023)</span></span><br><span class="line"><span class="comment">//the range is (1,9), size = 8</span></span><br></pre></td></tr></table></figure><ul><li>  解题流程：仔细看下来其实就是要在<code>vprintfmt()</code>函数里增加一种格式符的判断：<code>case &#39;R&#39;:</code>，作用是输出三个字符和两个整数（<code>%c%d%c%d%c</code>，当然这个<code>%d</code>是可能有副格式符的）；只需要判断一下输出的整数是<code>int</code>还是<code>long</code>就解决了，（然后课下出锅寄了一个多小时）</li><li>  BUG与坑点：课下对了就是对了，剩下的都可以抄<code>%c</code>和<code>%d</code>那里的</li></ul><h2 id="lab1-Extra"><a href="#lab1-Extra" class="headerlink" title="lab1-Extra"></a>lab1-Extra</h2><blockquote><p>题目要求：实现一个类似<code>fprintf</code>的函数<code>int sprintf(char *buf, const char *fmt, ...);</code>，将<code>fmt</code>字符串格式化输出到<code>buf</code>所在的内存空间中，且返回值应是<code>buf</code>中存放字符串的长度。 <strong>提示</strong>：可以调用<code>vprintfmt</code>函数进行协助输出</p></blockquote><ul><li>  样例：就不写了，可以拿个<code>fprintf</code>逝逝，效果一样的</li><li>这个考题完美回答了对于<code>vprintfmt</code>函数中不起作用的<code>void *data</code>形参和看起来有点复杂的函数形参<code>fmt_callback_t out</code>的问题：<ul><li>  函数中的<code>data</code>可以承载输出的目的地指针，在<code>printk</code>中我们输出至控制台，所以<code>data</code>的取值并不重要（最终以调用了<code>printcharc</code>函数作为具体输出）；但在这里实现的<code>sprintf</code>函数含有一个<strong>目的地</strong><code>buf</code>，所以我们需要把<code>buf</code>传入，负责接收所有需要输出的字符（写入<code>buf</code>指向的内存）</li><li>  函数中的<code>out</code>被称为回调函数参数，不过这个概念在这里并不重要，我们在解完题之后再来回顾。</li></ul></li><li>解题流程：实现思路与<code>printk</code>类似，顶层和中间层的调用都相同，不同的是最底层的输出方式：<ul><li>  <code>printk</code>使用<code>printcharc</code>写入控制台</li><li>  <code>sprintf</code>需要写入<code>buf</code>指向的内存</li><li>  （这是不是刚说过一遍）所以顶层函数照抄，我们重点实现这个替代原有<code>outputk</code>的新函数<code>outputbuf</code>（忘了啥是<code>outputk</code>的快回去看<code>lab1</code>讲解那篇文！）</li></ul></li><li>  <code>outputbuf</code>的实现：<code>void outputbuf(void *data, const char *buf, size_t len);</code></li></ul><p>如果能把<code>vprintfmt</code>整明白也挺容易看的，本函数应输出的字符串序列已经被安放在<code>buf</code>内，需要输出的长度为<code>len</code>，目的地为<code>data</code>；需要做的就是一个循环把字符搬运过去（记得末尾加一个<code>\0</code>） 这里的<code>\0</code>不需要考虑是否会导致下次再调用时没法接上，先取一下当前<code>data</code>的<code>strlen</code>，再从下一位（实际上是上一次写进去的<code>\0</code>）开始继续拼就可以了，最后又会是一个<code>\0</code>结束 附一种可能可行的实现方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *temp = (<span class="type">char</span> *)data + <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        *temp = buf[i];</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    *temp = <span class="string">&#x27;\0;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我课上的实现方法严格意义上不符合要求，因为传入的参数形式不同，但是给了警告也能照样跑（</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> **data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    **(<span class="type">char</span> **)data = buf[i];</span><br><span class="line">    (*data) = (*data) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    **(<span class="type">char</span> **)data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主要不同体现在没有充当临时变量的char *temp，全程都是void **data取一层值后*data这个char *的自由移动，效果类似，不使用strlen也许效率会高一点？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于outputbuf传参不同，所以这里给vprintfmt传参也需要发生改变，所以说这样的做法不太合适，相当于改变了函数结构</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *place = buf;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  vprintfmt(outputbuf, &amp;buf, fmt, ap);</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)(buf - place - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>好了，课上的部分大概就是这些了，现在我们回来谈谈这个回调函数<code>fmt_callback_t</code>到底是个买</p><blockquote><p>回调函数，是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，并且被传参的函数<strong>使用了这个函数指针</strong>，我们就认为这是一个回调函数。 回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另一方（被传参函数）调用的，用于对某事件或条件进行响应。</p></blockquote><p>说白了，回调函数就是一个只能被他人调用的函数，而回调函数参数就是某个函数中已经<strong>固定好返回值、自身形参</strong>的参数（类型是函数指针） 那我们还拿<code>vprintfmt</code>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>fmt_callback_t out</code>，就是一个回调参数，实际类型是一个函数指针，接收者<code>vprintfmt</code>在自身内部对<code>out</code>函数进行调用，用于处理某些事件（这个例子中就是输出处理好的字符串），这样的处理虽然看起来有些繁琐，但是实际上给了<code>vprintfmt</code>函数非常强的<strong>可拓展性</strong>，输出函数的接口化，意味着它可以通过传入不同的输出函数，完成更复杂情况下、更多种类的输出任务（就比如<code>lab1-extra</code>这个输出到内存）。 如果只考虑输出控制台，实际上完全可以不传入<code>out</code>参数，直接使用<code>printcharc</code>函数完成任务。但强拓展性可不是一个简简单单的<code>printcharc</code>能受的住的（） 顺便提一嘴最好让同一个回调参数对应的函数类型都一致，否则可不一定能保证功能正确（反正编译器会先给你个难看的警告.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303202324203.png" alt="image-20230320232412341"> 实际上，在C语言库中还有很多这样的<strong>回调函数</strong>，其中我们用的相当多的一个就是<code>qsort</code>中的第四个参数：<code>cmp</code>。每次我们调用<code>qsort</code>，都需要事先写好<code>cmp</code>函数，并且传入<code>qsort</code>中，让其按照我们程序员事先设定好的规则进行排序。 写到这里我也才注意到，当时程设 + DS绕的一圈一圈的<code>cmp</code>参数格式，实际上正是C库的高拓展性所在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先为了符合回调函数要求，无论编写怎样的<code>cmp</code>函数都要保证参数类型一致；而为了能够处理更多种类的数据（甚至结构体），形参被设置成了<code>const void*</code>，这样不管比较的是什么结构，传入形参后强制类型转换把引用解开就可以进一步处理了。所以虽然程序员用起来有点绕，但对C库来说，这样写绝对是件好事。 在编程过程中使用回调机制，可以更好地分离代码，使得应用层和驱动层尽可能分离，降低总代码的耦合性。 受教了。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT1-Summary（未完成-完成了会删括号.jpg）</title>
      <link href="/2023/03/buaa-oo-unit1-summary/"/>
      <url>/2023/03/buaa-oo-unit1-summary/</url>
      
        <content type="html"><![CDATA[<blockquote><p>UNIT1-递归下降 因为想把作业比较完整地记录下来，而不仅仅是提交一份作业、交差完事，所以会写的相对多一点（ 可能刚敲完报告的同学 or 已经看了 n 份报告的助教看这篇答辩会觉得很臃肿，但这就不关我事了（？） <strong>博客作业要求部分</strong> 包含在 <strong>作业完成情况</strong> 标题下</p></blockquote><h2 id="作业内容及完成情况"><a href="#作业内容及完成情况" class="headerlink" title="作业内容及完成情况"></a>作业内容及完成情况</h2><h3 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h3><blockquote><p>指导书总结搬运，回顾用</p></blockquote><h4 id="三次作业任务描述"><a href="#三次作业任务描述" class="headerlink" title="三次作业任务描述"></a>三次作业任务描述</h4><ul><li>  第一次作业任务：读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>多变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。 在本次作业中，<strong>展开所有括号</strong>的定义是：对原输入表达式E做<strong>恒等变形</strong>，得到新表达式E，且E中不含有字符 <code>(</code> 和 <code>)</code> 。</li><li>  第二次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。 本次作业起，不再限制表达式内的括号层数</li><li>  第三次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用、求导算子的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。</li></ul><h4 id="设定的形式化表述"><a href="#设定的形式化表述" class="headerlink" title="设定的形式化表述"></a>设定的形式化表述</h4><blockquote><p>本节按不同作业中课程组的条目标定进行整合； 其中，条目前标定**[2]<strong>的是第二次作业的新增项目，</strong>[3]**同理</p></blockquote><ul><li>  表达式 → 空白项 [加减 空白项] 项 空白项 表达式 加减 空白项 项 空白项</li><li>  项 → [加减 空白项] 因子 项 空白项 ‘*‘ 空白项 因子</li><li>  因子 → 变量因子 常数因子 表达式因子｜[3]求导因子</li><li>  变量因子 → 幂函数 **[2]**三角函数 <strong>[2]<strong>自定义函数</strong>调用</strong></li><li>  常数因子 → 带符号的整数</li><li>  表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</li><li>  幂函数 → 自变量 [空白项 指数]</li><li>  自变量 → ‘x’ ‘y’ ‘z’</li><li>**[2]**三角函数 → ‘sin’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数] ‘cos’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数]<ul><li>  <strong>请注意输出三角函数时需要满足的形式化表述：内部元素为因子</strong></li></ul></li><li>指数 → ‘**‘ 空白项 [‘+’] 允许前导零的整数<ul><li>  <strong>指数一定不是负数，且输入的指数不得超过8</strong></li></ul></li><li>  带符号的整数 → [加减] 允许前导零的整数</li><li>  允许前导零的整数 → (‘0’’1’’2’…’9’){‘0’’1’’2’…’9’}</li><li>  空白项 → {空白字符}</li><li>  空白字符 → （空格） <code>\t</code></li><li>  加减 → ‘+’ ‘-‘</li><li><strong>[2]<strong>自定义函数</strong>定义</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项]] ‘)’ 空白项 ‘=’ 空白项 函数表达式<ul><li>  <strong>规定自定义函数在表达式输入前进行输入，需要预先输入自定义函数数量，且0\le num\le3</strong></li></ul></li><li>  <strong>[2]<strong>自定义函数</strong>调用</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项]] ‘)’</li><li>  **[2]**自定义函数名 →→ ‘f’ ‘g’ ‘h’</li><li>**[2]**函数表达式 →→ 表达式<ul><li>  <strong>第三次作业函数表达式中可以调用其他自定义函数，但保证不会出现递归调用的情况；同时调用自变量为常数的自身也不被允许)</strong></li></ul></li><li>  **[3]**求导因子 →→ 求导算子 空白项 ‘(‘ 空白项 表达式 空白项 ‘)’</li><li>  **[3]**求导算子 →→ ‘dx’ ｜’dy’ ｜’dz’</li></ul><h3 id="作业完成情况"><a href="#作业完成情况" class="headerlink" title="作业完成情况"></a>作业完成情况</h3><blockquote><p>虽然笨人很喜欢写东西，但耐不住笨人就是<strong>菜</strong>，三次作业全有bug（寄）</p></blockquote><h4 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h4><h5 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h5><p>简单分析过题面之后，可以分析出一个初步的构造顺序： 表达式项因子表达式\to项\to因子 再进行进一步分析后，可以发现题目中最基础的<strong>单元</strong>就是一个形如a*x^b*y^c*z^d形式的<strong>单项式</strong>，而无论是题干中出现的任何一种构成成分，都由<strong>一个或多个</strong>这样的单项式构成：</p><ul><li>  常数因子\to带符号整数：b=c=d=0</li><li>  变量因子\to幂函数：a\ne0\ \&amp;\&amp;\ bcd中仅存在一个值\ne0</li><li>  表达式：<strong>若干</strong>单项式相加</li><li>  <strong>因子</strong>：<strong>若干</strong>单项式相加</li><li>  <strong>项</strong>：<strong>若干</strong>单项式相加 前三个条目的安排相对直观，<strong>那为什么因子也需要用若干单项式相加来表示呢？</strong>原因在于这里没有写下的一条构成路线：</li></ul><p>因子表达式因子表达式</p><p>也就是说，表达式的组成也可以成为因子的一种，也容易理解： (2x+y+1)按照形式化表述显然属于因子，然而很明显其无法用<strong>一个单项式</strong>表示 而对于<strong>项</strong>，则由组合规则同理可知，不再赘述 于是第一次设计采用了：</p><ul><li>数据结构：统一的<code>HashSet&amp;lt;Values&amp;gt; values</code>字段存储对应条目的值，每一个<code>Values</code>都表达一个单项式；<ul><li>  使用<code>HashSet</code>这种不能便利取值的容器是第二次的罪魁祸首</li></ul></li><li>  计算方法：<code>HashSet.add()</code>方法表示相加，创建一个两重遍历容器的方法表示相乘</li><li>  类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192152189.png" alt="name"></li></ul><h5 id="实现过程-难点"><a href="#实现过程-难点" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h5><ul><li>  词法分析器<code>Lexer</code>：构建思路来自单元训练栏目，根据当前字符判断元素种类，再决定<code>Paser</code>的解析逻辑，考虑各种可能出现的字符才能避免解析时出现<code>Runtime Error</code>（换句话说，一般<code>RE</code>的话就是解析错了，或者是爆递归栈、爆堆等，结构不是很怪的话比较少见）</li><li>  <strong>符号与减法</strong>：直到很靠后的时候才想出去解析<strong>可能出现</strong>负号位置（共三个）的解决方案：先查询一下是不是负号，然后给一个标记位，控制到最后返回的表达式/项/因子的系数正负</li><li>  乘法实现：开始直接把两项<code>add</code>到一个容器了，后来才意识到需要<strong>按照分配律</strong>一项一项的加指数再<code>add</code></li><li>指数与 **0：n次方就把前面的元素乘个n次<ul><li>  特判0**0=1（三角函数特判，易锅）</li></ul></li><li>  化简-合并同类项：每次<code>add</code>时，遍历所有容器内已有元素，如指数完全一致则进行系数运算并放弃<code>add</code>操作；否则直接<code>add</code></li><li>  输出：为<code>Values</code>类配置了<code>ttoString()</code>方法，不重写原有的<code>toString</code>方法（出过锅），输出最终表达式中所有<code>Values</code>的<code>ttoString()</code>字符串</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192156742.jpg" alt="img"></li></ul><h5 id="debug与测试"><a href="#debug与测试" class="headerlink" title="debug与测试"></a>debug与测试</h5><ul><li>  强测得分/互测失分/互测得分：100/1(1bug)/0.75(1bug)</li><li>互测锅是后导空白字符，会一直解析直到<code>OutofIndex</code>报<code>RE</code>，挑战最短hack数据之：<code>x&amp;lt;space&amp;gt;</code><ul><li>  解决方案是预处理所有空白字符，忍痛在递归下降里用<strong>字符串处理</strong>，写了<code>replaceAll</code></li></ul></li><li>  互测刀到的是如果有形如factor*a，且a.length\ge2时，会只乘以贴近乘号的值</li><li>性能方面：x*x要比x**2短一个字符，x-1要比-1+x短一个字符，处理好这个优化点就能强测100了（确信<ul><li>  不要随便对输出用正则：</li><li>  消去1*x的无用系数，导致21*x\to 2x</li><li>  替换长的x**2为等价描述，导致x**21\to x*x1</li></ul></li></ul><h4 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h4><h5 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h5><p><strong>TLE，遂重构。</strong> 很遗憾，对于上一次的遍历查询值的操作来说，2s的CPU时间很明显不够祸祸的，所以只能换成<code>Map</code>类型便于查询 <code>Map</code>类型就要考虑采用什么作为<code>key/value</code>进行匹配，我采用了<code>&amp;lt;String, Values&amp;gt;</code>的键值对进行适配，为每一个项创建一个独特的字符串，且<strong>能够合并</strong>的项需要保证字符串相同（合并同类项时使用） 于是增添了一个新的<code>hashString()</code>方法，为每个<code>Values</code>创建字符串（生成<code>key</code>），这样其中的键值对都是<code>&amp;lt;Values.hashString(), Values&amp;gt;</code>形式的了；具体而言需要输出除了系数外的所有信息（xyz指数，<strong>三角函数</strong>的种类、指数、内部表达式、数量）。这也是这次重构中<strong>我遇到的的主要难点</strong> 其次是三角函数引入对<code>Values</code>类造成的改变，为了保证项中仅含单个三角函数时也能进行合并，故也采用类似<code>Values</code>的结构构建，键值对类型相同，此处的<code>String</code>则指三角内<code>expr</code>的<code>hashStringInValues()</code>（必须保证系数也一并输出，否则sin(x)和sin(2*x)将能合并） 最终结构为</p><h5 id="实现过程-难点-1"><a href="#实现过程-难点-1" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h5><ul><li>  <code>hashString()</code>方法：由于采用字符串比较，所以需要严格保证<strong>能够合并的项需要保证字符串相同</strong>这一要求，否则无法合并。那么就需要避免出现2*cos(x-1)和-3*cos(-1+x)不能合并的惨案。最简单有效的办法就是保证<code>expr</code>有序，这也是为什么最后架构采用了<code>TreeMap&lt;String, Values&gt;</code>（其实这里同时做了诱导公式，保证三角内<code>expr</code>第一项恒为正，避免了上述无法合并的情况）</li><li>  三角函数化简 - 特殊值：对于特殊值，也就是cos(0)=1、sin(0)=0；务必注意(sin(0))**0=1，不过我是在创建三角函数时就进行了其中<code>expr</code>特判，如果<code>expr.values = 0</code>就会返回0/1，而不是<code>sincos</code>，转化计算的优先度要高于乘方</li><li>  三角函数化简 - 诱导公式：已在<code>hashString()</code>方法中进行了解释</li><li>  三角函数化简 - 二倍角：对于二倍角优化比较复杂，简化下只处理了指数为1的sin二倍角和指数为2的cos二倍角/平方和</li><li>自定义函数与调用：创建类<code>ArtiFunc</code>用于存储函数相关数据，在自定义函数<strong>调用时解析</strong>对应函数名、因子，同时使用字符串替换原公式形参后直接进行完整公式的解析，并返回<code>TreeMap &lt;String, Values&gt;</code><ul><li>  在调用时才进行解析的做法可以有效避免被<strong>根本不调用</strong>的超高cost自定义函数刀掉</li></ul></li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192158265.jpg" alt="img"></li></ul><h5 id="debug与测试-1"><a href="#debug与测试-1" class="headerlink" title="debug与测试"></a>debug与测试</h5><ul><li>bug点：<ul><li>  自定义函数实参因子替换后，需要给因子加一层括号，否则可能会出现sin(f(x))\to sin(x*y)这样不符合形式表达的bug</li><li>  三角函数优化太容易出锅了，尤其是引入了新的机制<code>hashString()</code>，即使二倍角优化更改的是三角函数中某一个<code>expr</code>的值，但最后需要把整个<code>Values</code>的<code>hashString()</code>再存一遍（更新），经常在运算忘记更新导致合并出锅，反向优化甚至错误输出</li><li>  在优化过程中需要不断把合并掉的三角函数从容器中取出、运算、装入，这个过程需对元素进行深克隆，出锅后细化了<code>Calculator</code>类，支持了各种元素的深克隆方法（尽可能同名以减轻记忆压力）</li><li>  输出时，三角函数套括号的层数判断出了问题，具体为编写的<code>hasOneFactor()</code>判断不严谨，没有考虑到a*sin(a^{‘})的情况，仍然会输出一层括号，导致格式不合法</li></ul></li><li>  强测得分/互测失分/互测得分：88.7/1(1bug)/4.75(4bug)</li><li>  强测（20测试点）2×0分，4×性能非满分</li><li>  互测则全是优化的问题，bug修复就注释了四行优化函数摆了烂，下来还是好好修了修；</li><li>  刀到的是自己写了随机数据的测评姬，同时<code>SymPy</code>房里所有人的输出，谁不一样就拎出来批（×），bug还算比较多的</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181203783.png" alt="《你在强测中得到了 88.7702 分。》"></li></ul><p>《你在强测中得到了 88.7702 分。》 <strong>架构设计</strong> 第三次作业的实现在上一次作业的合理基础上反而更加简单，只需要实现求导功能和自定义函数相互调用两点即可 求导方法函数增添在原有的计算类<code>Caluculator</code>中，接受<code>TreeMap&lt;String, Values&gt;</code>，对每个单项的<code>Values</code>求导后返回一个盛放导数的新容器 自定义函数由于支持了声明时嵌套，所以为了使用简洁，改成了在声明时<strong>预解析</strong>的方式处理，但这样虽然方便处理函数，但没法解决第二次作业提到的高cost互测数据，有<code>TLE/MLE</code>风险 类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192214859.png" alt="name"> <strong>实现过程/难点</strong></p><ul><li>求导功能：修改<code>Lexer</code>支持解析求导文法，并在<code>Calculator</code>类中创建求导方法，返回输入<code>TreeMap&lt;String, Values&gt;</code>的导数；<ul><li>  为便于实现，我将求导功能分类，分别实现基础项a、a*x^b、sincos(expr)和可递归项的求导(sincos(expr))**e、sincos(expr1)*sincos(expr2)、x^b*sincos(expr1)[*sincos(expr)]?</li></ul></li><li>  自定义函数：只需提前解析自定义函数内容即可，注意替换调用时的因子对应</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192215413.jpg" alt="img"></li></ul><p><strong>debug与测试</strong></p><ul><li>bug点：<ul><li>  递归部分的求导函数，复杂的判断条件以及繁琐的操作（取出、运算、更新、放回等）使得方法复杂度远超其他方法，回想起来，编写的时候实际上也很头疼，出错其实也不出意外</li><li>  三角函数因子内含有自定义函数调用，这种组合可能会出现仅用一层括号就包住一个表达式的情况，然后在解析过程中就会因为文法问题出锅；解决方案是在输出自定义函数调用结果时也用一层括号包起来，表达式\to表达式因子，使其符合三角函数形式化表述</li></ul></li><li>  强测得分/互测失分/互测得分：85.7/3(2bug)/1(1bug)</li><li>  强测（15测试点）2×0分，1×性能非满分</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181202787.png" alt="image-20230318120226762"></li></ul><p>《你在强测中得到了 85.72 分。》</p><h3 id="作业总结"><a href="#作业总结" class="headerlink" title="作业总结"></a><strong>作业总结</strong></h3><p>首先要感谢上学期的先导课，有先导课做Java语言的基础极大地便利了我对基础语法的理解与运用，尤其是在第一次作业上，没有犹豫太多就选择了相对能够满足当前要求的架构（虽然后续需要重构，但完成了当时任务的要求）。其次，本单元作业通过构造一系列类间关系进行表达式的解析，使用了部分接口、继承、重写等Java语言特性。再其次，这次作业为<strong>递归下降</strong>的原理做了引入和解释，对之后的编译原理也许有一定助力作用</p><h4 id="设计模式思考"><a href="#设计模式思考" class="headerlink" title="设计模式思考"></a>设计模式思考</h4><p>在第一次作业中因为实现的功能比较简单，就没有涉及到深/浅克隆的处理；但是随着计算功能复杂化、容器深度变深（<code>Values</code>内又存放了<code>Map</code>类），深克隆逐渐重要了起来。虽然应该写序列化深克隆方法，但是当时完全忘记了<code>clone</code>方法能重写（），然后又造了轮子 功能类（计算类）与数据类（表达式组件类）要进行明确划分，避免一个类同时运行多种复杂函数。从第二次作业重构起，创建了一个单独的运算类<code>Calculator</code>，用于执行乘法、乘方功能，并在第三次作业中把求导功能也一并集成，反思这个设定应该为每一种运算创建一个类，避免<code>Calculator</code>类过于复杂。同时写的东西实际上没有写成<strong>静态方法</strong>（知识储备不足），导致每次计算都要<code>new</code>一个对象，虽然没有字段但也对运行时间、空间有一定的影响。</p><h4 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h4><p>肉眼可见的，复杂度飘红的方法都是功能复杂的方法，如[1]中的<code>toString</code>、<code>pow</code>方法；[2]中的<code>doubleSin</code>、<code>mergeInduction</code>方法、[3]中的<code>qiuDao</code>方法。同时，出锅的实际上也正是这几个方法，几乎无一幸免。 所以在编写代码的过程中要尤其注意行数多、判断循环条件复杂、功能复杂的方法，尽量将其功能<strong>分散</strong>、模块化，或者说可以方法多，别让方法难，否则单个复杂方法debug过于折磨，而多设方法、接口处还能进行调试检测，方便缩小错误范围。</p><h4 id="互测总结"><a href="#互测总结" class="headerlink" title="互测总结"></a>互测总结</h4><p>各次作业中强测出现的bug已在各自的<strong>debug与测试</strong>栏目中进行分析。对于互测部分，<code>hack</code>他人代码主要依靠自己随机递归思路生成数据+借助<code>SymPy</code>库实现的校对测评姬。</p><ul><li>  纯多项式使用<code>expand</code>进行比对、含三角函数则输出式相减与0比较，如遇合并项则选择人工核对（这里其实可以代入变量值进行比对，不过没写.jpg） 只能说自己写的逻辑确实不容易<code>hack</code>到自己，第一次作业的测评姬甚至<strong>不支持生成</strong>末尾空格，所以根本测不出来自己的bug；</li></ul><p>前期的数据空有一番大体量，但是覆盖度并不好，总有组合测试不到；后面改良版本则更多侧重0、±1等<strong>边界</strong>小数据是否会出现错误。 对于三角函数合并、求导，以及求导后再进行的合并化简，我设计了一个占比不同的导数内表达式生成机制，能够较充分地覆盖各类情况进行测试（能出现含<strong>0</strong>层三角函数的项，同时也按照等比的概率考虑到了多重三角函数嵌套的可能性和概率的合理性） 对于导数，应该生成：</p><ul><li>  5\% a</li><li>  5\% a*x^b</li><li>  10\% a*x^b*y^c</li><li>  15\% a*sincos(expr)</li><li>  15\% a*x^b*sincos(expr)</li><li>  25\% a*sincos(expr1)*sincos(expr2)</li><li>  25\% a*x^b*y^c*sincos(expr1)*sincos(expr2)\ expr1 =? expr2</li></ul><h2 id="理论课知识点"><a href="#理论课知识点" class="headerlink" title="理论课知识点"></a>理论课知识点</h2><h2 id="研讨课相关"><a href="#研讨课相关" class="headerlink" title="研讨课相关"></a>研讨课相关</h2><h3 id="第一次研讨课"><a href="#第一次研讨课" class="headerlink" title="第一次研讨课"></a>第一次研讨课</h3><h3 id="第二次研讨课"><a href="#第二次研讨课" class="headerlink" title="第二次研讨课"></a>第二次研讨课</h3>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Report</title>
      <link href="/2023/03/buaa-os-2023-lab1-report/"/>
      <url>/2023/03/buaa-os-2023-lab1-report/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h3><p>不使用交叉编译，使用<code>gcc -c</code>对文件进行编译，对编译而尚未链接的文件进行反汇编可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc -c hello.c </span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;</span><br><span class="line">  17:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  1c:   5d                      pop    %rbp</span><br><span class="line">  1d:   c3                      ret    </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>不使用交叉编译，对编译出的可执行文件直接进行<code>objdump -DS</code>指令，可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc hello.c -o hello2</span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello2</span><br><span class="line"></span><br><span class="line">hello2：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .interp:</span><br><span class="line"></span><br><span class="line">0000000000000318 &lt;.interp&gt;:</span><br><span class="line"> 318:   2f                      (bad)  </span><br><span class="line"> 319:   6c                      insb   (%dx),%es:(%rdi)</span><br><span class="line"> 31a:   69 62 36 34 2f 6c 64    imul   <span class="variable">$0x646c2f34</span>,0x36(%rdx),%esp</span><br><span class="line"> 321:   2d 6c 69 6e 75          sub    <span class="variable">$0x756e696c</span>,%eax</span><br><span class="line"> 326:   78 2d                   js     355 &lt;__abi_tag-0x37&gt;</span><br><span class="line"> 328:   78 38                   js     362 &lt;__abi_tag-0x2a&gt;</span><br><span class="line"> 32a:   36 2d 36 34 2e 73       ss sub <span class="variable">$0x732e3436</span>,%eax</span><br><span class="line"> 330:   6f                      outsl  %ds:(%rsi),(%dx)</span><br><span class="line"> 331:   2e 32 00                cs xor (%rax),%al</span><br><span class="line"></span><br><span class="line">Disassembly of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line">0000000000000338 &lt;.note.gnu.property&gt;:</span><br><span class="line"> 338:   04 00                   add    <span class="variable">$0x0</span>,%al</span><br><span class="line"> 33a:   00 00                   add    %al,(%rax)</span><br><span class="line"> 33c:   20 00                   and    %al,(%rax)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如使用交叉编译<code>mips-linux-gnu-gcc hello.c</code>进行编译链接，并直接使用<code>objdump -DS</code>进行反汇编，则会返回如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump a.out -DS</span><br><span class="line"></span><br><span class="line">a.out：     文件格式 elf32-big</span><br><span class="line"></span><br><span class="line">objdump: can<span class="string">&#x27;t disassemble for architecture UNKNOWN!</span></span><br></pre></td></tr></table></figure><p>出现如上错误是因为，需要使用交叉编译链所对应的反汇编工具才能解析，在我们的实验环境下就是<code>mips-linux-gnu-objdump</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ mips-linux-gnu-objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf32-tradbigmips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   27bdffe0        addiu   sp,sp,-32</span><br><span class="line">   4:   afbf001c        sw      ra,28(sp)</span><br><span class="line">   8:   afbe0018        sw      s8,24(sp)</span><br><span class="line">   c:   03a0f025        move    s8,sp</span><br><span class="line">  10:   3c1c0000        lui     gp,0x0</span><br><span class="line">  14:   279c0000        addiu   gp,gp,0</span><br><span class="line">  18:   afbc0010        sw      gp,16(sp)</span><br><span class="line">  1c:   3c020000        lui     v0,0x0</span><br><span class="line">  20:   24440000        addiu   a0,v0,0</span><br><span class="line">  24:   8f820000        lw      v0,0(gp)</span><br><span class="line">  28:   0040c825        move    t9,v0</span><br><span class="line">  2c:   0320f809        jalr    t9</span><br><span class="line">  30:   00000000        nop</span><br><span class="line">  34:   8fdc0010        lw      gp,16(s8)</span><br><span class="line">  38:   00001025        move    v0,zero</span><br><span class="line">  3c:   03c0e825        move    sp,s8</span><br><span class="line">  40:   8fbf001c        lw      ra,28(sp)</span><br><span class="line">  44:   8fbe0018        lw      s8,24(sp)</span><br><span class="line">  48:   27bd0020        addiu   sp,sp,32</span><br><span class="line">  4c:   03e00008        jr      ra</span><br><span class="line">  50:   00000000        nop</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h4 id="objdump参数意义"><a href="#objdump参数意义" class="headerlink" title="objdump参数意义"></a><code>objdump</code>参数意义</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D  反汇编文件中的所有section(节)</span><br><span class="line">-S  输出时按照C语言与汇编代码相对应的格式输出</span><br></pre></td></tr></table></figure><h3 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h3><p>使用我们编写的<code>readelf</code>程序对内核文件检查后得到的视图如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122303933.png" alt="image-20230312230359908"></p><p>使用<code>Linux</code>系统内自带的<code>readelf</code>指令对<code>readelf</code>文件和<code>hello</code>文件进行分析（使用<code>readelf -h readelf/hello</code>指令）可以发现两个文件的类型不同：<code>hello</code>是<code>ELF32</code>类型，而<code>readelf</code>是<code>ELF64</code>类型</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122307115.png" alt="image-20230312230745084"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122308042.png" alt="image-20230312230826009"></p><p>这说明我们的<code>hello</code>文件是32位的格式，而<code>readelf</code>则是64位的。我们打开<code>readelf.c</code>文件，发现其中的的数据类型前缀都是<code>ELF32</code>，也正是说明了这个程序负责分析32位的<code>ELF</code>文件。所以它不能分析身为64位格式程序的自己。</p><p>进入同目录下的<code>Makefile</code>文件查看，发现了两个文件在编译方式上的不同：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303130009343.png" alt="image-20230313000915321"></p><p>查阅相关资料后得知参数<code>-m32</code>：编译出来的是32位程序，既可以在32位操作系统运行，又可以在64位操作系统运行。这也恰好印证了<code>readelf</code>指令对于这两个文件的类型判定。</p><h4 id="补充：大小端转换"><a href="#补充：大小端转换" class="headerlink" title="补充：大小端转换"></a>补充：大小端转换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//小端-&gt;大端：</span></span><br><span class="line">UINT <span class="title function_">EndianConvertLToB</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p&lt;&lt;<span class="number">24</span>)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">8</span>)+(UINT)*(p+<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大端-&gt;小端</span></span><br><span class="line">UINT <span class="title function_">EndianConvertBToL</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">16</span>)+(UINT)*(p+<span class="number">3</span>)&lt;&lt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h3><p>在我们的实验中，系统启动被简化成了把内核加载到指定内存位置。</p><p>MIPS系统启动时首先接管的是<code>bootloader</code>，随后<code>Linker Script</code>把各个节映射到对应的段上，内核文件也在这时被加载到合适的地址空间中。</p><p>在<code>Exercise 1.2</code>中，我们补全了<code>kernel.lds</code>文件，把<code>.text</code>、<code>.data</code>、<code>.bss</code>三个段映射到了合理空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* Exercise 1.2 Your code here. */</span><br><span class="line"></span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = .;</span><br></pre></td></tr></table></figure><p>经过<code>Linker Script</code>文件的引导，内核代码就会被加载到<code>0x80010000</code>这段地址。再通过<code>ENTRY(_start)</code>的入口规定，如此便保证了我们能够跳转到内核入口</p><h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><h3 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1.1"></a>Exercise 1.1</h3><h4 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h4><p>在<code>Exercise 1.1</code>中，我们需要使用指针对ELF头进行寻址后取值，那么这时使用指针取得合适的地址就是重点了</p><blockquote><p>C语言对指针的加法运算符进行了重载</p></blockquote><p>如果使用了<code>+</code>对地址进行运算，地址的位移量会自动根据加号前的数据结构调整。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Struct st * p = (Struct st*)p + a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体为：地址会向后移动<code>a*sizeof(Struct st)</code>字节</p><p>在我们的实验中需要在ELF头中寻找到节头表的入口，需要的行为是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line"><span class="comment">//binary、ehdr为ELF头地址；e_shoff为节头表入口偏移</span></span><br></pre></td></tr></table></figure><p>但是有的同学写成了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(ehdr + ehdr-&gt;e_shoff);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原本的<code>binary</code>类型为<code>const void *</code>，它的加法运算符向后移动的单位为1字节；而已经转型为<code>Elf32_Ehdr</code>的<code>ehdr</code>重载后则会向后移动一个<code>Elf32_Ehdr</code>大小的地址空间。于是虽然两个指针指向了同一个地址，<code>+</code>后的值也相同，但是运算后得到的结果却截然不同</p><h4 id="readelf-c文件的补全"><a href="#readelf-c文件的补全" class="headerlink" title="readelf.c文件的补全"></a><code>readelf.c</code>文件的补全</h4><p>实验目的为输出ELF文件的节头地址信息。</p><p>首先需要明确，我们需要的节头地址信息保存在节头表中每个项目的特定字段中（<code>Elf32_Shdr -&gt; sh_addr</code>）。并且这个<code>sh_addr</code>指向ELF文件中的每个节头所在地址。那么就需要我们从ELF表头访问到节头表，并对每一项遍历即可。</p><blockquote><p><strong>遍历每一个节头</strong>的方法是：先读取节头的大小，随后以指向第一个节头的指针（即节头表第一项的地址）为基地址，不断累加得到每个节头的地址。</p></blockquote><p>具体实现为根据<code>Elf32_Edhr -&gt; e_shoff</code>寻找到节头表入口地址、根据<code>Elf32_Edhr -&gt; e_shnum</code>获取节头表中所含有项的个数，并根据<code>Elf32_Edhr -&gt; e_shentsize</code>获取节头表长度，便于位移</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table;</span><br><span class="line">Elf32_Half sh_entry_count;</span><br><span class="line">Elf32_Half sh_entry_size;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (1/2) */</span></span><br><span class="line">sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line">sh_entry_count = ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size = ehdr-&gt;e_shentsize;</span><br><span class="line"><span class="comment">// For each section header, output its index and the section address.</span></span><br><span class="line"><span class="comment">// The index should start from 0.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sh_entry_count; i++) &#123;</span><br><span class="line"><span class="type">const</span> Elf32_Shdr *shdr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (2/2) */</span></span><br><span class="line">shdr = sh_table + i * sh_entry_size;</span><br><span class="line">addr = (<span class="type">unsigned</span> <span class="type">int</span>)(shdr-&gt;sh_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:0x%x\n&quot;</span>, i, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Exercise-1-2"><a href="#Exercise-1-2" class="headerlink" title="Exercise 1.2"></a>Exercise 1.2</h3><h4 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a><code>Linker Script</code></h4><blockquote><p><code>Linker Script</code>中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。</p></blockquote><p>在<code>Exercise 1.2</code>中，我们就要利用<code>Linker Script</code>，对内核文件的各节进行内存指派，找到对应节的地址。段是由节所结合组成的，因为节的位置改变了，所以段的地址也会相应地发生移动，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/* fill in the correct address of the key sections: text, data, bss. */</span><br><span class="line">/* Exercise 1.2: Your code here. */</span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>.</code>号用作<strong>定位计数器</strong>，通过设置<code>.</code>的地址，声明接下来的节会被按序安放在该地址后。（在<code>SECTIONS</code>中，默认初始的地址为0地址，所以需要先修改地址然后再安排节文件）</p><p>后面的代码如<code>.bss:&#123;*(.bss)&#125;</code>，表示将所有输入文件中的<code>.bss</code>节（右边<br>的<code>.bss</code>）都放到输出的<code>.bss</code>节（左边的<code>.bss</code>）中。</p><p>观察<code>kernel.lds</code>的其他代码，还能发现这个文件规定了程序的入口地址。我们的实验程序通过<code>ENTRY(_start)</code>设置<code>_start</code>函数作为入口地址开始运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Set the ENTRY point of the program to _start.</span><br><span class="line"> */</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure><p>而<code>_start</code>函数被安放在<code>/init/start.S</code>文件中</p><h3 id="Exercise-1-3"><a href="#Exercise-1-3" class="headerlink" title="Exercise 1.3"></a>Exercise 1.3</h3><h4 id="start函数的设置"><a href="#start函数的设置" class="headerlink" title="_start函数的设置"></a><code>_start</code>函数的设置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">EXPORT(_start)</span><br><span class="line">.set at</span><br><span class="line">.set reorder</span><br><span class="line">/* disable interrupts */</span><br><span class="line">mtc0    zero, CP0_STATUS</span><br><span class="line">/* hint: you can reference the memory layout in include/mmu.h */</span><br><span class="line">/* set up the kernel stack */</span><br><span class="line">/* Exercise 1.3: Your code here. (1/2) */</span><br><span class="line">li sp, 0x80400000</span><br><span class="line">/* jump to mips_init */</span><br><span class="line">/* Exercise 1.3: Your code here. (2/2) */</span><br><span class="line">jal mips_init</span><br></pre></td></tr></table></figure><p>在<code>mmu.h</code>文件中我们可以查询到系统内核各部分内存分配情况，这里就能找到栈顶地址为<code>0x80400000</code></p><p>设置结束后汇编程序完成，就可以跳转入C语言的函数入口<code>mips_init</code>了</p><blockquote><p>我们使用<code>jal</code>、<code>j</code>指令进行函数的跳转。在不同文件链接时，链接器回对目标文件中的符号（包括函数名）进行重定位，修改跳向这些函数的地址，实现跨文件的函数调用</p></blockquote><h4 id="printk函数的实现"><a href="#printk函数的实现" class="headerlink" title="printk函数的实现"></a><code>printk</code>函数的实现</h4><p><code>printk</code>函数实现功能，底层上依靠的是<code>console.c</code>文件中<code>printcharc</code>函数对控制台进行字符的输出；</p><p>向上一层，<code>print.c</code>中的<code>vprintfmt</code>函数则通过<strong>格式化字符</strong>的形式对<code>console.c</code>中的函数进行合理调用，实现输出；</p><p>再向上一层，就是<code>printk.c</code>这个文件，它接收输出参数，并把<strong>变长参数表</strong>和传递给<code>vprintfmt</code>函数，最终实现字符的输出。</p><h5 id="变长参数表"><a href="#变长参数表" class="headerlink" title="变长参数表"></a>变长参数表</h5><blockquote><p><code>stdarg.h</code>头文件对变长参数表定义了一系列宏变量与变量类型：</p></blockquote><ul><li>  <code>va_list</code>：变长参数表对应的变量类型</li><li>  <code>va_start(va_list ap, lastarg)</code>：初始化变长参数表</li><li>  <code>va_arg(ca_list ap, 类型)</code>：去除变长参数表的下一个参数</li><li>  <code>va_end(va_list ap)</code>：结束变长参数表的使用</li></ul><p>声明方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;<span class="comment">// 声明变长参数表</span></span><br><span class="line">va_start(ap, lastarg);<span class="comment">// 初始化参数表</span></span><br><span class="line"><span class="type">int</span> var = va_arg(ap, <span class="type">int</span>);<span class="comment">// 取出一个int类型的变量</span></span><br><span class="line">...</span><br><span class="line">va_end(ap);<span class="comment">// 结束当前的变长参数表</span></span><br></pre></td></tr></table></figure><p>回到我们的<code>printk</code>函数：<code>printk</code>本身接受了外部传入的不定长参数，创建了一个变长参数表，传入了<code>vprintfmt</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printcharc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        *((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outputk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputk</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="comment">// buf：输出的字符串指针；len：输出的字符长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                printcharc(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vprintfmt</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// 此处传入的out，实际上是outputk的函数指针，内部实际上在调用outputk函数进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line"><span class="comment">// fmt：传递的主字符串指针</span></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        vprintfmt(outputk, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自顶向下地：</span></span><br><span class="line"><span class="comment">// printk函数创建变长参数表，调用vprintfmt</span></span><br><span class="line"><span class="comment">// vprintfmt格式化参数表，调用outputk；</span></span><br><span class="line"><span class="comment">// outputk接收数据直接调用printcharc，实现功能</span></span><br></pre></td></tr></table></figure><p>具体实现不再说明</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><ol><li> 第一次完成<code>lab1</code>内容时还不能理解内核为什么能正常工作、函数为何能正常运行，只是按照指导书的说明进行补充而已。而恰是这个不理解，成了实验过程中的最大难题。只有完成内容后，再重新回过头来审视每一步，才能知道每一步的具体功效，明白实验过程中“那里”为什么要“那么做”。经常性的回顾对实验过程理解很有必要。</li><li> 完成实验过程中并没有查看除了需要填写代码文件以外的文件，然而，各个函数的实现过程与相关信息其实都藏在课程组为我们写好的其他文件中，读过一遍其他函数的定义、调用与功能，才让实验过程中填写的代码有理可据。</li></ol><p>align=”center/“</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 3</title>
      <link href="/2023/03/response-paper-for-positive-psychology-lecture-3/"/>
      <url>/2023/03/response-paper-for-positive-psychology-lecture-3/</url>
      
        <content type="html"><![CDATA[<p>“Marva Collins comes along and reframes the question. And her question becomes ‘how can we cultivate the seed of greatness in our students.” (0:04:52)</p><p>If a student has depression or other mental illness, we can’t just tell him that depression is wrong, you can’t do that. This method of correcting errors from the negative side cannot always be used. Instead, like the teacher, tell him what is right and what is beautiful and shining in life. In this way, students can understand the beauty of themselves and the world from a positive perspective, and can really help them out of difficulties.</p><p>“Happiness does not just come spontaneously when we negate unhappiness.” (0:25:34)</p><p>This sentence is very reasonable. From my perspective, life is like a ruler with scale. It is not enough to just go back to the origin from the negative half. To get real happiness, we must make changes and move forward to the positive side. These methods of change are what we really need in life. I think it is also very useful  to call on universities to teach these courses to discover the shining points of people, which was just like the author said.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 4</title>
      <link href="/2023/03/response-paper-for-positive-psychology-lecture-4/"/>
      <url>/2023/03/response-paper-for-positive-psychology-lecture-4/</url>
      
        <content type="html"><![CDATA[<p>“The problem is not lower these high expectations—that doesn’t matter. The problem is right versus wrong expectations. Not high or low, that won’t make a difference to our level of wellbeing. It is if we have right vs. wrong expectations.   </p><p>Hoping for changes created by one or two things happen in life probably cannot make us happier. The right expectation is to believe in change from within. Sometimes there is a huge barrier between the actual gain from one thing and our mental expectation. It’s the wrong expectation that make our mood upside down. However, the changes made by yourself when you absorbing the environment could help you last the sense of fulfilling. And it’s a critical way to bring happy from the outer life.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Record()</title>
      <link href="/2023/03/record/"/>
      <url>/2023/03/record/</url>
      
        <content type="html"><![CDATA[<p>23/03/09<br>网站正式启动，不过还只能通过IP访问。挂载了Sakurairo主题，也试着把两篇文章从公众号里搬了过来。不得不说wordpress这个写作后台还是不太适应</p><p>23/03/10 update<br>上军理课的时候接到邮件说，域名模板审批下来了，我直接放下手里的java开始搞解析。现在终于可以通过<a href="http://cookedbear.top/">cookedbear.top</a>访问啦！配置好之后也把站点里的分类随便写了写</p><p>23/03/11 update<br>今天申请了免费的SSL证书，现在访问支持https了，Chrome终于不再提示我“不安全”力！<br>之后可能会改改CDN给图片加个速之类的。还有个问题就是，首页这个图只要还在浏览器可见范围内，就会疯狂掉帧（</p><p>23/03/15 update<br>甲了，暂缓相关更新<br>同时发现评论的时区也得调一下</p><p>23/03/17 update<br>好点了，爬回来改网站，改了评论的时区了（大概），同时优化了一下缓存机制<br>红烧天堂真好玩（bushi</p><p>23/03/20 update<br>甲流那劲差不多过去了，还是有点咳嗽等等症状，问题不大了，等过十天半个月的冯如杯过去，就可以大张旗鼓回来写文了<br>lab1上机发现课下大锅，幸亏de出来了（）</p><p>23/03/26 update<br>学习暂告一段落，回来把主题改成了Sakura，至少现在自己电脑跑起来不会卡顿了。调了一下图床，给Gravatar改了一个代理，顺便在页首加了一个最后一次更新时间的显示。但是发布时间还是会显示8小时前，头大.jpg</p><p>23/04/14 update<br>发布时间和更新时间现在都能正常显示了， TOC 换了一个更好用的插件，基本上算成型了吧，有时间加一个分类页</p><p>23/04/16 update<br>前天加的灯箱插件寄了，点开一次灯箱之后图片就丢了，属实是逆天，回头再禁用掉吧。</p><p>23/05/05 update<br>在考虑需不需要转成 hexo 建站，wordpress 的写作风格有点难受，后台和主题也不太好管理。hexo 体验了一下感觉特点就是轻量化，如果不加入新功能的话，静态站点应该是够用了。择日再议。</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 5</title>
      <link href="/2023/03/positive-psychology-5/"/>
      <url>/2023/03/positive-psychology-5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Just take some notes down. I didn’t follow the video all the time.</p></blockquote><p>The video first stated the question about the importance of happiness. Not only happiness can make us feel good, it can also contribute to our life, relationships, and other people.</p><p>Barbara Fredrickson says is that positive emotion has a revolutionary reason, beyond making us feel good.(0:26:35) Enjoying the happiness is quite excellent experience. When I was suffering from some bad messages, trying to find some joy, and happiness can pull me out of there for a while indeed. It’s useful to help us overcome the negative emotions(just work as positive side).</p><p>Positive emotions broad and build, which can lead to more positive emotions. Then the positive emotions continue to broad and build. So they function as a virtuous cycle, which is completely contrast to the situation negative emotions do. Hopefully, if we are, unfortunately, trapped in the cycle created by the bad emotions, just think about the happiness things, which can help us get out of the narrow and constrict to the broad and build.</p><p>Being put into a positive mood is a win-win situation, for who experiences it and who give. Feeling positive can surely give us more motivation and energy to work further.</p><hr><p>The NO.1 causes of unhappiness is “equating to selfishness and immorality”, because people feel guilty for their own happiness. I think it’s quite suitable for me. When I gain something brilliant every time, I would think about the people around me. Is it <strong>fair</strong> for them? Can I take the joy just for myself? However the lecture told me that gain happiness for your self is a contribution indirect to other people’s happiness.</p><blockquote><p>Be the change you want to see in the world.</p></blockquote><p>People do what you do, more than what you say. The professor showed us that by a little experiment: ask students to put your hand on their cheek, while put his own hand on the chin. Amusingly, many students put their hands on their chin, including me. Cause I didn’t hear the actual word “chin” (lol). So quite right, the professor then add that, the optimal way spreading happiness is to work on your own happiness. Looking at your happiness, the people around you would surely influenced by your actions, cuz you are leading examples.</p><h2 id="Beliefs-as-Self-fulfilling-Prophecies"><a href="#Beliefs-as-Self-fulfilling-Prophecies" class="headerlink" title="Beliefs as Self-fulfilling Prophecies"></a>Beliefs as Self-fulfilling Prophecies</h2><p>Beliefs are self-fulfilling prophecies. Some time, subconsciousness stops us from moving forward. The barriers are not made by physical, medical, but mental.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延绵不绝的纯粹爱恋——观《相逢于明月映照的彼方》</title>
      <link href="/2023/03/rainbow-of-kanata/"/>
      <url>/2023/03/rainbow-of-kanata/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2697字</p><p>预计阅读时间：7分钟</p></blockquote><p>各位好，这次带来的是关于上次提到的补坑作品<strong>《相逢于明月映照的彼方》</strong>（偷懒下面就叫月彼了）的一些想法，作为tone work’s的第四作，游戏的整体内容配得上终极纯爱战士tone的一贯作风了（雨音线糖度拉满）；个人线路也各有千秋，但灯华线的表现实在让人……不好接受。在此处不做展开，来看下文罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-1.png"></p><h2 id="Part-1-tone-work’s"><a href="#Part-1-tone-work’s" class="headerlink" title="Part 1 tone work’s"></a><strong>Part 1 tone work’s</strong></h2><p>先来介绍一下tone work’s（tone社）吧 到现在为止tone社总共有4部作品：《初恋1/1》、《星织梦未来》、《银色遥远》还有这次提到的月彼。个人感觉tone的原画、音乐和系统演出基本无可挑剔，半清新画风的background图也称得上是壁纸级别了，不过你社真的缺一个把剧本写好的写手哇。总的来说，已经完成的后三部作品都属于高质量作，均可放心食用（1/1我没玩过就尴尬了）。话说回来，每次打开tone社的游戏，听到欢迎界面的7个单音（欢迎音）都感觉很安心，就和即将要玩的作品一样。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-2.png"></p><p>tone社社标</p><p>好闲话少说进入下一部分（</p><h2 id="Part-2-剧情介绍"><a href="#Part-2-剧情介绍" class="headerlink" title="Part 2 剧情介绍"></a><strong>Part 2 剧情介绍</strong></h2><p>如果，未来与过去被手机连接</p><p>你有什么后悔的事情选择重来？</p><p>高二那年的暑假</p><p>她们比谁都反复无常，比谁都不可捉摸</p><p>而且比谁，都楚楚动人。</p><p>第一次的恋爱。酸甜的回忆。</p><p>依依不舍，那是夏季的日子。</p><p>25岁的夏天</p><p>突然发现自己变成了上班族。</p><p>一边仰望天空，一边回想起梦一般的日子。</p><p>就像怀旧一般，把学生时代没用过的</p><p>智能手机启动了。启动短信应用程序后，</p><p>给自己发送短信。</p><p>后悔了吧</p><p>致过去的自己，无法传达的想法。</p><p>然而，智能手机振动了。</p><p>突如其来的事情</p><p>那是过去自己发来的邮件……</p><p>——来自萌娘百科相关页面</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-3.png"></p><p>游戏海报</p><p>不同于前几作的单纯学园纯爱作品，这次tone社加入了超自然因素（啊对就是你灯华手里拿着的恩底弥翁）以及数量众多的个人线，海报里出现的女主角都是有个人线的（右侧三位是在after篇社畜生活后开放的路线），所以游戏的体量也不小（但好像比银遥体积小不少欸）。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-4.png"></p><p>左起：新谷灯华、日紫喜うぐいす、佐仓雨音、<br>仓桥圣衣良、岬栞菜、松宫雾子、月ヶ洞きらり</p><p>作为社畜后选择的三人组路线和圣衣良线并没有对手机有过多的涉及，和核心故事的关联也不密切，这里就不再着笔叙述了（绝对不是因为二刷的时候没玩然后已经忘了内容了）关于游戏的配乐我就不多说什么了直接上图吧（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-5.png"></p><p>喵？</p><p>游戏的系统制作也很精良，动态效果等等都十分顺滑，顺带一提，第一次看到过场动画都这么艺术的我实在是叹为观止  </p><h2 id="Part-3-人物线浅析"><a href="#Part-3-人物线浅析" class="headerlink" title="Part 3 人物线浅析"></a><strong>Part 3 人物线浅析</strong></h2><h3 id="Rein-Side"><a href="#Rein-Side" class="headerlink" title="Rein Side"></a><strong>Rein Side</strong></h3><p>先看雨音线吧，作为官方认定的亲女儿，雨音在游戏发售的不久就增加了个人FanDisk（Sweet Summer Rainbow），全程发糖，糖度过高（大喜），在游戏本体的表现也算不错，虽然没有FD里的心态变化那么丰满自然，但是本体好好地承担了推进核心剧情的任务，没有把游戏玩成谜语真是太好了（</p><p>无论是恩底弥翁的本意，还是Rainbow与Kanata这样文字的小小解密；是雨音与父母短暂地相见，抑或是接受现状后的继续前行，都把游戏想传达出的点给到了。虽然说部分玩家评论雨音这个角色媚宅元素浓，但我在这一点保留一个中立态度，正因为是游戏，所以保有一些幻想的观点我认为无可厚非；削减糖度柔化人设让剧情故事更加平衡这种想法我更是表示欢迎。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-6.png"></p><p>但无论如何，感动永远是雨音线中不可或缺的重要组成部分，过多的不再言及，请诸位自行品味罢，如果想要深入了解雨音这个人设定位的话，强烈建议再补一下FD，失去了高度集中主线的约束，雨音的心理成长算是成为了其中聚焦的重点，嘛，反正不玩也不会怎样就是了。   </p><h3 id="U-guisu-Side"><a href="#U-guisu-Side" class="headerlink" title="_U_guisu Side"></a>_U_guisu Side</h3><p>学姐线走的是一种扑面而来的文艺风，始终是一首不浓不烈的爱情诗，没有一种喧宾夺主的色彩，通线的时候就很舒服，我也很喜欢学姐线的主题曲《月之钟》</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-7.png"></p><p>（每当钟声响起的时候/我想起的 是二人如诗般的过往）<br>哇我真的爱死这句</p><p>两人第一次在湖心岛许下诺言时确实心旷神怡。虽然这部作品刻画的学姐形象不很戳我，但是这种青涩、文艺、甚至可以称作优雅的恋爱经历却是令我向往的。本篇写下的是学姐虽然患病不久于人世但仍旧选择与奏汰共度剩余的时光。</p><p>但after篇接续的却是学姐的绝症可以治疗，但学姐已经因为自己患病离去的消息，意识到这一点的奏汰充满了痛苦与自我厌恶，但多亏恩底弥翁给了他重新选择的机会——让学姐前往国外医治疾病，重写这段历史，也因此他不得不对过去的自己出违心的主意，为的就是让莺学姐远离自己出国医治，而自己独自承受着内心的愧疚和来自过去的自己的埋怨。所幸在故事的最后满月之时，修正过的历史同步，两人重新在月之钟下约定诺言，故事驶向终章。 </p><h3 id="Duca-Side"><a href="#Duca-Side" class="headerlink" title="Duca Side"></a>Duca Side</h3><p>灯华在海报里这C位可不是白占的，本篇的表现确实不错，留下的观感很好，第一次推的时候还留了一个挺好的印象，结果进了after篇就开始拉大胯，剧本直接放弃了在成年后的时间线中推动剧情，索性让成年奏汰借助手机跨越时空起了一个远程军师的作用，但归根到底还是高中那点事，更类似于一种if线的展开，而且剧情衔接上总感觉莫名其妙，说不出的怪异点，怎么看怎么不舒服。如果只看本篇，甚至灯华的消失我都可以当成结局，但是这after的下饭操作我是真不太懂。</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>游戏的缺点不多但也明显，有一部分对手机必要的解释被放置在了雨音线里，如果没有先通雨音线的话在其他路线中感觉起来会有些牵强，以及灯华线这莫名其妙的塞粪感emmm ，其他方面都可圈可点，仍值得一试。  </p><p>其中特别要说的就是tone社特有的分段式恋爱了，不同于窗社等同样注重校园恋爱的会社，tone更倾向于抓住“生活”，没有用一句话勾勒几年，也不会对一个节点过度过度地抒写，这样的优点就让tone社作品地节奏很舒服，并没有赶着人往前走的急迫感，也能切实地感受到情感的变化、剧情的推进等。</p><p>但相对而言，这类“陪伴”型作品的剧本通常要长上不少，有时生活琐事都会成为游玩时的一大感触，可以说，有着这类特征的作品更像是散文诗篇，不进行浓墨重彩的挥洒，而是把情感放在平时不断地氤氲。个人认为这类用文本量换节奏的交换算是值得的，也正是如此，tone社的作品才会有这种悠长的回味，有更深的共感和感动罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-8.png"></p><blockquote><p>长久的陪伴，</p><p>才是这世上最深情的告白  </p></blockquote><p>谢谢谢谢你看到这里，因为咱小订阅号嘛看的人也不多，资源就送给关注我的大家啦 后台回复<strong>月彼</strong>或者<strong>相逢于明月映照的彼方</strong>就可以取本体和FD的链接了顺带一提里面攻略都做（翻译）好了，不给个赞鼓励鼓励？（逃）</p><p>再次感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天你学数分了吗？（1）</title>
      <link href="/2023/03/engineering-mathematical-analysis/"/>
      <url>/2023/03/engineering-mathematical-analysis/</url>
      
        <content type="html"><![CDATA[<p>近日来数分课程学习了数项级数（11章）和函数项级数（12章），倍感学习之苦（逃），所以就花了些功夫整理了下基础的笔记和定理之类的，当作个备忘录，也拿出来和大家分享分享，和同志们一起进步。其实11章算是为12章做下铺垫把，其中的重难点并不多，大部分是延续上学期末尾讲述的无穷积分部分，两者有相似之处。而12章的函数项级数相当于给数项级数多加了一个自由变化的未知量，虽然前面的题目也出现过类似的情况，不过当时是把它当作恒定不变的参数，而这里则成了探讨的一大重点。<br>类似的，12.4的幂函数内容也是对前面内容的一个拓延，把泰勒展开的完全形式搬了出来，让整个体系更加的完整。（也给我整不会了）</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/5.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/6.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/7.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/8.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/9.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/10.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/1.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/2.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/3.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Fundamental </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Fundamental </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于悲剧之下抗争，于星光之下颂歌——浅谈《水葬银货的Istria》</title>
      <link href="/2023/03/suisoginka-no-istria/"/>
      <url>/2023/03/suisoginka-no-istria/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共4099字</p><p>预计阅读时间：17分钟</p></blockquote><p><strong>『抛弃某人获得的未来，在我眼里已经失去了幸福的色彩』</strong></p><p>朋友们你们好啊，这是第二篇杂谈，今日也请多多指教。 </p><p>请注意：本文谈及的游戏包含少部分心理崩坏、监禁、血腥、欺诈等悲剧色彩的消极内容，同时也用那些不幸来衬托了真实与美好，在写作时我也尽量减少消极方面的涉及，如果您在我分享完杂谈过后对它还有兴趣的话，请来文末寻找回复词去体验，之后的分享估计也会提供相应资源吧（不咕的话）。</p><h2 id="Part-0-序言"><a href="#Part-0-序言" class="headerlink" title="Part 0 序言"></a><strong>Part 0 序言</strong></h2><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-9.png"></p><p>今天我们来谈谈发生在ルクル笔下架空世界的故事吧——那是一个关于眼泪、牺牲与恶意的故事、一部裹挟着英雄星光与向恶意反抗的<strong>正剧——《水葬银货的Istria》</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-10.png"></p><p>起初见到这部作品的时候，我并没有意识到它的杀伤力（哎你看回想里总共20个Hcg你告诉我这怎么输，怎么输啊哈哈哈哈哈），然后Episode1还没结束我就放弃了那个愚蠢的想法，至少没法笑着推进剩余的剧情了。 </p><p>为什么？ </p><p>因为这个故事的起源本就是一场悲剧，孕育自悲剧的故事自然难有完美的结局啊kora（无emo意，这里代指游戏）。</p><h2 id="Part-1-相关信息"><a href="#Part-1-相关信息" class="headerlink" title="Part 1 相关信息"></a><strong>Part 1 相关信息</strong></h2><p><strong>日文名称</strong>：水葬銀貨のイストリア</p><p><strong>品牌</strong>：ウグイスカグラ</p><p><strong>剧本</strong>： ルクル</p><p><strong>又名</strong>：水葬银货、水葬银币的Istoria </p><h3 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h3><p>水上都城 · アメマドイ。<br>这座建于海上的人工岛是秀丽多姿的花锦之地。<br>住在此处的我们——身负着种种烦恼。礼仪端正、心地善良的青梅竹马、煤谷小夜。<br>异想天开的妹妹、茅崎 夕桜。<br>憧憬英雄的后辈、小不動ゆるぎ。<br>卡在小巷里的垃圾箱之中的、汐入玖々里。<br>还有本人、茅崎英士。<br>一连串的阴谋、事件在等待着心灵受创的我们。<br>时而赌上部室来玩神经衰落（卡牌游戏）。<br>又或与被抛弃的少女一起玩抽鬼牌。<br>在倾心于夜空中绽放的礼花时、又不禁想要填补残缺的空洞。<br>以自己的做法、为成事而努力拼搏。<br>这样的我、若能帮到谁的话——<br>「——向你约定、幸福的结局」<br>愿所有人都能露出笑容。<br>在这遗失了泪水的都市里、我们的成长物语拉开了帷幕——</p><p>（以上内容摘自网站2dfan<strong>）</strong> </p><h3 id="人物出场表"><a href="#人物出场表" class="headerlink" title="人物出场表"></a>人物出场表</h3><p>茅崎英士：男主，背负着事实的真相和许多重担，想要保护身边的一切。</p><p>汐入玖玖里：英士在垃圾桶中捡到的少女。</p><p>煤谷小夜：英士的青梅竹马，总是叫英士“哥哥”，有很强的依恋感。</p><p>茅崎夕樱：英士的一抹多，性格古怪离奇。</p><p>小不动摇：后辈学妹，正义感十足。  </p><p>井土谷祈吏：小夜的幼年玩伴、青梅竹马。</p><p>C·A：杀死小夜父亲的凶手（实为茅崎英士）。</p><p>八椚红叶：C·A的主人。</p><p>神峰灯：红叶的手下，C·A的同伙，英士的朋友。</p><p>久末紫子：久末家（最大势力）的现任当家，红叶的对手。</p><p>久末紫乃：紫子的妹妹，第三代人鱼姬。</p><p>茅崎征士：英士、夕樱的父亲，老坏蛋了（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-11.png"></p><p>茅崎英士</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-12.png"></p><p>汐入玖玖里</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-13.png"></p><p>煤谷小夜</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-14.png"></p><p>茅崎夕樱</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-15.png"></p><p>小不动摇</p><p>主线故事建立在一个架空的<strong>人鱼公主童话</strong>的基础上：很久以前，有一名无私为他人奉献的少女，她的泪水能够治愈一切伤病。她不断地为他人的幸福流泪，村民们也非常感激她，大家过着安定而平和的生活。</p><p>然而某日，少女意识到自己的泪水将折损寿命，于是便不再为村民流泪。贪婪的村民们对此毫不在意，仍然强迫少女为自己流泪，柔弱的少女只能在悲伤中不断消耗着所剩无几的生命，渐渐滋生了怨恨。最终，少女的生命走到尽头，化作泡沫回归大海。</p><p>临终前，她含恨诅咒这些没有血与泪的村民们永远无法流泪，而这竟成为了现实。惊慌失措的村民们为了赎罪，求得这位人鱼公主的原谅，将她生前最喜欢的苹果投入大海。</p><p>然而少女的怨恨并未因此消除，村民们世世代代失去了流泪的能力，无论遭到怎样的痛苦与悲伤，都无法流出一滴眼泪。</p><p><strong>Amemadoi</strong>，就是一座如此诅咒缠身的小岛。人人都向往其上久末医院传说中能够瞬间治疗任何创伤的魔术，可却不知道这辉煌的魔术是用一代代人鱼姬的性命与泪水堆砌而来的。而人鱼公主又难以寻觅，但当一个人心中充斥的只是为他人奉献的情感时，或许会有奇迹发生（？）。巧合的是，故事中的主人公或多或少都与人鱼姬有着不可割舍的联系。</p><p><strong>『鸟笼事件』</strong>，岛上的居民这样称呼它，那个彻底改变两个少女和一个少年命运的悲剧事件：</p><p>茅崎征士绑架了三人并实施了非法监禁，而且还施加了精神上的折磨。茅崎夕樱不再表露真实的情感，煤谷小夜成了没有“哥哥”就活不下去的依恋症患者，而英士不得不背负痛苦与真相前进。 </p><p>过多剧情不再在此讲述，文章已经很拖沓了（）顺带一提一个小点：赌场的Ace公子哥C·A，正是茅崎英士的日语发音的前两个音节（Chigasaki Eishi），背负着这样罪名前行的他，实在是可笑啊。</p><h2 id="Part-2-不足在何"><a href="#Part-2-不足在何" class="headerlink" title="Part 2 不足在何"></a><strong>Part 2 不足在何</strong></h2><p>先来说说差的地方吧：水葬银货中的败笔当为个人线的塑造。说实话，太不走心了：没有铺垫的冲突像是生硬补充出来的；离谱的剧情好像故意为了r18场景和选择个人线而准备，甚至。。。小不动摇这条线甚至还没让人回过味来，就在『我们舍弃了一切，自私地获得幸福』『爱之花，肆意怒放』这样自甘堕落的话语中落幕。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-16.png"></p><p>等会等会，请允许我来个问号❓</p><p>共通章中向往正义的小不动摇怎么最后反而选了最自私的一种ending方式？这不白塑造形象了？亏我还对这个阳光学妹有所好感（） </p><h2 id="Part-3-扑克与选择"><a href="#Part-3-扑克与选择" class="headerlink" title="Part 3 扑克与选择"></a><strong>Part 3 扑克与选择</strong></h2><p>主人公英士自小就用扑克战斗，所以选择肢的外观也像扑克一样，而这内容嘛。。。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-17.png"></p><p>这，这tm是人能想出来的阴间说法？不是说你打算拯救谁，那种成为英雄但整个故事差一点点圆满、只能保护一个人的遗憾；</p><p>而是说你打算抛弃谁，“见死不救”，把加害者的名头安在英士头上，让他永远无法逃离这个痛苦的选择。</p><p>真不愧是极恶啊，把绝望如此肆意播撒，确实符合痛苦这个关键词了。</p><p>而『都不抛弃』，却是直指TrueEnding的一个选择，很简单啊，选择其中的任何一方都代表着妥协，放弃了赢下去的希望。红叶也都会对英士表示“放弃你”的态度。</p><p>都不放弃，虽然意味着结局未知，但这种前路飘渺的感觉才给人以动力。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-18.png"></p><p>——在通往成功的赌桌前，最终的选项如上</p><p>是一鼓作气，选择Call（跟注）迎来逆转；还是冷静处事，选择Fold（弃牌）明哲保身呢？</p><p>『无论如何都不能放弃，开阔视野，保持冷静』</p><p>这是宗名教给他的原则，</p><blockquote><p>我不能放弃——所以『都不抛弃』</p><p>保持冷静——所以『Fold』</p></blockquote><p>正是在这种选择过后，英士才能以自己的真面目回应小夜，继续前行。</p><h2 id="Part-4-品鉴"><a href="#Part-4-品鉴" class="headerlink" title="Part 4 品鉴"></a><strong>Part 4 品鉴</strong></h2><p>啊终于来到了我最喜欢的音乐鉴赏环节</p><p>这次的配乐我久违的想打出满分，虽然所有的24首乐曲没有一首铿锵有力能够鼓舞人，但是大部分曲子也能在柔和的曲风中给人以力量。。。令人敬佩呐。</p><p>尤其是OP《アズライトの棺》，悲伤而悠扬的女高音孤独的歌颂着人鱼公主的故事，即使沉入海底，也会有人来将你守护。再配上MV的视觉效果，耀眼流转的微小光束与大体深蓝的背景色相互映衬，可以说是一种微弱的壮观吧。</p><p>而去除人声的Inst Ver更利用弦乐营造了更加深邃的意境，高低声部的糅合流畅而自然，连升近一个八度的副歌把前一秒的悲伤倏地放大，仿佛自己也沉没海底、想要挣扎。</p><p>综上，建议欣赏MV！（<strong>底端阅读原文一键享受！！</strong>）</p><p>啊什么你说CG？啊说实话有部分CG实在是比例崩坏严重，这边不放了，影响观感（） </p><h3 id="有关故事核心的一些想法"><a href="#有关故事核心的一些想法" class="headerlink" title="有关故事核心的一些想法"></a><strong>有关故事核心的一些想法</strong></h3><p>人鱼姬为什么能够流泪？是因为内心深处的悲伤？或是因为难以忍受的苦痛？我想，眼泪在Istria中象征的大概是一种无私，一种甘愿奉献的精神吧。</p><p><strong>玖玖里</strong>虽然遭受了姐姐的折磨，但她在姐姐生命危急时刻依旧想要救她，所以她成为了人鱼姬；</p><p><strong>夕樱</strong>和英士一同遭受了鸟笼事件，她可以为自己的哥哥奉献自己的一切，但相对的，她无法对其他人流泪，因为她并不能对所有人温柔；</p><p><strong>久末紫乃</strong>是故事中难得的、纯粹的善，相信着向阳的正义，即使化为泡沫死去也没有怨言；</p><p><strong>紫子</strong>既接受了紫乃的善意，也经历了久末家、茅崎征士的恶意，她在善与恶的夹缝之中走向了自我，但又难逃其重。</p><p><strong>茅崎英士</strong>的本质是温柔的，这毫无异议，但在鸟笼事件之后这份温柔则被恶意扭曲，成了无法宽容自己的枷锁，也成了他逃避和选择的借口。</p><p>所幸，故事最终迎来结局，他也能安心的放下虚伪的面具，让满是苦楚的温柔氤氲临终的紫子，了却掉她一桩心愿了啊。<br>鸟笼事件的受害者、加害者的家属、小夜的弑父凶手、紫子和红叶的C·A、夕樱和小夜的哥哥、摇的可靠前辈、祈使无法原谅的仇人——</p><p>难以想象吧，这些名号都是那个少年——茅崎英士肩上所背负的，他无法摆脱，更无法逃离；他一次次地被打倒，又一次次狼狈起身；他渴望反击，却又如此弱小。我相信结局的那一刻是他的经历和为他付出过的人鱼公主们的眼泪，真正的给了他勇气吧——那可贵的、抗争到底的勇气。  </p><blockquote><p>『当弱者怀抱正义，便可称之为英雄；当英雄开始抗争，他便开始闪耀光芒。』</p></blockquote><p>抗争作为本作的主旋律，从未停止过高鸣。抗争不是做做样子的口头抗议，而是要勇敢地选择艰辛的道路。仅仅是在抉择面前徘徊后选择放弃的行为是不足以称为抗争的，<strong>真正的抗争是在绝望的深渊中重新挺身，再次踏向失败与悲伤的漩涡。</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-19.png"></p><p>英士无法放弃，但他选择了<strong>放下</strong>；英士无法成为光鲜的英雄，但他依旧<strong>像英雄一般战斗</strong>；英士身上的身份是那么沉重，但他<strong>决意抗争</strong>，选择了走下去。 面对渺小的希望，他没有放弃，在胜负难料的赌桌上搏来了胜利。 </p><h2 id="Part-5-尾声"><a href="#Part-5-尾声" class="headerlink" title="Part 5 尾声"></a><strong>Part 5 尾声</strong></h2><p>虽然水葬银货TE走到最后一幕令人痛苦，但也处在能够接受的范畴之内，不过最后一幕我还是有所失望。并没有皆大欢喜的完美团圆结局，而是采用了英士与红叶继续周旋下去的留白作为结尾，这种结局也许难以让人——至少不能让我满意。很浅显，万物的团圆固然飘渺，但是在苦难的最后，迎接我们的还是苦难吗，最好不是，我相信这也不是水葬这部作品想要传达给我们的。 </p><p>生活不易，但我们仍要一步步向前走去，尽管我们是弱者，也要心怀正义，去做某人的英雄——即使英雄不过是个自我安慰的梦，我们还是要为某人，为那些为我们牺牲过的人们成为英雄，这便是在绝境中重新奋起的勇气。</p><p> 最后的最后，分享游戏OP的一段歌词吧：  </p><p>蒼く深い海の底から</p><p>从苍蓝幽深的海底</p><p>君を連れ出して　光を求める</p><p>将你救出  追寻着光芒</p><p>もう二度と離れてしまわぬように</p><p>为了不让你再次与我分离</p><p>この手伸ばして　護り続ける</p><p>我将伸出这只手  持续着守护</p><p>暗く冷たい海の底へと</p><p>逐渐沉入昏暗冰冷的海底</p><p>光を求めながら　泡となって消える</p><p>一边追寻着光芒  一边化为泡沫消失</p><p>辛辛苦苦写了这么多，求赞求关注求在看捏–后台发送 水葬银货 资源自提捏（</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那是将我们三色交织在一起的绘卷——聊聊《三色绘恋》</title>
      <link href="/2023/03/tricolour-lovestory/"/>
      <url>/2023/03/tricolour-lovestory/</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2797字</p><p>预计阅读时间：12分钟</p></blockquote><h2 id="Part-1-序言"><a href="#Part-1-序言" class="headerlink" title="Part 1 序言"></a><strong>Part 1 序言</strong></h2><p>第一次写杂谈，各种想法肯定不够成熟，还请见谅。<br>第一篇，我们来谈谈国Gal<strong>《三色绘恋》</strong>(Tricolour Lovestory)。游戏发行于STEAM，以其超低的定价、庞大的文字量和CG数、刻画高中生活等等特点保有不错的口碑，前段时间公司也因为续集《三色绘恋S》因为版号问题被罚受玩家同情和支持。啊当然指的是在三色TrueEnd发行之前了。现在的情况确是一言难尽，我们之后再聊。</p><p>其实在推完序章之后就一直有为三色想写些什么的想法了，也许故事结构和剧本有不讨巧的地方，或许结局并不尽如人意，但它可以说是我玩过的最贴近日常生活的一款Galgame了。不同于美好的幻想故事、也不同于日G那活跃的校园生活，朋友、成绩、考试、升学，这些无趣的词充斥了我的高中生活，所以在玩到三色之后，便自然会有一种熟悉感和亲近感，就仿佛“啊，当时好像的确是这样过来的啊”，也会不自主地追忆一些东西吧。  </p><h2 id="Part-2-简介"><a href="#Part-2-简介" class="headerlink" title="Part 2 简介"></a><strong>Part 2 简介</strong></h2><p><strong>（可能没多少严重的剧透）</strong></p><p> 2005年，江城的暖秋。 童年有如被铁笼囚住一般，早已自觉为灰色浸染的男孩，第一次走进名为”艺术班”的教室之中。 </p><p>恰巧在同桌的位置上出现的，宛若冰山，却又似轻风薄雾的朝霞一般，紫水晶色的她…… </p><p>被”他们”焚毁象征着同那女孩回忆的画卷时，在炽热的火光下啜泣的，那一抹橘色的她…… </p><p>两个色彩截然不同的少女，同时伸出双手–相会、再会、交织、着色…… </p><p>是墨小菊十年的坚持为自己青涩的青春谱写的画卷， 还是文芷勾勒出梦中那被黑暗枷锁所束缚的世界。 </p><p>梦初醒已十年。 </p><p>三色，是梦中的绘恋。</p><p>故事发生在2005年的“江城武汉”（游戏开发山百合文化公司地址就在武汉，合理），游戏过程中也或多或少地体现了那个时代的小小标签。</p><p>从故事的第一幕开始算起，整个游戏剧情的时间轴（尾声就不计算在内了）总共覆盖了五个月，说长不长，说短也不算短。从盛夏到初冬、从重新和好到再度出发、从初次相识到决意前行，这三个人，这三抹颜色缓缓纠缠混杂，走向了两种截然不同的结局。</p><p>说邱诚“被灰色浸染”，是因为他的童年并不寻常，家长对他严加管教、大打出手，没有丝毫“自由”，但幸而他遇到了墨小菊，他童年里唯一的、不同于灰白的颜色，她一直温暖着他，帮助着他，默默地在后面支持着他，直到十年后，邱诚近乎毫无意义的“反抗”居然真的为他带来了意想不到的自由。不过换下这摇摇欲坠自由的代价，是他和墨小菊之间的关系。</p><p>在艺术班他遇到了“另一个她”，同为插班生，邱诚总是想要接近她，“保护”她，而文芷也承受不住那连绵不断从城墙外递来的善意，缓缓地降下了心防。“我们，真是一模一样呢”，是啊，都是一个人生活，都想寻求自由，都想回报温柔，他们看起来确实很像啊，不过，只是看起来而已吗。。。</p><h2 id="Part-3-浅析"><a href="#Part-3-浅析" class="headerlink" title="Part 3 浅析"></a><strong>Part 3 浅析</strong></h2><p>可以说，Ep0和Ep1的略显紧张的校园喜剧结束过后，邱诚的灰色便一直笼罩在我的心头，每一句台本下我都害怕会出现意料外的状况，这种微妙的平衡便会被一不留神地打破事实证明，也确实如此。</p><p>邱诚度过了一个扭曲的童年，所以他的很多观点和做法都被一并扭曲了；墨小菊伸出手去温柔地安慰他，所以他面对一切一切都想报以温柔。也正是这种扭曲了的温柔，把他们三人紧紧地束缚在这片灰暗的泥沼，难寻出路。</p><p>面对文芷，他仿佛看到了自己以前难获自由的影子，不断地想去帮助她、保护她，却总是忽视掉些什么，总是无功而返；面对墨小菊，他害怕自己的离开会伤害到她，所以他不断地隐瞒、不断地撒谎，播下一个谎言的种子，为的是阻止另一个谎言的破土而出。</p><p>但他没有想到，这所有的谎言都被墨小菊看在眼里；他更没有想到，这些谎言会在那一刻一齐盛开，把他和他的自以为是，统统绞杀在密不透风的“谎言之林”中。</p><p>“我没有一次怪过你，也没有一次觉得你有错，— —那为什么你就非得向我撒谎不可啊！”</p><p>之后的剧情我便不再多说，玩过的朋友可以回忆一下，没玩过的朋友，强烈建议你入一下，新年促只要5块啊，补库存都血赚的好吧（</p><hr><p>很明显，无论选谁，都是不可弥补的伤害，而且越是考虑到第三个人的心情，就越会把事情搞砸。“越是想完美的解决掉所有事情，越是连一件事情都做不好。”好友迟耀曾这么劝告，我深以为然。</p><p>后半程的游戏中，邱诚一直在做这样的工作，把一切抉择和责任都放在自己身上，两边都不想放手，自顾自地朝着自己心目中的方向前进，还会时不时地找借口安慰自己，可最终呢？只能让自己陷得越来越深，直到自己承受不住肩上的重量，才想要放下，但能和他并肩的人早已被他拖拽地伤痕累累，回天乏术。</p><p>因为我是菊党，所以我把墨小菊放在了最后，而过完文芷线后，我却愣是两天没敢动小菊线（刀麻了）。</p><h3 id="Violet-Side"><a href="#Violet-Side" class="headerlink" title="Violet Side"></a>Violet Side</h3><p>“人们总对触手可及的关怀置若罔闻，却好高骛远地追求海市蜃楼般的美好。”骆衍曾经这么说过。</p><p>也正是如此，相遇两个月的文芷教会了邱诚十年来相濡以沫的墨小菊都没办法教会的东西——爱。</p><p>虽然知道自己的父亲会影响他，但文芷还是没办法放弃邱诚的邀请，就算是在聚光灯下戴着镣铐起舞，就算是逃避过后如梦似幻的三天，也足以让文芷明白了邱诚和他的自由是多么的宝贵：“尝到这样甜头的她，还会愿意回去，回到那个冰冷的家吗？”所以他们没有过分停留，而是舔舐伤口过后一同径直走向了violet的终章。</p><h3 id="Orange-Side"><a href="#Orange-Side" class="headerlink" title="Orange Side"></a>Orange Side</h3><p>“墨小菊姐姐是大家的后盾，文芷姐姐带着大家一起往前走。”迟菓这样劝说文芷。</p><p>起初我不理解为什么在小菊线里依旧有这么多文芷的戏份，直到我再次读到这份剧情，邱诚和墨小菊两个人是不会前进的，只有文芷的加入，才让原本的两色转变为三色，未来更添变数。只有先解决文芷在邱诚心中迟迟纠结的问题，邱诚才能完全地接受墨小菊，不是因为青梅竹马，不是因为其他原因，而是对墨小菊十年的付出的响应，所以邱诚和墨小菊在心意相通后依旧优先解决的是文芷的考试，最终邱诚也狠下心来拒绝了文芷。也正是这些改变了文芷，让她反抗父亲“给我留下”的命令，明白了自己的追求、自己的自由。</p><p>“</p><p>先是试探，再是猜测。——最后庆幸不已，抑或大失所望。</p><p>我们如同植在裂纹的两端。随着地壳的迸裂，慢慢地越离越远。</p><p>尽力向彼此伸出的枝芽，慢慢地也因为不停地碰触，而磨损得圆滑而迟钝。</p><p>”</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>所幸，他们走了出来，从灰黑的泥沼中爬出，在千辛万苦确认到的信任中蹒跚向着Orange的终章。</p><p>这故事原本就不是对等的啊，哪会有完美的结局呢？那个说“我没关系的”女孩和那个说“我相信你”的女孩，她们又是怎么想的呢？对我来说，我想做的又是什么呢？回头望向那个等了你十年的女孩子吧，去感受她不离不弃的温柔触碰吧，去回应她十年来的妥协与支持吧，去让她变得幸福吧</p><p>毕竟，那可是黯淡无光的灰色和乐观活力的橙色交织的十年啊。</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab0-Report</title>
      <link href="/2023/03/buaa-os-2023-lab0-report/"/>
      <url>/2023/03/buaa-os-2023-lab0-report/</url>
      
        <content type="html"><![CDATA[<h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><p> </p><h2 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h2><blockquote><ul><li>  <code>git</code>中的<code>status</code>信息提示</li><li>  工作区、暂存区与文件树</li></ul></blockquote><p>首先使用<code>git checkout -b learnGit</code>，在本地创建并检出一个新的分支 然后再根据<code>Thinking</code>中给出的要求对<code>README.txt</code>文件进行一系列操作，并在操作后进行提交</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530699.png" alt="image-20230305153053676"></p><p>然后观察目录中的<code>Untracked.txt</code>、<code>Stage.txt</code>，其区别在于把<code>README.txt</code>移动到了暂存区，git显示的说明不同</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530519.png" alt="image-20230305152953421"></p><p>提交后再次修改文件，最终的<code>Modified.txt</code>内容如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051537728.png" alt="image-20230305153714706"></p><ul><li>  <code>add</code>前，<code>README.txt</code>文件不处于仓库跟踪范围内，在“未跟踪的文件：”分类中；<code>add</code>后被git追踪到修改记录，提示有修改、暂未提交</li></ul><p> </p><h2 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h2><blockquote><ul><li>  常见<code>git</code>指令：<code>add</code>、<code>commit</code></li></ul></blockquote><ul><li>  <code>add the file</code>：使git开始追踪某个文件，即<code>git add filename</code>指令</li><li>  <code>stage the file</code>：把修改过的文件加入暂存区，即<code>git add filename</code>指令</li><li>  <code>commit</code>：提交本次暂存区里保存的内容，回到初始状态，即<code>git commit</code>指令</li></ul><p> </p><h2 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h2><blockquote><ul><li>  使用<code>git rm</code>进行<strong>工作区</strong>文件删除</li><li>  <code>git checkout</code>使得<strong>暂存区</strong>文件回退至工作区</li><li>  使用<code>git checkout &lt;版本&gt; filename</code>进行其他版本的文件拉取</li></ul></blockquote><ol><li> 当本地文件被删除，但还没有提交时，可以使用<code>git checkout print.c</code>指令，把暂存区中的<code>print.c</code>文件拉到工作区</li><li> 执行<code>git rm print.c</code>后，不仅删除了工作区的文件，还把这次删除<code>add</code>到了暂存区，此时工作区和暂存区都不存在需要的文件了，可以使用<code>git restore --staged print.c</code>再把<code>print.c</code>的修改拉回工作区 （如果<code>commit</code>了还可以使用<code>git checkout HEAD^ &lt;filename&gt;</code>从上一个提交版本处把删除前的文件拉回本地）</li><li> 执行<code>git rm --cached &lt;filename&gt;</code>指令，可以只删去暂存区的文件内容，而不对本地的文件进行删除（与不加<code>--cached</code>对比）。可以使用这条指令，把文件从跟踪目录里移出</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051600387.png" alt="image-20230305160023353"></p><blockquote><p>进行实验时的部分操作</p></blockquote><p> </p><h2 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h2><blockquote><ul><li>使用<code>git reset --hard</code>进行git版本回退<ul><li>  可以回退<code>HEAD^^^^</code>或<code>HEAD~4</code>，也可以根据已知的<code>hash</code>值进行任意的跳转</li><li>  <code>--hard</code>会强制把工作目录中未提交的文件数据删除，<strong>并不做保留</strong>，使用前注意暂存区、工作区内容</li></ul></li><li>  <code>git log</code>信息与<code>git reset</code></li></ul></blockquote><ol><li> 先进行三次文件修改与<code>commit</code>操作：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051602484.png" alt="image-20230305160255454"></p><ol start="2"><li> 记录下的<code>git log</code>如下：提交3的hash值为<code>8974e1e6e98f726886103a13cba43fcd4fa08acf</code></li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051604438.png" alt="image-20230305160406404"></p><ol start="3"><li> 版本回退后查看log发现最近一次提交记录消失了：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051606728.png" alt="image-20230305160621703"></p><ol start="4"><li> 使用<code>git reset --hard &lt;hashcode&gt;</code>（hashcode填入提交“1”时的）回到了版本”1”；再把hashcode换成版本”3”的值，会切换回版本”3”</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051609979.png" alt="image-20230305160955957"></p><p> </p><h2 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h2><blockquote><ul><li>  重定向与管道</li></ul></blockquote><ol><li> 操作指令执行后显示如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051615424.png" alt="image-20230305161546400"></p><ol start="2"><li> <code>echo</code>指令向标准输出中输出后续内容，使用<code>&gt;</code>可把输出定向到符号后的文件（重写）；使用<code>&gt;&gt;</code>符号可把输出<strong>追加</strong>到目标文件中</li></ol><p> </p><h2 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h2><blockquote><ul><li>  重定向与文件</li><li>  <code>echo</code>指令与输出转义</li></ul></blockquote><ol><li> <code>command</code>文件使用了<code>echo</code>指令将每一行指令都输出到标准输出，再使用<code>&gt;&gt;</code>把输出重定向到<code>test</code>文件中，文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051639790.png" alt="image-20230305163906756"></p><blockquote><p>使用<code>echo</code>指令输出时需要注意转义字符的使用，如<code>$</code>、<code>&gt;</code>等字符都需要转义，否则会起到错误的效果 转义字符是<code>\</code>，不是<code>$</code>（后者是取值的意思）</p></blockquote><ol start="2"><li> <code>test</code>执行后的<code>result</code>文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051638470.png" alt="image-20230305163845452"></p><ol start="3"><li>结果说明：<ol><li> <code>test</code>文件中的所有没有重定向输出的<code>echo</code>语句都是提示性信息，并输出至控制台界面</li><li> 文件创建了三个变量，并分别对其进行赋值（其中变量<code>c</code>的值来自<code>ab</code>两变量的值之和）</li><li> 三个变量的值在有重定向的<code>echo</code>命令下被输出到对应的文件（<code>file1</code>、<code>file2</code>、<code>file3</code>）中，最终结果被连接并借助<code>file4</code>存入<code>result</code>中</li></ol></li><li><code>echo echo Shell Start</code> 与<code>echo `echo Shell Start` </code>效果是否有区别<ol><li> 没有区别，效果都是向控制台输出<code>echo Shell Start</code></li></ol></li><li><code>echo echo $c&gt;file1</code> 与<code>echo`echo $c&gt;file1` </code>效果是否有区别<ol><li> 有区别，前者向<code>file1</code>中写入了<code>echo \$c</code>信息；后者在控制台中输出了<code>echo \$c&gt;file1</code></li></ol></li></ol><p> </p><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><ul><li>  在<code>git</code>上，如果只按照最简单的操作去做的话目前还能正常使用，但如果出现版本选择、文件回退等操作就会因为许多指令不易区分而犯难，之后需要把各指令意义进行划分，匹配在图中便于记忆</li><li>  <code>awk</code>指令的使用，正则表达式该如何在<code>awk</code>中使用也是指令实现的一大难点</li></ul><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在lab0的课下实验中，我不仅复习了在<code>pre</code>阶段学到的知识：如git、makefile、文本处理、重定向，还对它们的具体实现有了更深的了解。在刚开始的学习过程中，<code>CLI</code>的使用、Linux基础命令、命令行参数的选取都是学习路上的困难，也是后面lab的基础。这些点需要勤练常用才能更好地运用在之后的实验中，便利之后的实验。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界，您好！</title>
      <link href="/2023/03/hello-world-1/"/>
      <url>/2023/03/hello-world-1/</url>
      
        <content type="html"><![CDATA[<p>欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
