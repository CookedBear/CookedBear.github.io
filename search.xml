<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUAA-SoftwareEngineering-Task3</title>
      <link href="/p/9a8de563.html"/>
      <url>/p/9a8de563.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是 2024 春季学期北航计算机学院本科生课程《软件工程》（嵌入式方向）的实验部分报告，不包含团队大作业项目内容与相关细节</p></blockquote><h1 id="任务3-机器人激光雷达建图与导航功能实现"><a href="#任务3-机器人激光雷达建图与导航功能实现" class="headerlink" title="任务3-机器人激光雷达建图与导航功能实现"></a>任务3-机器人激光雷达建图与导航功能实现</h1><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul><li>学会使用启智机器人的激光雷达建图与导航功能</li></ul><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><ul><li>使用启智机器人的激光雷达完成对仿真实验场景的建图</li><li>在建好的地图上进行导航功能</li></ul><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="使用启智机器人的激光雷达完成对仿真实验场景的建图"><a href="#使用启智机器人的激光雷达完成对仿真实验场景的建图" class="headerlink" title="使用启智机器人的激光雷达完成对仿真实验场景的建图"></a>使用启智机器人的激光雷达完成对仿真实验场景的建图</h2><p>本项目在任务 2 的基础上继续开发。</p><p><strong>SLAM 功能</strong>：即时定位与地图构建。</p><p>将连续的多个位置激光雷达扫描到的障碍物轮廓拼合在一起，就能形成一个比较完整的平面地图。这个地图是一个二维平面上的地图，其反映的是在激光雷达的扫描面上，整个环境里的障碍物轮廓和分布情况。在构建地图的过程中，还可以根据障碍物轮廓的重合关系，反推出机器人所走过的这几个位置之间的相互关系以及机器人在地图中所处的位置，这就同时完成了地图构建和机器人的自身实时定位这两项功能。</p><p>ROS 支持多种 SLAM 算法，常用的是 <strong>Hector SLAM</strong> 和 <strong>Gmapping</strong>，前者仅依靠激光雷达就能工作，后者需要结合电机码盘里程计等信息，建图的稳定性要更高。</p><p>Gmapping 建图中：<code>roslaunch wpr_simulation wpb_gmapping.launch</code></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152334432.png" alt="image-20240315233445391"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152333291.png" alt="image-20240315233200931"></p><p>GMapping 建图完毕：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152333910.png" alt="image-20240315233305406"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152335615.png" alt="image-20240315233525578"></p><p>在原有的 gmapping launch 文件基础上创建使用 Hector SLAM 的 launch 文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 载入 机器人 和 RoboCup@Home 的仿真场景 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpr_simulation)/launch/wpb_stage_robocup.launch&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Hector SLAM --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">type</span>=<span class="string">&quot;hector_mapping&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hector_mapping&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;tf_map_scanmatch_transform_frame_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;base_footprint&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Rviz --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;rvizconfig&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find wpr_simulation)/rviz/slam.rviz&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(arg rvizconfig)&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 手柄控制 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">respawn</span>=<span class="string">&quot;true&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joy&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joy_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;joy_node&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/dev/input/js0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;deadzone&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.12&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;axis_linear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;axis_angular&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_linear&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0.5&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;scale_angular&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;wpr_simulation&quot;</span> <span class="attr">type</span>=<span class="string">&quot;teleop_js_node&quot;</span> <span class="attr">name</span>=<span class="string">&quot;teleop_js_node&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Hector 建图完毕：<code>roslaunch wpr_simulation wpb_hector_mapping.launch</code></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152344550.png" alt="image-20240315234417410"></p><h3 id="Gmapping-amp-Hector比较"><a href="#Gmapping-amp-Hector比较" class="headerlink" title="Gmapping&amp;Hector比较"></a>Gmapping&amp;Hector比较</h3><p>两种 SLAM 的建图特点如下：</p><ol><li>建图效果比较：显然 hector 的清晰度更高，对细节的处理更好</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152349389.png" alt="image-20240315234927342"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152350670.png" alt="image-20240315235001611"></p><ol start="2"><li>分辨率：Hector 地图分辨率更高</li></ol><ul><li>Gmapping 保存的地图的分辨率为0.050米/像素</li><li>Hector 保存的地图的分辨率为0.025米/像素</li></ul><ol start="3"><li>执行速度：Gmapping 建图速度快于 Hector</li></ol><h2 id="在建好地图的上进行导航功能"><a href="#在建好地图的上进行导航功能" class="headerlink" title="在建好地图的上进行导航功能"></a>在建好地图的上进行导航功能</h2><h3 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h3><p>下一步执行的是<strong>模拟导航</strong>操作，需要执行的 launch 文件为 <code>wpb_navigation.launch</code>，其内容如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- We resume the logic in empty_world.launch, changing only the name of the world to be launched --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find wpr_simulation)/worlds/robocup_home.world&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;recording&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Spawn the objects into Gazebo --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;bed&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/bed.model -x 5.0 -y -3.9 -z 0 -Y 3.14159 -urdf -model bed&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;sofa&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/sofa.model -x -1.0 -y -3.9 -z 0 -Y 1.57 -urdf -model sofa&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;tea_table&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/tea_table.model -x -2.1 -y -2.2 -z 0 -Y 1.57 -urdf -model tea_table&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;bookshelft&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/bookshelft.model -x 2.0 -y -0.55 -z 0 -Y -1.57 -urdf -model bookshelft&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;kitchen_table&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/table.model -x -3.5 -y 3.7 -z 0 -Y 1.57 -urdf -model kitchen_table&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cupboard_0&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/cupboard.model -x -2.0 -y 0.7 -z 0 -Y 1.57 -urdf -model cupboard_0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;cupboard_1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/cupboard.model -x -1.3 -y 3.7 -z 0 -Y -1.57 -urdf -model cupboard_1&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;dinning_table_0&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/table.model -x 1.5 -y 1.5 -z 0 -Y 1.57 -urdf -model dinning_table_0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;dinning_table_1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/table.model -x 1.5 -y 2.0 -z 0 -Y 1.57 -urdf -model dinning_table_1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;dinning_table_2&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/table.model -x 2.7 -y 1.5 -z 0 -Y 1.57 -urdf -model dinning_table_2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;dinning_table_3&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/table.model -x 2.7 -y 2.0 -z 0 -Y 1.57 -urdf -model dinning_table_3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;chair_0&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/chair.model -x 1.5 -y 1.2 -z 0 -Y 1.57 -urdf -model chair_0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;chair_1&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/chair.model -x 1.5 -y 2.3 -z 0 -Y -1.57 -urdf -model chair_1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;chair_2&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/chair.model -x 2.7 -y 1.2 -z 0 -Y 1.57 -urdf -model chair_2&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;chair_3&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/chair.model -x 2.7 -y 2.3 -z 0 -Y -1.57 -urdf -model chair_3&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Spawn a robot into Gazebo --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;spawn_urdf&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-file $(find wpr_simulation)/models/wpb_home.model -urdf -x -6.0 -y -0.5 -model wpb_home&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Run the map server --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">type</span>=<span class="string">&quot;map_server&quot;</span> <span class="attr">args</span>=<span class="string">&quot;$(find wpr_simulation)/maps/map_hector.yaml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--- Run AMCL --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/amcl_omni.launch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--- Run move base --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;move_base&quot;</span> <span class="attr">type</span>=<span class="string">&quot;move_base&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">name</span>=<span class="string">&quot;move_base&quot;</span>  <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;global_costmap&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/costmap_common_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">ns</span>=<span class="string">&quot;local_costmap&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/local_costmap_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/global_costmap_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_tutorials)/nav_lidar/local_planner_params.yaml&quot;</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_global_planner&quot;</span> <span class="attr">value</span>=<span class="string">&quot;global_planner/GlobalPlanner&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_dijkstra&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;base_local_planner&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wpbh_local_planner/WpbhLocalPlanner&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>= <span class="string">&quot;controller_frequency&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- RViz and TF tree --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find wpb_home_bringup)/urdf/wpb_home.urdf&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;rvizconfig&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find wpr_simulation)/rviz/nav.rviz&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro $(arg model)&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span> <span class="attr">command</span>=<span class="string">&quot;load&quot;</span> <span class="attr">file</span>=<span class="string">&quot;$(find wpb_home_bringup)/config/wpb_home.yaml&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(arg rvizconfig)&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要可以分成四部分：</p><ul><li>创建 Gazebo 世界并放置物体和 robot</li><li>启动地图服务器，加载并广播已经生成的地图</li><li>启用 AMCL（自适应蒙特卡洛定位）、本地指向路径生成</li><li>RViz 节点启动，发布 tf 节点</li></ul><p>在这里需要将上一阶段生成的地图 yaml 和 pgm 文件全部移动到地图服务器节点指定的位置 <code>$(find wpr_simulation)/maps/map_hector.yaml</code>，等待地图服务器启动服务时调用；注意不要随便修改地图的名字，yaml 文件中包括其指向的 pgm 文件的名字，需要保持同步，才能加载地图。</p><h3 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h3><p>在 ROS 中，使用 <code>roslaunch wpr_simulation wpb_navigation.launch</code>启动 Navigation 导航系统后，可以在 Rviz 里看到障碍物栅格周围有一圈浅蓝色的安全边界。机器人的路径规划会避开黑色障碍物栅格和淡蓝色的安全边界，在剩余的白色可通行区域里寻找出一条最短路径。</p><p>在刚刚进入地图时，可能 Gazebo 和 RViz 显示的机器人位置不同，需要使用 RViz 中的 2D Pos Estimate 操作将机器人移动到地图边界与实际建模相匹配的情形，拖动生成的箭头可以选定机器人指向的方向。</p><p>地图匹配后，可以使用 2D Nav Goal 指定机器人的目标地点，类似的也可以拖动选定指向的方向。确定后，路线规划模块则会计算路线并驱动机器人进行移动。</p><p>机器人的导航速度可以通过配置文件进行调整，调整的文件和真实机器人移动时使用的文件一致：<code>/src/wpb_home/wpb_home_tutorials/nav_lidar/local_planner_params.yaml</code></p><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td>max_vel_trans</td><td>移动速度的最大值限制，单位为米/秒。</td></tr><tr><td>max_vel_rot</td><td>转动速度的最大值限制，单位为弧度/秒。</td></tr><tr><td>acc_scale_trans</td><td>移动速度的比例系数，这个值越大，移动速度越快。（调速主要字段）</td></tr><tr><td>acc_scale_rot</td><td>转动速度的比例系数，这个值越大，转动速度越快。</td></tr><tr><td>goal_dist_tolerance</td><td>机器人到达目标点的判定距离，单位为米。</td></tr><tr><td>goal_yaw_tolerance</td><td>机器人到达目标点的判定角度，单位为弧度。</td></tr><tr><td>scan_topic</td><td>获取激光雷达数据的主题名称，主要用于导航中的动态避障。</td></tr></tbody></table><p><video src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/QQ20240316001410.mp4"></video></p><p><a href="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/QQ20240316001410.mp4">在此可见演示视频</a></p><h3 id="软件包（节点）和话题订阅发布情况"><a href="#软件包（节点）和话题订阅发布情况" class="headerlink" title="软件包（节点）和话题订阅发布情况"></a>软件包（节点）和话题订阅发布情况</h3><p>使用 <code>rqt_graph</code> 统计得到的节点、话题发布情况如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403161609217.svg" alt="rosgraph"></p><h4 id="节点分析"><a href="#节点分析" class="headerlink" title="节点分析"></a>节点分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/ros/task1/BUAA-SoftwareEngineering-2024-ROS-Single$ rosnode list</span><br><span class="line">/amcl</span><br><span class="line">/gazebo</span><br><span class="line">/gazebo_gui</span><br><span class="line">/joint_state_publisher</span><br><span class="line">/map_server</span><br><span class="line">/move_base</span><br><span class="line">/robot_state_publisher</span><br><span class="line">/rosout</span><br><span class="line">/rviz</span><br></pre></td></tr></table></figure><ul><li><code>/amcl</code> (Adaptive Monte Carlo Localization)：实现了 AMCL 算法，用于机器人在已知地图上的自我定位，配合激光雷达等传感器使用</li><li><code>/gazebo</code>：Gazebo 仿真器运行需要的基础节点</li><li><code>gazebo_gui</code>：仿真器的GUI节点</li><li><code>/joint_state_publisher</code>：发布关于机器人各个关节的位置、速度、力等关节信息</li><li><code>/map_server</code>：提供地图数据服务，通过载入地图文件并作为话题发布出去，提供基础的地图信息</li><li><code>/move_base</code>：执行路径规划和导航，内部服务通过接受一个目标位置，控制机器人规划并执行到达该位置的最佳路径</li><li><code>/robot_state_publisher</code>：读取机器人的 URDF，并发布整个机器人的状态信息</li><li><code>/rosout</code>：ROS的日志节点</li><li><code>/rviz</code>：RViz 应用运行的基础节点</li></ul><h4 id="服务分析"><a href="#服务分析" class="headerlink" title="服务分析"></a>服务分析</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/ros/task1/BUAA-SoftwareEngineering-2024-ROS-Single$ rostopic list</span><br><span class="line">/amcl/parameter_descriptions</span><br><span class="line">/amcl/parameter_updates</span><br><span class="line">/amcl_pose</span><br><span class="line">/clicked_point</span><br><span class="line">/clock</span><br><span class="line">/cmd_vel</span><br><span class="line">/diagnostics</span><br><span class="line">/gazebo/link_states</span><br><span class="line">/gazebo/model_states</span><br><span class="line">/gazebo/parameter_descriptions</span><br><span class="line">/gazebo/parameter_updates</span><br><span class="line">/gazebo/set_link_state</span><br><span class="line">/gazebo/set_model_state</span><br><span class="line">/imu/data</span><br><span class="line">/initialpose</span><br><span class="line">/joint_states</span><br><span class="line">/kinect2/hd/camera_info</span><br><span class="line">/kinect2/hd/image_color_rect</span><br><span class="line">/kinect2/hd/image_color_rect/compressed</span><br><span class="line">/kinect2/hd/image_color_rect/compressed/parameter_descriptions</span><br><span class="line">/kinect2/hd/image_color_rect/compressed/parameter_updates</span><br><span class="line">/kinect2/hd/image_color_rect/compressedDepth</span><br><span class="line">/kinect2/hd/image_color_rect/compressedDepth/parameter_descriptions</span><br><span class="line">/kinect2/hd/image_color_rect/compressedDepth/parameter_updates</span><br><span class="line">/kinect2/hd/image_color_rect/theora</span><br><span class="line">/kinect2/hd/image_color_rect/theora/parameter_descriptions</span><br><span class="line">/kinect2/hd/image_color_rect/theora/parameter_updates</span><br><span class="line">/kinect2/hd/parameter_descriptions</span><br><span class="line">/kinect2/hd/parameter_updates</span><br><span class="line">/kinect2/qhd/camera_info</span><br><span class="line">/kinect2/qhd/image_color_rect</span><br><span class="line">/kinect2/qhd/image_color_rect/compressed</span><br><span class="line">/kinect2/qhd/image_color_rect/compressed/parameter_descriptions</span><br><span class="line">/kinect2/qhd/image_color_rect/compressed/parameter_updates</span><br><span class="line">/kinect2/qhd/image_color_rect/compressedDepth</span><br><span class="line">/kinect2/qhd/image_color_rect/compressedDepth/parameter_descriptions</span><br><span class="line">/kinect2/qhd/image_color_rect/compressedDepth/parameter_updates</span><br><span class="line">/kinect2/qhd/image_color_rect/theora</span><br><span class="line">/kinect2/qhd/image_color_rect/theora/parameter_descriptions</span><br><span class="line">/kinect2/qhd/image_color_rect/theora/parameter_updates</span><br><span class="line">/kinect2/qhd/parameter_descriptions</span><br><span class="line">/kinect2/qhd/parameter_updates</span><br><span class="line">/kinect2/qhd/points</span><br><span class="line">/kinect2/sd/depth/camera_info</span><br><span class="line">/kinect2/sd/depth_camera_info</span><br><span class="line">/kinect2/sd/image_depth_rect</span><br><span class="line">/kinect2/sd/image_ir_rect</span><br><span class="line">/kinect2/sd/image_ir_rect/compressed</span><br><span class="line">/kinect2/sd/image_ir_rect/compressed/parameter_descriptions</span><br><span class="line">/kinect2/sd/image_ir_rect/compressed/parameter_updates</span><br><span class="line">/kinect2/sd/image_ir_rect/compressedDepth</span><br><span class="line">/kinect2/sd/image_ir_rect/compressedDepth/parameter_descriptions</span><br><span class="line">/kinect2/sd/image_ir_rect/compressedDepth/parameter_updates</span><br><span class="line">/kinect2/sd/image_ir_rect/theora</span><br><span class="line">/kinect2/sd/image_ir_rect/theora/parameter_descriptions</span><br><span class="line">/kinect2/sd/image_ir_rect/theora/parameter_updates</span><br><span class="line">/kinect2/sd/parameter_descriptions</span><br><span class="line">/kinect2/sd/parameter_updates</span><br><span class="line">/kinect2/sd/points</span><br><span class="line">/map</span><br><span class="line">/map_metadata</span><br><span class="line">/map_updates</span><br><span class="line">/move_base/GlobalPlanner/parameter_descriptions</span><br><span class="line">/move_base/GlobalPlanner/parameter_updates</span><br><span class="line">/move_base/GlobalPlanner/plan</span><br><span class="line">/move_base/GlobalPlanner/potential</span><br><span class="line">/move_base/WpbhLocalPlanner/local_planner_target</span><br><span class="line">/move_base/cancel</span><br><span class="line">/move_base/current_goal</span><br><span class="line">/move_base/feedback</span><br><span class="line">/move_base/global_costmap/costmap</span><br><span class="line">/move_base/global_costmap/costmap_updates</span><br><span class="line">/move_base/global_costmap/footprint</span><br><span class="line">/move_base/global_costmap/inflation_layer/parameter_descriptions</span><br><span class="line">/move_base/global_costmap/inflation_layer/parameter_updates</span><br><span class="line">/move_base/global_costmap/obstacle_layer/parameter_descriptions</span><br><span class="line">/move_base/global_costmap/obstacle_layer/parameter_updates</span><br><span class="line">/move_base/global_costmap/parameter_descriptions</span><br><span class="line">/move_base/global_costmap/parameter_updates</span><br><span class="line">/move_base/global_costmap/static_layer/parameter_descriptions</span><br><span class="line">/move_base/global_costmap/static_layer/parameter_updates</span><br><span class="line">/move_base/goal</span><br><span class="line">/move_base/local_costmap/costmap</span><br><span class="line">/move_base/local_costmap/costmap_updates</span><br><span class="line">/move_base/local_costmap/footprint</span><br><span class="line">/move_base/local_costmap/inflation_layer/parameter_descriptions</span><br><span class="line">/move_base/local_costmap/inflation_layer/parameter_updates</span><br><span class="line">/move_base/local_costmap/obstacle_layer/parameter_descriptions</span><br><span class="line">/move_base/local_costmap/obstacle_layer/parameter_updates</span><br><span class="line">/move_base/local_costmap/parameter_descriptions</span><br><span class="line">/move_base/local_costmap/parameter_updates</span><br><span class="line">/move_base/local_costmap/static_layer/parameter_descriptions</span><br><span class="line">/move_base/local_costmap/static_layer/parameter_updates</span><br><span class="line">/move_base/parameter_descriptions</span><br><span class="line">/move_base/parameter_updates</span><br><span class="line">/move_base/result</span><br><span class="line">/move_base/status</span><br><span class="line">/move_base_simple/goal</span><br><span class="line">/odom</span><br><span class="line">/particlecloud</span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">/scan</span><br><span class="line">/scan_filtered</span><br><span class="line">/tf</span><br><span class="line">/tf_static</span><br><span class="line">/visualization_marker</span><br><span class="line">/visualization_marker_array</span><br><span class="line">/waypoints_marker</span><br><span class="line">/waypoints_marker_array</span><br></pre></td></tr></table></figure><p>由于服务过多，下面主要按照功能进行分类并解释：</p><ul><li><p>传感器信息：</p><ul><li><p>激光雷达、相机 Kinect：<code>/scan</code>、<code>/kinect2/hd/image_color_rect</code>、<code>/kinect2/qhd/points</code> 等话题，传递从激光雷达和 Kinect 相机接收到的数据</p></li><li><p>惯性测量单元 IMU：<code>/imu/data</code> 用于传输加速度、旋转速率等</p></li></ul></li><li><p>机器人控制：</p><ul><li><p>速度控制：<code>/cmd_vel</code> 接收控制机器人移动的速度命令，实验 2 中也是靠 cmd_vel 将键盘输入的指令传递给机器人的</p></li><li><p>位置与速度：<code>/odom</code> 发布机器人的位置和速度信息</p></li><li><p>关节状态：<code>/joint_states</code> 发布机器人关节的状态信息</p></li></ul></li><li><p>导航、定位：</p><ul><li><p>AMCL：自适应蒙特卡洛定位，如 <code>/amcl_pose</code> 和 <code>/particlecloud</code>，计算使用 AMCL 算法得到的自我定位结果</p></li><li><p>地图服务器：<code>/map</code>、<code>/map_metadata</code> 和 <code>/map_updates</code> 话题用于传递环境地图及其更新信息。</p></li><li><p>导航规划：<code>/move_base/*</code>，处理路径规划和导航的任务</p></li><li><p>时间、坐标：<code>/clock</code>和 <code>/tf_static</code> 等，处理模拟时间和坐标时的变换信息</p></li></ul></li><li><p>仿真软件：</p><ul><li><p>Gazebo：<code>/gazebo/model_states</code>、<code>/gazebo/link_states</code> 等话题</p></li><li><p>RViz：<code>/visualization_marker</code>、<code>/visualization_marker_array</code> 等话题</p></li></ul></li><li><p>参数配置：</p><ul><li>查询参数，<code>*/parameter_descriptions</code>，动态获取节点的配置文件包含的参数</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-SoftwareEngineering-Task2</title>
      <link href="/p/ed8ad5f5.html"/>
      <url>/p/ed8ad5f5.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是 2024 春季学期北航计算机学院本科生课程《软件工程》（嵌入式方向）的实验部分报告，不包含团队大作业项目内容与相关细节</p></blockquote><h1 id="任务2-启智机器人工程的导入与运动控制"><a href="#任务2-启智机器人工程的导入与运动控制" class="headerlink" title="任务2-启智机器人工程的导入与运动控制"></a>任务2-启智机器人工程的导入与运动控制</h1><h1 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h1><ul><li>建立启智机器人仿真环境</li><li>掌握仿真环境下机器人的运动控制</li></ul><h1 id="实验任务"><a href="#实验任务" class="headerlink" title="实验任务"></a>实验任务</h1><ul><li>完成启智机器人及仿真环境的环境配置和项目构建</li><li>学习 Twist 消息类型并完成机器人的运动控制</li></ul><h1 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h1><h2 id="建立启智机器人仿真环境"><a href="#建立启智机器人仿真环境" class="headerlink" title="建立启智机器人仿真环境"></a>建立启智机器人仿真环境</h2><p>首先在目录中新建一个工作空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> task2</span><br><span class="line"><span class="built_in">mkdir</span> task2/src</span><br><span class="line"><span class="built_in">cd</span> task2/src</span><br><span class="line">catkin_init_workspace</span><br></pre></td></tr></table></figure><p>然后通过 Github 将三个源码仓库同时拷贝进 <code>src</code> 目录中，再安装对应包的依赖项，注意安装依赖项与 ROS 的版本相关（kinetic-16.04，<strong>Melodic-18.04</strong>，Noetic-20.04）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/6-robot/wpr_simulation.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/6-robot/wpb_home.git</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/6-robot/waterplus_map_tools.git</span><br><span class="line"></span><br><span class="line">./wpr_simulation/scripts/install_for_melodic.sh</span><br><span class="line">./wpb_home/scripts/install_for_melodic.sh</span><br><span class="line">./waterplus_map_tools/scripts/install_for_melodic.sh</span><br></pre></td></tr></table></figure><p>依赖安装完毕后回到根目录编译项目，相当于此时项目就拥有了三个启智机器人内置的软件包，有了执行一定功能的能力</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_make</span><br></pre></td></tr></table></figure><p>此时已经可以通过执行以下指令开启机器人在 Gazebo 中执行简单的仿真场景</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roslaunch wpr_simulation wpb_simple.launch</span><br></pre></td></tr></table></figure><h2 id="掌握仿真环境下机器人的运动控制"><a href="#掌握仿真环境下机器人的运动控制" class="headerlink" title="掌握仿真环境下机器人的运动控制"></a>掌握仿真环境下机器人的运动控制</h2><p>参考指导书编写一个软件包实现对机器人的运动控制。</p><p>首先在 <code>src</code> 目录创建一个软件包，然后创建 <code>scripts</code> 目录并编写一个 python 代码，需要注意对脚本文件添加可执行属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg vel_pkg rospy geometry_msgs</span><br><span class="line">mkdir vel_pkg/scripts</span><br><span class="line">cd vel_pkg/scripts</span><br><span class="line">touch vel_ctrl_node.py</span><br><span class="line">chmod +x vel_ctrl_node.py</span><br></pre></td></tr></table></figure><blockquote><p>这里创建包的含义是：</p><ul><li><code>catkin_create_pkg</code>：创建 ROS 源码包</li><li><code>vel_pkg</code>：源码包名</li><li><code>rospy</code>：python 依赖项（内部文件使用 python 文件编写）</li><li><code>geometry_msgs</code>：包含机器人移动速度消息包格式文件的包名</li></ul></blockquote><p>python 代码的内容如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 引入两个声明包时用到的库：`rospy` 包含 python 中使用的 ROS 函数；`geometry_msgs.msg` 包含 `Twist` 模块</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化节点，命名为 vel_ctrl_node</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;vel_ctrl_node&quot;</span>)</span><br><span class="line">    <span class="comment"># 发布速度控制话题 cmd_vel（运动控制话题）</span></span><br><span class="line">    vel_pub = rospy.Publisher(<span class="string">&quot;cmd_vel&quot;</span>,Twist,queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 构建 Twist 速度消息包 msg，并赋值</span></span><br><span class="line">    msg = Twist()</span><br><span class="line">    msg.linear.x = <span class="number">0.1</span>  <span class="comment"># 只发送 x 方向线性速度</span></span><br><span class="line">    <span class="comment"># msg.angular.z =0.1</span></span><br><span class="line">    <span class="comment"># 构建发送频率对象 10Hz</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;发送一个速度消息包&quot;</span>)</span><br><span class="line">        vel_pub.publish(msg)  <span class="comment"># 循环在话题中发布数据包</span></span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p>然后现在回到项目根目录，重新编译，然后再配置环境，最终运行控制节点：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/task2</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">roslaunch wpr_simulation wpb_simple.launch</span><br><span class="line">rosrun vel_pkg vel_ctrl_node.py</span><br></pre></td></tr></table></figure><p>然后就能通过 Gazebo 环境观察仿真机器人的运动，并通过 vel_ctrl_node 节点对其发出指令控制其运动</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403152234892.png" alt="image-20240315223149660"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-FPGA多核并行计算-Exp2-1</title>
      <link href="/p/b94f504e.html"/>
      <url>/p/b94f504e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列是北航计算机学院于 2024 年春季学期开设的一般专业课《FPGA多核并行计算》课程的实验报告记录，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！</p></blockquote><h1 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h1><p>代码及相关数据文件上传在 <a href="https://github.com/CookedBear/BUAA-FPGA-Parallel-2024/tree/exp2-1">Github</a> 仓库中。</p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="使用卷积神经网络进行图像识别"><a href="#使用卷积神经网络进行图像识别" class="headerlink" title="使用卷积神经网络进行图像识别"></a>使用卷积神经网络进行图像识别</h3><p><strong>任务说明</strong>：使用 PyTorch 搭建一个简单的卷积神经网络模型，并实现对手写数字的识别。</p><p>首先在 <a href="http://yann.lecun.com/exdb/mnist/">MNIST Dataset</a> 中下载 MNIST 数据集，该数据集包含总计 70000 张手写数字的图片，其中划分为 60000 张训练图片以及 10000 张测试图片，每张样本图片都是一个 28x28 像素的灰度图像。</p><p>然后使用实验材料中提供的代码构建一个处理这些图像的卷积神经网络，最终的全连接层将全局最大池化层的输出的 64 个特征连接到一个有 10 个输出节点的全连接层，对应于 10 个分类标签（即数字 0~9 ）。</p><p>实验过程和实验结果见 <code>mnist.pynb</code>。</p><h3 id="使用yolov3进行图片中的目标检测"><a href="#使用yolov3进行图片中的目标检测" class="headerlink" title="使用yolov3进行图片中的目标检测"></a>使用yolov3进行图片中的目标检测</h3><p><strong>任务说明</strong>：使用 yolov3 和已经训练好的权重模型对图片中的物体进行目标检测。</p><p>本实验环境为 wsl 环境 Ubuntu 20.04.6。Windows 平台的 darknet 框架与 yolov3 编译部署参考<a href="https://segmentfault.com/a/1190000017773610">这篇文章</a></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142317595.gif" alt="img"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142317595.gif" alt="img"></p><p>预测结果如下，可见yolov3能对图像中物体进行有效识别：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142318258.jpg" alt="img"></p><h1 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h1><ul><li>如何通过设置单层感知机的 w 和 T 实现 <code>AND</code>，<code>OR</code> 和 <code>NOT</code>？</li></ul><p>单层感知机通过将输入向量与权重向量进行点积，并将结果与一个阈值（T）进行比较，来决定输出是 0 还是 1，常用于执行二元分类任务。对于 AND、OR 和 NOT 这三种基本逻辑运算可以简单通过二维坐标图确定 w 和 T 的值/合理取值范围：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142319719.gif" alt="img"></p><blockquote><p>上图来自实验教程</p></blockquote><p><strong>AND 运算真值表</strong></p><table><thead><tr><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_1\ AND\ x_2$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>设置权重 w1 = 1, w2 = 1，并设阈值 T = 2</p><p>感知机的输出 y = 1 当且仅当 x1 + x2 ≥ 2</p><p><strong>OR 运算真值表</strong></p><table><thead><tr><th align="center">$x_1$</th><th align="center">$x_2$</th><th align="center">$x_1\ OR\ x_2$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><p>设置权重 w1 = 1, w2 = 1，并设阈值 T = 1</p><p>感知机的输出 y = 1 当且仅当 x1 + x2 ≥ 1</p><p><strong>NOT 运算真值表</strong></p><table><thead><tr><th align="center">$x_1$</th><th align="center">$NOT\ x_1$</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">0</td></tr></tbody></table><p>设置权重 w = -1，并设阈值 T = -0.5</p><p>感知机的输出 y = 1 当且仅当 -x ≥ -0.5</p><ul><li>尝试用简洁的方式表示前向传播计算</li></ul><p>前向传播计算是通过输入矩阵和权重矩阵的乘积再加上偏置作为输入，应用激活函数转换这个值得出下一层的数据，逐层向前转播直至输出层。</p><p>首先假设前向传播的输入层中输入矩阵为 $X$，该层权重矩阵为 $W$，激活函数为 $f$，偏置为$b$，那么输入层的输出为 $Z = XW + b$。该矩阵输入给中间层，用作后续计算；中间层的输出为$A = f(Z)$，然后数值持续传播。</p><ul><li>参考<code>使用卷积神经网络进行图像识别</code>节的代码，自行设计神经网络完成对 <code>cifar10</code> 数据集的分类</li></ul><p>数据集为 <a href="https://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10 Dataset</a>，详细代码请见文件 <code>cifar10.ipynb</code>，训练中使用 <code> TersorflowBoard</code> 对数据进行查看如下，可见准确率约 75%：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142323734.gif" alt="img"></p><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>通过本次实验，我初步认识了深度学习的环境配置和实验流程，完成了MNIST和CIFAR10数据集的训练和识别。但是在实验过程中出现了环境配置的问题，通过查询网络获得了解决方式，完成了整个实验。</p><h1 id="实验2-1：深度学习基础"><a href="#实验2-1：深度学习基础" class="headerlink" title="实验2-1：深度学习基础"></a>实验2-1：深度学习基础</h1><ul><li>实验说明文档见 <a href="https://github.com/CookedBear/BUAA-FPGA-Parallel-2024/blob/exp2-1/%E5%AE%9E%E9%AA%8C2-1%E6%96%87%E6%A1%A3.md">Github 仓库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-FPGA多核并行计算-Exp1</title>
      <link href="/p/a164ec81.html"/>
      <url>/p/a164ec81.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列是北航计算机学院于 2024 年春季学期开设的一般专业课《FPGA多核并行计算》课程的实验报告记录，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！</p></blockquote><h1 id="在线实验平台使用及初识PYNQ"><a href="#在线实验平台使用及初识PYNQ" class="headerlink" title="在线实验平台使用及初识PYNQ"></a>在线实验平台使用及初识PYNQ</h1><p>代码及相关数据文件上传在 <a href="https://github.com/CookedBear/BUAA-FPGA-Parallel-2024/tree/exp-1">Github</a> 仓库中。</p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><h3 id="硬件滤波器Overlay的制作"><a href="#硬件滤波器Overlay的制作" class="headerlink" title="硬件滤波器Overlay的制作"></a>硬件滤波器Overlay的制作</h3><ul><li>打开Vivado，创建新工程，工程类型为<code>RTL Project</code>，板卡型号选择<code>pynq-z2</code></li><li>在左侧菜单中，选择<code>IP INTEGRATOR</code>下的<code>Create Block Design</code>项，创建模组设计并在模组中添加<code>ZYNQ7 Processing System</code>、<code>FIR Compiler</code>和<code>AXI Direct Memory Access</code>这三个模块</li><li>完成模块添加后，对模块进行修改<ul><li>双击<code>ZYNQ7 Processing System</code>模块，做如下修改：<ol><li>选择<code>PS-PL Configuration</code>页，勾选<code>HP Slave AXI Interface</code>页的<code>S AXI HP0 interface</code>，启用PS端的AXI协议数据传输接口</li></ol></li><li>双击<code>FIR Compiler</code>滤波器模块，做如下修改：<ol><li>修改其中的系数向量（系数向量详见后部软件实现滤波器部分）。</li><li>在<code>Channel Specification</code>页修改采样频率与时钟频率均为100MHz。</li><li>在<code>Implementation</code>页面修改<code>Output Rounding Mode</code>为<code>Non Symmetric Rounding Up</code>，修改输入输出数据位宽为32位。</li><li>在<code>Interface</code>页面设置<code>TLAST</code>为<code>Packet Framing</code>，并勾选<code>Output TREADY</code>以输出TREADY信号。</li></ol></li><li>双击<code>AXI Direct Memory Access</code>模块，做如下修改：<ol><li>取消勾选<code>Enable Scatter Gather Engine</code>，此处不需要非连续地址的数据传输，故可关闭SG模式</li><li><code>Width of Buffer Length Register</code>设置为23位</li></ol></li></ul></li><li>点击<code>Run Block Automation</code>进行自动添加附加模块。</li><li>将<code>FIR Compiler</code>的<code>M_AXIS_DATA</code>端口与<code>AXI Direct Memory Access</code>的<code>S_AXIS_S2MM</code>端口相连，用于将DMA模块的数据传输给滤波器模块。</li><li>将<code>FIR Compiler</code>的<code>S_AXIS_DATA</code>端口与<code>AXI Direct Memory Access</code>的<code>M_AXIS_MM2S</code>端口相连，用于将滤波器模块的输出结果回传给DMA模块。</li><li>在<code>Block Properties</code>中对<code>AXI Direct Memory Access</code>模块进行改名，此处修改为<code>fir_dma</code>，并将<code>FIR Compiler</code>模块改名为<code>fir</code>，同时选中<code>fir</code>和<code>fir_dma</code>模块，点击右键，选择<code>Create Hieracty</code>，创建层次，并将其命名为<code>filter</code></li><li>点击<code>Run Connection Automation</code>进行自动连线，连线过程中勾选<code>All Automation</code>（注：此处的自动连线需要执行两次）。</li><li>切换至<code>Sources</code>分页，选择当前的<code>Design Sources</code>，点击右键，选择菜单中的<code>Create HDL Wrapper</code>，生成顶层包装（将模块设计包装起来）</li><li>选择<code>Generate Bitstream</code>，生成Overlay所需要的比特流文件，注意，在点选之后，综合（<code>Synthesis</code>）和执行（<code>implementation</code>）均会在后台运行，此刻可查看界面右上角是否有流程未完成，或打开Log界面查看当前任务所输出的日志。</li><li>分别选择<code>File</code>菜单下的<code>Export</code>中的<code>Export Bitstream File</code>、<code>Export Block Design</code>导出比特流文件.bit和模块设计的tcl约束文件，并在<code>工程名.srcs/sources_1/bd/design_1/hw_handoff</code>文件夹下找到.hwh的硬件描述文件，将此三个文件改为同一文件名存放至同一工作目录下，即可作为PYNQ平台的Overlay进行使用。</li></ul><blockquote><p>说明：</p><p><code>ZYNQ7 Processing System</code>为ZYNQ7系列板卡（如xc7z020、xc7z100，PYNQ-Z2板卡使用的是xc7z020）所设计的PS侧资源的抽象模块。<code>FIR Compiler</code>为Xilinx所内置的滤波器IP核（IP核为预先设计好的电路功能模块），修改其中的系数向量（Coefficient Vector），即可实现所需要的滤波功能。<code>TLAST</code>选择为<code>Packet Framing</code>时，每个数据帧完成后将传出信号，数据将按包接收 <code>TREADY</code>勾选时将输出<code>TREADY</code>信号，其与<code>TVALID</code>信号实现了握手</p></blockquote><p>本图为实现元件连接后的示意图，最左侧时组合后的filter，右侧是zynq模块，图示元件共同构成了硬件滤波器。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141714244.jpg" alt="img"></p><p>本图是在仿真综合后，Vivado得到的设备仿真图。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141714311.jpg" alt="img"></p><h3 id="软件滤波器的构建"><a href="#软件滤波器的构建" class="headerlink" title="软件滤波器的构建"></a>软件滤波器的构建</h3><ul><li>首先需要构建原始信号</li><li>使用SciPy中的<code>lfilter</code>方法进行对输入信号进行滤波，并记录软件滤波器执行耗时；滤波器系数向量可通过<code>http://t-filter.engineerjs.com/</code>生成，通过滤波，可将高于5MHz的信号过滤掉。</li></ul><h3 id="硬件滤波器Overlay的使用"><a href="#硬件滤波器Overlay的使用" class="headerlink" title="硬件滤波器Overlay的使用"></a>硬件滤波器Overlay的使用</h3><ul><li>将生成的Overlay（.bit，.hwh，.tcl三个文件）拷贝到工作目录下</li><li>使用PYNQ的xlnk类，申请输入输出缓冲区，并使用dma对输入数据和输出数据进行处理</li></ul><p>下图是执行结束后的结果：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141710258.gif" alt="img"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141710258.gif" alt="img"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141710505.gif" alt="img"></p><h1 id="实验思考"><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h1><ul><li>计算回答为何AXI Direct Memory Access 模块的Width of Buffer Length Register 设置为23位？</li></ul><p>DMA模块中的Buffer Length Register 用于控制单次传输操作中可以处理的最大数据量。位宽为23位，说明DMA能够一次性传输8 MB数据。这个值是基于DMA的设计和应用需求而决定的。过小的Buffer难以即时传递采样获取的信息，过大的Buffer会提升内存管理的复杂性。</p><ul><li>参考Python Overlay API的文档，通过对Overlay类进行封装，实现滤波过程的驱动编写。</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">　　# -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">　　# @Time    : 2024/3/6 22:58</span></span><br><span class="line"><span class="string">　　# @Author  : CookedBear</span></span><br><span class="line"><span class="string">　　# @File    : overlay.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pynq <span class="keyword">import</span> Overlay, Xlnk</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyOverlay</span>(<span class="title class_ inherited__">Overlay</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, bitfile_name</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(bitfile_name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">driver</span>(<span class="params">self, samples, n</span>):</span><br><span class="line">        <span class="comment"># 加载滤波器的DMA</span></span><br><span class="line">        dma = self.<span class="built_in">filter</span>.fir_dma</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为输入和输出信号分配缓冲区</span></span><br><span class="line">        xlnk = Xlnk()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 申请内存地址连续的numpy数组作为输入输出缓冲区</span></span><br><span class="line">        in_buffer = xlnk.cma_array(shape=(n,), dtype=np.int32)</span><br><span class="line">        out_buffer = xlnk.cma_array(shape=(n,), dtype=np.int32)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将信号拷贝至输入缓冲区</span></span><br><span class="line">        np.copyto(in_buffer, samples)</span><br><span class="line">        dma.sendchannel.transfer(in_buffer)</span><br><span class="line">        dma.recvchannel.transfer(out_buffer)</span><br><span class="line">        dma.sendchannel.wait()</span><br><span class="line">        dma.recvchannel.wait()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 释放缓冲区</span></span><br><span class="line">        in_buffer.close()</span><br><span class="line">        out_buffer.close()</span><br></pre></td></tr></table></figure><ul><li>请思考或建立新工程尝试，若省略2-7的Create Hieracty 步骤，则可通过什么其他方式对DMA模块进行访问？</li></ul><p>若省略2-7的Create Hieracty 步骤，也就是不创建filter层次，可以选择在Python文件中直接调用以下语句对 DMA 模块进行访问。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dma = overlay.fir_dma  <span class="comment"># 加载滤波器的DMA</span></span><br></pre></td></tr></table></figure><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><ul><li>在进行实验步骤4.2时，我的notebook发生了如下报错：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403141713834.gif" alt="img"></p><p>回查后发现是Vivado中忘记对 DMA 模块做出如下修改：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 取消勾选Enable Scatter Gather Engine，此处不需要非连续地址的数据传输，故可关闭SG模式</span><br><span class="line"></span><br><span class="line">2. Width of Buffer Length Register设置为23位</span><br></pre></td></tr></table></figure><p>修改后重新综合，覆盖实验文件后出现正常现象。但尚未研究清楚其中的原因。</p><h2 id="实验建议"><a href="#实验建议" class="headerlink" title="实验建议"></a>实验建议</h2><p>本次实验是第一次FPGA的上机实验，对我而言，之前尚未接触过pynq和相关的知识。在这次上机时，能够感觉出实验指导书的步骤详尽，引导性强，但是整体实验后由于理论和基础知识不足，不能理解实验操作如何、为何能够得到实验现象。希望实验能够增加一些前期的讲解，理解运用上可能会更有裨益。</p><h2 id="实验收获"><a href="#实验收获" class="headerlink" title="实验收获"></a>实验收获</h2><p>通过本次实验，我初步认识了FPGA的设计流程和课程中“并行计算”的意义，硬件中实现的滤波器效率要远高于软件模拟出的元件，再次佐证了FPGA在实现计算加速的优越性。</p><h1 id="实验1：在线实验平台使用及初识PYNQ"><a href="#实验1：在线实验平台使用及初识PYNQ" class="headerlink" title="实验1：在线实验平台使用及初识PYNQ"></a>实验1：在线实验平台使用及初识PYNQ</h1><ul><li>实验文档见 <a href="https://github.com/CookedBear/BUAA-FPGA-Parallel-2024/blob/exp-1/%E5%AE%9E%E9%AA%8C1%E6%96%87%E6%A1%A3.md">Github 仓库</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-SoftwareEngineering-Task1</title>
      <link href="/p/7483844f.html"/>
      <url>/p/7483844f.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是 2024 春季学期北航计算机学院本科生课程《软件工程》（嵌入式方向）的实验部分报告，不包含团队大作业项目内容与相关细节</p></blockquote><h1 id="任务1-环境配置与机器人模型搭建"><a href="#任务1-环境配置与机器人模型搭建" class="headerlink" title="任务1-环境配置与机器人模型搭建"></a>任务1-环境配置与机器人模型搭建</h1><h2 id="工作空间创建"><a href="#工作空间创建" class="headerlink" title="工作空间创建"></a>工作空间创建</h2><p>注意创建包时使用 <code>urdf xacro</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_init_workspace</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br><span class="line">catkin_create_pkg mrobot_description urdf xacro</span><br></pre></td></tr></table></figure><p>然后创建 <code>urdf</code> 文件夹并进行 <code>urdf</code> 文件的书写。</p><h2 id="RViz仿真显示"><a href="#RViz仿真显示" class="headerlink" title="RViz仿真显示"></a>RViz仿真显示</h2><p>此时创建的 <code>urdf</code> 单个文件已经可以配合 <code>launch</code> 文件运行在 RViz 应用中了。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">robot</span> <span class="attr">name</span>=<span class="string">&quot;base&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    one basement</span></span><br><span class="line"><span class="comment">    two active wheel</span></span><br><span class="line"><span class="comment">    two all-direction wheel</span></span><br><span class="line"><span class="comment">    one lazer radar</span></span><br><span class="line"><span class="comment">    one camera</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;base_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.025&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 0.4 0.0 1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">inertial</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mass</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0.0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">inertia</span> <span class="attr">ixx</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">ixy</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">ixz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">iyy</span>=<span class="string">&quot;0.01&quot;</span> <span class="attr">iyz</span>=<span class="string">&quot;0.0&quot;</span> <span class="attr">izz</span>=<span class="string">&quot;0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">inertial</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;1&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.025&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_motor_base_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.8 0.4 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_motor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span> = <span class="string">&quot;0.6&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;gray&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span> = <span class="string">&quot;0.6&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_active_wheel_motor_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0.3 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;left_motor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_active_wheel_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_active_wheel_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.233&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.017&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 1 0.9&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.233&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.017&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;right_motor_base_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0.8 -0.4 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0 0 0&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;right_motor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;right_motor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span> = <span class="string">&quot;0.6&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;gray&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;0 0 0 1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0 0&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.1&quot;</span> <span class="attr">length</span> = <span class="string">&quot;0.6&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;right_active_wheel_motor_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;continuous&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 -0.3 0.0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;0.0 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;right_motor&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;right_active_wheel_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">axis</span> <span class="attr">xyz</span>=<span class="string">&quot;0 1 0&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;right_active_wheel_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.233&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.017&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 1 0.9&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">cylinder</span> <span class="attr">radius</span>=<span class="string">&quot;0.233&quot;</span> <span class="attr">length</span>=<span class="string">&quot;0.017&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;left_castor_wheel_base_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;-0.8 0.5 -0.1&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;left_castor_wheel_link&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;left_castor_wheel_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.133&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 1 0.9&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collision</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.133&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collision</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">joint</span> <span class="attr">name</span>=<span class="string">&quot;right_castor_wheel_base_joint&quot;</span> <span class="attr">type</span>=<span class="string">&quot;fixed&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;-0.8 -0.5 -0.1&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span> <span class="attr">link</span>=<span class="string">&quot;base_link&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">link</span>=<span class="string">&quot;right_castor_wheel_link&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">joint</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">name</span>=<span class="string">&quot;right_castor_wheel_link&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">visual</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">origin</span> <span class="attr">xyz</span>=<span class="string">&quot;0 0 0&quot;</span> <span class="attr">rpy</span>=<span class="string">&quot;1.5707 0.0 0.0&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">geometry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sphere</span> <span class="attr">radius</span>=<span class="string">&quot;0.133&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">geometry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">material</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">color</span> <span class="attr">rgba</span>=<span class="string">&quot;1 1 1 0.9&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">material</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">visual</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">robot</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- urdf_launcher.launch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">textfile</span>=<span class="string">&quot;$(find mrobot_description)/urdf/base.urdf&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置GUI参数，显⽰关节控制插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 运⾏joint_state_publisher节点，发布机器⼈的关节状态 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 运⾏robot_state_publisher节点，发布TF --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 运⾏rviz可视化界⾯ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find mrobot_description)/config/mrobot_urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写完毕后可以使用 <code>roslaunch mrobot_description urdf_launcher.launch</code> 命令行执行启动 NViz</p><p>注意到启动 NViz 后并不能正确选择 Fixed Frame（如下图），机器人也不能正常显示，搜索后需要对 <code>joint-state</code> 和 <code>robot-state</code> 进行安装，以发布正确的 tf 数据，指导 NViz 正确显示关节信息等。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403122101878.png" alt="image-20240312210119857"></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-joint-state-publisher</span><br><span class="line">sudo apt-get install ros-melodic-robot-state-publisher</span><br></pre></td></tr></table></figure><p>修复后可以正常启动文件类型为 <code>urdf</code> 的机器人</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403122357789.png" alt="image-20240312235034659" style="zoom:67%;" /><h2 id="xacro项目优化"><a href="#xacro项目优化" class="headerlink" title="xacro项目优化"></a>xacro项目优化</h2><p>在此基础上，可以对 <code>urdf</code> 文件进行优化，将其模块化为 <code>xacro</code> 文件并进行引用，形成更复杂、层次化的工程项目，在修改项目文件时同时需要注意引用命名空间 <code>xmlns:xacro=&quot;http://www.ros.org/wiki/xacro&quot;</code>，此外也需要修改启动文件：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130000947.png" alt="image-20240313000029925"></p><blockquote><p>项目文件结构图，顶层文件为 base.urdf.xacro，引用了 base_robot.urdf.xacro、camera.urdf.xacro、rplidar.urdf.xacro</p></blockquote><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- xacro_launcher.launch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;model&quot;</span> <span class="attr">default</span>=<span class="string">&quot;$(find xacro)/xacro --inorder &#x27;$(find mrobot_description)/urdf/base.urdf.xacro&#x27;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(arg model)&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;param name=&quot;robot_description&quot; textfile=&quot;$(find mrobot_description)/urdf/base.urdf.xacro&quot; /&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置GUI参数，显⽰关节控制插件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;use_gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏joint_state_publisher节点，发布机器⼈的关节状态 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏robot_state_publisher节点，发布TF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏rviz可视化界⾯ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">type</span>=<span class="string">&quot;rviz&quot;</span> <span class="attr">args</span>=<span class="string">&quot;-d $(find mrobot_description)/config/mrobot_urdf.rviz&quot;</span> <span class="attr">required</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Gazebo仿真显示"><a href="#Gazebo仿真显示" class="headerlink" title="Gazebo仿真显示"></a>Gazebo仿真显示</h2><p>最后将机器人进行调整，实现 Gazebo 软件上的模拟，然后利用 gazebo 生成真实世界场景 <code>world</code> 文件。过程中同样需要修改启动文件：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- gazebo_launcher.launch --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置launch⽂件的参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find mrobot_description)/worlds/playground.world&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏Gazebo仿真环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg world_name)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg paused)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg use_sim_time)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg headless)&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载机器⼈模型描述参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;robot_description&quot;</span> <span class="attr">command</span>=<span class="string">&quot;$(find xacro)/xacro --inorder &#x27;$(find mrobot_description)/urdf/gazebo.urdf.xacro&#x27;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏joint_state_publisher节点，发布机器⼈的关节状态 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;joint_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;joint_state_publisher&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运⾏robot_state_publisher节点，发布TF --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;robot_state_publisher&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;publish_frequency&quot;</span> <span class="attr">type</span>=<span class="string">&quot;double&quot;</span> <span class="attr">value</span>=<span class="string">&quot;50.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 在gazebo中加载机器⼈模型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;urdf_spawner&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;gazebo_ros&quot;</span> <span class="attr">type</span>=<span class="string">&quot;spawn_model&quot;</span> <span class="attr">respawn</span>=<span class="string">&quot;false&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">args</span>=<span class="string">&quot;-urdf -model mrobot -param robot_description&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在使用命令行运行时，出现了以下错误，随即 gazebo 软件崩溃：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VMware: vmw_ioctl_command error Invalid argument.</span><br></pre></td></tr></table></figure><p>解决方案是关闭虚拟机的 3D 硬件加速功能。顺带一提，在 20.04 的虚拟机系统上并未出现崩溃问题。</p><p>最终的渲染效果如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403122222180.png" alt="image-20240312222247078"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-SoftwareEngineering-Task0</title>
      <link href="/p/384b4d9.html"/>
      <url>/p/384b4d9.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本系列文章是 2024 春季学期北航计算机学院本科生课程《软件工程》（嵌入式方向）的实验部分报告，不包含团队大作业项目内容与相关细节</p></blockquote><h1 id="任务0-ROS配置与话题通信"><a href="#任务0-ROS配置与话题通信" class="headerlink" title="任务0-ROS配置与话题通信"></a>任务0-ROS配置与话题通信</h1><h2 id="Ubuntu系统安装"><a href="#Ubuntu系统安装" class="headerlink" title="Ubuntu系统安装"></a>Ubuntu系统安装</h2><p>从<a href="https://bhpan.buaa.edu.cn/link/AA92CF62C0FB0343039DB8C77B5862304D">北航云盘</a>（提取码：0GhE）下载 Ubuntu 18.04 版本系统，因为只有 18.04 对应的 ROS 版本是 <code>melodic</code>，其他的版本有所不同。</p><p>第一步是创建共享文件夹，首先在虚拟机设置—选项中启用共享文件夹，再在虚拟机中挂载文件夹：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t fuse.vmhgfs-fuse .host:/ /mnt/hgfs -o allow_other</span><br></pre></td></tr></table></figure><h2 id="melodic（ROS）安装"><a href="#melodic（ROS）安装" class="headerlink" title="melodic（ROS）安装"></a>melodic（ROS）安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://fishros.com/install -O fishros &amp;&amp; . fishros</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403122044280.png" alt="image-20240312204427183"></p><p>利用鱼香 ROS 安装 ROS 系统，注意安装过程中要选择 <code>melodic</code> 以及 <code>melodic</code>（桌面版）。桌面版有一些可视化的库，在后续展示小车状态时十分有效。</p><p>安装后使用 <code>roscore</code> 指令在终端测试 ROS 是否安装成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~$ roscore</span><br><span class="line">... logging to /home/cookedbear/.ros/log/a0f68c1a-e06e-11ee-9294-000c29175981/roslaunch-ubuntu-36422.<span class="built_in">log</span></span><br><span class="line">Checking <span class="built_in">log</span> directory <span class="keyword">for</span> disk usage. This may take a <span class="keyword">while</span>.</span><br><span class="line">Press Ctrl-C to interrupt</span><br><span class="line">Done checking <span class="built_in">log</span> file disk usage. Usage is &lt;1GB.</span><br><span class="line"></span><br><span class="line">started roslaunch server http://ubuntu:46803/</span><br><span class="line">ros_comm version 1.14.13</span><br></pre></td></tr></table></figure><h2 id="创建ROS项目"><a href="#创建ROS项目" class="headerlink" title="创建ROS项目"></a>创建ROS项目</h2><p>第一步是创建项目工作目录与环境，首先进入 <code>src</code> 文件夹，在终端中运行 <code>catkin_init_workspace</code> 完成初始化，然后回到上一级目录运行 <code>catkin_make</code> 编译建好的工作空间</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> yknb</span><br><span class="line"><span class="built_in">mkdir</span> yknb/src</span><br><span class="line"><span class="built_in">cd</span> yknb/src</span><br><span class="line">catkin_init_workspace</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">catkin_make</span><br><span class="line"><span class="built_in">source</span> ./devel/setup.bash</span><br></pre></td></tr></table></figure><h2 id="ROS节点话题通信"><a href="#ROS节点话题通信" class="headerlink" title="ROS节点话题通信"></a>ROS节点话题通信</h2><p>首先创建功能包，然后使用 Python 语言新建两个脚本，分别执行 <code>Publisher</code> 和 <code>Subscriber</code> 的功能。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catkin_create_pkg iamyk</span><br></pre></td></tr></table></figure><p>Python 代码如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># talker.py</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talker</span>():</span><br><span class="line">    pub = rospy.Publisher(<span class="string">&#x27;chatter&#x27;</span>, String, queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;talker&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>) <span class="comment"># 10hz</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        hello_str = <span class="string">&quot;hello world %s&quot;</span> % rospy.get_time()</span><br><span class="line">        rospy.loginfo(hello_str)</span><br><span class="line">        pub.publish(hello_str)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        talker()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># listener.py</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> std_msgs.msg <span class="keyword">import</span> String</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">callback</span>(<span class="params">data</span>):</span><br><span class="line">    rospy.loginfo(rospy.get_caller_id() + <span class="string">&#x27;I heard %s&#x27;</span>, data.data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listener</span>():</span><br><span class="line"></span><br><span class="line">    <span class="comment"># In ROS, nodes are uniquely named. If two nodes with the same</span></span><br><span class="line">    <span class="comment"># name are launched, the previous one is kicked off. The</span></span><br><span class="line">    <span class="comment"># anonymous=True flag means that rospy will choose a unique</span></span><br><span class="line">    <span class="comment"># name for our &#x27;listener&#x27; node so that multiple listeners can</span></span><br><span class="line">    <span class="comment"># run simultaneously.</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;listener&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    rospy.Subscriber(<span class="string">&#x27;chatter&#x27;</span>, String, callback)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># spin() simply keeps python from exiting until this node is stopped</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    listener()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>两段代码利用 <code>std_msgs.msg</code> 作为传递字符串的载体，由 talker.py 在指定话题中以固定的频率循环发送信息；listener.py 同样加入该话题，并接收发送的 <code>msg</code> 信息，转化为字符串打印在控制台中</p><p>随后修改 <code>CMakeLists.txt</code> 文件，将原本注释的 python 脚本还原，并且加入两个新的脚本：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catkin_install_python(PROGRAMS</span><br><span class="line">  scripts/talker.py</span><br><span class="line">  scripts/listener.py</span><br><span class="line">  DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>设置完毕后，使用 <code>catkin_make</code> 重新编译项目，即可分别在两个命令行中运行两个节点：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rosrun iamyk talker.py</span><br><span class="line">[INFO] [1710258107.379227]: hello world 1710258107.3791575</span><br><span class="line">[INFO] [1710258107.479932]: hello world 1710258107.4797711</span><br><span class="line">[INFO] [1710258107.579850]: hello world 1710258107.5796387</span><br><span class="line">[INFO] [1710258107.679717]: hello world 1710258107.679525</span><br><span class="line">[INFO] [1710258107.780339]: hello world 1710258107.7801197</span><br><span class="line">[INFO] [1710258107.880397]: hello world 1710258107.8802269</span><br><span class="line">[INFO] [1710258107.979713]: hello world 1710258107.9794989</span><br><span class="line">[INFO] [1710258108.079838]: hello world 1710258108.0796237</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rosrun iamyk listener.py</span><br><span class="line">[INFO] [1710258131.381349]: /listener_3772_1710258131254I heard hello world 1710258131.380313</span><br><span class="line">[INFO] [1710258131.482291]: /listener_3772_1710258131254I heard hello world 1710258131.4802547</span><br><span class="line">[INFO] [1710258131.581786]: /listener_3772_1710258131254I heard hello world 1710258131.5797513</span><br><span class="line">[INFO] [1710258131.681842]: /listener_3772_1710258131254I heard hello world 1710258131.6798933</span><br><span class="line">[INFO] [1710258131.781949]: /listener_3772_1710258131254I heard hello world 1710258131.77978</span><br></pre></td></tr></table></figure><p>在节点运行过程中，使用 <code>rosnode</code> 打印节点名、查询详细信息：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rosnode list</span><br><span class="line">/listener_3802_1710258195435</span><br><span class="line">/rosout</span><br><span class="line">/talker_3826_1710258197701</span><br><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rosnode info /talker_3826_1710258197701 </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">Node [/talker_3826_1710258197701]</span><br><span class="line">Publications: </span><br><span class="line"> * /chatter [std_msgs/String]</span><br><span class="line"> * /rosout [rosgraph_msgs/Log]</span><br><span class="line"></span><br><span class="line">Subscriptions: None</span><br><span class="line"></span><br><span class="line">Services: </span><br><span class="line"> * /talker_3826_1710258197701/get_loggers</span><br><span class="line"> * /talker_3826_1710258197701/set_logger_level</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contacting node http://ubuntu:45411/ ...</span><br><span class="line">Pid: 3826</span><br><span class="line">Connections:</span><br><span class="line"> * topic: /chatter</span><br><span class="line">    * to: /listener_3802_1710258195435</span><br><span class="line">    * direction: outbound (38897 - 127.0.0.1:40302) [10]</span><br><span class="line">    * transport: TCPROS</span><br><span class="line"> * topic: /rosout</span><br><span class="line">    * to: /rosout</span><br><span class="line">    * direction: outbound (38897 - 127.0.0.1:40306) [8]</span><br><span class="line">    * transport: TCPROS</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同样可以使用命令行 <code>rostopic</code> 对话题进行相关信息的查阅：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rostopic list</span><br><span class="line">/chatter</span><br><span class="line">/rosout</span><br><span class="line">/rosout_agg</span><br><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rostopic info /chatter</span><br><span class="line">Type: std_msgs/String</span><br><span class="line"></span><br><span class="line">Publishers: </span><br><span class="line"> * /talker_3826_1710258197701 (http://ubuntu:45411/)</span><br><span class="line"></span><br><span class="line">Subscribers: </span><br><span class="line"> * /listener_3802_1710258195435 (http://ubuntu:36141/)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cookedbear@ubuntu:~/Desktop/ros/yknb$ rostopic <span class="built_in">echo</span> /chatter</span><br><span class="line">data: <span class="string">&quot;hello world 1710258298.9224079&quot;</span></span><br><span class="line">---</span><br><span class="line">data: <span class="string">&quot;hello world 1710258299.022878&quot;</span></span><br><span class="line">---</span><br><span class="line">data: <span class="string">&quot;hello world 1710258299.1224391&quot;</span></span><br><span class="line">---</span><br><span class="line">data: <span class="string">&quot;hello world 1710258299.2226434&quot;</span></span><br><span class="line">---</span><br><span class="line">data: <span class="string">&quot;hello world 1710258299.3219335&quot;</span></span><br><span class="line">---</span><br><span class="line">data: <span class="string">&quot;hello world 1710258299.4222023&quot;</span></span><br></pre></td></tr></table></figure><p>接着新建一个 <code>launch</code> 文件夹和 <code>launcher.launch</code> 文件，实现多节点的同时工作：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;iamyk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;iamyk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;talker2&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;iamyk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;listener.py&quot;</span> <span class="attr">name</span>=<span class="string">&quot;listener&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最后使用 <code>rqt_graph</code> 生成节点关系图：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403122347987.png" alt="image-20240312234728955"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-X86汇编程序设计笔记</title>
      <link href="/p/5ed428af.html"/>
      <url>/p/5ed428af.html</url>
      
        <content type="html"><![CDATA[<h1 id="X86汇编程序设计"><a href="#X86汇编程序设计" class="headerlink" title="X86汇编程序设计"></a>X86汇编程序设计</h1><p>本文章是北航计算机学院于 2024 年春季学期开设的一般专业课《X86汇编程序设计》的学习笔记，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！</p><h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="数制及数制间的转换"><a href="#数制及数制间的转换" class="headerlink" title="数制及数制间的转换"></a>数制及数制间的转换</h2><p>开摆！</p><h2 id="二进制数与十六进制数的运算"><a href="#二进制数与十六进制数的运算" class="headerlink" title="二进制数与十六进制数的运算"></a>二进制数与十六进制数的运算</h2><p>开摆！</p><h2 id="ASCII码和BCD码"><a href="#ASCII码和BCD码" class="headerlink" title="ASCII码和BCD码"></a>ASCII码和BCD码</h2><ul><li>BCD 码：用二进制编码的十进制数，每一位数用四位二进制数表示</li><li>ASCII 码：标准码有 128 个字符</li></ul><h1 id="IBM-PC计算机组织"><a href="#IBM-PC计算机组织" class="headerlink" title="IBM-PC计算机组织"></a>IBM-PC计算机组织</h1><p>本节以最基础的 Intel 8086/8088 为例进行学习，8086 的指令为 16 位，8088 为 8 位。</p><p>8088 和 8086 的体系结构和指令系统、指令编码格式、寻址方式完全相同，软件也完全兼容。</p><h2 id="IBM-PC微型计算机的基本结构"><a href="#IBM-PC微型计算机的基本结构" class="headerlink" title="IBM-PC微型计算机的基本结构"></a>IBM-PC微型计算机的基本结构</h2><ul><li>可直接寻址的内存：$2^{20}=1MB$</li><li>地址线有 20 根，但字长只有 16 位</li></ul><h2 id="Intel-8086-CPU-寄存器结构"><a href="#Intel-8086-CPU-寄存器结构" class="headerlink" title="Intel 8086 CPU 寄存器结构"></a>Intel 8086 CPU 寄存器结构</h2><blockquote><p>Intel 8086/8088 CPU 主要由运算器、控制器以及工作寄存器三部分组成</p></blockquote><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器共有 8 个：AX、BX、CX、DX、SP、BP、SI、DI；</p><ul><li>数据寄存器：前四个寄存器，可以拆分为两个 8 位的寄存器，即 AX→AH:AL<ul><li>AX：通常存储计算结果和操作数</li><li><strong>BX：间接寻址时存放基地址</strong></li><li>CX：循环指令、移位指令的计数器</li><li>DX：双字乘除法运算的拓展寄存器；IO 指令中存放 IO 端口的地址</li></ul></li><li>指针寄存器：后四个寄存器，主要用于存放地址（<strong>只有 BP 使用堆栈基地址</strong>）<ul><li>SP：栈指针寄存器，栈生长方式在<a href="#%E5%A0%86%E6%A0%88">堆栈</a>一节再进行详细介绍</li><li>BP：堆栈段的基址指针，<strong>和 BX 作用类似</strong>，用于传递参数</li><li>SI：源变址寄存器，用作寻址的偏移量，不能和 DI 互换，某些指令会<strong>隐含指定</strong>所使用的寄存器</li><li>DI：目的变址寄存器，同上</li></ul></li></ul><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><blockquote><p>段是内存空间的一片区域，表示一个段需要使用段的基地址来进行表示</p></blockquote><p>段寄存器存放对应段的基地址，但因为地址是20位的，所以寄存器仅存放了地址的高16位，具体地址可由低四位的偏移量以及公式推导得来</p><ul><li>段：代码段、数据段、堆栈段、附加段</li><li>寄存器：CS、DS、SS、ES</li></ul><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>指令指针寄存器（IP）是一个专用的 16 位寄存器，它表示的是当前要执行的指令在<strong>代码段</strong>中的偏移地址（也就是实际地址相对于 CS 寄存器的偏移），在可使用的指令中，只有转移指令、子程序调用+返回指令、中断调用+返回指令三类指令能够主动修改 IP 的值。</p><blockquote><p>标志寄存器可以暂且不考虑。</p></blockquote><h2 id="PC机的内存组织"><a href="#PC机的内存组织" class="headerlink" title="PC机的内存组织"></a>PC机的内存组织</h2><blockquote><ul><li>内存大小：20 根地址线 → $2^{20}=1MB$</li><li>单字长 16 位，一个字由 <strong>2 字节</strong>构成</li></ul></blockquote><h3 id="内存地址、字"><a href="#内存地址、字" class="headerlink" title="内存地址、字"></a>内存地址、字</h3><p>在内存的排布中，需要遵守一些规则：</p><ul><li>单字的地址是第 1 个字节的地址</li><li><strong>单字</strong>存放在内存中时，<strong>低字节在低地址一侧，高字节在高地址一侧</strong></li><li><strong>双字</strong>存放在内存中时，<strong>低字在低地址一侧，高字在高地址一侧</strong></li></ul><h3 id="内存地址的分段"><a href="#内存地址的分段" class="headerlink" title="内存地址的分段"></a>内存地址的分段</h3><p>前面提到了，内存地址划分为了段的基地址和段内的偏移地址，实际地址通过这两个地址来进行计算得到。</p><p>考虑到过大的段内地址使得内存分配十分浪费，过小的段内地址会进行频繁的段切换，使用段地址、段内地址均 16 位+二者重叠 12 位的做法能够更好地利用内存空间。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292316091.png" alt="image-20240229231652056"></p><p>在这种分段方法中，总计可以分为 64K 个段，每一段又<strong>最多</strong>能拥有 64KB 的空间，给内存分配带来了灵活性。</p><h3 id="物理地址和逻辑地址"><a href="#物理地址和逻辑地址" class="headerlink" title="物理地址和逻辑地址"></a>物理地址和逻辑地址</h3><p>在 8086 的体系中，也存在物理地址和逻辑地址之分。</p><ul><li>逻辑地址：使用 <code>段地址:段内地址</code> 的格式表示，前后均为 16 位二进制，可以表示地址在程序段中的逻辑位置</li><li>物理地址：没有分页与映射机制，所以直接使用逻辑地址就能得到物理地址（反之也成立）</li></ul><p>物理地址的计算公式如下：<br>$$<br>段地址&lt;&lt;10H+段内地址=物理地址<br>$$<br>在这种地址处理机制下，逻辑地址和分段的灵活性使得一个物理地址可以对应多个逻辑地址</p><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="堆栈结构"><a href="#堆栈结构" class="headerlink" title="堆栈结构"></a>堆栈结构</h3><p>8086 中，堆栈的位置和大小是由 SS 和 SP 寄存器确定的：SS 寄存器保存栈的边界（栈自身增长的极限地址），SP 寄存器保存的是栈边界到当前栈顶地址的偏移量</p><p>也就是说，无论栈发生怎样的变化，SS 寄存器都不会发生改变；数据存取始终在 SS+SP 地址发生；存入数据时 SP 会减少，取出相反</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292336305.png" alt="image-20240229233619270"></p><blockquote><p>在这个图中栈开始从 24100H 存放数据，一致增长到 24080H，SP 寄存器减少了 20H</p></blockquote><h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><p>堆栈的操作遵守 FIFO 规则，操作分为压入和弹出两种，<strong>操作必须以单字为单位进行</strong>，不允许一次操作一个字节/双字。</p><h1 id="寻址方式与指令系统"><a href="#寻址方式与指令系统" class="headerlink" title="寻址方式与指令系统"></a>寻址方式与指令系统</h1><p>汇编语言程序由基本指令与基本伪指令组成，本节仅介绍部分指令</p><p>8086 指令的汇编语言格式与 mips 指令相似；但是机器语言格式区别较为明显，字长不同使得指令的字段变化十分明显。下面将对指令格式、指令系统和简单的寻址方式等进行介绍</p><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="指令的汇编语言格式"><a href="#指令的汇编语言格式" class="headerlink" title="指令的汇编语言格式"></a>指令的汇编语言格式</h3><p>8086/8088 指令由操作码和操作数两部分构成，表示为 <code>OP  DST, SRC</code>。大部分指令有两个操作数，部分指令仅有单个操作数或无操作数。</p><p>当指令无操作数时，操作的对象一般是预定好的。例如 STD 指令无操作数，其功能是设置方向标志寄存器 DF 为 1。</p><h3 id="指令的机器语言格式"><a href="#指令的机器语言格式" class="headerlink" title="指令的机器语言格式"></a>指令的机器语言格式</h3><p>8086/8088 的机器码格式相较于 mips 而言更复杂，一条指令的长度可以是 1-7 个字节，单条指令的前后字节都可能根据指令类型起到不同的作用。</p><p>可以将指令分为三段：操作码字节、寻址方式字节和段超越字节。</p><p>每个指令不一定都含有这三段，但是每一段都能起到对应的说明作用。</p><p><strong>操作码字节</strong></p><p>操作码字节一般只占用一个字节，表示本指令的操作和操作数的地址码。</p><p>根据指令的不同，操作码可以分为两种基本格式：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011008353.png" alt="image-20240301100811199"></p><ul><li>d 位和 s 位分别在两个/一个操作数时有效：<ul><li>d 位（destination）：指定位于寄存器中的操作数是目的操作数（d=1）还是源操作数（d=0）</li><li>s 位（signed）：控制立即数的扩展方式，s=1 时符号拓展、s=0 时零拓展</li></ul></li><li>w 位（word）表示本指令的操作对象是字（w=1）或字节（w=0）</li></ul><p><strong>寻址方式字节</strong></p><p>寻址方式字节表示操作数的寻址方式，通常是指令的第二个字节，其定义如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011013181.png" alt="image-20240301101307105"></p><p>由于 8086/8088 指令中必然有一个操作数为寄存器的值，所以必定会存在寄存器字段。</p><ul><li>mod 位：寻址方式，控制另一个操作数的来源<ul><li>mod=11：寄存器，由 r/m 位控制寄存器编号</li><li>mod=00：直接内存，由 r/m 位控制地址的运算方式</li><li>mod=01/10：计算内存，在mod=00的基础上加上了偏移量（字节/字）</li></ul></li><li>reg 位：指令中所使用寄存器的编号，reg+w → 寄存器<ul><li>操作码字节中的 d 位控制了 reg 所指向的寄存器充当的是什么操作数</li><li>操作码字节中的 w 位控制了 reg 是取整个字还是一个字节</li></ul></li><li>r/m 位：寄存器/内存，根据 mod 位取值确定不同的内容</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011104112.png" alt="image-20240301110403008"></p><blockquote><p>reg 与 r/m（mod=00）时寄存器的取法，需要注意 r/m 与 w 位无关，总是取出整个字</p></blockquote><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011105170.png" alt="image-20240301110501082"></p><blockquote><p>在不同 mod 位的控制下，r/m 位计算地址时的规则（得出的值会用作地址去内存中读出）</p></blockquote><p><strong>段超越字节</strong></p><p><strong>当使用寄存器 BP 寻址时，段寄存器默认为 SS；使用 BX、SI、DI 寻址时，默认为 DS。</strong>若想主动指定段寄存器，可以使用段超越字节。</p><p>段超越字节在操作码字节前，可以在这个字接种指定一个 seg 寄存器，用作后面紧邻指令的段寄存器。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011107923.png" alt="image-20240301110757855"></p><blockquote><p>seg：段寄存器</p><p>00 → ES     01 → CS</p><p>10 → SS     11 → DS</p></blockquote><h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>在寻址方式字节中，简单的介绍了指令寻址的写法，对于完整的 8086/8088 指令而言，总共有三类寻址方式：</p><ul><li>数据相关寻址</li><li>转移、过程调用寻址</li><li>I/O 指令寻址（在<a href="">第八章</a>进行介绍）</li></ul><p>在进行寻址方式的介绍前，有一个我认为需要区别于 mips 的关键点：</p><p>8086/8088 指令大多数都可以直接操作内存，可以直接通过<strong>中括号</strong> <code>[]</code> 将括号内的数字/寄存器值/内存值<strong>转化为地址</strong>，然后直接访问内存取出内存值；而在 mips 中只有 save/load 类指令能操作内存，8086/8088 的自由度要大上不少。注意取偏移时只能使用基址寄存器和变址寄存器（BX、<strong>BP</strong>；SI、DI）</p><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><blockquote><p><strong>立即寻址</strong>指的是指令所需操作数直接包含在指令代码中，通常是一个<strong>常量或常数</strong>。</p><p>常数为 8 位或 16 位</p></blockquote><ul><li>立即寻址方式（立即数）只能出现在源操作数位置，目的操作数可以是寄存器/内存</li><li>立即数的运算需要注意位宽的匹配，不要出现两个操作数位宽不同的情况</li><li>立即数表示方式：<ul><li>常数：直接写在指令中</li><li>常量：先通过伪指令 EQU 定义后，直接在指令中写常量名</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VALUE EQU 512      ; 定义常量 VALUE</span><br><span class="line">MOV AL, 05H</span><br><span class="line">MOV AL, 00000101b</span><br><span class="line">MOV AX, 512</span><br><span class="line">MOV AX, VALUE      ; 直接使用 VALUE 赋值</span><br></pre></td></tr></table></figure><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><blockquote><p>寄存器寻址指的是指令中所需要的操作数来自某个寄存器，存取操作完全在 CPU 内部进行，执行速度快</p><p>可以来自全字寄存器，也可以来自半字寄存器</p></blockquote><p>没有什么好解释的，部分指令虽然不含操作数，但仍可能使用隐含寄存器（PUSHF：PSW 是源寄存器，存入堆栈所在的内存）</p><h3 id="直接-寄存器间接-寄存器相对-基址变址寻址"><a href="#直接-寄存器间接-寄存器相对-基址变址寻址" class="headerlink" title="直接/寄存器间接/寄存器相对/基址变址寻址"></a>直接/寄存器间接/寄存器相对/基址变址寻址</h3><blockquote><p><strong>直接寻址</strong>是指操作数的偏移地址直接在指令中指出的寻址方式。</p><p><strong>寄存器间接寻址</strong>指的是操作数的有效地址 EA 不是位于指令中，而是位于且<strong>仅位于</strong>基址寄存器 BX、BP 或变址寄存器 SI、DI 中。</p><p><strong>寄存器相对寻址</strong>指的是操作数的有效地址 EA 是一个基址/变址寄存器和指令中指定的位移量的和。</p><p><strong>基址变址寻址</strong>指的是操作数的有效地址 EA 是<strong>基址寄存器+变址寄存器</strong>的值</p></blockquote><ul><li>直接：用<strong>立即数</strong>直接在<strong>内存中</strong>取数<ul><li><code>MOV AX, [02000H]</code></li></ul></li><li>寄存器间接：用基址/变址寄存器的值在内存中取数<ul><li><code>MOV AX, [BX]</code></li></ul></li><li>寄存器相对：传统 <code>lw/sw</code>，注意可能是 DS 或 SS<ul><li><code>MOV AX, 10H[SI]</code></li></ul></li><li>基址变址：基址寄存器+变址寄存器<ul><li><code>MOV [BP+DI], [BX][SI]</code>（指令意为从 BX 和 SI 寄存器中取出值，相加得到内存地址，取出值后存入 BP 和 DI 寄存器值的和所指向的内存空间）</li></ul></li></ul><h3 id="转移指令寻址"><a href="#转移指令寻址" class="headerlink" title="转移指令寻址"></a>转移指令寻址</h3><h4 id="标号与过程名"><a href="#标号与过程名" class="headerlink" title="标号与过程名"></a>标号与过程名</h4><p>定义数据的变量/符号实质上确定的使它在数据段内的偏移地址，定义代码段/函数可以使用标号和过程名（标签）</p><ul><li>直接定义了代码段中的偏移值</li></ul><h4 id="段内直接寻址"><a href="#段内直接寻址" class="headerlink" title="段内直接寻址"></a>段内直接寻址</h4><blockquote><p>段内直接寻址是要转向指令实际的有效地址是 IP 寄存器和立即数偏移量之和（PC+offset）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP SHOUT F1   ; 此处即为段内直接寻址，此处代表 F1 与当前 IP 的位移量</span><br></pre></td></tr></table></figure><ul><li>通常是标号、过程名</li><li>条件转移指令只能使用 8 位位移量，不需使用 SHORT 等操作符</li><li>JMP 指令携带 <code>NEAR PTR</code> 或 <code>SHORT</code> 操作符则使用 8 位位移量，否则使用 16 位位移量</li></ul><h4 id="段内间接寻址"><a href="#段内间接寻址" class="headerlink" title="段内间接寻址"></a>段内间接寻址</h4><ul><li>通常是寄存器，或寄存器指向的内存值</li></ul><p>说白了就是 jr，跳转的寄存器中保存的是相对于当前代码段（CS 寄存器）的偏移值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; p1 作为过程名、ADD1 作为变量名</span><br><span class="line">MOV AX, OFFSET p1      ; 让 AX 存放 p1 相对于代码段的偏移</span><br><span class="line">MOV ADD1, AX           ; 把 AX 存放到 ADD1 指向的内存</span><br><span class="line">CALL ADD1              ; 段内间接转移：从 ADD1 指向的地址中取出值，然后作为偏移量转移</span><br><span class="line">MOV BX, OFFSET ADD1    ; 让 BX 存放 ADD1 相对于数据段的偏移</span><br><span class="line">CALL [BX]              ; 以 BX 存放值为地址，取出对应的值，然后作为偏移量转移</span><br></pre></td></tr></table></figure><h4 id="段间寻址"><a href="#段间寻址" class="headerlink" title="段间寻址"></a>段间寻址</h4><p>段间寻址的两种方式与段内寻址类似，只不过需要在偏移/目标地址之外给出转移目标的<strong>段地址</strong>。</p><ul><li>直接寻址使用的标号或过程名需要具有 <code>FAR</code> 属性</li><li>间接寻址的转移地址不再来自寄存器，而是在内存中的一个双字：<ul><li>高字在高地址、低字在低地址</li><li>转移后：低字→IP、高字→CS</li></ul></li></ul><h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>这一节主要介绍 8086/8088 的指令集，接下来的内容会尽量按照课本中给出的顺序记录，同时进行一些内容和示例的精简。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403012122770.png" alt="image-20240301212220732"></p><p>取地址可以使用 OFFSET、SEG 操作符，也可以用 LEA 获取变量的偏移量</p><p>根据地址取值可以使用中括号，，取出指向内存单元的内容</p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>数据传送指令负责把运算过程中所需的数据、地址或立即数传送到寄存器或存储单元中。主要指令有：</p><h4 id="MOV、XCHG"><a href="#MOV、XCHG" class="headerlink" title="MOV、XCHG"></a>MOV、XCHG</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DST, SRC   ; 将 SRC 的内容转移至 DST</span><br><span class="line">XCHG OP1, OP2  ; 交换 OP1 和 OP2</span><br></pre></td></tr></table></figure><ul><li>目的操作数不能为立即数</li><li>源操作数和目的操作数不能同时为内存/段寄存器</li><li>数据位宽必须保持一致，可以使用<strong>操作符进行强制类型转换</strong>（BYTE/WORD/DWORD PTR）</li><li><code>XCHG</code> 指令不允许出现立即数作为操作数</li></ul><h4 id="PUSH、POP"><a href="#PUSH、POP" class="headerlink" title="PUSH、POP"></a>PUSH、POP</h4><p>堆栈操作指令，包括四条指令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH SRC   ; 将 SRC 的值存入栈帧</span><br><span class="line">POP DST    ; 将栈顶的值写入 DST</span><br><span class="line">PUSHF      ; </span><br><span class="line">POPF       ; 将 PSW 的值存入战阵</span><br></pre></td></tr></table></figure><ul><li>8086/8088 的栈帧只能以单字为单位存取</li><li>POP 指令不允许使用 CS 寄存器</li><li>不需手动修改 SP 寄存器的值</li></ul><h4 id="LEA、LDS、LES"><a href="#LEA、LDS、LES" class="headerlink" title="LEA、LDS、LES"></a>LEA、LDS、LES</h4><p>类似于 load 类指令，以上三个指令从指定地址取出值写入寄存器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA  reg, src  ; 完全是 lw，reg 不能是段寄存器</span><br><span class="line">LDS  reg, src  ; 取双字，低字写入 reg 中、高字写入 DS 寄存器中</span><br><span class="line">LES  reg, src  ; 与 LDS 类似，高字写入 ES 寄存器中</span><br></pre></td></tr></table></figure><h4 id="传送指令举例"><a href="#传送指令举例" class="headerlink" title="传送指令举例"></a>传送指令举例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, BL            ; AX 16 位，BL 8 位，两者位宽不匹配</span><br><span class="line">MOV AL, 257           ; 257 实际为 0101H，也就是需要 16 位（WORD）存储，AL 8 位</span><br><span class="line">MOV [BX], 0           ; 0 未指定位宽，必须显式指定是对字节/字操作，正确见下</span><br><span class="line"></span><br><span class="line">MOV BYTE PTR [BX], 0  ; 指定了 [BX] 的内存为 BYTE，此时 0 被视作字节</span><br><span class="line">MOV WORD PTR [BX], 0  ; 同理 WORD</span><br><span class="line"></span><br><span class="line">MOV AX, AX            ; 无实际作用，可以用于延时</span><br><span class="line"></span><br><span class="line">NOP                   ; No Operation，无实际作用</span><br><span class="line"></span><br><span class="line">MOV 02000H, AX        ; 无法将数值存入立即数中</span><br><span class="line">MOV [DX], AL          ; DX 不能作为寻址寄存器，应选用 BX、BP、SI、DI 四者之一</span><br><span class="line">MOV X1+1, AX          ; 对 X1+1 而言，先将变量 X1 解释为地址偏移值，+1 后再执行 MOV 操作</span><br></pre></td></tr></table></figure><h4 id="内存图与传送指令"><a href="#内存图与传送指令" class="headerlink" title="内存图与传送指令"></a>内存图与传送指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 数据定义</span><br><span class="line">X1 DW 02000H</span><br><span class="line">X2 EQU 100</span><br><span class="line">X3 DB &#x27;1&#x27;</span><br><span class="line">X4 DD 12345678H</span><br><span class="line">X5 DD ?</span><br></pre></td></tr></table></figure><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403061509344.png" alt="image-20240306150914232" style="zoom:50%;" /><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 移动操作：X4 → X5 (DD → DD)</span><br><span class="line"></span><br><span class="line">MOV X5, X4              ; 显然不能实现 内存 → 内存，而且不能移动双字</span><br><span class="line"></span><br><span class="line">LEA DI, X5              ; 将 X5 的地址存放在 DI 寄存器中</span><br><span class="line">MOV [DI], WORD PTR X4   ; 仍然有 内存 → 内存 的现象</span><br><span class="line">MOV AX, X4              ; </span><br><span class="line"></span><br><span class="line">MOV AX, WORD PTR X4     ; 先利用 AX 寄存器输送 X4 的低字</span><br><span class="line">MOV [DI], AX            ; 放入 X5 的低字</span><br><span class="line">MOV AX, WORD PTR X4+2   ; 输送 X4 高字</span><br><span class="line">MOV [DI+2], AX          ; 放入 X5 高字</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 移动操作： X3 → X5 (DB → DD)</span><br><span class="line"></span><br><span class="line">MOV X5, X3              ; 显然不能 内存 → 内存</span><br><span class="line"></span><br><span class="line">MOV BYTE PTR X5, X3     ; 仍然在 内存 → 内存</span><br><span class="line"></span><br><span class="line">MOV AL, X3              ; </span><br><span class="line">MOV BYTE PTR X5, AL     ; 实现了 X5 最低字节的覆写</span><br><span class="line"></span><br><span class="line">XOR AL, AL              ; 清零 AL 寄存器</span><br><span class="line">MOV BYTE PTR X5+1, AL   ; 利用 AL 清零剩余字节</span><br><span class="line">MOV BYTE PTR X5+2, AL   ;</span><br><span class="line">MOV BYTE PTR X5+3, AL   ;</span><br><span class="line"></span><br><span class="line">; 间接寻址模式</span><br><span class="line">MOV BX, OFFSET X5       ; 取出 X5 地址偏移</span><br><span class="line">MOV AL, X3              ; 取出 X3 对应的值</span><br><span class="line">MOV [BX], AL            ; 寄存器间接寻址，目标地址 DS + BX</span><br><span class="line"></span><br><span class="line">; 重复三次覆盖高字节</span><br><span class="line">XOP AL, AL</span><br><span class="line">INC BX</span><br><span class="line">MOV [BX], AL</span><br></pre></td></tr></table></figure><p>最后一段的 <code>BX</code> 寄存器一定不能使用 <code>BP</code> 寄存器作为偏移寄存器，因为 <code>[BX]</code> 会以 <code>DS</code> 为基地址，而 <code>[BP]</code> 会以 <code>SS</code> 为基地址，<code>[BP]</code> 会把堆栈已存放的内容覆盖</p><h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="部分标志寄存器"><a href="#部分标志寄存器" class="headerlink" title="部分标志寄存器"></a>部分标志寄存器</h4><ul><li>ZF：若运算结果为 0，则 ZF = 1</li><li>SF：等于运算结果的<strong>符号位</strong></li><li>CF：运算加法（发生进位）或减法（发生借位）时 CF = 1</li><li>OF：运算操作是否溢出，溢出时 OF = 1</li></ul><h4 id="基础算数指令"><a href="#基础算数指令" class="headerlink" title="基础算数指令"></a>基础算数指令</h4><p>只介绍基础的二进制数运算指令，下列指令都需要匹配类型，数据结果存储在 dst 中。加减操作中只有自增自减指令不会影响进位标志（CF）；乘法也会影响标志位</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;  字节、单字运算</span><br><span class="line">ADD  dst, src  ; 直接相加</span><br><span class="line">ADC  dst, src  ; 带进位加，dst = dst + src + CF</span><br><span class="line">INC  opr       ; opr 自增</span><br><span class="line">SUB  dst, src  ; 直接相减</span><br><span class="line">SBB  dst, src  ; 带进位减，dst = dst - src - CF</span><br><span class="line">DEC  opr       ; opr 自减</span><br><span class="line"></span><br><span class="line">MUL  src       ; 无符号数乘法</span><br><span class="line">IMUL  src      ; 有符号数乘法</span><br><span class="line"></span><br><span class="line">DIV  src       ; 无符号数除法，AX / src = AL ······ AH</span><br><span class="line">IDIV  src      ; 有符号数除法</span><br><span class="line"></span><br><span class="line">;  考虑溢出的单字加法，实际上只需考虑进位标志</span><br><span class="line">X  DW ?</span><br><span class="line">Y  DW ?</span><br><span class="line">Z  DD ?</span><br><span class="line"></span><br><span class="line">MOV  DX, 0</span><br><span class="line">MOV  AX, X             ; 将 X 保存在 AX 中</span><br><span class="line">ADD  AX, Y             ; 计算 X + Y</span><br><span class="line">ADC  DX, 0             ; DX 加上进位标志</span><br><span class="line">MOV  WORD PTR Z+2, DX  ; 高字放回</span><br><span class="line">MOV  WORD PTR Z, AX    ; 低字放回</span><br><span class="line"></span><br><span class="line">;  双字减法，最好用竖式</span><br><span class="line">X DD ?</span><br><span class="line">Y DD ?</span><br><span class="line">Z DD ?</span><br><span class="line"></span><br><span class="line">MOV DX, WORD PTR X+2</span><br><span class="line">MOV AX, WORD PTR X     ; 加载高低双字 X</span><br><span class="line">SUB AX, WORD PTR Y     ; 先做低字减法，保留退位</span><br><span class="line">SBB DX, WORD PTR Y+2   ; 带进位标志计算减法</span><br><span class="line">MOV WORD PTR Z+2, DX   ; 高字放回</span><br><span class="line">MOV WORD PTR Z, AX     ; 低字放回</span><br></pre></td></tr></table></figure><ul><li>乘除法操作会对寄存器做隐性的类型匹配，但是<strong>内存操作数不会判断，需要手动声明</strong>！</li><li>乘除法的 OP 不允许是<strong>立即数</strong>，可以为内存或寄存器</li><li>乘法：<ul><li><code>src</code> 为 8 位： <code>AL × src → AX</code></li><li><code>src</code> 为 16 位： <code>AX × src → DX:AX</code> </li></ul></li><li>除法：<ul><li><code>src</code> 为 8 位：<code>AX / src → AL ······AH</code></li><li><code>src</code> 为 16 位：<code>DX:AX / src → AX ······ DX</code></li><li><strong>需要额外注意溢出</strong>：16 位除以 2 位 → 15 位，AL溢出了，程序会产生中断/直接停止</li></ul></li></ul><h4 id="CMP、NEG"><a href="#CMP、NEG" class="headerlink" title="CMP、NEG"></a>CMP、NEG</h4><p>CMP 指令虽然会产生标志位，但是实际上实现的是数值相减，只不过结果并未存入 dst 中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG  opr         ; opr 变为 -opr</span><br><span class="line">CMP  opr1, opr2  ; opr1 - opr2 计算标志位</span><br></pre></td></tr></table></figure><h4 id="CWB、CWD"><a href="#CWB、CWD" class="headerlink" title="CWB、CWD"></a>CWB、CWD</h4><p>这两条指令都将 8 位的数据拓展至 16 位，<code>CBW</code> 指令将 <code>AL</code> <strong>符号扩展</strong>至 <code>AH</code>；类似的，<code>CWD</code> 指令将 <code>AX</code> 中的符号位直接拓展到 <code>DX</code> 寄存器中（结果非 0 即 0FFFF）</p><h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><ul><li>逻辑运算指令：AND、OR、XOR、NOT</li><li>测试指令：TEST</li><li>移位指令：SHL(SHR)、SAL(SAR)、ROL(ROR)、RCL(RCR)</li></ul><p>对逻辑运算指令而言，<code>src</code> 可以是<strong>立即数</strong>（8/16），使用灵活</p><ul><li>数字 → ASCII 数字：<code>OR AL, 030H</code></li><li>大写字母 → 小写字母：<code>OR AL, 020H</code></li></ul><p>对移位指令而言，有下图：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403061836662.png" alt="image-20240306183607598" style="zoom:67%;" /><h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><ul><li>条件转移指令：JA、JB、JE</li><li>无条件转移指令：JMP</li><li>循环指令：LOOP、LOOPZ、LOOPNZ</li><li>调用与返回指令：CALL、RET、RETF</li></ul><p>条件跳转指令 ABE 比较的是两个无符号数的大小，分别对应 Above、Below 和 Equal</p><p>无条件跳转指令相当于 mips 中的 <code>j</code> 指令，需要注意<strong>寻址方式</strong>：</p><ul><li>段内直接转移：<code>JMP NEAR PTR 标号 | JMP SHORT 标号</code>，8 位</li><li>段内间接转移：<code>JMP WORD PTR &lt;REG | MEM&gt;</code></li><li>段间直接转移：<code>JMP FAR PTR 标号</code>，16 位</li><li>段间间接转移：<code>JMP DWORD PTR &lt;REG | MEM&gt;</code></li></ul><p>如果跳标号，就看 SHORT/NEAR/FAR，SHORT 不需要加 PTR</p><p>如果跳寄存器，就看有没有取地址，取了就看 WORD/DWORD PTR，没取就直接用</p><p>循环指令中，使用的循环计数器均为 <code>CX</code> 寄存器，在执行循环体前先更新计数器，LOOP：<code>CX</code> 不为 0 时转移、JCXZ：<code>CX</code> 为 0 时转移</p><p>CALL 指令的执行过程与调用的 dst 相关（四种分类和上面寻址方式一致）：</p><ul><li>段内标号：返回地址偏移值入栈；<code>IP = IP + D16</code></li><li>段内寄存器：返回地址偏移值入栈；<code>IP = dst</code></li><li>段外标号：返回地址段值入栈、偏移值入栈；<code>IP = dst 偏移值</code>；<code>CS = dst 段地址</code></li><li>段外寄存器：返回地址段值入栈、偏移值入栈；<code>IP = EA[15:0]</code>；<code>CS=EA[31:16]</code></li></ul><p>对于 RET 指令而言，执行的完全就是 CALL 的逆过程</p><h1 id="汇编语言程序格式"><a href="#汇编语言程序格式" class="headerlink" title="汇编语言程序格式"></a>汇编语言程序格式</h1><p>本章节介绍 8086/8088 汇编语言中的程序结构、内存布局、指令与伪指令、关键字，以及汇编程序运行过程前/中的调试工作。</p><h2 id="分段式程序结构"><a href="#分段式程序结构" class="headerlink" title="分段式程序结构"></a>分段式程序结构</h2><p>8086 程序在内存中是以分段形式来组织的，程序在执行时会使用<strong>代码段、数据段和堆栈段</strong>。它们统合形成完整的汇编程序。</p><h3 id="程序组成"><a href="#程序组成" class="headerlink" title="程序组成"></a>程序组成</h3><blockquote><p>在汇编语言中，无论是常数、常量、标号、符号名、指令助记符、伪指令、操作符、参数等，都<strong>不区分大小写</strong>。</p></blockquote><ul><li>在命名规则上，标号和符号名都必须以字母或专用字符（<code>?,@,-</code>）开头，当常数以 <code>A-F</code> 开头时，都要在前端补充一个 0，从而与标识符区分</li></ul><p>代码段中的内容由主程序和组过程组成，两者都是统一的过程，需要使用伪指令指定。过程必须有一个名字，当只有主程序时，可以省去命名过程。</p><p>程序起始处的必备内容：初始化 SS、SP、DS 寄存器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, STACK1       ; </span><br><span class="line">MOV SS, AX           ; 初始化栈帧基地址</span><br><span class="line">MOV SP, STACK_BTM    ; 初始化栈帧长度</span><br><span class="line">MOV AX, DATA1        ; </span><br><span class="line">MOV DS, AX           ; 挂载数据段部分</span><br></pre></td></tr></table></figure><p>必备函数：回到 MS-DOS 的命令提示符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXIT:   MOV AX, 4C00H</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><ul><li>向 AH 中放入功能号 <code>4CH</code>，向 AL 中放入返回码 <code>00H</code></li><li>调用 MS-DOS 例程，<code>4C</code> 号功能调用作用是返回命令提示符</li></ul><p>程序终止处的必备内容：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENDMAIN</span><br></pre></td></tr></table></figure><p>END 表示本模块的总结束，后续的内容不会进入汇编，END 后跟着的标号说明本程序的入口是 <code>MAIN</code></p><h2 id="定义程序结构的伪指令"><a href="#定义程序结构的伪指令" class="headerlink" title="定义程序结构的伪指令"></a>定义程序结构的伪指令</h2><h3 id="SEGMENT-amp-END"><a href="#SEGMENT-amp-END" class="headerlink" title="SEGMENT&amp;END"></a>SEGMENT&amp;END</h3><p>在定义段时需要使用 <code>SEGMENT</code> 和 <code>ENDS</code> 指令。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NAME&gt;SEGMENT[对齐类型][组合类型][类别名]</span><br><span class="line">...</span><br><span class="line">&lt;NAME&gt;ENDS</span><br></pre></td></tr></table></figure><ul><li>段名：由用户喜好定义，无特殊限制</li><li>对齐类型：相当于 align，确定了段整体的对齐方式，可选项有BYTE（字节）、WORD（字，2B）、PARA（节，16B）、PAGE（页，256B）</li><li>组合类型：确定段之间的组合方式<ul><li>NONE：缺省，本段独立、不指定组合类型</li><li>PUBLIC：将段名相同的小段<strong>拼接</strong>为一个大段，共用基地址</li><li>COMMON：将段名相同的段覆盖到同一起始地址上</li><li>STACK：说明是堆栈段的一部分，同名段连接为一个连续段<ul><li>SS：连续段的首地址</li><li>SP：最大偏移地址</li></ul></li><li>MEMORY：本段在内存中应定位在所有连接在一起的段的前面</li><li>AT：本段直接以节边界对齐，定位在内存的某个位置</li></ul></li><li>类别名：用引号括起来，程序在连接时会把同名的程序放在连续的内存区中，但仍然属于不同的段；<strong>优先级低于组合类型</strong></li></ul><h3 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h3><p>一种设定指令，告诉汇编器各段应该具体是哪些程序段</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:AAA, DS:BBB, SS:CCC</span><br></pre></td></tr></table></figure><p><code>AAA、BBB、CCC</code> 指的都是某个段的段首地址，用这些地址初始化寄存器（<strong>但实际上并没有将地址放进去</strong>）</p><h3 id="PROC-amp-ENDP"><a href="#PROC-amp-ENDP" class="headerlink" title="PROC&amp;ENDP"></a>PROC&amp;ENDP</h3><blockquote><p>汇编程序中定义的函数（子过程）需要定义为过程。过程通过定义伪指令 <code>PROC</code> 和 <code>ENDP</code> 实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NAME&gt;PROC[NEAR|FAR]</span><br><span class="line">...</span><br><span class="line">RET; 过程的最后一条指令通常为 RET，以返回调用者</span><br><span class="line">&lt;NAME&gt;ENDP</span><br></pre></td></tr></table></figure><p>与标号类似，但是<strong>定义时没有冒号</strong>，<code>NEAR|FAR</code> 定义了过程属性，<code>NEAR</code> 调用时仅压栈 CALL 指令下一条的偏移，<code>FAR</code> 则压栈段地址与偏移；<code>NEAR</code> 过程不修改 <code>RET</code> 指令，<code>FAR</code> 过程将 <code>RET</code> 转化为 <code>RETF</code>，从堆栈弹出两个字充当 IP 和 CS 值</p><h3 id="ORG"><a href="#ORG" class="headerlink" title="ORG"></a>ORG</h3><p>定位伪指令，为某指令、数据指定一个特定的偏移地址，可以使用 ORG 进行限制</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA1SEGMENTPARA AT 0B800H; STRING 在 DATA1 中</span><br><span class="line">ORG2000H; 指定 2000H</span><br><span class="line">STRINGDB&#x27;ABCD&#x27;; 设定首地址 DATA1 距离为 2000H</span><br><span class="line">DATA1ENDS; 也就是 B800H + 2000H → BA000H</span><br></pre></td></tr></table></figure><h3 id="END、NAME、TITLE"><a href="#END、NAME、TITLE" class="headerlink" title="END、NAME、TITLE"></a>END、NAME、TITLE</h3><ul><li>END：出现在每个程序、模块的末尾；若带标号则指明了程序开始执行的入口点</li><li>NAME：模块名</li><li>TITLE：标题名</li></ul><h2 id="数据定义与内存分配"><a href="#数据定义与内存分配" class="headerlink" title="数据定义与内存分配"></a>数据定义与内存分配</h2><h3 id="常数和常量"><a href="#常数和常量" class="headerlink" title="常数和常量"></a>常数和常量</h3><blockquote><p>常数和常量指没有任何属性的纯数值，在汇编过后，这些量都会变成纯二进制数</p></blockquote><p>常数类型：二进制数（B）、八进制数（O）、十进制数（D）、十六进制数（H）</p><p>常量定义：使用伪指令 <code>EQU</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT_ADDREQU2B5H</span><br><span class="line">STACK_BTMEQU$-STACK_AREA</span><br><span class="line">; $ 是当前位置计数器，代表当前的偏移值</span><br></pre></td></tr></table></figure><h3 id="变量与定义"><a href="#变量与定义" class="headerlink" title="变量与定义"></a>变量与定义</h3><blockquote><p>变量的实质是代表存放在内存单元中的数据，这些数据允许程序在运行期间由指令修改。</p></blockquote><p>汇编语言中的变量名代表了存放数据的内存单元的<strong>地址</strong>，可以通过 <code>OFFSET</code> 和 <code>LEA</code> 指令获取变量的地址</p><p>变量的定义使用伪指令 <code>DB、DW、DD、DF、DT</code> 实现（字节、单字、双字、三个字、10Byte 的压缩 BCD） 码</p><p>在汇编中，变量名+1永远只会给偏移地址+1，不会+变量大小</p><ul><li><code>$</code>：地址表达式，指向下一个位置</li><li><code>DUP</code>：重复操作符，</li><li><code>?</code>：不预置任何内容</li><li>字符串表达式：用引号、逗号分配字符串，初始化为字符的 ASCII 码<ul><li>DD、DW 不允许两个以上字符的字符串作为参数</li></ul></li><li>地址表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat_count DUP (operand, ...,operand)</span><br><span class="line">; repeat_count 是正整数常量、整个句子表示重复 operand 的全部内容总共 repeat_count 次</span><br></pre></td></tr></table></figure><h2 id="表达式与操作符"><a href="#表达式与操作符" class="headerlink" title="表达式与操作符"></a>表达式与操作符</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式是操作数的一种，它由常量、变量、寄存器、标号和一些操作符相组合，程序在汇编时会按照一定的优先顺序进行计算得出数值或地址</p><h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>常用的算术操作符有 <code>+, -, *, /, MOD</code>，MOD 是求余数的双目操作符；算术操作的数和结果都必须是整数，除法运算的结果只保留商</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>主要有 <code>AND、OR、XOR、NOT</code> 四个，逻辑操作符是按位操作符，只能用于数字表达式中，需要注意数字的类型匹配</p><h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符对两个表达式进行比较，常数 or 同一段的两个内存地址，结果为真时=0FFFFH，结果为假时=0；主要的几个关系操作符有：EQ、NE、LT、LE、GT、GE，含义见首字母缩写</p><h3 id="数值回送操作符"><a href="#数值回送操作符" class="headerlink" title="数值回送操作符"></a>数值回送操作符</h3><h4 id="TYPE、LENGTH、SIZE"><a href="#TYPE、LENGTH、SIZE" class="headerlink" title="TYPE、LENGTH、SIZE"></a>TYPE、LENGTH、SIZE</h4><ul><li>TYPE 指令用于求出变量、数组的类型，其返回值如下：</li></ul><table><thead><tr><th>变量或标号</th><th>属性</th><th>类型值</th></tr></thead><tbody><tr><td>DB 类型变量</td><td>BYTE</td><td>1</td></tr><tr><td>DW 类型变量</td><td>WORD</td><td>2</td></tr><tr><td>DD 类型变量</td><td>DWORD</td><td>4</td></tr><tr><td>段内标号、过程名</td><td>NEAR</td><td>-1</td></tr><tr><td>段间标号、过程名</td><td>FAR</td><td>-2</td></tr></tbody></table><p>使用时可以充当其他指令的操作数，例如 <code>MOV AL, TYPE VAR</code></p><ul><li>LENGTH 指令用于求出变量名的单元数：使用 DUP 则是 DUP 的次数、未使用则是 1</li><li>SIZE 指令用于求出分配给变量名的字节数</li></ul><h4 id="OFFSET、SEG"><a href="#OFFSET、SEG" class="headerlink" title="OFFSET、SEG"></a>OFFSET、SEG</h4><ul><li>OFFSET 指令计算变量名、标号和过程名的偏移值地址</li><li>SEG 指令计算其所处的段地址</li></ul><h3 id="属性操作符"><a href="#属性操作符" class="headerlink" title="属性操作符"></a>属性操作符</h3><p><code>PTR、段操作符、SHORT、THIS、HIGH、LOW</code> 六种操作符</p><ul><li><code>PTR</code> 的作用是强制说明或转换存储单元的类型为指定的种类，修改视为一次性修改</li><li><code>THIS</code> 为某个变量指定一个<strong>类型</strong>；为一个标号/过程名指定一种<strong>转移距离</strong></li><li>段操作符就是段超越的表示方式</li><li><code>SHORT</code> 操作符说明 <code>JMP</code> 的跳转地址为 8 位偏移量，而不再是 16 位（范围为 <code>IP-128 \~ IP+128</code> 字节）</li><li><code>HIGH</code> 和 <code>LOW</code> 操作符为字节分离操作符，<code>HIGH</code> 说明取出变量的高字节、<code>LOW</code> 同理<ul><li>注意字节分离操作符不能应用于内存操作数（取它们的字节可以使用 <code>BYTE PTR</code>）</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X1EQUTHIS BYTE  ; X1 视为 BYTE 类型的量</span><br><span class="line">MOV AX,ES: [BX][SI];指定数据取自 ES 段</span><br></pre></td></tr></table></figure><h2 id="汇编、连接和运行"><a href="#汇编、连接和运行" class="headerlink" title="汇编、连接和运行"></a>汇编、连接和运行</h2><blockquote><p>接下来的部分是<strong>汇编程序设计</strong>，主要关注 8086/8088 程序的实际操作</p></blockquote><h1 id="数制转换及乘除法"><a href="#数制转换及乘除法" class="headerlink" title="数制转换及乘除法"></a>数制转换及乘除法</h1><blockquote><p>待补充</p></blockquote><h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><blockquote><p>待补充</p></blockquote><h1 id="子程序和跳转表"><a href="#子程序和跳转表" class="headerlink" title="子程序和跳转表"></a>子程序和跳转表</h1><blockquote><p>待补充</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》</title>
      <link href="/p/feaaa974.html"/>
      <url>/p/feaaa974.html</url>
      
        <content type="html"><![CDATA[<h1 id="超低配主播女孩，略显可惜的小品作——《Pricolage-IDOLIZED-》"><a href="#超低配主播女孩，略显可惜的小品作——《Pricolage-IDOLIZED-》" class="headerlink" title="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》"></a>超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》</h1><p>上一次写杂谈还是上一次，<del>疑似在长达半年之前，</del>今天带来的是一个“像素图形”、“解谜”、“剧情丰富”，并且“多半好评”的新作，<a href="https://store.steampowered.com/app/2510890/_Pricolage/">《失踪的偶像 Pricolage》</a>（翻译前的标题在文章题目里）。游戏简介麻烦去 steam 页面自己看了，我这就懒得复制了，全年龄、国区原价33。<a href="https://pan.baidu.com/s/1J5GdvSXKP-aXQNb1VgLP7A?pwd=pfn5">链接</a>放这了，有需要自提。</p><p><strong>这次打算随便写点没营养的，反正也是临时起意。</strong>写了一点游戏的攻略，推不动了也可以找找看看。</p><p><img src="https://cdn.cloudflare.steamstatic.com/steam/apps/2510890/extras/Pricolage_KeyVisual.png?t=1708421482" alt="img"></p><p>总的来说是一个比较可惜的作品，选的主题和操作方法都是不错的，第一眼看上去是有主播女孩的感觉的，但开推之后才发现几乎完全不同，而且在剧情质量和长度上有点拉跨，使得这部作品有点电波的感觉，我甚至不太推荐付费游玩。不过好在它搭载了官中，翻译质量也还说得过去。</p><p>游戏发售在2024年2月19日，我是在21号凌晨达成的全收集，首先一提时长，完全初见大概需要1-3h全收集，这其实主要看的是你在屏幕上点点点的速度，理解上几乎没有任何问题。其次游戏总共有7个结局，1GE，5BE，1TE（至少我认为ED7更现实一点）。我的初见是跟完了一个v的直播，比较细地跑了一整套流程，2.5h进了GE，但说实话其他的结局发展路线几乎一致，3h应该也能全收集。在后续自己跑了一遍整个流程，用了也就不到一个小时。</p><iframe width="560" height="315" src="https://www.youtube.com/embed/ZIY2a1adk0U?si=WHGU8vinFGaxCSlQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>游戏讲的故事相当的简单，但也导致了它叙事性并不是那么强，有相当一部分细节是没有深入解释的。主要的操作是浏览社交媒体“twitgram”上的一些帖子，并且在搜索引擎“Geogle”里找相关的信息，实际上让我想到了很久之前玩的 Replica，也是摆弄一个手机，去发现“对国家安全造成威胁”的罪犯的证据。</p><p><img src="https://pic1.zhimg.com/v2-ba8f7f3eea28c3e3fa9fb66534e55ada_r.jpg?source=1def8aca" alt="img"></p><p>本作也是一样，通过细小的信息去“拼凑”出星娜这个偶像的信息，发现她失踪背后的真相，我觉得拼凑（bricolage）可能和标题的Pricolage是有联系的，过程中的种种信息会影响结局的走向。游戏的内容不太想在这里剧透了，想在这里说说这个游戏给我最直观的优缺点在哪。</p><p>先谈缺点：</p><ul><li>朋友笑夏有点太假了，游戏试着把她塑造成一个前后充满矛盾而苦苦挣扎的人，但做出来却感觉有点在哭惨，整的故事一下就没什么对抗的要素存在了</li><li>剧情有点跳脱，过于巧合，ED1在回复消息的同时就正好碰到常服偶像然后就完事了，多少有点尬</li></ul><p>然后是优点：</p><ul><li>高潮前的动画还蛮有代入感的，纵屏（手机）和横屏（PC与现实）的切换视觉效果还不错，值得肯定</li><li>ED5最后的镜头笑夏的名字被雾气遮挡了，确实也是对她自己当前身份的一个思考，冒充后的属于自己的肉体、性格、灵魂真的还存在吗</li><li>ED7的将错就错更像是对走上错误道路的两人的惩罚，一边自暴自弃直接开摆，另一边想要痛改前非但又被迫成为提线木偶，这里和标题里的IDOLIZED应该也是有关系的，笑夏为了保护朋友被迫走上了“成为偶像”的道路，到现在也彻底没办法刹车了（感觉和ED6的重归于好比起来可好太多了）</li><li>所有ED的名字实际上都没有做本土化（中文和日文都一样），英文的结局名感觉韵味是不错的</li></ul><h1 id="结"><a href="#结" class="headerlink" title="结"></a>结</h1><p>到头来也没写啥有用的，下次<del>开学后有空</del>再见吧朋友们。</p><p><del>我是挺喜欢有个人装成我忙里忙外，最后回来通知我说“我已经彻底被取代了”的，一天天的还赶不上AI有目标，真不如趁早拉倒了。</del></p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译课设编译器设计文档</title>
      <link href="/p/a137a2e9.html"/>
      <url>/p/a137a2e9.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译器设计文档"><a href="#编译器设计文档" class="headerlink" title="编译器设计文档"></a>编译器设计文档</h1><h1 id="文档要求"><a href="#文档要求" class="headerlink" title="文档要求"></a>文档要求</h1><p>请自选一种编译器的源代码进行阅读分析，在此基础上完成总体架构设计，然后在编译器实现的每个阶段完成相应部分的设计文档，格式及内容不限，每个阶段均需写出编码之前的设计，编码完成之后对设计的修改情况。<br>文档包括如下内容：</p><ol><li>参考编译器介绍：总结所阅读的编译器的<strong>总体结构、接口设计、文件组织</strong>等内容</li><li>编译器总体设计：介绍自己的将要实现的编译器的<strong>总体结构、接口设计、文件组织</strong>等内容</li><li>词法分析设计：编码前的设计、编码完成之后的修改</li><li>语法分析设计：编码前的设计、编码完成之后的修改</li><li>错误处理设计：编码前的设计、编码完成之后的修改</li><li>代码生成设计：编码前的设计、编码完成之后的修改</li><li>代码优化设计：编码前的设计、编码完成之后的修改，未选择 MIPS 代码生成的同学无需完成此项内容</li></ol><p>应在各个阶段任务完成相应部分并提交，最终提交一份完整的文档，文档格式为 <strong>pdf</strong> 版本。</p><h1 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h1><p>一个凝练的小编译器 <a href="https://github.com/rswier/c4">c4</a>，实现了词法分析、语法分析、目标代码生成，在 525 行内使用了四个函数（实际上也就是三个大模块 + main 函数）完成对简单 C 语言程序的编译，虽然其中的代码实现比较复杂，但是逻辑相对清晰，能够很直观地理解编译的进程。但是它没有实现错误处理和代码优化（）</p><p>除此之外也参考了许多往届学长的课设代码，大致地了解了编译器的各个模块</p><h1 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>本编译器设计按照主流编译器的编译过程，也就是课程释放的作业顺序编排工作的步骤实现了从 SysC 语言的输入到 mips 汇编语言的输出：</p><blockquote><p><strong>词法分析</strong> → <strong>语法分析</strong> → <strong>语义分析与中间代码生成</strong> → <strong>目标代码生成</strong> → <strong>代码优化</strong></p><p><strong>符号表管理</strong>与<strong>错误处理</strong></p></blockquote><p>这五个主要流程分为前端和后端两部分，前端包括词法分析（核心类为 <code>TokenAnalyzer</code>）、语法分析（核心类为 <code>NodePaeser</code>）、中间代码生成（核心类为 <code>LLCenter</code>），后端包括目标代码生成（核心类为 <code>MipsCenter</code>）和代码优化（实际未进行优化）。</p><h2 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h2><p>总体文件组织如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|   Compiler.java</span><br><span class="line">|   config.json</span><br><span class="line">|</span><br><span class="line">+---exception</span><br><span class="line">|       NoFileException.java</span><br><span class="line">|       StatusCode.java</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">|   |   ErrorChecker.java</span><br><span class="line">|   |   NodeParser.java</span><br><span class="line">|   |   TokenAnalyzer.java</span><br><span class="line">|   |</span><br><span class="line">|   +---ast</span><br><span class="line">|   |       AddExpNode.java</span><br><span class="line">|   |       BlockItemNode.java</span><br><span class="line">|   |       BlockNode.java</span><br><span class="line">|   |       BTypeNode.java</span><br><span class="line">|   |       CompUnitNode.java</span><br><span class="line">|   |       CondNode.java</span><br><span class="line">|   |       ConstDeclNode.java</span><br><span class="line">|   |       ConstDefNode.java</span><br><span class="line">|   |       ConstExpNode.java</span><br><span class="line">|   |       ConstInitValNode.java</span><br><span class="line">|   |       DeclNode.java</span><br><span class="line">|   |       EqExpNode.java</span><br><span class="line">|   |       ExpNode.java</span><br><span class="line">|   |       ForStmtNode.java</span><br><span class="line">|   |       FuncDefNode.java</span><br><span class="line">|   |       FuncFParamNode.java</span><br><span class="line">|   |       FuncFParamsNode.java</span><br><span class="line">|   |       FuncRParamsNode.java</span><br><span class="line">|   |       FuncTypeNode.java</span><br><span class="line">|   |       IdentNode.java</span><br><span class="line">|   |       InitValNode.java</span><br><span class="line">|   |       LAndExpNode.java</span><br><span class="line">|   |       LOrExpNode.java</span><br><span class="line">|   |       LValNode.java</span><br><span class="line">|   |       MainFuncDefNode.java</span><br><span class="line">|   |       MulExpNode.java</span><br><span class="line">|   |       NodeCategory.java</span><br><span class="line">|   |       NumberNode.java</span><br><span class="line">|   |       PrimaryExpNode.java</span><br><span class="line">|   |       RelExpNode.java</span><br><span class="line">|   |       StmtCategory.java</span><br><span class="line">|   |       StmtNode.java</span><br><span class="line">|   |       UnaryExpNode.java</span><br><span class="line">|   |       UnaryOpNode.java</span><br><span class="line">|   |       VarDeclNode.java</span><br><span class="line">|   |       VarDefNode.java</span><br><span class="line">|   |</span><br><span class="line">|   +---shortSymbol</span><br><span class="line">|   |       Function.java</span><br><span class="line">|   |       Symbol.java</span><br><span class="line">|   |       SymbolTable.java</span><br><span class="line">|   |       Var.java</span><br><span class="line">|   |</span><br><span class="line">|   \---token</span><br><span class="line">|           Token.java</span><br><span class="line">|           TokenCategory.java</span><br><span class="line">|</span><br><span class="line">+---llvm</span><br><span class="line">|   |   LLCenter.java</span><br><span class="line">|   |   Visitor.java</span><br><span class="line">|   |</span><br><span class="line">|   +---identifier</span><br><span class="line">|   |       Identifier.java</span><br><span class="line">|   |</span><br><span class="line">|   +---symbol</span><br><span class="line">|   |       Symbol.java</span><br><span class="line">|   |       SymbolTable.java</span><br><span class="line">|   |</span><br><span class="line">|   +---type</span><br><span class="line">|   |       ArrayType.java</span><br><span class="line">|   |       BasicType.java</span><br><span class="line">|   |       BlockType.java</span><br><span class="line">|   |       LabelType.java</span><br><span class="line">|   |       PointerType.java</span><br><span class="line">|   |       Type.java</span><br><span class="line">|   |       TypeList.java</span><br><span class="line">|   |       VoidType.java</span><br><span class="line">|   |</span><br><span class="line">|   \---value</span><br><span class="line">|       |   ArrayValue.java</span><br><span class="line">|       |   BasicBlock.java</span><br><span class="line">|       |   Builder.java</span><br><span class="line">|       |   ConstantValue.java</span><br><span class="line">|       |   FuncFParam.java</span><br><span class="line">|       |   Function.java</span><br><span class="line">|       |   GlobalVar.java</span><br><span class="line">|       |   Use.java</span><br><span class="line">|       |   User.java</span><br><span class="line">|       |   Value.java</span><br><span class="line">|       |</span><br><span class="line">|       \---instruction</span><br><span class="line">|               AllocaInstr.java</span><br><span class="line">|               BinaryInstr.java</span><br><span class="line">|               BitCastInstr.java</span><br><span class="line">|               BranchInstr.java</span><br><span class="line">|               CallInstr.java</span><br><span class="line">|               GepInstr.java</span><br><span class="line">|               IcmpInstr.java</span><br><span class="line">|               InstrType.java</span><br><span class="line">|               Instruction.java</span><br><span class="line">|               JumpInstr.java</span><br><span class="line">|               LoadInstr.java</span><br><span class="line">|               ReturnInstr.java</span><br><span class="line">|               StoreInstr.java</span><br><span class="line">|</span><br><span class="line">+---mips</span><br><span class="line">|   |   Builder.java</span><br><span class="line">|   |   MipsCenter.java</span><br><span class="line">|   |   RegisterFile.java</span><br><span class="line">|   |</span><br><span class="line">|   +---data</span><br><span class="line">|   +---instr</span><br><span class="line">|   |       AbstractInstr.java</span><br><span class="line">|   |       BranchDInstr.java</span><br><span class="line">|   |       CalDInstr.java</span><br><span class="line">|   |       CalSInstr.java</span><br><span class="line">|   |       DataRecord.java</span><br><span class="line">|   |       DataTag.java</span><br><span class="line">|   |       InstrType.java</span><br><span class="line">|   |       JumpInstr.java</span><br><span class="line">|   |       LabelInstr.java</span><br><span class="line">|   |       MemSInstr.java</span><br><span class="line">|   |       PseudoInstruction.java</span><br><span class="line">|   |       Syscall.java</span><br><span class="line">|   |       UtilsSInstr.java</span><br><span class="line">|   |</span><br><span class="line">|   \---operands</span><br><span class="line">|           Imm.java</span><br><span class="line">|           Label.java</span><br><span class="line">|           Operand.java</span><br><span class="line">|           Register.java</span><br><span class="line">|</span><br><span class="line">\---utils</span><br><span class="line">    |   Calculator.java</span><br><span class="line">    |   Logger.java</span><br><span class="line">    |   OutputRecord.java</span><br><span class="line">    |   Pair.java</span><br><span class="line">    |   ParameterParser.java</span><br><span class="line">    |   Settings.java</span><br><span class="line">    |</span><br><span class="line">    \---error</span><br><span class="line">            Error.java</span><br><span class="line">            ErrorType.java</span><br></pre></td></tr></table></figure><p>分功能介绍见文档后续内容</p><h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>各功能部分按照一定的规则输入和输出进行划分，接口供给定义如下：</p><ul><li>工具类：创建文件流，从源文件读入字符串序列；分析参数并创建输出文件</li><li>词法分析：输入为工具类提供的 <code>ArrayList&lt;String&gt;</code> 形式的源文件，输出为语法分析后得到的 <code>ArrayList&lt;Token&gt;</code> 形式的词法单元</li><li>语法分析：输入为词法分析提供的 <code>ArrayList&lt;Token&gt;</code>，输出为语法分析后得到的语法树顶层节点 <code>CompUnitNode</code></li><li>错误处理：输入为语法分析得到的语法树，输出为语法树中存在的语法错误，若存在错误则不进行后续部分，编译程序直接退出</li><li>中间代码生成：输入为语法分析得到的语法树，输出为语法树对应的线性 <code>ArrayList&lt;Value&gt;</code> llvm 指令序列和等价的字符序列</li><li>目标代码生成：输入为中间代码生成得到的 llvm 指令序列，输出为 <code>ArrayList&lt;AbstrctInstruction&gt;</code> 的线性 mips 指令序列和等价字符序列</li><li>代码优化：本编译器不涉及代码优化部分，故不存在相应接口</li></ul><h1 id="工具类设计"><a href="#工具类设计" class="headerlink" title="工具类设计"></a>工具类设计</h1><h2 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---exception</span><br><span class="line">|       NoFileException.java</span><br><span class="line">|       StatusCode.java</span><br><span class="line">|</span><br><span class="line">\---utils</span><br><span class="line">    |   Calculator.java</span><br><span class="line">    |   Logger.java</span><br><span class="line">    |   OutputRecord.java</span><br><span class="line">    |   Pair.java</span><br><span class="line">    |   ParameterParser.java</span><br><span class="line">    |   Settings.java</span><br><span class="line">    |</span><br><span class="line">    \---error</span><br><span class="line">            Error.java</span><br><span class="line">            ErrorType.java</span><br></pre></td></tr></table></figure><h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p><code>utils</code> 包包括了编译器执行过程中需要用到的一些辅助类、保存类和相关的信息。</p><h3 id="utils-Calculator"><a href="#utils-Calculator" class="headerlink" title="utils/Calculator"></a>utils/Calculator</h3><ul><li><code>public static produceConst(Value v1, TokenCategory tc, Value v2)</code> </li></ul><p>按照 TokenCategory 不同，执行在中间代码生成过程中对常数进行对应的优化运算，减少 llvm 指令的条数</p><h3 id="utils-Logger"><a href="#utils-Logger" class="headerlink" title="utils/Logger"></a>utils/Logger</h3><ul><li><code>public static void initLogger()</code></li></ul><p>初始化输入输出文件流，为各功能部分提供对应的写入/读取文件</p><ul><li><code>public static void process(int statusCode, String msg)</code></li></ul><p>编译器运行过程中的相关信息显示，根据不同 <code>statusCode</code> 区分信息级别</p><ul><li><code>public static void printFile(String content, String targetType)</code></li></ul><p>编译器各功能部分对外的输出接口，根据所处的功能阶段不同调用不同的 <code>targetType</code> 进行对应文件的输出</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils/*"></a>utils/*</h3><ul><li><p><code>Settings</code> 类与 <code>Logger</code> 类联动控制文件的输出与否</p></li><li><p><code>Pair</code> 类是一个实现 <code>&lt;K, V&gt;</code> 结构的工具类</p></li><li><p><code>ParameterParser</code> 类实现了对命令行参数的解析，实际测评无用，可供课下测试使用</p></li><li><p><code>OutputRecord</code> 类已弃用</p></li><li><p>软件包 <code>error</code> 存放运行时产生的错误种类，供 <code>Logger</code> 进行信息级别区分和输出</p></li></ul><h3 id="exception"><a href="#exception" class="headerlink" title="exception/*"></a>exception/*</h3><ul><li>本软件包提供具体的错误类，可加入更具体的错误信息供 <code>Logger</code> 输出</li></ul><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，解析参数并初始化设置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* Init */</span></span><br><span class="line">   <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123; ParameterParser.setParameter(args); &#125;</span><br><span class="line">Logger.initLogger();</span><br></pre></td></tr></table></figure><h1 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h1><h2 id="文件组织-2"><a href="#文件组织-2" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   TokenAnalyzer.java</span><br><span class="line">    |</span><br><span class="line">    \---token</span><br><span class="line">            Token.java</span><br><span class="line">            TokenCategory.java</span><br></pre></td></tr></table></figure><h2 id="具体设计-1"><a href="#具体设计-1" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-TokenAnalyzer"><a href="#frontend-TokenAnalyzer" class="headerlink" title="frontend/TokenAnalyzer"></a>frontend/TokenAnalyzer</h3><p>词法分析的核心类，采用单例模式进行调用。关键处理点在于通过字符的移动和匹配对当前的短语进行匹配，匹配成功后形成对应的 Token，存入短语集合中，供后续词法分析使用。</p><ul><li><code>public int getChar(BufferedInputStream buffer)</code> ：从输入字符串中获取下一个字符，进行后续匹配</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChar</span><span class="params">(BufferedInputStream buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = buffer.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public ArrayList&lt;Token&gt; getToken(BufferedInputStream buffer)</code>：解析核心函数，通过对输入字符串的逐字符判断，进入不同的解析方法得出具体单词，最终返回解析得到的 token 序列</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;Token&gt; <span class="title function_">getToken</span><span class="params">(BufferedInputStream buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> getChar(buffer);</span><br><span class="line"><span class="keyword">while</span> (cha != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">/* 排除注释 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;\n&#x27;</span> || Character.isWhitespace((<span class="type">char</span>) cha)) &#123; </span><br><span class="line">            <span class="comment">/* 排除空白符、换行符 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析字符串 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析等号、逻辑等 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">         <span class="comment">/* 解析逻辑非 */</span>   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&gt;&#x27;</span> || (<span class="type">char</span>) cha == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析比较运算符 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&amp;&#x27;</span> || ((<span class="type">char</span>) cha == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析逻辑与、或 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLetter((<span class="type">char</span>) cha) || (<span class="type">char</span>) cha == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析标识符 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tk</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">            <span class="keyword">switch</span> (tk) &#123; </span><br><span class="line">                <span class="comment">/* 解析关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;main&quot;</span> -&gt; <span class="comment">/* 解析 main 关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;const&quot;</span> -&gt; <span class="comment">/* 解析 const 关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;int&quot;</span> -&gt; <span class="comment">/* 解析 int 关键字 */</span></span><br><span class="line">                <span class="comment">/* 解析其他关键字 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 其余解析逻辑 */</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析其余语法成分，如各类括号、分号等 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="frontend-token"><a href="#frontend-token" class="headerlink" title="frontend/token/*"></a>frontend/token/*</h3><ul><li>Token 类是保存短语单元的对象类，保存了当前词的详细信息（类型、字符串、所在行数）</li><li>TokenCategory 类是枚举类，用于保存所有可能出现的 token 种类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> frontend.token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenCategory</span> &#123;</span><br><span class="line">    IDENFR, INTCON, STRCON,</span><br><span class="line">    MAINTK, CONSTTK, INTTK, BREAKTK, CONTINUETK, VOIDTK, IFTK, ELSETK, FORTK,</span><br><span class="line">    NOT, AND, OR, PLUS, MINU, MULT, DIV, MOD,</span><br><span class="line">    GETINTTK, PRINTFTK, RETURNTK,</span><br><span class="line">    LSS, LEQ, GRE, GEQ, EQL, NEQ, ASSIGN,</span><br><span class="line">    SEMICN, COMMA, LPARENT, RPARENT, LBRACK, RBRACK, LBRACE, RBRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Compiler-1"><a href="#Compiler-1" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，产生一个 <code>ArrayList&lt;Token&gt;</code> 供语法分析解析</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lexer */</span></span><br><span class="line">ArrayList&lt;Token&gt; tokenList = TokenAnalyzer.getInstance().getToken(Logger.getSource());</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">tokenList.forEach(i -&gt; tokens.append(i.toString()));</span><br><span class="line">Logger.printFile(tokens.toString(), <span class="string">&quot;lexer&quot;</span>); <span class="comment">// printToken(tokenList);</span></span><br></pre></td></tr></table></figure><h1 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h1><h2 id="文件组织-3"><a href="#文件组织-3" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   NodeParser.java</span><br><span class="line">    |</span><br><span class="line">    +---ast</span><br><span class="line">            AddExpNode.java</span><br><span class="line">            BlockItemNode.java</span><br><span class="line">            BlockNode.java</span><br><span class="line">            BTypeNode.java</span><br><span class="line">            CompUnitNode.java</span><br><span class="line">            CondNode.java</span><br><span class="line">            ConstDeclNode.java</span><br><span class="line">            ConstDefNode.java</span><br><span class="line">            ConstExpNode.java</span><br><span class="line">            ConstInitValNode.java</span><br><span class="line">            DeclNode.java</span><br><span class="line">            EqExpNode.java</span><br><span class="line">            ExpNode.java</span><br><span class="line">            ForStmtNode.java</span><br><span class="line">            FuncDefNode.java</span><br><span class="line">            FuncFParamNode.java</span><br><span class="line">            FuncFParamsNode.java</span><br><span class="line">            FuncRParamsNode.java</span><br><span class="line">            FuncTypeNode.java</span><br><span class="line">            IdentNode.java</span><br><span class="line">            InitValNode.java</span><br><span class="line">            LAndExpNode.java</span><br><span class="line">            LOrExpNode.java</span><br><span class="line">            LValNode.java</span><br><span class="line">            MainFuncDefNode.java</span><br><span class="line">            MulExpNode.java</span><br><span class="line">            NodeCategory.java</span><br><span class="line">            NumberNode.java</span><br><span class="line">            PrimaryExpNode.java</span><br><span class="line">            RelExpNode.java</span><br><span class="line">            StmtCategory.java</span><br><span class="line">            StmtNode.java</span><br><span class="line">            UnaryExpNode.java</span><br><span class="line">            UnaryOpNode.java</span><br><span class="line">            VarDeclNode.java</span><br><span class="line">            VarDefNode.java</span><br></pre></td></tr></table></figure><h2 id="具体设计-2"><a href="#具体设计-2" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-NodeParser"><a href="#frontend-NodeParser" class="headerlink" title="frontend/NodeParser"></a>frontend/NodeParser</h3><p>语法分析核心类，采用单例模式调用。通过逐个读取 token 的内容来进行语法树的构建。</p><ul><li><code>private Token matchToken(TokenCategory tokenCategory)</code>：读取 token 的函数，如果待取出的 token 和预想的种类不同就不进行取出，同时具有一定的错误处理能力</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Token <span class="title function_">matchToken</span><span class="params">(TokenCategory tokenCategory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token.getTokenCategory() == tokenCategory) &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">temp</span> <span class="operator">=</span> token;</span><br><span class="line">        getToken();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(tokenCategory) &#123;</span><br><span class="line">                <span class="comment">/* 处理 ijk 三种错误处理类型 */</span></span><br><span class="line">            <span class="keyword">case</span> SEMICN  -&gt; </span><br><span class="line">            <span class="keyword">case</span> RPARENT -&gt; </span><br><span class="line">            <span class="keyword">case</span> RBRACK  -&gt; </span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                Logger.process(StatusCode.UNEXPECTED_TOKEN_ERROR, <span class="string">&quot;Match utils.error frontend.token &quot;</span> + token.getToken() + <span class="string">&quot; at line &quot;</span> + lineCount);</span><br><span class="line">                Logger.exit(StatusCode.UNEXPECTED_TOKEN_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public CompUnitNode compUnitNode()</code>：解析 <code>compUnit</code> 节点，也就是语法树的根节点，通过逐层调用内部函数来进行语法成分的解析，每一个相对应的函数都会返回一个和函数名相同的类型的对象，其余函数完全按照语法树进行解析即可，不再占用篇幅展示</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompUnitNode <span class="title function_">compUnitNode</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;DeclNode&gt; declNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;FuncDefNode&gt; funcDefNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    MainFuncDefNode mainFuncDefNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not main &amp;&amp; func: int function &#x27;(&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (!peekAt(<span class="number">2</span>).getTokenCategory().equals(TokenCategory.LPARENT)) &#123;</span><br><span class="line">        declNodes.add(declNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not main: int &#x27;main&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(!peekAt(<span class="number">1</span>).getTokenCategory().equals(TokenCategory.MAINTK)) &#123;</span><br><span class="line">        funcDefNodes.add(funcDefNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main: left choice</span></span><br><span class="line">    mainFuncDefNode = mainFuncDefNode();</span><br><span class="line"></span><br><span class="line">    outputs.add(<span class="keyword">new</span> <span class="title class_">OutputRecord</span>(NodeCategory.CompUnit));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompUnitNode</span>(declNodes, funcDefNodes, mainFuncDefNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="frontend-ast"><a href="#frontend-ast" class="headerlink" title="frontend/ast/*"></a>frontend/ast/*</h3><p><code>ast</code> 软件包内包含了所有在核心类 <code>NodeParser</code> 中创建的节点类，同时对应了语法文档中的非终结符，文档中以较为复杂的 <code>StmtNode</code>，也就是语法中的 <code>Stmt</code> 作为示例进行说明</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StmtNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LValNode lValNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExpNode expNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ExpNode&gt; expNodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockNode blockNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CondNode condNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;StmtNode&gt; stmtNodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ForStmtNode forStmtNode1, forStmtNode2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Token tokenCategory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String formatString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StmtCategory stmtCategory;</span><br><span class="line">    <span class="keyword">private</span> Token ifTk, elseTk, forTk;</span><br><span class="line">    <span class="keyword">private</span> Token lp, rp;</span><br><span class="line">    <span class="keyword">private</span> Token eq, semicolon, semicolon2;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Token&gt; comma;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据不同的 Stmt 使用不同的构造函数，赋值内容省略 */</span></span><br><span class="line">    <span class="comment">/* Stmt -&gt; LVal &#x27;=&#x27; Exp &#x27;;&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(LValNode lValNode, ExpNode expNode, Token eq, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; [Exp] &#x27;;&#x27;  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ExpNode expNode, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; Block  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(BlockNode blockNode)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt] */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ArrayList&lt;StmtNode&gt; stmtNodes,</span></span><br><span class="line"><span class="params">                    Token ifTk, Token elseTk, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ArrayList&lt;StmtNode&gt; stmtNodes,</span></span><br><span class="line"><span class="params">                    ForStmtNode forStmtNode1, ForStmtNode forStmtNode2,</span></span><br><span class="line"><span class="params">                    Token forTk, Token semicolon, Token semicolon2, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ForStmtNode forStmtNode2, ArrayList&lt;StmtNode&gt; stmtNodes, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** Stmt -&gt; &#x27;break&#x27; &#x27;;&#x27; &amp; &#x27;continue&#x27; &#x27;;&#x27;</span></span><br><span class="line"><span class="comment">      * for break; continue; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(Token tokenCategory, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;return&#x27; [Exp] &#x27;;&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ExpNode expNode, Token tokenCategory, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; LVal &#x27;=&#x27; &#x27;getint&#x27; &#x27;(&#x27; &#x27;)&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(LValNode lValNode, Token tokenCategory, Token eq, Token lp,</span></span><br><span class="line"><span class="params">                    Token rp, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;printf&#x27; &#x27;(&#x27; FormatString &#123; &#x27;,&#x27; Exp &#x27;)&#x27; &#x27;;&#x27; &#125; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ArrayList&lt;ExpNode&gt; expNodes, Token tokenCategory, String formatString,</span></span><br><span class="line"><span class="params">                    ArrayList&lt;Token&gt; comma, Token lp, Token rp, Token semicolon, <span class="type">int</span> line)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* getter、setter、代码生成相关方法省略 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 语法树输出函数，省略部分种类分支 */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">switch</span> (stmtCategory) &#123;</span><br><span class="line">            <span class="keyword">case</span> LVal -&gt; &#123;</span><br><span class="line">                sb.append(lValNode);</span><br><span class="line">                sb.append(eq);</span><br><span class="line">                sb.append(expNode);</span><br><span class="line">                sb.append(semicolon);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Exp -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Block -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> If -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> For -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Continue, Break -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Return -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> GetInt -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Printf -&gt; &#123;</span><br><span class="line">                sb.append(tokenCategory).append(lp).append(<span class="string">&quot;STRCON &quot;</span>).append(formatString).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; expNodes.size(); i++) &#123;</span><br><span class="line">                    sb.append(comma.get(i)).append(expNodes.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(rp).append(semicolon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;&quot;</span>).append(NodeCategory.Stmt).append(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在语法分析部分结束后，会形成一个以 <code>CompUnitNode</code> 为根节点的语法树，每个非叶节点都含有语法成分对应的子节点对象，输出语法树成分时调用递归的 <code>toString</code> 函数即可全部输出</p><h3 id="Compiler-2"><a href="#Compiler-2" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，返回一个 CompUnitNode 供错误处理和中间代码生成使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Parser */</span></span><br><span class="line">   NodeParser.getInstance().setTokenList(tokenList);</span><br><span class="line">   <span class="type">CompUnitNode</span> <span class="variable">compUnit</span> <span class="operator">=</span> NodeParser.getInstance().compUnitNode();</span><br><span class="line"></span><br><span class="line">   Logger.printFile(compUnit.toString(), <span class="string">&quot;parser&quot;</span>); <span class="comment">// printOutputs(compUnit.toString());</span></span><br></pre></td></tr></table></figure><h1 id="错误处理设计"><a href="#错误处理设计" class="headerlink" title="错误处理设计"></a>错误处理设计</h1><h2 id="文件组织-4"><a href="#文件组织-4" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   ErrorChecker.java</span><br><span class="line">    |</span><br><span class="line">    +---shortSymbol</span><br><span class="line">            Function.java</span><br><span class="line">            Symbol.java</span><br><span class="line">            SymbolTable.java</span><br><span class="line">            Var.java</span><br></pre></td></tr></table></figure><h2 id="具体设计-3"><a href="#具体设计-3" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-ErrorChecker"><a href="#frontend-ErrorChecker" class="headerlink" title="frontend/ErrorChecker"></a>frontend/ErrorChecker</h3><p>错误处理的核心类，采用单例模式调用。对可能出现错误的 ast 语法类和其父类，都编写了相应的 Error 函数，递归调用到指定的对象中检查是否存在错误，如对变量可能的重定义错误，设置了如下函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 变量声明: VarDecl → BType VarDef &#123; &#x27;,&#x27; VarDef &#125; &#x27;;&#x27; // i */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">varDeclError</span><span class="params">(VarDeclNode node)</span> &#123;</span><br><span class="line">    node.getVarDefNodes().forEach(<span class="built_in">this</span>::varDefError); <span class="comment">/* 递归调用 varDefError 检查每个 VarDefNode 是否含有错误*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量定义: VarDef → Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; // b</span></span><br><span class="line"><span class="comment"> *                  | Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; &#x27;=&#x27; InitVal // k*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">varDefError</span><span class="params">(VarDefNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (existNow(node.getIdentNode().getIdent())) &#123;</span><br><span class="line">        <span class="comment">/* 已经存在同名符号声明，记录当前错误 ErrorType.NameRedefinition 并返回 */</span></span><br><span class="line">        insert(<span class="keyword">new</span> <span class="title class_">Error</span>(node.getIdentNode().getLineCount(), ErrorType.NameRedefinition));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    node.getConstExpNodes().forEach(<span class="built_in">this</span>::constExpError);</span><br><span class="line">    tables.get(tables.size() - <span class="number">1</span>).add(node.getIdentNode().getIdent(),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">Var</span>(node.getIdentNode().getIdent(), node.getConstExpNodes().size(), <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">if</span> (node.getInitValNode() != <span class="literal">null</span>) &#123;</span><br><span class="line">        initValError(node.getInitValNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的语法类同理，均为逐层调用函数进行错误的检查</p><h3 id="frontend-shortSymbol"><a href="#frontend-shortSymbol" class="headerlink" title="frontend/shortSymbol/*"></a>frontend/shortSymbol/*</h3><p><code>shortSymbol</code> 软件包主要作用为建立错误处理时使用的符号表，该符号表包含的信息要少于代码生成时使用的符号表，结构也相对简单</p><ul><li><code>SymbolTable</code> 类是符号表类，创建一个可以存放当前层符号的表，内部符号使用 <code>HashMap&lt;String, Symbol&gt;</code> 进行管理，便于快速查找；同时提供了查找、插入等操作函数，供错误处理核心类调用对是否发生错误进行判断</li><li><code>Symbol</code> 类是符号类，仅包含标识符名，<code>Var</code> 和 <code>Function</code> 两个类对其进行继承，分别代表当前符号表管理区域中的变量声明和函数声明，两个类的对象都要存放在符号表的 <code>HashMap</code> 中管理</li></ul><h3 id="Compiler-3"><a href="#Compiler-3" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，调用错误处理类单例进行解析并输出，如果存在错误则使用 <code>Logger</code> 终止编译程序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Error */</span></span><br><span class="line">   ErrorChecker.getInstance().compUnitError(compUnit);</span><br><span class="line">   Logger.printFile(ErrorChecker.getInstance().getErrors(), <span class="string">&quot;error&quot;</span>); <span class="comment">// printErrors(ErrorChecker.getInstance().getErrors());</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Logger.hasError) &#123; Logger.exit(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure><h1 id="中间代码生成设计"><a href="#中间代码生成设计" class="headerlink" title="中间代码生成设计"></a>中间代码生成设计</h1><h2 id="文件组织-5"><a href="#文件组织-5" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---llvm</span><br><span class="line">    |   LLCenter.java</span><br><span class="line">    |   Visitor.java</span><br><span class="line">    |</span><br><span class="line">    +---identifier</span><br><span class="line">    |       Identifier.java</span><br><span class="line">    |</span><br><span class="line">    +---symbol</span><br><span class="line">    |       Symbol.java</span><br><span class="line">    |       SymbolTable.java</span><br><span class="line">    |</span><br><span class="line">    +---type</span><br><span class="line">    |       ArrayType.java</span><br><span class="line">    |       BasicType.java</span><br><span class="line">    |       BlockType.java</span><br><span class="line">    |       LabelType.java</span><br><span class="line">    |       PointerType.java</span><br><span class="line">    |       Type.java</span><br><span class="line">    |       TypeList.java</span><br><span class="line">    |       VoidType.java</span><br><span class="line">    |</span><br><span class="line">    \---value</span><br><span class="line">        |   ArrayValue.java</span><br><span class="line">        |   BasicBlock.java</span><br><span class="line">        |   Builder.java</span><br><span class="line">        |   ConstantValue.java</span><br><span class="line">        |   FuncFParam.java</span><br><span class="line">        |   Function.java</span><br><span class="line">        |   GlobalVar.java</span><br><span class="line">        |   Use.java</span><br><span class="line">        |   User.java</span><br><span class="line">        |   Value.java</span><br><span class="line">        |</span><br><span class="line">        \---instruction</span><br><span class="line">                AllocaInstr.java</span><br><span class="line">                BinaryInstr.java</span><br><span class="line">                BitCastInstr.java</span><br><span class="line">                BranchInstr.java</span><br><span class="line">                CallInstr.java</span><br><span class="line">                GepInstr.java</span><br><span class="line">                IcmpInstr.java</span><br><span class="line">                InstrType.java</span><br><span class="line">                Instruction.java</span><br><span class="line">                JumpInstr.java</span><br><span class="line">                LoadInstr.java</span><br><span class="line">                ReturnInstr.java</span><br><span class="line">                StoreInstr.java</span><br></pre></td></tr></table></figure><h2 id="具体设计-4"><a href="#具体设计-4" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="llvm-LLCenter"><a href="#llvm-LLCenter" class="headerlink" title="llvm/LLCenter"></a>llvm/LLCenter</h3><p><code>LLCenter</code> 类是生成中间代码时的中控类，编译过程中产生的 llvm 指令都会存放在中控类中，并指导进行输出，同时存放 llvm 产生的函数和全局变量，生成复杂的全局函数/变量表</p><ul><li><code>public static void initFunction()</code>：初始化函数表，添加四个库函数</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Function</span> <span class="variable">getInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.I32_TYPE, <span class="string">&quot;getint&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">Function</span> <span class="variable">putint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putint&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(TypeList.I32_TYPE, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="type">Function</span> <span class="variable">putch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putch&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(TypeList.I32_TYPE, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Function</span> <span class="variable">putstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putstr&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(<span class="keyword">new</span> <span class="title class_">PointerType</span>(TypeList.I8_TYPE), <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;getint&quot;</span>, getInt);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putint&quot;</span>, putint);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putch&quot;</span>, putch);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putstr&quot;</span>, putstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="llvm-Vistor"><a href="#llvm-Vistor" class="headerlink" title="llvm/Vistor"></a>llvm/Vistor</h3><p><code>Vistor</code> 类是 llvm 生成过程中重要的类，从语法树的根节点开始，开始逐级调用传递 Vistor 的 visit 函数，并在 visit 函数中解析语法结构，生成语法树对应的 llvm 语句。Vistor 类主要在遍历过程中存放当前处理的上下文信息，如是否在函数中、循环层数、基本块信息和跳转目标地址等。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Vistor 类部分信息字段 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Visitor</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">blockCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">loopDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;BasicBlock&gt; continueBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;BasicBlock&gt; breakBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Function currentFunction;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SymbolTable</span> <span class="variable">currentTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>();  <span class="comment">/* Add an initial table without parent */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, GlobalVar&gt; globalVarTable = LLCenter.globalVarTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Function&gt; functionTable = LLCenter.functionTable;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Builder.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isGlobal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">inFuncDef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFillValue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h3 id="llvm-identifier"><a href="#llvm-identifier" class="headerlink" title="llvm/identifier/*"></a>llvm/identifier/*</h3><ul><li><code>identifier</code> 软件包只含有一个 <code>Identifier</code> 类，存放 llvm 指令的序号、标识等信息，标识的产生并不重复，由 Vistor 在遍历语法树的过程中产生</li></ul><h3 id="llvm-symbol"><a href="#llvm-symbol" class="headerlink" title="llvm/symbol/*"></a>llvm/symbol/*</h3><ul><li><code>symbol</code> 软件包存放了代码生成过程中用到的符号结构和符号表结构，只有变量/常量会使用此类，当 vistor 发现一个对象的定义时就创建一个 <code>Symbol</code> 对象存放在 vistor 携带的 <code>SymbolTable</code> 实例中</li></ul><h3 id="llvm-type"><a href="#llvm-type" class="headerlink" title="llvm/type/*"></a>llvm/type/*</h3><ul><li><code>type</code> 软件包包含了llvm 指令对象的种类，包含基本类型（<code>i32</code>、<code>i1</code>）、指针类型（<code>i32*</code>）、数组类型（<code>[a x i32]</code>）和空类型，每一个 llvm 的 value 都拥有其对应的 type</li></ul><h3 id="llvm-value"><a href="#llvm-value" class="headerlink" title="llvm/value/*"></a>llvm/value/*</h3><ul><li><code>value</code> 软件包包含了 llvm 的绝大部分指令，“万物皆 value”，本编译器首先将 value 的指令划分出来形成一个独立的软件包 <code>instruction</code>，其余的 value 直接形成文件（数组量ArrayValue、基本块BasicBlock、常值量ConstantValue、函数形参FuncFParam、 函数Function、全局变量GlobalVar），并形成一个工厂类Builder负责在 vistor 遍历时产生 llvm 指令插入到 LLCenter 中。</li><li><code>instruction</code> 软件包包含了 llvm 最终生成时的所有可见指令，继承 <code>Instruction</code> 类，并持有一个枚举类选择指令的类型与功能，最后重写指令的 <code>toString</code> 方法便于最后部分对指令进行输出</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">InstrType</span> &#123;</span><br><span class="line">    ADD(<span class="string">&quot;add&quot;</span>), SUB(<span class="string">&quot;sub&quot;</span>), MUL(<span class="string">&quot;mul&quot;</span>), DIV(<span class="string">&quot;sdiv&quot;</span>), REM(<span class="string">&quot;srem&quot;</span>),</span><br><span class="line">    BR(<span class="string">&quot;br&quot;</span>), CALL(<span class="string">&quot;call&quot;</span>), RET(<span class="string">&quot;ret&quot;</span>),</span><br><span class="line">    ALLOCA(<span class="string">&quot;alloca&quot;</span>), STORE(<span class="string">&quot;store&quot;</span>), LOAD(<span class="string">&quot;load&quot;</span>), GEP(<span class="string">&quot;getelementptr&quot;</span>),</span><br><span class="line">    ZEXT(<span class="string">&quot;zext&quot;</span>),</span><br><span class="line">    EQ(<span class="string">&quot;icmp eq&quot;</span>), NE(<span class="string">&quot;icmp ne&quot;</span>), SGT(<span class="string">&quot;icmp sgt&quot;</span>),</span><br><span class="line">    SGE(<span class="string">&quot;icmp sge&quot;</span>), SLT(<span class="string">&quot;icmp slt&quot;</span>), SLE(<span class="string">&quot;icmp sle&quot;</span>),</span><br><span class="line">    <span class="comment">/* temp no usage */</span></span><br><span class="line">    ICMP(<span class="string">&quot;icmp&quot;</span>), AND(<span class="string">&quot;and&quot;</span>), OR(<span class="string">&quot;or&quot;</span>), NOR(<span class="string">&quot;nor&quot;</span>), NOT(<span class="string">&quot;not&quot;</span>), BITCAST(<span class="string">&quot;bitcast&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line">    InstrType(String typeName) &#123; <span class="built_in">this</span>.typeName = typeName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> typeName; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="frontend-ast-1"><a href="#frontend-ast-1" class="headerlink" title="frontend/ast/*"></a>frontend/ast/*</h3><ul><li>语法树类中在 llvm 部分为每个语法结构都添加了 <code>visit</code> 函数用于访问并生成 llvm 代码，以条件表达式为例，进行短路求值的构造：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CondNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock)</span> &#123;</span><br><span class="line">    <span class="comment">/* thenBlock 为成立时跳转块，elseBlock 为不成立时的跳转块 */</span></span><br><span class="line">    <span class="keyword">return</span> lOrExpNode.visit(visitor, thenBlock, elseBlock, visitor.getBlock());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LOrExpNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock, BasicBlock andBlock)</span> &#123;</span><br><span class="line">    <span class="comment">/* only process same level branch */</span></span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> andBlock;</span><br><span class="line">    visitor.setBlock(currentBlock);</span><br><span class="line">    <span class="keyword">if</span> (or == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 单一 &amp;&amp; 判断，不需进行短路 */</span></span><br><span class="line">        <span class="type">Value</span> <span class="variable">andValue</span> <span class="operator">=</span> lAndExpNode.visit(visitor, thenBlock, elseBlock, andBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 为下一个判断式生成基本块 */</span></span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">childAndBlock</span> <span class="operator">=</span> visitor.builder.buildBlockBegin(visitor.getCurrentFunction());</span><br><span class="line">        visitor.getCurrentFunction().pushBlock(childAndBlock);</span><br><span class="line">        visitor.setBlock(currentBlock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为子与表达式设置跳转块：成功则直接结束。失败则进行下一个 &amp;&amp; 表达式判断 */</span></span><br><span class="line">        lAndExpNode.visit(visitor, thenBlock, childAndBlock, andBlock);</span><br><span class="line">        <span class="comment">/* 为子或表达式设置跳转块：与自身的跳转情况一致 */</span></span><br><span class="line">        Objects.requireNonNull(lOrExpNode).visit(visitor, thenBlock, elseBlock, childAndBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LAndExpNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock, BasicBlock eqBlock)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> eqBlock;</span><br><span class="line">    visitor.setBlock(currentBlock);</span><br><span class="line">    <span class="type">Value</span> <span class="variable">eqValue</span> <span class="operator">=</span> eqExpNode.visit(visitor);</span><br><span class="line">    <span class="comment">/* 解析子相等表达式 */</span></span><br><span class="line">    <span class="keyword">if</span> (and == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 单一表达式，调用 Builder 生成跳转 llvm 指令*/</span></span><br><span class="line">    <span class="type">BranchInstr</span> <span class="variable">finalBranch</span> <span class="operator">=</span> visitor.builder.buildBranch(eqValue, thenBlock, elseBlock, visitor.getBlock());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 为子表达式设置跳转块，为自身设置跳转指令 */</span></span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">childEqBlock</span> <span class="operator">=</span> visitor.builder.buildBlockBegin(visitor.getCurrentFunction());</span><br><span class="line">        visitor.getCurrentFunction().pushBlock(childEqBlock);</span><br><span class="line">        visitor.setBlock(currentBlock);</span><br><span class="line">        <span class="type">BranchInstr</span> <span class="variable">finalBranch</span> <span class="operator">=</span> visitor.builder.buildBranch(eqValue, childEqBlock, elseBlock, visitor.getBlock());</span><br><span class="line">        <span class="type">Value</span> <span class="variable">andExpValue</span> <span class="operator">=</span> Objects.requireNonNull(lAndExpNode).visit(visitor, thenBlock, elseBlock, childEqBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h1><h2 id="文件组织-6"><a href="#文件组织-6" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---mips</span><br><span class="line">    |   Builder.java</span><br><span class="line">    |   MipsCenter.java</span><br><span class="line">    |   RegisterFile.java</span><br><span class="line">    |</span><br><span class="line">    +---data</span><br><span class="line">    +---instr</span><br><span class="line">    |       AbstractInstr.java</span><br><span class="line">    |       BranchDInstr.java</span><br><span class="line">    |       CalDInstr.java</span><br><span class="line">    |       CalSInstr.java</span><br><span class="line">    |       DataRecord.java</span><br><span class="line">    |       DataTag.java</span><br><span class="line">    |       InstrType.java</span><br><span class="line">    |       JumpInstr.java</span><br><span class="line">    |       LabelInstr.java</span><br><span class="line">    |       MemSInstr.java</span><br><span class="line">    |       PseudoInstruction.java</span><br><span class="line">    |       Syscall.java</span><br><span class="line">    |       UtilsSInstr.java</span><br><span class="line">    |</span><br><span class="line">    \---operands</span><br><span class="line">            Imm.java</span><br><span class="line">            Label.java</span><br><span class="line">            Operand.java</span><br><span class="line">            Register.java</span><br></pre></td></tr></table></figure><h2 id="具体设计-5"><a href="#具体设计-5" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="mips-MipsCenter"><a href="#mips-MipsCenter" class="headerlink" title="mips/MipsCenter"></a>mips/MipsCenter</h3><p>和中间代码生成类似，在目标代码生成时也设置了一个中控类，用于存放所有的 mips 指令和编译时的信息，其功能比 LLCenter 更复杂，分成了几个区段，在生成 mips 指令时进行辅助</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --------------- data segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;DataRecord&gt; dataSegment = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;GlobalVar, DataRecord&gt; tagMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> dataOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">gpValue</span> <span class="operator">=</span> <span class="number">0x10008000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">spValue</span> <span class="operator">=</span> <span class="number">0x7fffeffc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- text segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;AbstractInstr&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- data segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;DataRecord&gt; <span class="title function_">getDataSegment</span><span class="params">()</span> &#123; <span class="keyword">return</span> dataSegment; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushData</span><span class="params">(GlobalVar globalVar, DataTag data)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- text segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFunction</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushInstr</span><span class="params">(String comment,AbstractInstr instruction)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushInstr</span><span class="params">(AbstractInstr instruction, String blockLabel)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- stack segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;Value, Integer&gt; stacks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;()&#123;&#123; put(<span class="keyword">new</span> <span class="title class_">Value</span>(TypeList.I1_TYPE, <span class="literal">null</span>), <span class="number">4</span>); &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findStackValue</span><span class="params">(Value target)</span> &#123; <span class="keyword">return</span> stacks.containsKey(target); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStack</span><span class="params">(Value target)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushStack</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStackSize</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStackOffset</span><span class="params">(Value target)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- register segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">RegisterFile</span> <span class="variable">registerFile</span> <span class="operator">=</span> RegisterFile.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Operand <span class="title function_">dispatchRegister</span><span class="params">(Value patch, <span class="type">boolean</span> needLoad, <span class="type">boolean</span>... inStorePointer)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadStore</span><span class="params">(Pair&lt;Register, Value&gt; storePair, <span class="type">boolean</span> isLoad)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeRegisterBack</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- output segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMips</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="mips-RegisterFile"><a href="#mips-RegisterFile" class="headerlink" title="mips/RegisterFile"></a>mips/RegisterFile</h3><ul><li>在生成目标代码指令过程中对寄存器进行管理的类，模拟一个真正的寄存器，记录其中正在被占用的寄存器和可释放、申请的寄存器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initial</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">dispatchIdleRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">dispatchTargetRegister</span><span class="params">(Value value, Register register)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">recycleRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">recycleRegister</span><span class="params">(Register recycle)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Pair&lt;Register, Value&gt; <span class="title function_">recycleRegister</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">pickOut</span><span class="params">()</span> &#123; <span class="keyword">return</span> useList.getFirst(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasIdle</span><span class="params">()</span> &#123; <span class="keyword">return</span> !idles.isEmpty(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">getValue</span><span class="params">(Register register)</span> &#123; <span class="keyword">return</span> dispatches.getOrDefault(register, <span class="literal">null</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">getRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Register, Value&gt; <span class="title function_">getDispatches</span><span class="params">()</span> &#123; <span class="keyword">return</span> dispatches; &#125;</span><br></pre></td></tr></table></figure><h3 id="mips-operands"><a href="#mips-operands" class="headerlink" title="mips/operands/*"></a>mips/operands/*</h3><ul><li><code>operands</code> 软件包存放的是 mips 指令的操作数类，可以分为立即数（<code>Imm</code>）、寄存器（<code>Register</code>）和标签（<code>Label</code>）三类，它们在不同的指令中出现，不可直接换用</li></ul><p>操作数是指令内部 value 的具象，也就是承载着 llvm 的 value 的一个对象，我们将多种 llvm 指令转化为 能够表达同等意思的 mips 指令，靠的就是 mips 指令对这些操作数的动作。例如一个 Binary 的 llvm 指令可以将其两个运算的 value 提取出来当作两个 operands，并生成一条同样的运算类的 mips 指令，而运算的两个操作数就是这两个 value，由此就简单地实现了 llvm 到 mips 的转化。</p><h3 id="mips-instr"><a href="#mips-instr" class="headerlink" title="mips/instr/*"></a>mips/instr/*</h3><ul><li><code>instr</code> 软件包存放的是 mips 指令的种类，这些类的对象就实际对应一条可执行的 mips 指令，均继承自 <code>AbstractInstr</code> 类，再额外实现相关的字段</li></ul><h3 id="llvm-value-instruction"><a href="#llvm-value-instruction" class="headerlink" title="llvm/value/instruction/*"></a>llvm/value/instruction/*</h3><ul><li>llvm 的每一条指令都需要转化成对应的 mips 指令，所以在每个 llvm 指令类中都新建 <code>generateMips</code> 方法，实现从 llvm 到 mips 的转化</li></ul><p>以 BinaryInstr 为例进行转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateMips</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">lhs</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(operands.get(<span class="number">0</span>).getUseValue(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">rhs</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(operands.get(<span class="number">1</span>).getUseValue(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">rd</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Register &amp;&amp; rhs <span class="keyword">instanceof</span> Register) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (instrType) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD, SUB -&gt;</span><br><span class="line">            <span class="keyword">case</span> EQ -&gt;</span><br><span class="line">            <span class="comment">/* case 其余种类 -&gt; */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Register &amp;&amp; rhs <span class="keyword">instanceof</span> Imm) &#123;</span><br><span class="line">        <span class="comment">/* 实现类似的判断 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Imm &amp;&amp; rhs <span class="keyword">instanceof</span> Register) &#123;</span><br><span class="line">        <span class="comment">/* 实现类似的判断 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* both imm */</span></span><br><span class="line">        <span class="comment">/* 可直接对立即数进行优化运算得出其结果*/</span></span><br><span class="line">        <span class="keyword">assert</span> lhs <span class="keyword">instanceof</span> Imm;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lhsImm</span> <span class="operator">=</span> ((Imm) lhs).getImmValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rhsImm</span> <span class="operator">=</span> ((Imm) rhs).getImmValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (instrType) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD -&gt; res = lhsImm + rhsImm;</span><br><span class="line">            <span class="keyword">case</span> SUB -&gt; res = lhsImm - rhsImm;</span><br><span class="line">            <span class="comment">/* case 其余种类 -&gt; */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 插入 mips 指令 */</span></span><br><span class="line">        MipsCenter.getInstance().pushInstr(<span class="built_in">this</span>.toString(), <span class="keyword">new</span> <span class="title class_">PseudoInstruction</span>(LI, (Register) rd, <span class="keyword">new</span> <span class="title class_">Imm</span>(res)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><p>本编译器未进行代码优化，本部分无相关内容</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译技术实验课程感想</title>
      <link href="/p/9291ce54.html"/>
      <url>/p/9291ce54.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译技术课程感想"><a href="#编译技术课程感想" class="headerlink" title="编译技术课程感想"></a>编译技术课程感想</h1><h2 id="总结课程收获"><a href="#总结课程收获" class="headerlink" title="总结课程收获"></a>总结课程收获</h2><p>这一整个学期的编译学习，在今天理论考试结束后就暂时告一段落了（文档 21 号截止但是实验期末 25 号考所以没法写进总结里（×</p><p>对实验部分来说，最大的收获就是从代码的层面上解释了编译的整个过程，（至少对我来说）揭开了编译这个在大学的整个学习过程中一直处于比较模糊的一个概念。从最开始的词法的解析、语法树的构建；再到符号表管理、错误处理；最后是中间代码和目标代码的生成和优化，实际动手实践过这一系列过程后才对编译这个概念有了具体的实感。</p><p>对我来说印象最深的是中间代码的生成，语法分析只提供了语法树作为输入，编译器却要生成一条条的中间代码，最开始我是无法理解这个过程的实现的。但是在理论课学到翻译文法后就大概有了想法，再根据教程文字逐步理解，具体生成了代码后的喜悦感还是很强烈的。</p><p>同时我认为编译技术还是整个计算机系学习体系中十分重要的一环，前有运行 mips 代码的实际 CPU（计组），后有根据高级程序设计语言建立的操作系统（操作系统）和相应的程序（面向对象），编译技术实际上把这两部分联系了起来，实现了从高级语言到汇编语言的转换，能够学到这部分知识是十分重要的。</p><h2 id="课程改进建议"><a href="#课程改进建议" class="headerlink" title="课程改进建议"></a>课程改进建议</h2><p>主要比较想吐槽的是时间安排，感觉可以把词法 &amp; 语法的时间占比压缩一点，给后面的代码生成多一些时间，或者说开始得早一些。从我自己的角度来说，这个学期的学习体验是相对不均衡的，错误处理和之前的部分实际上用了比较少的时间去设计和写代码，但是提交时间段给的又有点长；后半段和其他课程的作业一起冲过来有一点不太好处理，整个代码生成都是赶着时间才冲完的，优化更是完全没时间处理（<del>甚至现在三点了明天还要起来整数据库qaq</del>）。还有一个时间安排不太好的是理论和实验的时间安排，实验截止的第二天进行理论考试，下 一 周 才进行实验上机考试，我觉得应该不止我一个同学希望把这两个考试换个位置，真的体感很不好，希望明年的课程安排可以参考一下这一点。</p><p>第二点建议是希望能够丰富一下 mips 部分的教程内容，分析一下常用的指令和中间代码→目标代码的转换方式，在写目标代码生成时会更顺滑一点。其他的部分我觉得已经挺完善的了，尤其是延期 3 天这个人性化的操作拯救苍生于水火之中，给课程组磕了 orz</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译课设编译器优化文档</title>
      <link href="/p/373cf855.html"/>
      <url>/p/373cf855.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译器优化文档"><a href="#编译器优化文档" class="headerlink" title="编译器优化文档"></a>编译器优化文档</h1><p>本编译器设计初步就采用了寄存器分配和释放的分配策略，此外未进行额外的优化。</p><p>在分配寄存器时，遇到的问题主要是不易确定何时释放寄存器，过早释放会丢失其中存储的值，过晚释放会影响分配效率。由于一个 value 在声明后最多只有一个 user 对其进行使用，所以一旦唯一的 user 将其使用后，该 value 就没有其余的使用点了，此时可以在寄存器池中进行释放。</p><p>此外还遇到了寄存器池划分的问题，最开始的寄存器包括了参数寄存器，这样会影响函数调用前参数的分配，产生额外 bug。</p><p>学期末任务比较重所以只做到了堪堪没有 TLE，有机会还是希望好好研究一下优化的（哭</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-DataBase-Chapter3</title>
      <link href="/p/5e23a9b2.html"/>
      <url>/p/5e23a9b2.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-6-章-关系数据理论"><a href="#第-6-章-关系数据理论" class="headerlink" title="第 6 章 关系数据理论"></a>第 6 章 关系数据理论</h1><p>本章讨论关系数据理论。关系模式被看作为一个三元组：$R&lt;U,F&gt;$。当且仅当 $U$ 上的一个关系 $r$ 满足 $F$ 时，$r$ 被称为关系模式的一个关系。</p><p>由此引出第一范式的定义：</p><ul><li>第一范式：该关系的每一个分量必须是不可分的数据项。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-DataBase-Homework3</title>
      <link href="/p/eb75ce2.html"/>
      <url>/p/eb75ce2.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据库第三章作业"><a href="#数据库第三章作业" class="headerlink" title="数据库第三章作业"></a>数据库第三章作业</h1><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul><li>Windows 10 21H2</li><li>SQL Server 19</li><li>Microsoft SQL Server Management Studio</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ol><li>创建一个 school 数据库，为数据库文件和日志文件命名，并将它们存储到不同目录下。将数据库文件的初始大小设置为 10M，最大大小设置为 20M，每次增长 1M。</li><li>为 school 数据库再增加一个数据库文件。</li></ol><p>新建数据库图示如下，过程中要注意选取自动增长和最大大小。数据库文件第一行为普通数据，第二行为数据库日志文件。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310192133309.png" alt="image-20231019213347215" style="zoom:80%;" /><p>右键数据库名并查看数据库属性，可以添加新的数据库文件</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310192140602.png" alt="image-20231019214016574" style="zoom:67%;" /><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310192139285.png" alt="image-20231019213939244" style="zoom: 80%;" /><h3 id="完成练习"><a href="#完成练习" class="headerlink" title="完成练习"></a>完成练习</h3><p>数据表规格如下：</p><ul><li>学生表（学号，姓名，性别，年龄，入学年份，籍贯，系号，班长学号），学号是主码，系号和班长学号是外部码，手机号码必须唯一，学生的年龄不得小于10岁和大于50岁，性别必须是’男’或者’女’。</li><li>系表（系号，系名，系主任），其中系号是主码，系名不能有重复的。</li><li>选课表（学号，课程号，成绩），（学号，课程号）是主码，学号和课程号是外部码，成绩不能小于0分和大于100分</li><li>课程表（课程号，课程名，先修课，学分），课程号是主码，课程名必须唯一，学分必须大于0小于5。</li></ul><ul><li>创建上述表，并定义相应的完整性约束。</li></ul><p>实现数据表创建的代码为 <code>Create.sql</code> 文件，于 SSMS 中运行可以直接获得正确的数据表结构。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 建立数据表和相关约束 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Department(</span><br><span class="line">Dnumber <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Dname <span class="type">VarChar</span>(<span class="number">40</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">Director <span class="type">VarChar</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Class(</span><br><span class="line">Cnumber <span class="type">VarChar</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Cname <span class="type">VarChar</span>(<span class="number">40</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">Cprev <span class="type">VarChar</span>(<span class="number">10</span>),</span><br><span class="line">Ccredit <span class="type">FLOAT</span> <span class="keyword">CONSTRAINT</span> Ccredit_1 <span class="keyword">CHECK</span> (Ccredit <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">AND</span> Ccredit <span class="operator">&lt;</span> <span class="number">5</span>),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student(</span><br><span class="line">Sno <span class="type">VarChar</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">Sname <span class="type">VarChar</span>(<span class="number">40</span>),</span><br><span class="line">Ssex <span class="type">VarChar</span>(<span class="number">10</span>) <span class="keyword">CONSTRAINT</span> Ccredit_0 <span class="keyword">CHECK</span> (Ssex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span> <span class="keyword">OR</span> Ssex<span class="operator">=</span><span class="string">&#x27;女&#x27;</span>),</span><br><span class="line">Sage <span class="type">FLOAT</span> <span class="keyword">CHECK</span> (Sage <span class="operator">&gt;=</span> <span class="number">10</span> <span class="keyword">AND</span> Sage <span class="operator">&lt;=</span> <span class="number">50</span>),</span><br><span class="line">Syear <span class="type">FLOAT</span>,</span><br><span class="line">Shometown <span class="type">VarChar</span>(<span class="number">40</span>),</span><br><span class="line">SDnumber <span class="type">INT</span>,</span><br><span class="line">Smonitor <span class="type">VarChar</span>(<span class="number">10</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (SDnumber) <span class="keyword">REFERENCES</span> Department(Dnumber),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (Smonitor) <span class="keyword">REFERENCES</span> Student(Sno)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Record(</span><br><span class="line">Sno <span class="type">VarChar</span>(<span class="number">10</span>),</span><br><span class="line">Cnumber <span class="type">VarChar</span>(<span class="number">10</span>),</span><br><span class="line">Score <span class="type">FLOAT</span> <span class="keyword">CHECK</span> (Score <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> Score <span class="operator">&lt;=</span> <span class="number">100</span>),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (Sno) <span class="keyword">REFERENCES</span> Student(Sno),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (Cnumber) <span class="keyword">REFERENCES</span> Class(Cnumber),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (Sno, Cnumber)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>将提供的上述各表的数据导入 SQL Server。如果导入过程存在错误，请说明可能是什么原因。</li></ul><p>通过数据库菜单下的 任务 - 导入数据 操作将 Excel 文件导入数据库中（Excel → SQL Server Native Client 11.0）。导入过程中发生了错误，经检查发现是因为约束条件出错：不能将选课表中不存在的学号（外码） <code>0320</code>、<code>0321</code> 加入数据表中；同时还存在同一学生有多个同一课程的成绩的现象（主码重复），修改方式是删去不合法记录。</p><ul><li>在学生表中插入学号为26，姓名为’李四’，性别为’女’，年龄为20，入学年份为2008，籍贯为’广东’，手机号码为10010001000，班长学号为10的一条记录。</li></ul><p>首先，原文件中学生表不存在手机号码字段，故予以忽略；其次，不存在学号为 10 的记录，在这里忽视班长学号的信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> Student</span><br><span class="line"><span class="keyword">Values</span> (<span class="string">&#x27;26&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">20</span>, <span class="number">8</span>, <span class="string">&#x27;广东&#x27;</span>, <span class="keyword">null</span>, <span class="string">&#x27;0105&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li>删除上述记录。</li></ul><p>由于 Student 主码为学号（Sno），故使用 Sno 作为筛选条件删除学号为 26 的记录即可。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno<span class="operator">=</span><span class="number">26</span>;</span><br></pre></td></tr></table></figure><ul><li>将学生表中的姓名字段的长度改为6个汉字。</li></ul><p>由于姓名字段原本使用了 <code>VarChar(10)</code> 作为字段长度限制，且一个汉字通常使用两个<code>VarChar</code>，故将长度修改为 <code>VarChar(12)</code> 即可。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ALTER COLUMN */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> Sname <span class="type">VarChar</span>(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>操作后可从可视化界面中观察结果：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310192326754.png" alt="image-20231019232601727"></p><ul><li>为学生表增加一个字段电子邮件，20个字符。</li></ul><p>对一般英文字符，使用 <code>Char</code> 作为变量类型即可。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ALTER COLUMN */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student </span><br><span class="line"><span class="keyword">ADD</span> Email <span class="type">Char</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212027266.png" alt="image-20231021202747185"></p><p>查询整个表的结果如下，发现 <code>Email</code> 列添加成功</p><ul><li>对课程表的学分字段上的完整性约束进行修改，使其在0到6之间取值。</li></ul><p>修改完整性约束应拆解为删除旧约束并添加新约束：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Class </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> Ccredit_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Class </span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> Ccredit_2 <span class="keyword">CHECK</span> (Ccredit <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">AND</span> Ccredit <span class="operator">&lt;=</span> <span class="number">6</span>);</span><br></pre></td></tr></table></figure><ul><li>为学生表在学号列上创建cluster索引。</li></ul><p>将按学号升序建立唯一聚簇索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX Stusno <span class="keyword">ON</span> Student(Sno);</span><br></pre></td></tr></table></figure><ul><li>创建一个视图，计算每门课的最高分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> C_G(Cnumber, Gmax)</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Cnumber, <span class="built_in">MAX</span>(Score)</span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">BY</span> Cnumber;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212030443.png" alt="image-20231021203026404"></p><ul><li>查找每个学生的学号、姓名、总成绩和平均分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Sname, <span class="built_in">SUM</span>(Score), <span class="built_in">AVG</span>(Score)</span><br><span class="line"><span class="keyword">FROM</span> Student, Record</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> Record.Sno</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">BY</span> Student.Sno, Sname;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212030999.png" alt="image-20231021203057974"></p><ul><li>将6系所有学生的年龄，改为7系学生的平均年龄。</li></ul><p>没有 7 系学生，条件改为 8 系。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage<span class="operator">=</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(b.Sage) </span><br><span class="line"><span class="keyword">FROM</span> Student b </span><br><span class="line"><span class="keyword">WHERE</span> b.SDnumber <span class="operator">=</span> <span class="number">8</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> SDnumber <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212031803.png" alt="image-20231021203138767"></p><ul><li>将’曹洪’同学操作系统课程的成绩改为62分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Record</span><br><span class="line"><span class="keyword">SET</span> Score <span class="operator">=</span> <span class="number">62</span></span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;曹洪&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;操作系统&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查找所有学生的姓名、入学年份和籍贯。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname, Syear, Shometown <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212032433.png" alt="image-20231021203222397"></p><ul><li>列出籍贯为’山东’的同学的所有属性。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Shometown <span class="operator">=</span> <span class="string">&#x27;山东&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212032025.png" alt="image-20231021203230990"></p><ul><li>查找年龄最小的学生的学号和姓名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sage <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212032861.png" alt="image-20231021203245830"></p><ul><li>查找选修了’数据库’的学生的学号。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212032792.png" alt="image-20231021203255760"></p><ul><li>查找选修了’编译技术’的女学生的学号和姓名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Record.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Record, Student</span><br><span class="line"><span class="keyword">WHERE</span> Record.Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;编译技术&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> Ssex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033216.png" alt="image-20231021203304184"></p><ul><li>查找’典韦’同学的班长所选修的课程的课程号。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Record, Student</span><br><span class="line"><span class="keyword">WHERE</span> Record.Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Record.Sno <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Smonitor</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;典韦&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033802.png" alt="image-20231021203312776"></p><ul><li>查找名字中倒数第二字为’侯’的学生的学号、姓名和所在系的系名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname, SDnumber</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="keyword">LIKE</span> <span class="string">&#x27;%侯_&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033551.png" alt="image-20231021203320527"></p><ul><li>查找名字以P打头，倒数第三字为L的课程的名字。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">&#x27;P%L__&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033311.png" alt="image-20231021203328278"></p><ul><li>查找’甘宁’同学所有选修课程的总分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(Score) <span class="keyword">AS</span> TotalScore</span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Sno</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;甘宁&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033364.png" alt="image-20231021203335338"></p><ul><li>查找既选修了’数据库’，也选修了’操作系统’的同学。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> s.Sno <span class="operator">=</span> Sno <span class="keyword">AND</span> Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span></span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AND</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> s.Sno <span class="operator">=</span> Sno <span class="keyword">AND</span> Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;操作系统&#x27;</span></span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/* Another Way to Solve */</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record, Class</span><br><span class="line"><span class="keyword">WHERE</span> Record.Cnumber <span class="operator">=</span> Class.Cnumber <span class="keyword">AND</span></span><br><span class="line">Cname <span class="keyword">IN</span> (<span class="string">&#x27;数据库&#x27;</span>, <span class="string">&#x27;操作系统&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">Sno <span class="operator">=</span> s.Sno</span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">BY</span> Sno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033612.png" alt="image-20231021203347581"></p><ul><li>查找没有选修’数据库’课程的学生的学号和姓名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, Record r1, Class</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> r1.Sno <span class="keyword">AND</span></span><br><span class="line">r1.Cnumber <span class="operator">=</span> Class.Cnumber <span class="keyword">AND</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record r2</span><br><span class="line"><span class="keyword">WHERE</span> r1.Sno <span class="operator">=</span> r2.Sno <span class="keyword">AND</span></span><br><span class="line">r2.Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span></span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212033112.png" alt="image-20231021203355078"></p><ul><li>查找’数据库’课程及格了，但’编译技术’没有及格的学生的学号和姓名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, Record</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> Record.Sno <span class="keyword">AND</span> </span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">Score <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line">) <span class="keyword">AND</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;编译技术&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">Score <span class="operator">&lt;</span> <span class="number">60</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212034430.png" alt="image-20231021203403398"></p><ul><li>查找数据库成绩低于数据库课平均成绩的同学的学号和姓名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Student.Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student, Record</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> Record.Sno <span class="keyword">AND</span></span><br><span class="line"><span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line">Score <span class="operator">&lt;</span> </span><br><span class="line">(<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Score)</span><br><span class="line"><span class="keyword">FROM</span> Record</span><br><span class="line"><span class="keyword">WHERE</span> Cnumber <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Cnumber</span><br><span class="line"><span class="keyword">FROM</span> Class</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;编译技术&#x27;</span></span><br><span class="line">)</span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212034301.png" alt="image-20231021203411270"></p><ul><li>查找与’貂蝉’同学选修课程完全相同的学生的学号和姓名（不能多选也不能少选）。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.Sno, s1.Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record r1</span><br><span class="line"><span class="keyword">WHERE</span> r1.Sno <span class="operator">=</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;貂蝉&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record r2</span><br><span class="line"><span class="keyword">WHERE</span> r2.Sno <span class="operator">=</span> s1.Sno <span class="keyword">AND</span></span><br><span class="line">r2.Cnumber <span class="operator">=</span> r1.Cnumber</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> Record </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> s1.Sno) <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> Record </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Sno </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;貂蝉&#x27;</span></span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212034522.png" alt="image-20231021203419494"></p><ul><li>查找不仅选修了’貂蝉’同学选修的课程，而且还选修了其他课程的同学。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.Sno, s1.Sname</span><br><span class="line"><span class="keyword">FROM</span> Student s1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record r1</span><br><span class="line"><span class="keyword">WHERE</span> r1.Sno <span class="operator">=</span> (<span class="keyword">SELECT</span> Sno <span class="keyword">FROM</span> Student <span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;貂蝉&#x27;</span>) <span class="keyword">AND</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span>(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Record r2</span><br><span class="line"><span class="keyword">WHERE</span> r2.Sno <span class="operator">=</span> s1.Sno <span class="keyword">AND</span></span><br><span class="line">r2.Cnumber <span class="operator">=</span> r1.Cnumber</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> Record </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> s1.Sno) <span class="operator">&gt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) </span><br><span class="line"><span class="keyword">FROM</span> Record </span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> Sno </span><br><span class="line"><span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> Sname <span class="operator">=</span> <span class="string">&#x27;貂蝉&#x27;</span></span><br><span class="line">)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212034146.png" alt="image-20231021203429110"></p><ul><li>查找’高等数学’平均成绩最高的系的系名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TOP <span class="number">1</span> Dname</span><br><span class="line"><span class="keyword">FROM</span> Record, Student, Department</span><br><span class="line"><span class="keyword">WHERE</span> Cnumber <span class="operator">=</span> (<span class="keyword">SELECT</span> Cnumber <span class="keyword">FROM</span> Class <span class="keyword">WHERE</span> Cname <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span>) <span class="keyword">AND</span> </span><br><span class="line">Record.Sno <span class="operator">=</span> Student.Sno <span class="keyword">AND</span></span><br><span class="line">Student.SDnumber <span class="operator">=</span> Department.Dnumber</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SDnumber, Dname</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">AVG</span>(Score) <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212035296.png" alt="image-20231021203553262"></p><ul><li>查找至少有一个籍贯为’四川’同学所选修的课程的课程名。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Cname</span><br><span class="line"><span class="keyword">FROM</span> Student, Class, Record</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> Record.Sno <span class="keyword">AND</span></span><br><span class="line">Class.Cnumber <span class="operator">=</span> Record.Cnumber <span class="keyword">AND</span></span><br><span class="line"><span class="keyword">EXISTS</span>(<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">WHERE</span> Shometown <span class="operator">=</span> <span class="string">&#x27;四川&#x27;</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Cname;</span><br></pre></td></tr></table></figure><p>鉴定为，根本没有。</p><ul><li>查询选修了’数据库’课程的学生的学号和获得的学分。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.Sno, Ccredit</span><br><span class="line"><span class="keyword">FROM</span> Student, Record, Class</span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> Record.Sno <span class="keyword">AND</span></span><br><span class="line">Record.Cnumber <span class="operator">=</span> Class.Cnumber <span class="keyword">AND</span></span><br><span class="line">Cname <span class="operator">=</span> <span class="string">&#x27;数据库&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310212036002.png" alt="image-20231021203621966"></p><h3 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h3><ul><li>SQL语言的特点。</li></ul><p>综合统一、高度非过程化、面向集合的操作方式、以同一种语法结构提供多种使用方式、语言简洁</p><ul><li>创建一个数据库，需要创建几个文件，它们分别是做什么用的？它们对应于三级模式中的哪一级？创建的表存储在什么地方？它们对应于三级模式中的哪一级？</li></ul><p>创建两个文件。分别是数据库主文件和数据库日志文件。它们对应三级模式中的内模式。创建的表存储在数据库主文件中，对应模式。</p><ul><li>可以为表定义哪些完整性约束？它们各自的作用是什么？</li></ul><table><thead><tr><th align="center">约束类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">主键约束<br/>（PRIMARY KEY）</td><td align="center">确定表中的标识列（主键字段不能为空，必须唯一）标识：确定一个对象的唯一表现</td></tr><tr><td align="center">外键约束<br/>（FOREIGN KEY）</td><td align="center">确定表与表之间的联系方式，一般情况下通过主表的标识列进行确定主表：给哪张表添加约束哪张表就是主表，辅助表为从表</td></tr><tr><td align="center">唯一约束<br/>（UNIQUE）</td><td align="center">确定这个字段中的数据必须是唯一存在的</td></tr><tr><td align="center">非空约束（NOT NULL）</td><td align="center">确定这个字段中的数据必须不能为空</td></tr><tr><td align="center">检查约束<br/>（CHECK）</td><td align="center">设置这个字段中的数据特性</td></tr><tr><td align="center">默认约束<br>（DEFAULT ）</td><td align="center">若在表中定义了默认值约束，用户在插入新的数据行时，如果该行没有指定数据，那么系统将默认值赋给该列，如果我们不设置默认值，系统默认为NULL</td></tr></tbody></table><ul><li>自然连接和等值连接有什么差别？</li></ul><p>等值连接是基于两个表之间的相等条件进行连接，而自然连接是基于两个表之间的相同列名进行连接。等值连接可以连接任意两个表，而自然连接只能连接具有相同列名的两个表。等值连接可以通过指定连接条件来连接两个表，而自然连接只能通过列名相同来连接两个表。</p><ul><li>子查询分为哪几种？它们之间有什么区别？</li></ul><p>子查询主要包括嵌套子查询和连接子查询两种类型。</p><p>嵌套子查询是一个查询内部包含另一个子查询的查询。它可以用于在一个完整的查询中引用外部查询中的条件，通常用于在FROM子句中引用外部查询的结果集。嵌套子查询通常涉及多层嵌套，但也可以有单层嵌套。</p><p>连接子查询则主要用于在两个或多个表之间建立关系，通过在WHERE子句中使用外部查询的结果作为连接条件。连接子查询可以使用INNER JOIN、LEFT JOIN、RIGHT JOIN等连接类型。</p><p>这两种子查询的主要区别在于它们的使用方式和目的不同。嵌套子查询主要关注如何在一个完整的查询中引用外部查询中的条件，而连接子查询则关注如何在多个表之间建立关系。同时，它们的使用场景和限制也不同，需要根据具体的需求和场景选择合适的子查询类型。另外，嵌套子查询和连接子查询在语法上也有所不同，需要根据具体情况进行适当的调整。</p><ul><li>索引有什么作用和缺点？</li></ul><ol><li>提高查询性能：索引可以大大提高查询速度，特别是在处理大量数据时。</li><li>减少磁盘I/O操作：索引通过将数据存储在内存中，减少了从磁盘中读取数据的需求，从而减少了I/O操作的数量。</li><li>减少重新排序和排序成本：索引通常基于数据表的某些列创建，这样可以减少在进行更新操作时对整个表进行重新排序或排序的成本。</li></ol><p>其主要缺点是会增加插入、更新和删除操作的开销，因为每次对这些操作都需要重新构建索引。此外，如果一个表上的索引过多，可能会占用更多的存储空间，并影响数据库的性能。因此，在设计数据库时，需要权衡索引的优点和缺点，并根据实际需求选择合适的索引策略。</p><ul><li>基本表和视图有什么区别？视图有什么优点？什么样的视图是可以更新的？</li></ul><p>基本表是数据库中实际存在的表，具有完整的字段和记录，并且可以与其他表建立关系。基本表提供了数据存储的框架，是数据库中数据存储的基本单位。视图是基本表的虚拟表，它是基于基本表的查询结果而生成的。在实际操作中，视图并不存在于数据库中，它只是一种基于基本表的查询逻辑。</p><p>视图优点有：</p><ol><li>简化操作：视图可以对基本表进行筛选，只显示符合特定条件的数据，从而简化复杂的查询操作。</li><li>提高安全性：视图可以用于保护数据，只有具有适当权限的用户才能查看视图的记录。</li><li>提高性能：视图可以减少对基本表的频繁查询操作，从而提高查询性能。</li></ol><p>可以更新的视图是指用户可以通过直接修改视图的定义来更新视图所展示的数据。通常情况下，只有受支持的、符合特定条件的视图才可以进行更新操作。更新的操作通常涉及到对基本表的修改，并在更新后重新创建视图。</p><ul><li>请针对第三章SQL语言讲义中的除法例子，给出其他两种除法的实现方法。</li></ul><p>SQL语言中没有全称量词，具体实现时可以把带有全称量词的谓词转换为等价的带有存在量词的谓词。</p><p>解决这类的除法问题一般采用双嵌套notexists来实现带全称量词的查询解决所谓forall的问题。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-DataBase-Chapter2</title>
      <link href="/p/29249924.html"/>
      <url>/p/29249924.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-3-章-SQL-概述"><a href="#第-3-章-SQL-概述" class="headerlink" title="第 3 章 SQL 概述"></a>第 3 章 SQL 概述</h1><h2 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h2><p>支持 SQL 的关系数据库管理系统同样支持关系数据库的三级模式结构。存储结构如图所示：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310102151012.png" alt="image-20231010214329495"></p><ul><li>外模式：若干视图、部分基本表</li><li>模式：若干基本表</li><li>内模式：存储文件</li></ul><p>基本表和视图一致，都属于关系。视图是从一个或多个基本表导出的表，属于<strong>虚表</strong>，用户可以查看视图，但视图并不实际存放数据。通常一个关系数据库管理系统可以包含多个数据库，一个数据库可以建立多个模式，一个模式可以包含多个表、视图、索引等数据库对象</p><p>数据定义语句如下：创建（CREATE）、删除（DROP）、修改（ALTER），对象包含模式（SCHEMA）、视图（VIEW）、表（TABLE）、索引（INDEX）</p><p>具体使用时采用 $&lt;操作&gt;+&lt;对象&gt;$ 的语句即可。其中只有表和索引可以执行修改操作</p><h3 id="模式的定义与删除"><a href="#模式的定义与删除" class="headerlink" title="模式的定义与删除"></a>模式的定义与删除</h3><p>定义模式实际上定义了一个命名空间。在模式中可以进一步定义数据库对象。模式定义语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>USERNAME<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><ul><li>如果没有指定模式名 <code>NAME</code> 则默认为用户名称 <code>USERNAME</code></li></ul><p>在定义了模式后，可以继续追加定义该模式中的对象：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> <span class="keyword">AUTHORIZATION</span> <span class="operator">&lt;</span>USERNAME<span class="operator">&gt;</span> [<span class="operator">&lt;</span><span class="keyword">TABLE</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span><span class="keyword">VIEW</span><span class="operator">&gt;</span> <span class="operator">|</span> <span class="operator">&lt;</span>AUTHORIZE<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><ul><li>这里的可选项是完整的定义子句，直接追加在模式定义的同一句中即可</li></ul><p>模式在删除时有两类操作，第一类（CASCADE）会连带删除模式下的所有对象；第二类（RESTRICT）只允许删除空的模式，语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> SCHEMA <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> <span class="operator">&lt;</span>CASCADE <span class="operator">|</span> RESTRICT<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h3 id="基本表的定义、删除与修改"><a href="#基本表的定义、删除与修改" class="headerlink" title="基本表的定义、删除与修改"></a>基本表的定义、删除与修改</h3><p>基本表的定义语句如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create Table */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束条件][, <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [完整性约束条件]]);</span><br><span class="line"><span class="comment">/* Delete Table */</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]</span><br></pre></td></tr></table></figure><p>要注意删除表时，RESTRICT 要求表不能存在引用、视图、触发器、存储过程/函数，CASCADE 会连带删除</p><p>创建整个表时，需要设置其所属的模式，设置有三种方法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. 创建表时显式给出模式名 */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Schema1.Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 创建模式时直接创建表 */</span></span><br><span class="line"><span class="keyword">CREATE</span> SCHEMA Schema1 <span class="keyword">AUTHORIZATION</span> CookedBear</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3. 不显式声明，搜索路径：使用搜索到的第一个模式，如果找不到模式则报错 */</span></span><br></pre></td></tr></table></figure><p>在创建列时定义的完整性约束条件会被存储在数据字典中，当用户操作数据时会自动检查是否满足约束条件；如果一个约束条件需要跨多个属性列，就必须定义在表上，如下例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course</span><br><span class="line">(Cno <span class="type">CHAR</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,   <span class="comment">/* Cno = 主码 */</span></span><br><span class="line"> Cname <span class="type">CHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,   <span class="comment">/* Cname != null*/</span></span><br><span class="line"> Cpno <span class="type">CHAR</span>(<span class="number">4</span>),</span><br><span class="line"> Ccredit <span class="type">SMALLINT</span>,</span><br><span class="line"> <span class="keyword">FOREIGN</span> KEY (Cpno) <span class="keyword">REFERENCES</span> Course(Cno)</span><br><span class="line"> <span class="comment">/* Cpno 是外码，被参照属性是 Course 的 Cno 列 */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>基本表中列的数据类型有以下几种常用的数据类型：</p><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>CHAR(n), CHARACTER(n)</td><td>长度为 n 的定长字符串</td></tr><tr><td>VARCHAR(n), CHARACTERVARYING(n)</td><td>最大长度为 n 的变长字符串</td></tr><tr><td>CLOB</td><td>字符串大对象</td></tr><tr><td>BLOB</td><td>二进制大对象</td></tr><tr><td>INT, INTEGER</td><td>4 bit 长整数</td></tr><tr><td>SMALLINT</td><td>2 bit 短整数</td></tr><tr><td>BIGINT</td><td>8 bit 大整数</td></tr><tr><td>NUMERIC(p, d)</td><td>定点数，总长 p 位，小数点后有 d 位</td></tr><tr><td>DECIMAL(p, d), DEC(p, d)</td><td>同 NUMERIC</td></tr><tr><td>REAL</td><td>单精度浮点数</td></tr><tr><td>DOUBLE PRECISION</td><td>双精度浮点数</td></tr><tr><td>FLOAT(n)</td><td>可选精度浮点数，精度大于等于 n</td></tr><tr><td>BOOLEAN</td><td>布尔量</td></tr><tr><td>DATE</td><td>日期，YYYY-MM-DD</td></tr><tr><td>TIME</td><td>时间，HH:MM:SS</td></tr><tr><td>TIMESTAMP</td><td>时间戳</td></tr><tr><td>INTERVAL</td><td>时间间隔</td></tr></tbody></table><p>修改基本表使用如下语句：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">ADD</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>LineName<span class="operator">&gt;</span><span class="operator">&lt;</span>DataType<span class="operator">&gt;</span> [Restriction]]</span><br><span class="line">[<span class="keyword">ADD</span> <span class="operator">&lt;</span>TableLevelRestriction<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">DROP</span> [<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>LineName<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]]</span><br><span class="line">[<span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> <span class="operator">&lt;</span>RestrictionName<span class="operator">&gt;</span> [CASCADE <span class="operator">|</span> RESTRICT]]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>LineName<span class="operator">&gt;</span><span class="operator">&lt;</span>DataType<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><ul><li>在 DROP 操作中，如果删除的列被其他的列所引用且使用了 CASCADE 模式，则连带删除所有引用的对象（如视图）</li></ul><h3 id="索引的建立与删除"><a href="#索引的建立与删除" class="headerlink" title="索引的建立与删除"></a>索引的建立与删除</h3><p>索引可以加速大数据量的查询速度。数据库索引有多种类型，常见的包括顺序文件索引、B+树索引、散列索引、位图索引等。索引是关系数据库管理系统的内部实现技术，属于<strong>内模式</strong>的管理范围</p><ul><li>索引需要占用一定的存储空间，并且需要随数据更新而维护，因此需要有选择地创建索引。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [CLUSTER] INDEX <span class="operator">&lt;</span>IndexName<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>TableName<span class="operator">&gt;</span>(<span class="operator">&lt;</span>LineName<span class="operator">&gt;</span>[<span class="operator">&lt;</span>排列次序<span class="operator">&gt;</span>][, <span class="operator">&lt;</span>LineName<span class="operator">&gt;</span>[排列次序]]);</span><br><span class="line"><span class="keyword">ALTER</span> INDEX <span class="operator">&lt;</span>OldName<span class="operator">&gt;</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>NewName<span class="operator">&gt;</span>;  <span class="comment">/* 索引的重命名 */</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>IndexName<span class="operator">&gt;</span>                      <span class="comment">/* 删除索引    */</span></span><br></pre></td></tr></table></figure><ul><li>索引可以建立在多个列上，每个列使用逗号隔开</li><li>次序指定索引值的排列次序，默认为 ASC(升序)，也可采用 DESC(降序)</li><li>UNIQUE 表示索引值只唯一对应数据记录</li><li>CLUSTER 表示建立聚簇索引</li></ul><h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><p>SQL 使用 SELECT 语句进行数据查询，SELECT 指令可以进行单表查询，也可进行复杂的连接查询和嵌套查询，其指令格式为：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>LineExp<span class="operator">&gt;</span> [, <span class="operator">&lt;</span>LineExp<span class="operator">&gt;</span>]</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span><span class="keyword">Table</span><span class="operator">/</span><span class="keyword">View</span><span class="operator">&gt;</span> [, <span class="operator">&lt;</span><span class="keyword">Table</span><span class="operator">/</span><span class="keyword">View</span><span class="operator">&gt;</span>] <span class="operator">|</span> (<span class="operator">&lt;</span><span class="keyword">SELECT</span>语句<span class="operator">&gt;</span>) [<span class="keyword">AS</span>] <span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>Cond<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>LineName1<span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>Cond<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>LineName2<span class="operator">&gt;</span> [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]];</span><br></pre></td></tr></table></figure><h3 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h3><h4 id="列查询"><a href="#列查询" class="headerlink" title="列查询"></a>列查询</h4><ul><li>查询指定列时则可以在第一行中的 <code>LineExp</code> 中指定查询的属性列，选择全部列时可以简写为 <code>*</code>（输出顺序和原表中一致）</li><li><code>LineExp</code> 不仅可以输入列的名，也可以输入含列的表达式，例如 <code>SELECT Sno+10 FROM Student;</code>，就把 <code>Sno+10</code> 这个表达式作为元素进行输出</li></ul><h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><ul><li>当输出内容中包含有完全相同的两个元组时，可以通过 <code>DISTINCT</code> 对重复行进行合并，使用 <code>ALL</code> 则不合并输出</li><li>当需要对元组进行内容上的筛选时，使用 <code>WHERE</code> 子句对元组进行筛选，常用的查询条件如下：</li></ul><table><thead><tr><th>条件</th><th>谓词</th></tr></thead><tbody><tr><td>比较</td><td>比较运算符</td></tr><tr><td>确定范围</td><td>[NOT] BETWEEN &lt;data1&gt; AND &lt;data2&gt;</td></tr><tr><td>确定集合</td><td>[NOT] IN (element1, element2)</td></tr><tr><td>字符匹配</td><td>[NOT] LIKE &lt;String&gt; ESCAPE &lt;换码字符&gt;</td></tr><tr><td>空值</td><td>IS [NOT] NULL</td></tr><tr><td>逻辑运算</td><td>AND, OR, NOT</td></tr></tbody></table><ul><li><p>比较：表示某个字段是否满足数学上的关系</p></li><li><p>确定范围：寻找属性值在指定范围内的元组；<code>Cno BETWEEN 1 AND 10</code></p></li><li><p>确定集合：寻找属性值是 <code>element&lt;i&gt;</code> 的元组；<code>Cname IN (name1, name2)</code></p></li><li><p>字符匹配：换码字符表示其后的字符不再具有通配符的含义，转义为普通的字符，例如 <code>LIKE &#39;APP\_00__&#39; ESCAPE &#39;\&#39;</code> 中，换码字符为 <code>\</code>，那么在 00 前的 <code>\_</code> 就将通配符转化为了一般的下划线字符，而后面的两个通配符没有进行转义，仍表示通配意义</p><ul><li>关于字符串匹配符：表示多个字符用 <code>%</code>，单个字符用 <code>_</code>，中文字符在 <code>ASCII</code> 中使用两个下划线， <code>GBK</code> 中使用一个</li></ul></li><li><p>多条件约束：使用 <code>AND</code> 和 <code>OR</code> 连接多个查询条件</p></li></ul><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><ul><li>聚集函数用于查询的返回值字段，用于执行一些整体上的统计功能，包含 <code>DISTINCT</code> 和 <code>ALL</code> 两个短语，默认为后者，前者会取消计数重复值</li><li>除了第一个 <code>COUNT(*)</code> 外，其余的聚集函数会跳过 NULL 值</li><li>聚集函数不能应用于 WHERE 子句中，只能使用在 HAVING 子句和 SELECT 子句中</li></ul><table><thead><tr><th>聚集函数名</th><th>作用</th></tr></thead><tbody><tr><td>COUNT(*)</td><td>统计返回的元组个数</td></tr><tr><td>COUNT([DISTINCT | ALL] &lt;LineName&gt;)</td><td>计算指定列有值（不为 NULL）的个数</td></tr><tr><td>SUM([DISTINCT |ALL] &lt;LineName&gt;)</td><td>计算指定列值的总和</td></tr><tr><td>AVG([DISTINCT |ALL] &lt;LineName&gt;)</td><td>计算指定列值的平均值</td></tr><tr><td>MAX([DISTINCT |ALL] &lt;LineName&gt;)</td><td>同理，最大值</td></tr><tr><td>MIN([DISTINCT |ALL] &lt;LineName&gt;)</td><td>最小值</td></tr></tbody></table><h4 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h4><ul><li>GROUP BY 语句将查询结果值相等的所有元组看作一个组，在分组操作后，聚集函数会单独应用于每个组内</li><li>类似的可以对组进行筛选，使用 HAVING 语句指定筛选条件</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sno             <span class="comment">/* 查询 学生学号 */</span></span><br><span class="line"><span class="keyword">FROM</span> SC                <span class="comment">/* 从 选课记录表 中进行选择 */</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno           <span class="comment">/* 以 学生学号 分组 */</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">3</span>;   <span class="comment">/* 筛选 元组数量大于 3 的组 */</span></span><br></pre></td></tr></table></figure><p>我们可以注意到，聚集函数的功能都是应用于复数个元组的，所以显然不能在 WHERE 语句中使用，但对于 GROUP BY 语句，它操作的对象是<strong>组</strong>，也就是复数个元组，此时就可以使用聚集函数进行筛选，获得符合计算要求的组</p><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><ul><li>当查询操作同时涉及多个表，操作便成为了<strong>连接查询</strong>，连接查询是关系数据库中最主要的查询操作</li><li>连接语句中 WHERE 子句用于连接两个表的条件被称为连接条件，通过控制连接条件驱动进行多表查询，连接条件中字段类型必须是可比较的，但是列名不需要完全一致</li><li>对于两个表以上的连接操作，设置复数个连接条件即可</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A, B, C</span><br><span class="line"><span class="keyword">FROM</span> T1, T2, T3</span><br><span class="line"><span class="keyword">WHERE</span> T1.Z<span class="operator">=</span>T2<span class="operator">=</span>Z <span class="keyword">AND</span> T2.Y<span class="operator">=</span>T3.Y;</span><br></pre></td></tr></table></figure><h4 id="等值、非等值连接查询"><a href="#等值、非等值连接查询" class="headerlink" title="等值、非等值连接查询"></a>等值、非等值连接查询</h4><ul><li>当连接条件中的连接运算符为 <code>=</code> 时，操作被称为<strong>等值连接</strong></li></ul><p>例如查询每个学生的信息与选课情况：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Student.<span class="operator">*</span> SC.<span class="operator">*</span>       <span class="comment">/* 展示字段 */</span></span><br><span class="line"><span class="keyword">FROM</span> Student, SC            <span class="comment">/* 数据来源 */</span></span><br><span class="line"><span class="keyword">WHERE</span> Student.Sno <span class="operator">=</span> SC.Sno; <span class="comment">/* 等值连接 */</span></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310131826348.png" alt="image-20231013182648190"></p><ul><li>可以在 WHERE 执行连接操作的同时追加其他的限定条件从而对连接后的结果进行筛选</li></ul><h4 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h4><p>一个表也可以和自己连接，查询操作一致，只需要注意命名问题：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FIRST.Cno, SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span> <span class="comment">/* 注意需要给两个表起名进行区分 */</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno <span class="operator">=</span> Second.Cno;</span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>当元组不满足连接条件时，连接操作会默认将这些元组删去，可以用 <code>LEFT | RIGHT OUTER JOIN &lt;Table&gt; ON (Condition)</code> 来执行外连接操作</p><p>例如 FROM 语句可以写成：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> (Student.Sno<span class="operator">=</span>SC.Sno) </span><br><span class="line"><span class="comment">/* 这里等号左边就是 LEFT 表了 */</span></span><br></pre></td></tr></table></figure><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><ul><li><p><strong>嵌套查询</strong>：将一个查询块嵌至另一个查询块的 WHERE、HAVING 条件中就形成了嵌套查询；两个操作分别被称为<strong>外层查询</strong>和<strong>内层查询</strong>；</p></li><li><p>当子查询的查询条件与父查询不相关时是不相关子查询，有依赖时称为相关子查询</p></li><li><p>SQL 允许多层嵌套，但只有最外层操作可以使用 ORDER BY 进行排序</p></li></ul><p>嵌套查询一般分有几类，IN 查询、比较运算符查询、ANY/ALL 谓词查询、EXISTS 谓词查询</p><p>当子查询返回了一个元组/值（聚集函数）时，可以直接使用比较运算符进行处理，若返回了多个元组，就要使用 <code>ANY/ALL</code> 进行辅助（或者利用<strong>聚集函数</strong>转化结果为单值）</p><p>ANYALL 谓词需要和比较运算符连用：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310131911301.png" alt="image-20231013191145200"></p><p>EXISTS 查询返回逻辑真值</p><p>下面是一些查询的示例：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310131906518.png" alt="image-20231013190645408"></p><h3 id="集合查询"><a href="#集合查询" class="headerlink" title="集合查询"></a>集合查询</h3><p>实质上是把多次查询的结果做了运算，包括集合上的交并差三种（分别为 INTERSECT、UNION、EXCEPT）集合运算。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="派生表查询"><a href="#派生表查询" class="headerlink" title="派生表查询"></a>派生表查询</h3><p>将子查询放在 <code>FROM</code> 子句中，充当父级查询的数据来源，如：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查询<span class="keyword">SELECT</span> Sno, Cno</span><br><span class="line"><span class="keyword">FROM</span> SC, (</span><br><span class="line">    <span class="keyword">SELECT</span> Sno, <span class="built_in">Avg</span>(Grade) </span><br><span class="line">    <span class="keyword">FROM</span> SC <span class="keyword">GROUP</span> <span class="keyword">BY</span> Sno</span><br><span class="line">) <span class="keyword">AS</span> Avg_sc(avg_sno, avg_grade)</span><br><span class="line"><span class="keyword">WHERE</span> SC.Sno <span class="operator">=</span> Avg_sc.Sno <span class="keyword">AND</span> SC.Grade <span class="operator">&gt;=</span> Avg_sc.avg_grade</span><br></pre></td></tr></table></figure><h2 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h2><p>主要分为增删改三种操作，简单说明：</p><ul><li>插入：<code>INSERT INTO &lt;Table&gt; &lt;Column&gt;, &lt;Column&gt; VALUES &lt;Value&gt;, &lt;Value&gt;</code></li><li>更新：<code>UPDATE &lt;Table&gt; SET &lt;Column&gt;=&lt;Value&gt;, &lt;Column&gt;=&lt;Value&gt;</code></li><li>删除：<code>DELETE FROM &lt;Table&gt; WHERE &lt;Cond&gt;</code><ul><li>这里的 <code>&lt;Cond&gt;</code> 可以用来构造子查询，充当删除项的筛选条件</li></ul></li></ul><p>数据更新操作可能会破坏数据表的参照完整性</p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值与另一个值的算数运算结果为空值，比较运算结果为 UNKNOWN。在查询语句中，只有使得 WHERE 和 HAVING 的条件为 TRUE 的元组才能被选中。</p><ul><li>要注意一个空值和另一个空值做 <code>eq</code> 运算结果可能为 <code>Unknown</code>，需要注意判断条件</li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是从几个基本表中导出的虚表，不存放实际数据。基本表数据若发生变化，视图数据也会变化。允许在视图上再定义视图，但更新视图有一定限制。</p><h3 id="视图的操作"><a href="#视图的操作" class="headerlink" title="视图的操作"></a>视图的操作</h3><ul><li>定义视图：<code>CREATE VIEW &lt;NAME&gt; &lt;Column&gt;, &lt;Column&gt; AS &lt;子查询&gt; [WITH CHECK OPTION]</code>。子查询可以是任意 <code>SELECT</code> 指令，最后的条件语句说明修改视图时会自动加上子查询中的筛选条件，不合法则不执行。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_S</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno, Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sdept <span class="operator">=</span> <span class="number">6</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CHECK</span> OPEION;</span><br></pre></td></tr></table></figure><p>这里就会把所有 6 系学生的学号+姓名拿出来形成一个新视图，在修改视图时，数据库系统会自动检查修改后是否满足 <code>Sdept = 6</code> 这个限制条件。</p><ul><li><p>删除视图：<code>DROP VIEW &lt;NAME&gt; [CASCADE]</code> ，如果被删除的视图导出了其他的视图，<code>CASECADE</code> 关键字会将所有关联视图都删除掉</p></li><li><p>查询视图：操作与查基本表相同，视图会持久保存</p></li><li><p>修改数据：也和基本表类似，但是需要注意并不是所有视图都支持更新。如果视图的某一列使用了类似聚集函数等操作（例如AVG），因为系统无法更改所有与之相关的数据从而修改 AVG，所以这个表就是不可更新的。</p></li></ul><p>以下是不允许更新的视图：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310242136814.png" alt="image-20231024213643712"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310242136296.png" alt="image-20231024213657260"></p><ul><li>需要注意<strong>不允许更新</strong>视图仍然有可能更新，但是不可更新视图一定不能更新</li></ul><h1 id="第-4-章-数据库的安全性与完整性"><a href="#第-4-章-数据库的安全性与完整性" class="headerlink" title="第 4 章 数据库的安全性与完整性"></a>第 4 章 数据库的安全性与完整性</h1><blockquote><p>这一章不是授课重点喵，过一遍 ppt 选点放放</p></blockquote><h2 id="SQL-的数据控制"><a href="#SQL-的数据控制" class="headerlink" title="SQL 的数据控制"></a>SQL 的数据控制</h2><p>当数据库管理员建立了一个新用户之后，必须授予它一定的权限，该用户才能使用数据库。在数据库系统中可以授予用户两类权限：</p><ul><li>用户级权限：用户级权限是数据库管理员为每个用户授予的特定权限。这种权限与整个数据库相关，与数据库中具体的关系无关。这种权限是对用户使用整个数据库的权限的限定。</li><li>关系级权限：关系级权限是数据库管理员或数据库对象的拥有者为用户授予的与关系或视图有关的权限。这种权限是对用户使用关系和视图的权限的限定。</li></ul><h2 id="用户级权限的管理"><a href="#用户级权限的管理" class="headerlink" title="用户级权限的管理"></a>用户级权限的管理</h2><ul><li>通过 Grant 语句为用户授予用户级权限或角色，其语法格式为：</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Grant</span> <span class="operator">&lt;</span>用户级权限<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span> [&#123;,<span class="operator">&lt;</span>用户级权限<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span>&#125;]</span><br><span class="line"><span class="keyword">To</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span><span class="operator">|</span>public [&#123;,<span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span>&#125;]</span><br><span class="line">[<span class="keyword">With</span> <span class="keyword">Grant</span> Option]</span><br></pre></td></tr></table></figure><ul><li>通过 Revoke 指令收回权限</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Revoke</span> <span class="operator">&lt;</span>用户级权限<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span> [&#123;,<span class="operator">&lt;</span>用户级权限<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span>&#125;]</span><br><span class="line"><span class="keyword">From</span> <span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span><span class="operator">|</span>public [&#123;,<span class="operator">&lt;</span>用户名<span class="operator">&gt;</span><span class="operator">|</span><span class="operator">&lt;</span>角色<span class="operator">&gt;</span>&#125;]</span><br></pre></td></tr></table></figure><ul><li><code>public</code> 指数据库中所有用户，<code>With Grant Option</code> 则说明权限是否可以二次传递，若包含则说明本次被 <code>Grant</code> 的用户也有了使用 <code>Grant</code> 语句的权力</li><li>仍要注意，当收回权限时，若该用户已将权限授予其它用户，则也一并收回。</li></ul><h2 id="完整性规则"><a href="#完整性规则" class="headerlink" title="完整性规则"></a>完整性规则</h2><ul><li>一条完整性规则可以用一个五元组描述（DOACP）：</li><li>D（Data）约束所作用的数据对象</li><li>O（Operation）触发完整性检查的数据库操作，即当用户发出什么操作请求时需要检查该完整性规则，是立即检查还是延迟检查。</li><li>A（Assertion）数据对象必须满足的断言或语义约束。</li><li>C（Condition）选择A作用的数据对象值的谓词。</li><li>P（Procedure）违反完整性规则时触发的过程。</li></ul><h2 id="完整性约束的分类"><a href="#完整性约束的分类" class="headerlink" title="完整性约束的分类"></a>完整性约束的分类</h2><ul><li>固有约束：在 DBMS 实现时已经考虑，不必特殊说明。</li><li>隐含约束的说明可以通过 DDL 语句来定义实现，实体完整性、参照完整性</li><li>显式完整性约束的说明一般有过程说明方式，断言说明方式，触发器说明方式等几种。</li></ul><hr><ul><li>过程说明方式：把约束的说明和检验作为一个过程，由程序员编码到每个更新数据库的事务中。用以检验数据库更新是否违反了给定约束。使用这种方法，为程序员利用通用程序设计语言编制高效率完整性验证程序提供了有利条件。然而，这种方法也为程序员增加了负担。程序员必须清楚他所编码的事务所涉及的所有完整性约束，为每个约束编制一个验证过程。程序员的任何误解、遗漏，疏忽都将导致数据库不正确。同时，一旦完整性约束发生变化，应用程序就必须作相应的修改。</li><li>断言说明方式：断言指数据库必须满足的逻辑条件，数据库完整性约束可以看成一系列断言的集合。使用这种方法DBMS需要提供断言说明语言，用以定义断言。并提供完整性验证子系统将其编译和存储到约束库，对于每个更新事务，完整性检查子系统利用约束库中的定义进行检查，判断是否违背了完整性约束。利用这种方法可以将约束集中在约束库中，免除了程序员在应用程序中分散定义和维护完整性约束的问题，减少了编程的麻烦，方便了应用程序和约束的维护。但其实现比较复杂，开销也大，降低了数据库更新的性能。例如 ASSERT 余额约束 ON 储蓄表：余额&gt;=0；</li><li>触发器说明方式：所谓触发器就是一类事件驱动的特殊过程，一旦定义，当发生预定义的事件时，系统自动执行相应的触发器。定义触发器时，需要定义：触发器的触发条件以及触发器应当完成的操作。注意：断言表示数据库状态应当满足的条件，而触发器中的条件却是违反约束的条件，二者正好相反。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CompilePrincipal-Chapter4</title>
      <link href="/p/942e82b.html"/>
      <url>/p/942e82b.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理笔记"><a href="#编译原理笔记" class="headerlink" title="编译原理笔记"></a>编译原理笔记</h1><p>第 08 讲 ~ 第 10 讲：错误处理、语法制导翻译技术、语义分析和代码生成</p><h1 id="第-08-讲-错误处理"><a href="#第-08-讲-错误处理" class="headerlink" title="第 08 讲 错误处理"></a>第 08 讲 错误处理</h1><h2 id="错误的定义与分类"><a href="#错误的定义与分类" class="headerlink" title="错误的定义与分类"></a>错误的定义与分类</h2><p>编译器在面对错误的源程序时需要进行语法、语义上的处理，发现成分的错误。一般错误分为两类：<strong>语法错误</strong>和<strong>语义错误</strong></p><ul><li>语法错误：不符合语法规则（上下文无关的）；简单来说就是看上去就不是人话</li><li>语义错误：不符合语义规则、超越系统限制</li><li>语义规则：<ul><li>标识符先定义后引用</li><li>标识符引用满足作用域规定</li><li>函数调用时形参、实参类型与数量匹配</li><li>参与运算的操作数类型匹配</li><li>数组等下标不允许越界</li></ul></li><li>系统限制：<ul><li>数值溢出</li><li>符号表、静态存储区溢出</li><li>动态存储分配区域溢出</li></ul></li></ul><h2 id="错误的诊察与报告"><a href="#错误的诊察与报告" class="headerlink" title="错误的诊察与报告"></a>错误的诊察与报告</h2><p>对错误的勘察大致可以分为三部分：语法规则检查、语义规则检查、溢出错误检查，分别进行在语法分析、语义分析和程序运行中。</p><p>错误报告需要判断出错的位置和错误性质，位置指的就是行号或 Token 的计数器；错误性质要根据进行的错误处理具体判断</p><h2 id="错误处理技术"><a href="#错误处理技术" class="headerlink" title="错误处理技术"></a>错误处理技术</h2><p>发现错误后并报告后，需要对错误进行处理，使得编译能继续执行。</p><ul><li>错误改正：对于语法错误可以根据文法进行错误改正，但由于文法的复杂性很难实现</li><li>错误局部化处理：将错误产生的影响限制在一个范围内，避免错误扩散对其他部分造成进一步影响</li></ul><p>下面介绍错误局部化处理的几个步骤：</p><ul><li>当诊察到错误时，先暂停分析，跳过<strong>词法分析中</strong>出现的不合法单词、<strong>语法分析中</strong>当前的语法成分，向下分析</li><li>找到对应的合法后继符号（语法成分的后继符号）和停止符号，控制错误影响的范围</li></ul><h1 id="第-09-讲-语法制导翻译技术"><a href="#第-09-讲-语法制导翻译技术" class="headerlink" title="第 09 讲 语法制导翻译技术"></a>第 09 讲 语法制导翻译技术</h1><h2 id="翻译文法"><a href="#翻译文法" class="headerlink" title="翻译文法"></a>翻译文法</h2><ul><li>动作符号：以 <code>@</code> 开头，代表执行某个功能的符号，<code>@print(&#39;a&#39;)</code> 可以代表输出字符 <code>a</code>，输出字符串也可以直接写成 <code>@a</code></li><li>翻译文法：翻译文法是上下文无关文法，在翻译文法中，终结符号集合由<strong>输入符号</strong>和<strong>动作符号</strong>组成。</li><li>活动序列：由翻译文法确定的语言中的符号串<ul><li>输入序列：活动序列中删掉所有动作符号后得到的序列（就是输入符号）</li><li>动作序列：同理，删掉所有输入符号后得到的序列</li></ul></li></ul><p>如果一个翻译文法的所有动作符号都是输出符号串，那么这个翻译文法又叫符号串翻译文法；更普遍的来说，动作可能是执行某些子程序，实现拓展功能等</p><h2 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h2><ul><li>语法制导翻译：根据输入文法获得翻译该符号串的动作序列，并执行动作序列里的所有动作的过程</li></ul><p>对于符号串翻译文法而言，输出序列和动作符号序列的意义是相同的，以后缀表达式为例，动作序列 <code>@a@b@c@*@+</code> 和输出序列 <code>abc*+</code> 在意义上是等价的，都可以认为是输入 <code>a+b*c</code> 的翻译</p><p>在尝试编写某个已有文法的符号串翻译文法时，需要根据输出序列和动作序列的要求，来合理安排动作符号在文法中的位置，借此来让动作序列效果等价于输出序列</p><h2 id="属性翻译文法"><a href="#属性翻译文法" class="headerlink" title="属性翻译文法"></a>属性翻译文法</h2><p>引入属性翻译文法，需要向符号引入值（属性）的概念。在翻译文法的所有终结符、非终结符和动作符号中，都具有值的概念，通常而言有自下向上传播的综合属性和自上向下传播的继承属性。在引入这两种属性后，我们就可以对属性翻译文法进行定义。</p><p>属性翻译文法是一个满足下列约束条件的翻译文法：</p><ul><li>终结符、非终结符和动作符号都带有属性，且属性有对应的值域</li><li>非终结符和动作符号可以具有综合属性和继承属性</li><li>起始符号的继承属性和终结符号的综合属性都具有初始值（前者预定义，后者源自输入）</li><li>继承属性：<ul><li>产生式右端的继承属性来自于该产生式中左侧的其他符号</li><li>如在产生式左端，则寻找一个自身在右端的产生式，套上一条</li><li>符号的继承属性表示为 $A_{\downarrow p}$</li></ul></li><li>综合属性：<ul><li>产生式左端的综合属性来自于右端符号的运算</li><li>动作符号的综合属性来自于其他属性值</li><li>符号的总和属性表示为 $a_{\uparrow q}$</li></ul></li><li>对于文法中的属性计算，也需要形成对应的属性求值规则</li></ul><p>一个属性翻译文法的实例如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310102002378.png" alt="image-20231010200223280"></p><blockquote><p>包含属性求值规则的文法，这里的 $@ ANSWER$ 是一个动作，意为执行 $ANSWER$ 函数，参数为 $r$</p></blockquote><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310102003840.png" alt="image-20231010200303805"></p><blockquote><p>示例的属性计算语法树，输入串为 $(i_{\uparrow 3}+i_{\uparrow 9})*i_{\uparrow 2}$</p></blockquote><h2 id="属性翻译文法的自顶向下翻译"><a href="#属性翻译文法的自顶向下翻译" class="headerlink" title="属性翻译文法的自顶向下翻译"></a>属性翻译文法的自顶向下翻译</h2><blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CompilePrincipal-Chapter3</title>
      <link href="/p/97267d88.html"/>
      <url>/p/97267d88.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理笔记"><a href="#编译原理笔记" class="headerlink" title="编译原理笔记"></a>编译原理笔记</h1><p>第 05 讲 ~ 第 07 讲：符号表管理技术、运行时的存储组织及管理、源程序的中间形式</p><h1 id="第-05-讲-符号表管理技术"><a href="#第-05-讲-符号表管理技术" class="headerlink" title="第 05 讲 符号表管理技术"></a>第 05 讲 符号表管理技术</h1><ul><li>符号表：编译程序为了记录源程序中标识符以及相关的信息时所用到的表格。其中的每一个登记项都填入了标识符的种类、类型、特征、存储单元地址等信息。</li></ul><h2 id="符号表的概念"><a href="#符号表的概念" class="headerlink" title="符号表的概念"></a>符号表的概念</h2><ul><li>在多遍编译程序中，符号表在<strong>词法分析</strong>时创建，当检测到标识符单词时就添加一个符号表的项和对应索引；符号表在<strong>语义分析</strong>时才填入项的其他信息，因为只有这时才能根据标识符上下文分析出标识符的相关属性。</li></ul><p>如果在语法分析时就对符号表进行填写会导致某些信息的缺失，或在错误的阶段产生了信息，导致编译程序耦合度过高，工程性下降。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309242220876.png" alt="image-20230924222017786"></p><ul><li>在单遍编译程序中，程序则在<strong>语义分析</strong>阶段才创建符号表，之前的阶段和符号表是完全无关的，这样可以降低耦合度，同时简化符号表和程序之间的交互</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309242222155.png" alt="image-20230924222250119"></p><h3 id="符号表的作用"><a href="#符号表的作用" class="headerlink" title="符号表的作用"></a>符号表的作用</h3><ul><li>源程序中，标识符的每一次出现都需要从符号表中查询对应的项，有则获取信息，无则添加条目；不同声明类型的语言在查表时的操作也存在差异</li><li>符号表的表项会随着标识符的存在、创建和删除而做出动态的修改，也就是说符号表是一个动态表，编译程序需要时刻对其进行管理</li><li>符号表在编译过程中，主要提供标识符的名称、类型和存储地址空间等关键信息，访问量大</li></ul><h3 id="符号表的操作"><a href="#符号表的操作" class="headerlink" title="符号表的操作"></a>符号表的操作</h3><p>最常见的操作是插入、查询，插入操作与声明类型相关。</p><ul><li>显式声明语言：插入和查询是<strong>可以区分的</strong>，插入时理论上不需要查表，可以直接插入；而查询时则正常查询</li><li>隐式声明语言：无法区分插入与查询，无论是插入还是查询都需要进行查表的工序，然后再进行插入或获取信息</li><li>在实际的编译器中，大部分符号表都采用排序后的方式进行存储，那么显式声明语言在插入之前也需要找到自己需要插入的位置，说到底还得做一次查询的操作，这样一来两类语言的两种操作区别就不是很明显了</li></ul><p>除了两类基本操作外，还有定位、重定位两类操作，它们在分程序结构语言的符号表中也经常使用，当检测到分程序的开始时执行定位，结束时则执行重定位。具体的操作将在第 4 小节中进行介绍。</p><ul><li>分程序结构语言是指其模块可以包含能嵌套的子模块，每个子模块都能包含独立的标识符和函数参数，在查表时，程序会递归地查找所有自己之上的所有符号表，直到找到标识符或无定义报错，C 语言就具有分程序结构</li><li>定位：当子模块开始时，编译器创建一块新的子符号表，在新模块中出现的所有标识符都放置在这个子符号表中；所有的子符号表都可以嵌套新的符号表</li><li>重定位：当子模块结束时，编译器对该模块的符号表进行销毁，清空其中的所有标识符，归还空间（允许后续的模块对其进行覆盖）</li></ul><p>需要注意的是，在查找分程序结构的符号表时可以允许不同的符号表（模块）中包含相同的定义（局部变量），但是不允许同一符号表中有相同的定义（重复定义）</p><h2 id="符号表的组织与内容"><a href="#符号表的组织与内容" class="headerlink" title="符号表的组织与内容"></a>符号表的组织与内容</h2><h3 id="符号表的结构"><a href="#符号表的结构" class="headerlink" title="符号表的结构"></a>符号表的结构</h3><p>符号表由一系列行组成，每行类似于一条记录，包含了指定富豪的相关属性，通常包含以下信息：</p><ul><li>名称：标识符的名称</li><li>类型：整型、字符串等</li><li>分配的内存地址</li><li>声明、使用行</li><li>链域：如若使用链式符号表，则会存在一个指向下一个标识符的链域</li></ul><h3 id="符号表的组织方式"><a href="#符号表的组织方式" class="headerlink" title="符号表的组织方式"></a>符号表的组织方式</h3><p>通常符号表有以下三种组织方式：</p><ul><li>统一符号表：对所有标识符都填入结构相同的符号表中，符号表查表会比较方便，但浪费空间</li><li>按种类符号表：将属性相同的符号组织在一起，形成多张符号表，空闲的域少，空间效率高，但是查表等操作的时间复杂度高</li><li>折中办法：将大部分共同信息组合成一个符号表，再将多余的信息拉一个链域单独存放</li></ul><p>对于符号表中标识符名称的存放方式有两种：定长空间（能够快速存取，但是空间浪费），包含标识符起始位置和长度的字符串描述符（字符紧密排列，但是效率低）</p><h2 id="非分程序结构语言的符号表组织"><a href="#非分程序结构语言的符号表组织" class="headerlink" title="非分程序结构语言的符号表组织"></a>非分程序结构语言的符号表组织</h2><h3 id="标识符的作用和基本处理方法"><a href="#标识符的作用和基本处理方法" class="headerlink" title="标识符的作用和基本处理方法"></a>标识符的作用和基本处理方法</h3><ul><li>对非分程序结构语言而言，每个程序单元都不包含子模块，声明的所有标识符都属于这个模块</li><li>全局变量和局部变量需要分别存放，声明变量时需要存入局部变量表中，如果已经出现重复定义则需报错</li><li>执行时查表顺序为局部表 → 全局表，如果都没找到则说明未声明</li><li>局部表在程序段结束后则应该释放</li></ul><h3 id="符号表的组织方式-1"><a href="#符号表的组织方式-1" class="headerlink" title="符号表的组织方式"></a>符号表的组织方式</h3><p>分为无序符号表、有序符号表和散列符号表，无序符号表查表复杂，管理简单；有序符号表因为插入之前要先比查找，所以导致插入较慢，但查询相对而言更快</p><p>散列符号表则将符号进行 hash 处理，以 hash 值进行符号的存储和访问。</p><p>散列函数有一些常用的备选选项：中平方散列法、折叠法和长度相关法。</p><ul><li>中平方散列法：选取中间几位数进行平方操作，最后取模</li><li>折叠法：将值按位数拆成几个固定位数的值再相加，最后取模</li><li>长度相关法：将第一个和最后一个字符的编码相加，再加上 16 倍的符号长度，最后取模</li></ul><h2 id="分程序结构语言的符号表组织"><a href="#分程序结构语言的符号表组织" class="headerlink" title="分程序结构语言的符号表组织"></a>分程序结构语言的符号表组织</h2><p>主要涉及到了定位和重定位操作，至于链表法符号表的具体方法不如找一个题目进行应用</p><h1 id="第-06-讲-运行时的存储组织及管理"><a href="#第-06-讲-运行时的存储组织及管理" class="headerlink" title="第 06 讲 运行时的存储组织及管理"></a>第 06 讲 运行时的存储组织及管理</h1><p>编译程序替程序员管理了符号变量等的内存地址，这些地址需要编译程序主动进行分配，本章介绍静态存储分配、动态存储分配和内存垃圾回收三部分内容，其中静态存储分配适用于静态定义的数据结构，而动态存储分配更实用于管理分程序结构语言内存。</p><h2 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h2><p>如果在编译时能确定数据所需存储空间的大小，并分配固定的存储空间，这种分配方式就叫静态存储分配。换句话说当遇到可变长串、动态数组，甚至递归过程时，都不能使用静态存储分配。</p><p>我们可以很容易填写静态分配下符号表所含有的地址信息，只需要将变量按照指定的大小紧密地线性排列即可</p><ul><li>数据区：一个非分程序结构的程序模块在采用静态存储分配时的数据区分为三部分：隐式参数、形式参数和程序变量<ul><li>隐式参数：与调用模块间进行通信，调用程序时的跳转地址</li><li>形式参数：存放实参的地址和值</li><li>程序变量：编译过程中需要的变量等</li></ul></li></ul><h2 id="动态存储分配"><a href="#动态存储分配" class="headerlink" title="动态存储分配"></a>动态存储分配</h2><p>动态存储的分配方式主要基于堆栈的思想实现，程序会为每一个程序段创建一个自己的数据区域，并占用一定空间，当程序调用子模块时就延伸这个堆栈，程序结束时就弹出这部分栈，这部分占用的专用数据区被称为活动记录</p><p>活动记录包含局部数据区、参数区和 display 区三部分</p><ul><li>局部数据区：为局部变量的存储提供空间</li><li>参数区：保存隐式参数和显式参数</li><li>display 区：一系列指针</li></ul><h3 id="参数区"><a href="#参数区" class="headerlink" title="参数区"></a>参数区</h3><p>参数区用于保存隐式参数和显式参数。隐式参数包含返回调用者时的地址、指向上一级活动记录的指针（prevabp）、当前模块结束后的返回值</p><p>在值调用的方案中，实参值一般赋值给形式参数，并且放置在显式参数区。具体的参数传递机制在第 10 章会进行学习</p><h3 id="display-区"><a href="#display-区" class="headerlink" title="display 区"></a>display 区</h3><p>display 区为访问外部变量提供了重要方式。display 区存放了一系列指针，每一个指针都指向某一级活动记录，这些活动记录逐级调用，都是当前区域的调用者（间接调用者）。他们的变量等对于当前模块都是可见的，或者说全局的。换句话说，子模块的 display 区需要包含所有父模块的活动记录基地址指针</p><p><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230927213001590.png" alt="image-20230927213001590"></p><p>这是一个程序的调用过程</p><ul><li>首先顶层模块的活动记录 AR1 包含局部数据区，不需要参数区和 display 区；</li><li>其次调用了一个子模块，活动记录 AR2 包括正常的三个分区，参数区含有 prevabp（指向 AR1），子程序结束后的返回地址；display 区含有父模块的活动记录指针，这里还是 AR1 的指针</li><li>随后在退出 AR2 后，主程序又调用了子程序，在子模块 AR3 的参数区中，prevabp 此时也指向父模块 AR1</li><li>接着在 AR3 中又调用了 AR4，它的 prevabp 指向 AR3，并且 display 区中含有指向 AR3、AR1 的指针</li></ul><h3 id="运行时地址计算"><a href="#运行时地址计算" class="headerlink" title="运行时地址计算"></a>运行时地址计算</h3><p>假设现在要访问某一个模块中偏移量为 $ON$ 的变量（模块位于栈的第 $BL$ 层），假设当前位于该模块的子程序中，计算地址的方式如下：<br>$$<br>ADDR=display[BL] + BL-1 + nip +ON<br>$$</p><ul><li>$nip$ 指隐式参数的数目，$BL-1+nip$ 可以看作 display 区的大小</li><li>实际上是选出了 display 区中第 BL 层的活动记录的基地址，再加上 display 区的大小，最后加上变量在局部数据区的地址偏移，实际操作要比虚空推导好得多</li></ul><h2 id="内存垃圾回收器"><a href="#内存垃圾回收器" class="headerlink" title="内存垃圾回收器"></a>内存垃圾回收器</h2><blockquote><p>内存垃圾回收器是一种自动内存管理机制，可以对动态分配的内存空间进行自动回收，它需要从编译器、操作系统、芯片中获得一些信息才能达成自动回收的目的。</p></blockquote><ul><li>变量根集：程序运行时运行栈上的所有变量集合+全局变量、静态变量</li></ul><p>如果一个对象不能被根集出发的指针遍历到，那么就相当于不可达对象，那么就可以当成垃圾进行回收</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>为每个对象都设置一个计数器，它记录当前有多少引用指向当前对象，类似于操作系统中的页引用，当引用为 0 时就可以释放物理页内存。</p><p>当回收对象前，要对它的每个指针进行检查，再回收后要检查其他的对象引用计数，这样就带来了较大的开销。</p><h3 id="标记和清除垃圾回收器"><a href="#标记和清除垃圾回收器" class="headerlink" title="标记和清除垃圾回收器"></a>标记和清除垃圾回收器</h3><p>标记和清除垃圾回收器是跟踪型回收器的一种，它不移动对象。</p><ul><li>首先从对象根集遍历指针关系图，对可以到达的对象进行标记</li><li>遍历所有内存，对所有未被标记的对象进行回收，此刻回收的都是不可抵达的对象</li></ul><p>由于清理过程中不会移动对象，于是会产生内存碎片，内碎片问题严重</p><p>在空闲空间分配新对象后，不同生命周期的对象共用一个页面，导致换页频繁，程序运行效率低</p><h3 id="标记紧缩算法"><a href="#标记紧缩算法" class="headerlink" title="标记紧缩算法"></a>标记紧缩算法</h3><p>标记紧缩算法修正了标记清除回收器的碎片化、分配效率低的问题</p><ul><li>标记阶段：标记所有可达的对象</li><li>紧缩阶段：对内存空间进行多次扫描，对空间进行滑动紧凑，修改指针的引用值，将空闲空间转化为连续的空间</li></ul><p>这样的紧缩操作对于后续的访问有较大的收益，但是紧缩操作本身开销较大，如果大部分变量都不需要清理的话，多次修改大量变量的指针开销会很大</p><h3 id="拷贝回收算法"><a href="#拷贝回收算法" class="headerlink" title="拷贝回收算法"></a>拷贝回收算法</h3><p>拷贝回收算法和标记紧缩算法相似，但是拷贝回收算法不关心垃圾对象的清理工作，只将活对象移动到连续空间中。它将内存空间一分为二，并线性地分配内存，一旦内存分配至边界线处，就开始拷贝回收，将所有的活对象拷贝到当前空闲的半块内存，并将空闲的内存转化为工作状态，当前的内存转为空闲状态。</p><p>缺点就在内存的使用率上，一分为二的思想注定了内存的使用率不能超过 50%。</p><h3 id="分代垃圾回收器"><a href="#分代垃圾回收器" class="headerlink" title="分代垃圾回收器"></a>分代垃圾回收器</h3><p>目前 Java 常用的垃圾回收机制。有点复杂不想写了就先放着了）</p><h1 id="第-07-讲-源程序的中间形式"><a href="#第-07-讲-源程序的中间形式" class="headerlink" title="第 07 讲 源程序的中间形式"></a>第 07 讲 源程序的中间形式</h1><ul><li>源程序的中间形式，即编译程序将高级语言程序翻译为汇编语言或机器代码过程中产生的一种内部表示形式。</li><li>优点是移植性强、优化处理容易，缺点是效率低，需要二次翻译</li></ul><h2 id="波兰表示"><a href="#波兰表示" class="headerlink" title="波兰表示"></a>波兰表示</h2><p>前缀表示和后缀表示被称为前缀、后缀表示，后缀被称为逆波兰表示。由于前缀表达式不常使用，所以后缀表示也可以称为波兰表示</p><h3 id="波兰表示的语言结构"><a href="#波兰表示的语言结构" class="headerlink" title="波兰表示的语言结构"></a>波兰表示的语言结构</h3><p>波兰表示除了可以表示一般的表达式、赋值语句外，也可以通过扩充操作符来表示其他较为复杂的语言结构</p><p>对于 <code>if</code> 语句而言，可以进行如下的形式转换：<br>$$<br>if<expr>then<stmt_1>else<stmt_2>\ 转换为\<br><expr><label_1>BZ<stmt1><label_2>BR<stmt2><br>$$</p><h2 id="N-元表示"><a href="#N-元表示" class="headerlink" title="N 元表示"></a>N 元表示</h2><p>在 N 元表示中，每一条指令由 $n$ 个域组成，第一个域代表操作符，后续的域代表操作数</p><h3 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h3><ul><li>三元表示：$&lt;操作符&gt;,\ &lt;操作数1&gt;,\ &lt;操作数2&gt;$</li></ul><p>对复杂的表达式，可以用一组三元式表示，例如 $W*X+(Y+Z)$ 可表示成下式：<br>$$<br>1)\ *,\ W,\ X\<br>2)\ +,\ Y,\ Z\<br>3)\ +,\ 1),\ 2)<br>$$<br>类似的，条件语句也可以进行转换：<br>$$<br>\begin{align}<br> &amp; if\ X&gt;Y\<br> &amp; then\ Z:=X\<br> &amp; else\ Z:=Y+1<br>\end{align}<br>$$<br>转换成三元式则如下：<br>$$<br>\begin{align}<br> &amp; 1)\ -,\ X,\ Y\<br> &amp; 2)\ BMZ,\ 1),\ 5)\<br> &amp; 3)\ :=,\ Z,\ X\<br> &amp; 4)\ BR,\ \ ,\ 7)\<br> &amp; 5)\ +,\ Y,\ 1\<br> &amp; 6)\ :=, Z, 5)\<br> &amp; 7)\ left\ content<br>\end{align}<br>$$</p><ul><li>这里的 $BMZ$ 代表小于等于 $0$ 转移，条件语句在第二个域中，跳转标签在第三个域中；</li><li>$BR$ 代表无条件转移</li></ul><h3 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h3><p>与三元式类似，四元式也有相应的域和运算规则，具体而言域的含义如下：<br>$$<br>&lt;操作符&gt;,\ &lt;操作数1&gt;,\ &lt;操作数2&gt;,\ &lt;结果&gt;<br>$$<br>四元式的每次运算后后会产生一个临时变量，这个临时变量可以参与后续的运算，效果和三元式中的标签类似</p><ul><li>四元式便于对程序进行优化处理，因此在介绍优化的章节中会使用四元式作为中间代码形式</li></ul><h2 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h2><p>抽象语法树是另一种常用的源代码中间形式，树结构中的非叶节点代表操作符，而叶节点代表操作数，对于表达式 $(A+B<em>C)/(D</em>E-(F+G)/(H+I))$ 而言，构造的抽象语法树如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202310101311839.png" alt="image-20231010131143194" style="zoom:80%;" /><ul><li>树中的编号代表分析器自底向上创建树节点的顺序</li><li>遍历抽象语法树能够获得语法式的波兰表达式，整个树也可以由多个三元式进行组合表示，要注意最后一个三元式与树的根节点相关，每一个三元式都代表树中的一个子树</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CompilePrincipal-Chapter2</title>
      <link href="/p/79281ca4.html"/>
      <url>/p/79281ca4.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理笔记"><a href="#编译原理笔记" class="headerlink" title="编译原理笔记"></a>编译原理笔记</h1><p>第 03 讲 ~ 第 04 讲：词法分析、语法分析</p><h1 id="第-03-讲-词法分析"><a href="#第-03-讲-词法分析" class="headerlink" title="第 03 讲 词法分析"></a>第 03 讲 词法分析</h1><h2 id="正则文法和状态图"><a href="#正则文法和状态图" class="headerlink" title="正则文法和状态图"></a>正则文法和状态图</h2><ul><li>左线性文法：字母代表状态，数字代表转移过程，可添加开始状态和终止状态的标志，形成一个状态转移图。文法中表示状态的字母在左，故称左线性文法</li><li>左线性文法的状态图画法：<ul><li>每个左侧的非终结符都可以画为一个状态，，其与右侧的每一个可以推导的状态间都有一条单向的状态转移线，线上需要标记相邻的数字</li><li>重复第一步，直到某个状态推导的文法中不包含状态字母，只包含数字，这时拟出一个<strong>初始状态</strong>，与线上标记该数字，最后标记终止状态即可</li></ul></li></ul><p>以下列文法为例，进行左线性文法的状态图绘制：<br>$$<br>Z::=U1|V1\<br>U::=Z1|1\<br>V::=Z0|0<br>$$</p><ul><li>这里从第一句 $Z$ 开始，绘出状态点 $Z$、$U$、$V$，并画出 $U\to Z$、$V\to Z$ 的两条状态转移线，分别标注 $1$ 和 $1$</li><li>第二句针对状态点 $U$，画出 $Z\to U$ 的状态转移线，标注 $1$；注意到 $U$ 也可推导出 $1$，于是拟出一个初始状态 $S$ 加入状态图，并画出 $S\to U$ 的状态转移线，标注 $1$</li><li>最后一句针对状态点 $V$，画出 $Z\to V$ 的状态转移线，标注 $0$；同理从初始状态画出一条 $S\to V$ 的状态转移线，标注为 $0$</li><li>最终形成的状态转移图如下图所示：</li></ul><div align=center><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309131317199.png" alt="image-20230913131716100" style="zoom: 67%;" /></div> <ul><li>对左线性文法的状态转移而言，处理问题的过程是<strong>自底向上</strong>的。</li></ul><p>例如上图中输入字符串 $1001$ 进行识别，就会生成以下的推导过程：<br>$$<br>S=|=&gt;V1=|=&gt;Z01=|=&gt;U001=|=&gt;1001<br>$$<br>而显然，我们是从第一个 $1$ 输入后倒推回状态 U、$U+0$ 推出状态 $Z$、……、直至推回最初的初始状态 $S$</p><ul><li>在匹配字符串的过程中可以将推导得到的序列化成语法树，进行句柄的判断</li></ul><h2 id="词法分析程序"><a href="#词法分析程序" class="headerlink" title="词法分析程序"></a>词法分析程序</h2><ul><li>词法分析程序的功能：识别、组合单词，进行词法检查；将数字常数从字符串转化为数值；删去空白符号和注释</li><li>单词的种类：各个种类都有自己的状态图进行匹配，下图为简单示例<ul><li>保留字：<code>begin</code>、<code>end</code>、<code>for</code>等</li><li>标识符：由用户定义的变量名</li><li>常数：无符号数、布尔量、字符串常数</li><li>分界符：运算符等</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309131335933.png" alt="image-20230913133508874" style="zoom:67%;" /><h2 id="正则表达式与有限状态机"><a href="#正则表达式与有限状态机" class="headerlink" title="正则表达式与有限状态机"></a>正则表达式与有限状态机</h2><ul><li>正则表达式的运算符定义：<ul><li>$|$：选择其一</li><li>$·$：连接（可以省略）</li><li>${}$ 或 $*$：重复（$0$ 或更多次）</li><li>正则集合是由某一个正则表达式规则能够形成的所有句型的集合</li></ul></li><li>正则表达式的递归定义：<ul><li>$\varepsilon$ 和 $\phi$ 都是 $\Sigma$ 上的正则表达式，正则集合是 ${\varepsilon}$ 和 $\phi$</li><li>对任意 $a\in \Sigma$，其均为正则表达式，且正则集合为 ${a}$</li><li>假定 $U$ 和 $V$ 都是正则表达式，正则集合分别记为 $L(U)$ 和 $L(V)$，那么 $U|V$、$U·V$ 和 $U^*$ 都是正则表达式，正则集合分别为 $L(U)\and L(V)$、$L(U)·L(V)$ 和 $L(U)^*$</li><li>任何正则表达式和正则集合都由此递归定义</li></ul></li><li>正则表达式的性质：<ul><li>两个正则表达式相同则说明两者表示的语言相等</li><li>交换律：$e1|e2=e2|e1$</li><li>结合律：$e1|(e2|e3)=(e1|e2)|e3$</li><li>分配律：$e1(e2|e3)=e1e2|e1e3$</li><li>正则表达式与 $3$ 型文法等价</li></ul></li><li>特殊运算等式：<ul><li>$r^*=(r|\varepsilon)^*$</li><li>$r^{**}=r^*$</li><li>$(r|s)^*=(r<em>s</em>)^*$</li></ul></li></ul><h3 id="确定的有穷自动机（DFA）和状态图"><a href="#确定的有穷自动机（DFA）和状态图" class="headerlink" title="确定的有穷自动机（DFA）和状态图"></a>确定的有穷自动机（DFA）和状态图</h3><ul><li>一个确定的有穷自动机可以表示为五元式：</li></ul><p>$$<br>M=(S,\ \Sigma,\ \sigma,\ s_0,\ Z)<br>$$</p><p>其中，$S$ 是有穷状态集，$\Sigma$ 是输入字母表，$\sigma(s_x, a_i)=s_y$ 是状态转移函数，$s_0$ 是初始状态，$Z$ 是终止状态集</p><p>也可以根据状态转换矩阵画出状态转移图来表示：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191127251.png" alt="image-20230919112726111" style="zoom:67%;" /><p>此时，这个 DFA 就可以表示为这样的状态转移图：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191128437.png" alt="image-20230919112802369"></p><ul><li>DFA 可接受的符号串，若一个符号串 $\alpha=a_1a_2…a_n,\ \alpha\in\Sigma$，且 $\sigma(\sigma(…\sigma(s_0,\ a_1)…),\ a_n) = s_n,\ s_n\in Z$，那么 $\alpha$ 就可以被该 DFA 接受（也就是说如果输入能够将初始状态转移到某一个终止状态，字符串就可接受）</li><li>DFA 可接受的语言： $L(M)={\alpha\ |\ \sigma(s_0,\ \alpha)=s_n,\ s_n\in Z}$</li></ul><h3 id="不确定的有穷状态机（NFA）"><a href="#不确定的有穷状态机（NFA）" class="headerlink" title="不确定的有穷状态机（NFA）"></a>不确定的有穷状态机（NFA）</h3><p>若对于一个有穷状态机而言，输入可以为 $\varepsilon$，且 $\sigma$ 为多值函数，那么它就是不确定的（对于输入某个字符后可能存在多个后继状态）它也可以表示为五元式：<br>$$<br>M^{‘}=(S,\ \Sigma\cup{\varepsilon},\ \sigma,\ s_0,\ Z)<br>$$<br>其中，$S$ 是有穷状态集，$\Sigma\cup{\varepsilon}$ 是输入符号和 $\varepsilon$，$\sigma$ 是转换函数，$s_0$ 是初态，$Z$ 是终止状态集，如下例：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191147384.png" alt="image-20230919114718288" style="zoom:67%;" /><p>对 NFA 的状态图而言，其特点是同一个状态有同一字符标记的多条边或以 $\varepsilon$ 标记的特殊边（不消耗字符）。</p><h3 id="NFA-的确定化"><a href="#NFA-的确定化" class="headerlink" title="NFA 的确定化"></a>NFA 的确定化</h3><p>NFA 需要猜测字符串可能途径的节点和路径，可能需要多次匹配才能确定某一符号串是否能被 DFA 接受。由于 NFA 的不确定性，我们可以将 NFA 构造成一个 DFA，即将 NFA 确定化，从而进行字符序列的匹配。</p><ul><li>集合 $I$ 的 $\varepsilon$-闭包（$\varepsilon-closure(I)$）<ul><li>若 $s\in I$，则 $s\in\varepsilon-closure(I)$</li><li>若 $s\in I$，则从 $s$ 出发并经过任意条 $\varepsilon$ 边能到达的节点均属于 $\varepsilon-closure(I)$</li></ul></li></ul><p>换言之， $\varepsilon$-闭包就是所有 $I$ 中节点 + 走 $\varepsilon$ 能碰到的节点</p><ul><li>集合 $I$ 是 NFA 状态集的一个子集，$a\in\Sigma$，$I_a=\varepsilon-closure(J)$，其中 $J=\cup_{S\in I}\sigma(s,\ a)$</li></ul><p>换言之， $I_a$ 是以 $I$ 所有节点经过 $a$ 边所到达的节点再做 $\varepsilon-$闭包操作得到的集合。这个集合里所有节点距离 $I$ 都只有一个 $a$ </p><p>通过以上两个定义，可以将一个 NFA 确定化：</p><ul><li>以初始节点为集合 $I$，求出 $\varepsilon-closure(I)$</li><li>求出所有 $I_x$，其中 $x$ 为图中存在的边</li><li>将上两步中出现的所有集合都视作 $I$，重新执行 $1、2$ 两步，直至没有新集合出现</li><li>将每个出现的集合编号，每个编号都对应一个新的状态，并且 $I$ 到 $I_x$ 的转换边为 $x$</li><li>原初始状态的 $\varepsilon$ 子集是 DFA 的初态，<strong>包含</strong>原终止状态的状态为 DFA 的终态，最终画出 DFA 的状态图</li></ul><p>以下图为例说明 DFA 的转换过程：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191446257.png" alt="image-20230919144628565" style="zoom: 67%;" /><ul><li>初始状态为 ${1}$，$I={1,\ 4}$，求出 $I_a、I_b、I_c$ 并画出表格；</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191450194.png" alt="image-20230919145023156" style="zoom:80%;" /><ul><li>表格中新出现了集合 ${2,\ 3}$，将其加入 $I$ 中，重新求出 $I_x$；</li><li>过程中又出现了新的集合 ${2}、{4}、{3,\ 4}$，同样加入 ${I}$ 并循环</li><li>求出所有已出现集合后，将集合编号，表头中的 $I_x$ 转化为 $x$，得到新的状态转换矩阵</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191450588.png" alt="image-20230919145030553" style="zoom:67%;" /><ul><li>原本初始状态的 $I={1,\ 4}$，转化为初始状态；包含原终止状态 $4$ 的所有状态（${1,\ 4}、{4}、{3,\ 4}$）都转化为终止状态 </li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191450901.png" alt="image-20230919145045871"></p><h2 id="正则表达式与-DFA-的等价性"><a href="#正则表达式与-DFA-的等价性" class="headerlink" title="正则表达式与 DFA 的等价性"></a>正则表达式与 DFA 的等价性</h2><ul><li>在 $\Sigma$ 上的一个子集 $V$ 是正则集合，当且仅当存在一个 DFA M，使得 $V=L(M)$</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191507656.png" alt="image-20230919150717616" style="zoom: 67%;" /><p>对任何一个正则表达式，都可以构造出等价的 NFA，并能转化为 DFA</p><h2 id="词法分析的自动生成器（LEX）"><a href="#词法分析的自动生成器（LEX）" class="headerlink" title="词法分析的自动生成器（LEX）"></a>词法分析的自动生成器（LEX）</h2><blockquote><p>一个 LEX 源程序主要由三个部分组成（各部分之间用 $%%$ 隔开）：</p><ul><li>辅助定义式</li><li>识别程序</li><li>用户子程序</li></ul></blockquote><p>LEX 的功能是根据 LEX 源程序构造一个词法分析程序，生成对应的状态转移矩阵和控制程序，实际上是一个有穷自动机</p><h3 id="LEX-的工作过程"><a href="#LEX-的工作过程" class="headerlink" title="LEX 的工作过程"></a>LEX 的工作过程</h3><ul><li>扫描每条识别规则 $P_i$，构造相应的有穷自动机 $M_i$</li><li>将每条有穷自动机合成出新的 NFA</li><li>确定化 NFA</li><li>生成最终 DFA 的状态转换矩阵和控制执行程序</li></ul><p>过程中需要遵守的两条原则（处理二义性）：</p><ul><li>最长匹配原则：在识别单词时会优先识别为匹配最长序列的单词</li><li>优先匹配原则：若同时能有多条规则匹配，那么有限与靠前的规则进行匹配（优先权更高）</li></ul><br><h2 id="有穷自动机、正则文法、正则表达式间的转换"><a href="#有穷自动机、正则文法、正则表达式间的转换" class="headerlink" title="有穷自动机、正则文法、正则表达式间的转换"></a>有穷自动机、正则文法、正则表达式间的转换</h2><h3 id="有穷自动机-→-正则文法"><a href="#有穷自动机-→-正则文法" class="headerlink" title="有穷自动机 → 正则文法"></a>有穷自动机 → 正则文法</h3><ul><li>对转换函数/连接弧 $\sigma(A,\ t)=B$ 或 $A\overset{t}{\to} B$，有一个产生式 $A\to tB$</li><li>对终止状态 $Z$，有一个产生式 $Z\to\varepsilon$</li><li>有穷自动机的初态对应于开始符号；字母表为终结符号集</li></ul><h2 id="正则文法-→-有穷自动机"><a href="#正则文法-→-有穷自动机" class="headerlink" title="正则文法 → 有穷自动机"></a>正则文法 → 有穷自动机</h2><ul><li>每个非终结符都对应一个状态，开始符号对应起始状态 $S$</li><li>新添加一个状态 $Z$ 作为自动机的终止状态</li><li>对 $A\to tB$ 的推导，构造一条弧 $A\overset{t}{\to} B$</li><li>对 $A\to t$ 的推导，构造一条弧 $A\overset{t}{\to}Z$</li></ul><h3 id="正则式-→-有穷自动机"><a href="#正则式-→-有穷自动机" class="headerlink" title="正则式 → 有穷自动机"></a>正则式 → 有穷自动机</h3><ul><li>对于 $\varphi、\varepsilon、a\in\Sigma$，构造自动机如下：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200820060.png" alt="image-20230920082036951" style="zoom:80%;" /><ul><li>对正则式 $R=s|t$ 和 $R=st$，构造自动机如下：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200822063.png" alt="image-20230920082211990"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200822718.png" alt="image-20230920082226665"></p><ul><li>对正则式 $R=s^*$，构造自动机如下：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200822884.png" alt="image-20230920082257819"></p><h3 id="有穷自动机-→-正则式"><a href="#有穷自动机-→-正则式" class="headerlink" title="有穷自动机 → 正则式"></a>有穷自动机 → 正则式</h3><ul><li>在自动机上添加两个节点 $x、y$，前者通过 $\varepsilon$ 连接所有初态，后者同理连接所有终态</li><li>逐渐消去过程中的所有节点直至保留 $x、y$ 两个节点</li><li>消结规则如下：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200826641.png" alt="image-20230920082657562"></p><h3 id="正则文法-→-正则式"><a href="#正则文法-→-正则式" class="headerlink" title="正则文法 → 正则式"></a>正则文法 → 正则式</h3><ul><li>将文法进行转换，保留开始符号，最终剩余的产生式不包含非终结符</li><li>消结规则如下：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200835765.png" alt="image-20230920083538700" style="zoom:67%;" /><h3 id="正则式-→-正则文法"><a href="#正则式-→-正则文法" class="headerlink" title="正则式 → 正则文法"></a>正则式 → 正则文法</h3><ul><li>对正则式的每一部分，若形如 $xy、x*y、x|y$，则新创建一个非终结符</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309200837267.png" alt="image-20230920083746183"></p><h2 id="DFA-的最小化"><a href="#DFA-的最小化" class="headerlink" title="DFA 的最小化"></a>DFA 的最小化</h2><blockquote><p>对于任意一个 DFA，存在一个唯一的等价 DFA，其状态最少，这个 DFA 被称为最简的（最小化的）DFA</p></blockquote><ul><li>多余状态：对任何输入而言均为不可到达状态</li><li><strong>等价状态</strong>条件：<ul><li>一致性条件：状态 $s$ 和 状态 $t$ 必须同时可接受/不可接受</li><li>蔓延性条件：对于所有输入，两个状态必须转化到等价的状态中</li></ul></li><li>找到所有等价类后，对图中所有节点重新编号</li></ul><br><h1 id="第-04-讲-语法分析"><a href="#第-04-讲-语法分析" class="headerlink" title="第 04 讲 语法分析"></a>第 04 讲 语法分析</h1><ul><li>本讲的内容较为零散，其中包括了原书第 4 章的语法分析（一）和第 12 章的语法分析（二）两部分内容。</li><li>前一部分介绍了语法分析中<strong>自顶向下</strong>的递归子程序法，其手工实现方便、效率高，但难以自动实现</li><li>后一部分从笔记中的 LL 语法分析法开始，介绍了包括几种<strong>自底向上</strong>分析法在内的多种自动生成文法的分析程序</li></ul><h2 id="自顶向下分析"><a href="#自顶向下分析" class="headerlink" title="自顶向下分析"></a>自顶向下分析</h2><ul><li><p>给定符号串 $S$，为其构造一棵语法树，若能匹配为某一语法成分则 $S\in L(G[Z])$</p></li><li><p>主要分析过程是用起始符号进行推导，逐步匹配输入串；当出现无法匹配时逐级回溯，重新匹配其他的语法规则<br></p></li><li><p>自顶向下分析法存在两个问题，需要进行手动规避</p><ul><li>自顶向下分析的过程是预测性的，要预测输入串的语法成分</li><li>自顶向下的方法是自回溯的，在试探匹配的过程中无法避免回溯过程</li></ul></li></ul><p>下面我们对这两种问题进行分析和处理<br></p><h3 id="左递归文法问题"><a href="#左递归文法问题" class="headerlink" title="左递归文法问题"></a>左递归文法问题</h3><ul><li>当语法中存在非终结符 $U$，且有形如 $U::=U……$ 的语法规则时，则称其为<strong>左递归</strong>的</li><li>自顶向下分析的方法无法处理左递归文法问题。由于自顶向下会优先进入最左侧非终结符的解析过程，于是在处理左递归文法/间接左递归文法时会持续进入递归过程，无法结束</li><li>若要使用自顶向下的方法则必须消除直接左递归和间接左递归</li></ul><p><strong>解决方法</strong>：</p><ol><li>使用<strong>扩充 BNF</strong> 改写文法</li></ol><ul><li>若 $U::=xy|xw|…|xz$，则改写为 $U::=x(y|w|…|z)$；<ul><li>当提取公因子后，存在某一项为 $\varepsilon$，则尽量将其放置在匹配项的最后一项，因为任何字符均能匹配 $\varepsilon$，会影响匹配的结果</li></ul></li><li>若有 $U::=x|y|…|Uv$，则改写为 $U::=(x|y|…){v}$<ul><li>当同时含有左递归 or 非左递归的规则时，说明非终结符由非左递归部分+任意个左递归后部分组合而来的</li></ul></li></ul><p>对于第二条规则，有下例：$U::=x|y|z|Ua|Ub$</p><ul><li>先分为<strong>递归部分</strong>和<strong>非递归部分</strong>：$x|y|z$、$U(a|b)$</li><li>再进行连接：$U::=(x|y|z){a|b}$<br></li></ul><ol start="2"><li><p>将左递归转化为右递归：若 $U::=U\alpha|U\beta|\gamma|\theta$，则可转化为右递归 $U::=\gamma|\theta{U^{‘}};\ U^{‘}::=\alpha|\beta$</p></li><li><p>消除一般左递归：</p></li></ol><ul><li>把所有非终结符整理成后续非终结符可推导前驱非终结符的顺序然后把所有前驱的非终结符带入到后续的非终结符，消除后续规则的左递归</li><li>通常一般左递归包含了多余规则，需要进行语法压缩</li></ul><h3 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h3><p>当非终结符在解析规则时，右部有多个选择就需要做出挑选，当无法匹配完全时，就需要考虑回溯，选择其他的分支，回溯会导致语法分析工作的浪费，因此文法需要尽量避免回溯问题。回溯不发生时文法需要满足：<br>$$<br>FIRST(\alpha_i)\cap FIRST(\alpha_j)=\varphi(i\ne j)<br>$$<br>消除回溯可以通过以下几种方法实现：</p><ul><li>改写文法：对具有多个相同左部的规则提取公因子<ul><li>将 $U::=xV|xW$ 改写为 $U::=x|Z;\ Z::=V|W$</li></ul></li><li>超前扫描：当语法无法改写为公因子形式时，可以向前侦察输入符号串的后续字符进行匹配，但是不进行语义的处理工作（<strong>一般不采用</strong>）</li></ul><h3 id="非回溯自顶向下分析文法的两个条件"><a href="#非回溯自顶向下分析文法的两个条件" class="headerlink" title="非回溯自顶向下分析文法的两个条件"></a>非回溯自顶向下分析文法的两个条件</h3><p>为了实现非回溯的自顶向下分析法，文法需要满足两个条件：</p><ul><li>文法是非左递归的</li><li>当非终结符规则右侧有多个选择时，各个选择的首符号集合不相交<br></li></ul><p>下面介绍两种常用的自顶向下分析法：递归子程序法和 LL(1) 分析法<br></p><h3 id="递归子程序法"><a href="#递归子程序法" class="headerlink" title="递归子程序法"></a>递归子程序法</h3><ul><li>对语法中每一个非终结符都编写一个分析程序，根据输入匹配时，逐个调用对应非终结符的分析程序</li><li>不允许出现左递归，但是允许存在其他位置的递归</li><li>在进行分析程序的调用时，需要先将语法成分的第一个字符读入程序再解析</li><li>递归子程序法对应的是<strong>最左推导过程</strong></li></ul><h3 id="LL-1-语法分析法（未完成）"><a href="#LL-1-语法分析法（未完成）" class="headerlink" title="LL(1) 语法分析法（未完成）"></a>LL(1) 语法分析法（未完成）</h3><ul><li><p>LL 分析法自左向右扫描+自顶向下推导、分析、匹配输入串，体现为最左推导</p></li><li><p>由分析表、执行程序、符号栈三部分组成</p></li><li><p>分析表：一个概括文法全部信息的矩阵，每一行都有一个非终结符，每一列都有一个终结符</p></li><li><p>执行程序：按照分析表逻辑对符号栈和输入串进行操作的程序，程序逻辑在不同语言中是通用的</p></li></ul><h4 id="分析表的构造方法"><a href="#分析表的构造方法" class="headerlink" title="分析表的构造方法"></a>分析表的构造方法</h4><p>为构造分析表，需要预定义两个和文法有关的集合 FIRST 和 FOLLOW</p><ul><li>$FIRST(\alpha)={a|\alpha\overset{*}{\to} a…,\ a\in V_t}$，换言之，$FIRST$ 就是从 $\alpha$ 推导出所有可能的符号串中，第一个终结符、$\varepsilon$ 的集合</li><li>$FOLLOW(\alpha)={a|S\overset{*}{\to} …Aa…,\ a\in V_t}$，$FOLLOW$ 是所有从 $S$ 推出的句型中 $A$ 后终结符的集合<br></li></ul><p>构造 $FIRST$ 集合（$\alpha\in{V_n,\ V_t}$）：</p><ul><li>若 $\alpha\in V_t$，则 $FIRST(\alpha)={\alpha}$</li><li>若 $\alpha\in V_n$，且存在可推导 $\alpha\to aX$ 的产生式，则把 $a$ 加入集合</li><li>若存在 $\alpha\to Y_1Y_2…Y_n$ 的产生式，如果 $Y_i$ 的 $FIRST$ 集合中有 $\varepsilon$，就能把 $Y_{i+1}$ 的 $FIRST$ 集合计入 $FIRST(\alpha)$ 中</li><li>对于整个符号串，方式与第三条相同</li></ul><p>构造 $FOLLOW$ 集合（$\alpha\in{V_n}$）：</p><ul><li><p>对于开始符号 $S$，令 #\in FOLLOW(S)$</p></li><li><p>若存在 $A\to\alpha B\beta$ 的产生式（$\beta\ne \varepsilon$），则将 $FIRST(\beta)$ 中一切非 $\varepsilon$ 符号计入 $FOLLOW(B)$</p></li><li><p>若存在 $A\to\alpha B\beta$ 的产生式，且 $\varepsilon\in FIRST(\beta)$，则 $FOLLOW(A)$ 中的所有元素都属于 $FOLLOW(B)$</p></li><li><p>注意 $FOLLOW$ 集合中可能包含 $#$ 符号<br></p></li></ul><p>为了构造文法 $G$ 的 LL 分析表，需要对 $G$ 中每一个规则 $A\to\alpha$ 按照以下规则确定</p><ul><li>若 $a\in FIRST(\alpha)$，则 $M[A,\ a]=A\to\alpha$</li><li>若 $\varepsilon\in FIRST(\alpha)$，则将每个 $b\in FOLLOW(A)$ 置 $M[A,\ b]=A\to\varepsilon$</li><li>其余位置均为 $error$，代表出错</li></ul><h2 id="自底向上分析"><a href="#自底向上分析" class="headerlink" title="自底向上分析"></a>自底向上分析</h2><ul><li>从输入的符号串开始，重复规约当前句柄（把句柄合成为规则左侧的非终结符），若能规约为文法能识别的符号则说明输入串是合法的句子</li></ul><h3 id="移进—规约过程"><a href="#移进—规约过程" class="headerlink" title="移进—规约过程"></a>移进—规约过程</h3><ul><li>建立一个符号栈，自左向右地每次推入一个符号，在形成当前句型的句柄时进行规约，将栈中内容化为非终结符，向着初始符号 $S$ 靠近，如果化为初始符号则说明规约完成，输入串是合法句子</li><li>规约的方式实际上存在一定的不确定性，如果句柄识别有误，可能合成的非终结符并不能继续合成，导致错判</li></ul><h3 id="算符优先分析"><a href="#算符优先分析" class="headerlink" title="算符优先分析"></a>算符优先分析</h3><ul><li>算符优先分析法预先规定<strong>相邻终结符</strong>的优先关系，利用关系确定句柄，最终达到规约的目的，需要注意的是，若有 $a\gt b$ 的关系，并不一定有 $b \lt a$ 的关系</li><li>在算符优先分析法中，每一步分析并不是严格地自左向右的，它每一步规约的都是当前句型的<strong>最左素短语</strong></li></ul><h3 id="素短语与最左素短语"><a href="#素短语与最左素短语" class="headerlink" title="素短语与最左素短语"></a>素短语与最左素短语</h3><ul><li>素短语是至少包含一个终结符号地短语，并且其中不含有任何素短语（也就是最小的、语法树中最靠下的短语）</li><li>素短语和句柄之间并没有直接联系</li></ul><p>算符优先分析流程如下：</p><ul><li><p>确定终结符之间的优先关系：若 $a、b$ 都是终结符且可能相邻，那么 $a\gt/=/&lt;b$ 说明 $a$ 的优先级大于/等于/小于 $b$</p></li><li><p>将所有终结符画出一个矩阵，包含所有优先关系，矩阵空白处说明终结符不相邻；或选择构造算符优先函数，决定算符之间的关系</p><ul><li>这里的矩阵叫做<strong>优先关系矩阵</strong>，矩阵消耗空间更大，但使用<strong>优先关系函数</strong>可能会使得原本不存在优先关系的符号根据运算出现错误的比较关系</li></ul></li><li><p>重复比较、出入栈、规约的过程，直至符号串输入完毕</p><ul><li>入栈：当栈内终结符优先级 $\le$ 栈外优先级时则入栈，出栈则相反</li><li>规约：当终结符未入栈、已出栈时要对输入的元素进行规约，合成为新的语法成分，在重新压入输入串栈</li></ul></li></ul><p><strong>算符优先函数</strong>的确定方法：</p><ul><li>定义优先函数 $f$（栈内）、$g$（栈外），若两终结符存在优先关系，则 $f(a)&gt;=&lt;g(b)$</li><li>对每个终结符，令 $f(a)=g(a)=1$</li><li>若 $a&gt;b$，而 $f(a)\le g(b)$，则 $f(a)=g(b)+1$</li><li>若 $a=b$，而 $f(a)\ne g(b)$，则令 $f(a)、g(b)$ 的最小值和最大值相等</li></ul><p><strong>优先关系矩阵</strong>的构造方法在下一小节介绍</p><h4 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h4><ul><li><p>算符文法：文法中无 $U::=…VW…$ 的规则，则称 $G$ 为 OG 文法，即算符文法</p><ul><li>运算规则都是中缀形式</li><li>规则中不会出现两个非终结符相邻</li></ul></li><li><p>算符<strong>优先</strong>文法：一个算符文法，且两个终结符之间（即 $a?b$、$b?a$ 中）最多只有一种优先关系成立，则称为算符优先文法</p></li><li><p>优先关系的定义：$a=b$、$a&lt;b$、$a&gt;b$，指文法中包含以下三种类型的规则：</p><ul><li><p>$U::=…ab…$ 或 $U::=…aVb…$</p></li><li><p>$U::=…aW…$，且 $W\overset{+}{\to}b…$ 或 $W\overset{+}{\to}Vb…$</p></li><li><p>$U::=…Wb…$，且 $W\overset{+}{\to}…a$ 或 $W\overset{+}{\to}…aV$</p></li><li><p>换句话说，也就是相邻时谁后被推导出来（反过来就先被<strong>规约</strong>），谁的优先级就更高</p></li></ul></li></ul><h4 id="优先关系矩阵的构造"><a href="#优先关系矩阵的构造" class="headerlink" title="优先关系矩阵的构造"></a>优先关系矩阵的构造</h4><p>构造优先关系矩阵的方法：</p><ul><li><p>先通过优先关系的定义求 $=$ 关系</p></li><li><p>再求每个非终结符 $U$ 的 $FIRSTVT(U)$ 和 $LASTVT(U)$ 两个集合</p><ul><li><p>$FIRSTVT(U)={b|U\overset{+}{\to}b… ||U\overset{+}{\to}Vb…}$</p></li><li><p>$LASTVT(U)={b|U\overset{+}{\to}…a||U\overset{+}{\to}…aV}$</p></li></ul></li><li><p>逐条分析文法规则，若某条规则出现 $…aU…$，那么对任意的 $b\in FIRSTVT(U)$，都有 $a\lt b$，类似地可以推出 $\gt$ 的优先关系</p></li></ul><h3 id="LR-语法分析法（未完成）"><a href="#LR-语法分析法（未完成）" class="headerlink" title="LR 语法分析法（未完成）"></a>LR 语法分析法（未完成）</h3><ul><li>LR 分析法是自左向右扫描+自底向上规约的分析方法</li><li>这种分析方法效率高，可自动生成规则、适用度高</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-DataBase-Chapter1</title>
      <link href="/p/b02dc89e.html"/>
      <url>/p/b02dc89e.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h1><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2 数据模型"></a>1.2 数据模型</h2><blockquote><p>数据模型是一种模型，它是对现实世界数据特征的抽象，是数据库描述数据、组织数据、操作数据的途径。</p></blockquote><h3 id="两类数据模型"><a href="#两类数据模型" class="headerlink" title="两类数据模型"></a>两类数据模型</h3><p>根据模型应用的不同目的，可以将模型划分为两大类：<strong>概念模型</strong>，<strong>逻辑模型和物理模型</strong></p><p>前者用于对数据建模，用于数据库的设计；后者中，物理模型描述了数据在系统内部的表示方式（硬件层面），逻辑模型按计算机系统的观点对数据进行建模。</p><p>数据库管理设计人员需要选择物理模型，而物理模型对于使用者来说实际上是透明的</p><h4 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h4><blockquote><p>概念模型实际上是现实世界到机器世界的一个中间层次。</p></blockquote><p>信息世界中存在一些概念，这对于数据库概念模型的建立有重要的作用：</p><ul><li>实体：客观存在并可相互区别的<strong>事物</strong>；人就是实体的一种</li><li>属性：实体具有的某一特性；一个实体可以由多个属性进行描述</li><li>码：某一标识实体的属性集；例如学号、班级都是学生实体的码</li><li>实体型：用实体名和属性的集合来抽象、刻画同类实体；例如 学生（年龄、性别、学号、……）</li><li>实体集：同一类型实体的集合</li><li>联系：实体间的联系通常指不同实体集之间的联系；联系有一对一、一对多和多对多等类型</li></ul><p>这里的<strong>一</strong>和<strong>多</strong>是针对于联系中实体的数量</p><h4 id="实体-联系方法"><a href="#实体-联系方法" class="headerlink" title="实体-联系方法"></a>实体-联系方法</h4><p>实体-联系方法使用 E-R 图来对概念模型进行抽象，E-R 图的画法在第 7 章讲解。</p><h3 id="数据模型的组成要素"><a href="#数据模型的组成要素" class="headerlink" title="数据模型的组成要素"></a>数据模型的组成要素</h3><blockquote><p>数据模型通常由数据结构、数据操作和数据的完整性约束条件三部分组成。</p></blockquote><ul><li>数据结构：描述数据库的组成对象和对象之间的关系，通常按照数据结构的类型命名数据模型</li><li>数据操作：对数据库中各种对象的实例进行的操作的集合，包括操作和规则</li><li>数据的完整性约束条件：一组完整性规则，用以限定数据库状态和变化，保证数据的正确、完整性</li></ul><h3 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h3><p>主流的逻辑数据模型有以下几种：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。其中层次模型和网状模型统称为格式化模型，正在逐渐被关系模型取代</p><ul><li>基本层次关系：两个记录和它们之间的联系</li><li>双亲节点：关系 $L_{ij}$ 的始点；类似地，$L_{ij}$ 的终点称为子女节点；同理有兄弟节点的关系</li></ul><h3 id="层次模型"><a href="#层次模型" class="headerlink" title="层次模型"></a>层次模型</h3><ul><li>层次模型用<strong>树形结构</strong>描述实体以及实体间的关系，由于有向边的方向和节点的层次，使得层次模型只能处理一对多的数据联系</li><li>层次结构有且仅有一个节点没有双亲节点，称为<strong>根节点</strong></li><li>根节点以外的节点有且仅有一个双亲结点</li><li>节点：代表一个记录<strong>类型</strong>，节点内可以有很多记录，每个记录都能延伸出自己的子节点，可以理解为节点有厚度，而每一薄层都能展开树杈</li><li>有向边：代表一个联系</li></ul><p>每个记录类型可以包括若干个字段，可以定义一个<strong>排序字段</strong>（码字段），若在层次模型中查找给定的记录值，只能按照层次路径查看，不能脱离双亲的记录值而独自存在</p><p>层次模型的数据操纵主要有查询、插入、删除、更新。插入操作必须确定双亲的节点值，否则就无法确定子记录的层次位置；删除操作在删除双亲节点的数据时，其下所有的子节点记录会被一并删除</p><ul><li>层次模型的特点：<ul><li>数据结构简单，全部数据都以树形存放</li><li>查询效率高：有向边通常以指针的形式实现，当要对某一记录进行操作时，可以快速查询到路径的位置</li><li>节点间若为多对多关系或无层次关系则不适用层次模型</li><li>查询子节点必须通过双亲结点</li></ul></li></ul><h3 id="网状模型"><a href="#网状模型" class="headerlink" title="网状模型"></a>网状模型</h3><p>当数据记录间的层次性并不明显或无层次关系时可以采用网状模型：</p><p>网状模型允许：</p><ul><li>一个以上的节点无双亲</li><li>一个节点有多于一个的双亲</li></ul><p>网状模型具有更普遍性的结构，描述关系更为灵活；节点中的记录可以实现一对多、多对多的联系</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309191026443.png" alt="image-20230919102623231"></p><ul><li>支持记录码：数据库不允许标识记录的数据项出现重复</li><li>保证一个联系中双亲记录和子女记录间时一对多的关系</li><li>支持特定约束条件</li></ul><ul><li>网状模型的特点：<ul><li>描述关系更为广泛，描述方式更直接</li><li>性能高，存取效率较高</li><li>结构复杂，不利用用户使用</li><li>DDL、DML 复杂，不易掌握在指定语言的使用方式</li></ul></li></ul><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>感觉不如第 2 章再讲</p><h2 id="1-3-数据库系统的结构"><a href="#1-3-数据库系统的结构" class="headerlink" title="1.3 数据库系统的结构"></a>1.3 数据库系统的结构</h2><h3 id="模式与三级模式结构"><a href="#模式与三级模式结构" class="headerlink" title="模式与三级模式结构"></a>模式与三级模式结构</h3><ul><li>模式时数据库中全体数据的逻辑结构和特征的表述，只涉及型（结构、字段等），不涉及值（具体的记录值）</li><li>实例：模式的一个具体值，包含具体的记录值；模式是相对稳定的，而实例时实时变动的</li><li>数据库一般采用三级模式结构和两级映像结构，三级模式是数据的三个抽象级别，两级映像是层次之间的转换</li></ul><ul><li>模式（逻辑模式）：数据库全体数据的逻辑结构和特征的表述，时公共数据视图，不涉及到物理的存储细节和设计数据库的语言</li><li>外模式（用户模式）：用户能够看到的局部数据的逻辑结构，是模式的子集，每个用户看全体数据时都通过自己的外模式，获得到的数据结构可能不同，也只能看到数据的一部分</li><li>内模式（存储模式）：数据库存储物理信息时采用的结构，体现了存储时数据结构上的组织方式</li></ul><ul><li>外模式/模式映像：这个映像面向外模式，实现从总体数据到用户数据之间的转变，每个外模式都有对应的映像，当模式改变时可以通过修改映像来保持外模式的应用不变，保证了数据的逻辑独立性</li><li>模式/内模式映像：定义了全局逻辑结构和存储结构之间的对应关系，类似于声明数据结构，当数据结构更改时，同理可以修改映像保证数据的物理独立性</li></ul><h1 id="第-2-章-关系数据库"><a href="#第-2-章-关系数据库" class="headerlink" title="第 2 章 关系数据库"></a>第 2 章 关系数据库</h1><h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1 关系数据结构及形式化定义"></a>2.1 关系数据结构及形式化定义</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li>关系模型中，数据只包含单一的二维数据结构，即关系。</li><li>域：一组具有相同数据类型的值的集合</li><li>笛卡尔积：定义在域上的一种集合运算：</li></ul><p>$$<br>D_1×D_2×…×D_n={(d_1,\ d_2, … ,\ d_n)}<br>$$</p><p>通过笛卡尔积计算得出的是域中所有元素以任意形式进行组合后的元素，也称<strong>元组</strong>，元组的每一个值叫做<strong>分量</strong></p><ul><li>关系：笛卡尔积的子集叫做对应域上的关系，分量的数目被称为<strong>目</strong>或<strong>度</strong></li><li>候选码：某一属性组的值能够唯一地标识一个元组，但是子集不能，则该组属性就称为候选码；换句话说，候选码就是能够独立判别所有元组的属性的集合</li><li>主码：对于多个候选码，选取其中一个成为主码，候选码中的所有属性都称作<strong>主属性</strong>，其余属性被称为非主属性（非码属性）</li><li>全码：当主码的属性是全部的属性时，就被称为全码</li><li>基本表、查询表、视图表：实际存在的、存储数据的表；查询结果对应的表；根据某些条件筛选得出的表</li></ul><h4 id="基本关系的性质"><a href="#基本关系的性质" class="headerlink" title="基本关系的性质"></a>基本关系的性质</h4><ul><li>列是同质的：同一列的数据来自同个域</li><li><strong>不同的列可以来自相同的域</strong>：属性不同可以来自同一个域，比如可以有姓名和家属名两个属性，它们是不同的属性，但是来自同一个域（人名）</li><li>列的顺序可以交换：列的次序无关紧要，添加列时通常添加在最后一列</li><li>行的顺序可以交换，和列同理</li><li>分量必须取原子值：意味着分量不可再分，是一个不可分的数据项</li><li>任意两个候选码不能取相同的值<br>满足以上六条性质的关系是规范化的关系，也称为范式</li></ul><h2 id="2-2-关系操作"><a href="#2-2-关系操作" class="headerlink" title="2.2 关系操作"></a>2.2 关系操作</h2><ul><li>关系操作包括查询、插入、删除、修改。查询操作中包含选择、投影、并、差、笛卡尔积这 5 种基本操作。</li></ul><h3 id="关系数据语言的分类"><a href="#关系数据语言的分类" class="headerlink" title="关系数据语言的分类"></a>关系数据语言的分类</h3><p>早期关系操作能力通常用代数方式和逻辑方式表示，分别成为关系代数和关系演算。</p><ul><li>关系代数用对关系的运算来表达要求</li><li>关系演算用谓词的逻辑表述要求</li><li>同时还有一种具有关系代数和关系演算双重特点的语言（结构化查询语言）</li></ul><h2 id="2-3-关系的完整性"><a href="#2-3-关系的完整性" class="headerlink" title="2.3 关系的完整性"></a>2.3 关系的完整性</h2><ul><li>关系模型中有三类完整性约束：<strong>实体完整性</strong>、<strong>参照完整性</strong>和用户定义完整性，前两项需要关系系统实现自动支持，最后一项是应用时需要遵守的约束条件</li></ul><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul><li>若属性 $A$ 是基本关系 $R$ 的主属性（主码），则任意的元组都不能允许出现空值的 $A$</li><li>如果主属性 $A$ 为空值，那么说明这个记录的唯一性标识不存在，那么无法通过主属性进行实体的区分，显然不应被允许</li></ul><h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul><li>外码：某个属于基本关系 $R$ 的属性 $F$（不是码），同时是另一个关系 $S$ 的码，那么对于 $R$ 来说，$F$ 就是一个外码；且 $R$ 被称为参照关系，$S$ 被称为被参照关系<ul><li>显然两个关系的这两个属性必须来自同一个（组）域</li><li>要注意 $R$ 和 $S$ 可能是同一个关系（例如学生元组中的学号与班长学号）</li></ul></li><li>在关系和关系间的引用中，若属性 $F$ 是基本关系 $R$ 的外码，它与基本关系 $S$ 的主码 $K_s$ 相对应，则对于 $R$ 的每个元组在 $F$ 上的值必须：<ul><li>取空值（尚未分配）</li><li>取 $S$ 中的某个出现过的主码值</li></ul></li></ul><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul><li>用户定义的完整性就是针对某一具体应用情况的约束条件而存在的一系列语义要求，关系模型应提供定义和检验这类完整性的机制，是实际应用时的一大类约束</li></ul><h2 id="2-4-关系代数"><a href="#2-4-关系代数" class="headerlink" title="2.4 关系代数"></a>2.4 关系代数</h2><blockquote><p>关系代数是一种抽象的查询语言，它用对关系的运算表达查询操作</p><p>运算对象、运算符、运算结果是运算的三大要素</p></blockquote><ul><li>运算对象：数据库中存放的关系</li><li>运算符：集合运算符（$\cup\ -\ \cap\ ×$）、关系运算符（$\sigma$ 选择、$\Pi$ 投影、连接，$÷$ 除）<ul><li>其中集合运算符把关系看成传统的集合，进行交并差等操作，关系运算符从列的角度处理关系，进行操作</li></ul></li></ul><h3 id="传统的集合运算"><a href="#传统的集合运算" class="headerlink" title="传统的集合运算"></a>传统的集合运算</h3><ul><li>传统的集合运算是二目运算，包括交并差、笛卡尔积四种运算，每种运算的集合表示如下：</li></ul><p>$$<br>R\cup S={t|t\in R\or t\in S}\<br>R-S={t|t\in R\and t\notin S}\<br>R\cap S={t|t\in R\and t\in S}\<br>R× S={t_rt_s|t_r\in R\and t_s\in S}\若RS分别有k_1、k_2个元素，则笛卡尔积有 k_1×k_2个元素<br>$$</p><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li>分量：元组中相对于关系的某个属性，$t[A_i]$ 代表元组 $t$ 在属性 $A_i$ 上的值（分量）</li><li>$t[A],\ A={A_{i1},A_{i2},…,A_{in}}$ $A$ 被称为属性组，$t[A]$ 被称为属性组分量的集合，$\overline A$ 表示去掉属性组后剩余的属性</li><li>$t_rt_s$ 表示元组的<strong>串接</strong>，它是将 $t_r$、$t_s$ 两个元组进行链接后得到的元组，是一个 $m+n$ 元组（两个单独的元组长度分别为 $m、n$）</li><li>象集：当 $t[X]=x$ 时，$x$ 在 $R$ 中的象集为：</li></ul><p>$$<br>Z_x={t[Z]|t\in R, t[X]=x}<br>$$</p><p>表示在 $X$ 上值等于 $x$ 的所有元组，它们的 $Z$ 属性组分量值的集合</p><ul><li>选择（限制）：关系中满足条件的所有元组</li></ul><p>$$<br>\sigma_F(R)={t|t\in R\cap F(t)=真}<br>$$</p><p>这里的 $F$ 是逻辑表达式，用于进行筛选，通常包含某些属性从而进行约束，比如 $\sigma_{age&gt;20||no&gt;21370000}(Student)$ 可以表达从 $Student$ 这个关系中进行筛选，限制条件是 $age$ 字段大于 20 或 $no$ 字段大于 21370000</p><ul><li>投影：从 $R$ 中选择出若干的属性列组成新的关系</li></ul><p>$$<br>\Pi_A(R)={t[A]}<br>$$</p><p>这里的 $A$ 是属性组，这样将会取出某些特定的列，并保持行中原有的信息不改变</p><p>要注意投影操作可能会删去某些行，因为去掉列后可能出现重复行，需要进行删除，比如 $\Pi_{ {name, age} }(Student)$ 就选出了 $Student$ 中的姓名和年龄两列组成新的关系，如果出现名字和年龄相同的学生那么需要删除一个记录</p><ul><li>连接（$\theta$ 连接）：从两关系的笛卡尔积中选取满足条件的元组，要求 $R$ 关系在 $A$ 属性组上的值和 $S$ 关系在 $B$ 属性组上的值满足比较关系<ul><li>等值连接：$\theta$ 为 $=$ 的连接运算，也就是要求 $R$ 的 $A$ 属性和 $S$ 的 $B$ 属性值相同，如果选取了两关系共有的一个属性，就会筛选出所有共用项相同的元组不删去属性）</li><li>自然连接：要求连接时筛选的属性必定是同名的，并且会删除重复的属性</li></ul></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309271929383.png" alt="image-20230927192934240"></p><ul><li>悬浮元组：在连接的过程中可能会导致某些元组被浪费，这些无法连接的元组就是悬浮元组。</li><li>外连接：如果把无法连接的元组也放在结果中，并给没有的属性标记 $NULL$，就叫做外连接，左右连接分别保留了左右侧关系的元组</li></ul><h3 id="除运算"><a href="#除运算" class="headerlink" title="除运算"></a>除运算</h3><p>设 $R$ 集合除以 $S$ 集合，则结果关系 $T$ 为：</p><ul><li>包含所有在 $R$ 但是不在 $S$ 的属性和值</li><li>$T$ 的元组和 $S$ 元组的组合都属于 $R$<ul><li>先求出目标的属性组和象集，再求出另一个集合的在这个属性组上的投影，这样就包含了另一个单位在其上的投影</li></ul></li><li>遍历所有不共用的属性组，若 $S$ 中值对应的元组能在 $R$ 中找到，就说包含了投影</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309271945670.png" alt="image-20230927194524606"></p><ul><li>$A$ 属性是不共用的</li><li>从 $a_1$ 开始遍历，象集为第1、4、7行</li><li>发现 1、4、7 三行都在象集中，就说明 $a_1$ 属于除法的结果之一</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> DataBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-Algorithms-Chapter1</title>
      <link href="/p/b220a2af.html"/>
      <url>/p/b220a2af.html</url>
      
        <content type="html"><![CDATA[<h1 id="第-01-讲-渐进记号"><a href="#第-01-讲-渐进记号" class="headerlink" title="第 01 讲 渐进记号"></a>第 01 讲 渐进记号</h1><p>表示时间、空间复杂度时会采用一系列符号来表示其对应的数量级</p><ul><li>$O$：渐进上界，表示算法复杂度的上限，算法执行时复杂度不会超过这个值（实际上也是估算，常数级不予考虑）</li><li>$\Omega$：渐进下界，表示算法复杂度的下限，通常表示最优情况下的复杂度</li><li>$\Theta$：渐进紧确界，当 $O$ 和 $\Omega$ 相等时，对应的值就被记为 $\Theta$，表示算法的性能浮动</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309161447615.webp" alt="img" style="zoom:80%;" /><p>这张图中 $f(n)$ 代表算法的实际运算，可以看到当自变量 $n$ 足够大时，$O&gt;f&gt;\Omega$  的关系相对明确，也间接说明了渐进上下界的概念</p><br><h1 id="第-02-讲-复杂度分析"><a href="#第-02-讲-复杂度分析" class="headerlink" title="第 02 讲 复杂度分析"></a>第 02 讲 复杂度分析</h1><p>分析递归的时间复杂度可以使用三种方式：递归树法、代入法、主定理法</p><h3 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h3><p>递归树法主要计算的是树的深度，最终的时间复杂度是深度乘以每层的复杂度得到的积。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309161522861.png" alt="image-20230916152237825" style="zoom:67%;" /><p>如上图中每层的复杂度都是 $O(n)$，同时每一个分支进入每一层都要变为一半，选取随意一支，计算 $1 = n*(\frac 1 2)^{k}$，得到 $k=log_2n$，最终换底提出系数，算出深度为 $log\ n$ 层。当各个分支分得的复杂度不同时，要选取下降最慢（复杂度最高）的一条分支进行计算，保证覆盖度。</p><h3 id="代入法"><a href="#代入法" class="headerlink" title="代入法"></a>代入法</h3><p>代入法从数学方向证明复杂度，过程中先进行猜测，再找出对应复杂度的系数，利用数学归纳法证明复杂度的猜测成立。但当猜测解不容易得到时比较困难</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309162028283.png" alt="image-20230916202852221" style="zoom:55%;" /><h3 id="主定理法"><a href="#主定理法" class="headerlink" title="主定理法"></a>主定理法</h3><p>主定理法能够将常用的公式对应的递归式分析得出通解，形式简洁，但其使用范围有限，需要递归式满足特定情况才可以使用。<br>$$<br>T(n)=aT(\frac n b)+f(n)\<br>T(n)=\begin{cases}<br>\Theta(f(n)) &amp; if\ f(n)=\Omega(n^{log_ba+\epsilon})\<br>\Theta(n^{log_ba·logn}) &amp; if\ f(n)=\Theta(n^{log_ba})\<br>\Theta(n^{lob_ba}) &amp; if\ f(n)=O(n^{log_ba-\epsilon})<br>\end{cases}<br>$$<br>简单来说，如果 $f(n)$ 的数量级要比 $n^{log_ba}$ 大，那么时间复杂度就取决于更大的 $f(n)$；若同数量级则是乘以 $log\ n$；若 $f(n)$ 更小，则体现为 $n^{log_ba}$ 的数量级。当 $f(n)=n^k$ 时，可以进一步简化：<br>$$<br>T(n)=\begin{cases}<br>\Theta(n^k) &amp; if\ k &gt; log_ba\<br>\Theta(n^·klogn) &amp; if\ k = log_ba\<br>\Theta(n^{lob_ba}) &amp; if\ k &lt; log_ba<br>\end{cases}<br>$$<br>当主定理中 $f(n)$ 的部分处于 $[n^{log_ba-\epsilon},n^{log_ba+\epsilon}]$ 之间，同时不等于 $n^{log_ba}$ 时（也就是比 $n^{log_ba}$ 大，但是又不大出一个 $n$ 的数量级，比如 $nlogn$），不能应用主定理的任意一项，这时需要使用拓展形式：<br>$$<br>T(n)=\Theta(n^{log_ba·log^{k+1}n})\<br>if\ f(n)-\Theta(n^{log_ba·log^kn})<br>$$</p><br><h1 id="第-03-讲-分治思想"><a href="#第-03-讲-分治思想" class="headerlink" title="第 03 讲 分治思想"></a>第 03 讲 分治思想</h1><h2 id="分治（Divide-and-Conquer）"><a href="#分治（Divide-and-Conquer）" class="headerlink" title="分治（Divide-and-Conquer）"></a>分治（Divide-and-Conquer）</h2><p>分治思想（D&amp;C）是计算机中一种重要的处理问题的思想，它首先将给定的问题进行分割，划分出多个子问题（通常是近似规模的），再对各个问题逐个解答（考虑递归处理），最终把子问题的解整合为所给问题的解</p><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><ul><li>合并策略：当输入为多组有序数组时，对其进行两两合并，并在过程中保持其有序性，最终合并得到所有元素的有序序列，完成排序流程；<ul><li>当输入完全无序时，将数组的长度降低为 $1$，此时每个数组（单个元素）都必定有序，由此开始进行合并的排序方式，这就是归并排序</li></ul></li><li>归并排序将整个无序数组进行拆分，划分为局部有序的数组（单一元素），再进行数组间两两的排序，最终实现对整体元素的排序；划分这一过程是分治思想的重要体现</li></ul><h3 id="归并排序流程"><a href="#归并排序流程" class="headerlink" title="归并排序流程"></a>归并排序流程</h3><ul><li>将数组 $A[1, n]$ 排序的问题分解为数组 $$A[1, |\frac n 2|]$$ 和 $A[|\frac n 2|, n]$ 的排序问题</li><li>递归解决分解后的子数组排序问题，并得到有序的子数组<ul><li>递归边界为数组长度为 $1$ ，此时单元素数组天然有序</li></ul></li><li>最终将子数组反向合并为有序数组</li><li>伪代码实现：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数调用：MergeSort(A, left, right)</span></span><br><span class="line"><span class="comment">// 终止递归的边界条件</span></span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">    <span class="keyword">return</span> A[left, right]</span><br><span class="line">&#125;</span><br><span class="line">mid = (left + right) / <span class="number">2</span></span><br><span class="line"><span class="comment">// 排序左侧数组</span></span><br><span class="line">MergeSort(A, left, mid)</span><br><span class="line"><span class="comment">// 排序右侧数组</span></span><br><span class="line">MergeSort(A, mid + <span class="number">1</span>, right)</span><br><span class="line"><span class="comment">// 将两数组排为一个有序数组</span></span><br><span class="line">Merge(A, left, mid, right)</span><br><span class="line"><span class="keyword">return</span> A[left, right]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体排序函数：Merge(A, left, mid, right)</span></span><br><span class="line"><span class="comment">// Input: A[1, n]</span></span><br><span class="line"><span class="comment">// Output: A[left, right] ( sorted array )</span></span><br><span class="line">B[left, right] &lt;- A[left, right]</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 初始化指针</span></span><br><span class="line">i = left, j = mid, k = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 数组 1：0~mid，数组 2：mid+1~right （均分别有序）</span></span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">    <span class="comment">// 比较 i &amp; j，谁小就在 A 的后面放下</span></span><br><span class="line">    <span class="keyword">if</span> (B[i] &lt;= B[j]) &#123;</span><br><span class="line">        A[left + k] = B[i]</span><br><span class="line">        i++, k++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        A[left + k] = B[j]</span><br><span class="line">        j++, k++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中一个数组输入完了，把剩下的大数全插入</span></span><br><span class="line"><span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">    <span class="comment">// i 没完，j 完了，把数组 1 剩余的元素插在后面</span></span><br><span class="line">    A[left+k, right] = B[i, mid]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// j 没完，i 完了，把数组 2 剩余的元素插在后面</span></span><br><span class="line">    A[left+k, right] = B[j, right]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 排序完毕，返回结果</span></span><br><span class="line"><span class="keyword">return</span> A[left, right]</span><br></pre></td></tr></table></figure><ul><li>子过程由于相当于只遍历了一遍 $A$ 数组，故单轮排序的时间复杂度为 $O(n)$</li></ul><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>设 $n$ 个元素的 <code>MergeSort</code> 函数的运行句数为 $T(n)$，则有<br>$$<br>T(n)=\begin{cases}<br>2*T(n/2) + O(n)\<br>O(1)<br>\end{cases}<br>$$<br>对整个过程画出<strong>递归树</strong>，分别计算每个节点的时间复杂度：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309161522861.png" alt="image-20230916152237825" style="zoom: 67%;" /><p>观察可以得到，每一层的复杂度都为 $O(n)$，同时纵向共有 $log\ n + 1$ 层（计算<strong>深度</strong>为 $log\ n$），相乘则可得到总时间复杂度：<br>$$<br>T(n)=O(nlog\ n)<br>$$</p><h2 id="最大子数组（Maxinum-Contiguous-Subarray）"><a href="#最大子数组（Maxinum-Contiguous-Subarray）" class="headerlink" title="最大子数组（Maxinum Contiguous Subarray）"></a>最大子数组（Maxinum Contiguous Subarray）</h2><ul><li>最大子数组问题给定一个实数数组 $A[n]$，其中任意元素不限制其正负，我们需要寻找保持连续的子数组 $A[i, j]$，要求其元素和在所有的子数组中最大</li></ul><h3 id="暴力（Brute-Force）流程"><a href="#暴力（Brute-Force）流程" class="headerlink" title="暴力（Brute Force）流程"></a>暴力（Brute Force）流程</h3><ul><li>求出每个合法的 $i$ 和 $j$ 的组合，并更新维护子数组和的最大值</li><li>遍历 $i$、$j$  和子数列的每一项，易知其为 $O(n^3)$ 的算法</li></ul><h3 id="数据重用（Data-Reuse）流程"><a href="#数据重用（Data-Reuse）流程" class="headerlink" title="数据重用（Data Reuse）流程"></a>数据重用（Data Reuse）流程</h3><ul><li>发现每次计算子数组和时并不需要每次都从第一个元素开始加起，因为有：</li></ul><p>$$<br>A[i, j]=A[i,j-1]+A[j]<br>$$</p><ul><li>也就是说保存每次计算的 $A[i,j-1]$ 再加上一个新元素就能够实现子数组和的计算，易知其为 $O(n^2)$ 的算法</li></ul><h2 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h2><p>在数组中部划线将其分割为两部分，则最大子数组必定从以下三部分之中取得：线左侧的数组、线右侧的数组、跨越线的数组</p><ul><li>跨线的数组由于必定包括线左右的元素，可以以此分别向两侧遍历，获得最大的跨线数组</li><li>左右单侧的数组可以通过递归主过程来寻找，直至数组变为单个元素返回结果</li><li>算法复杂度为 $O(n·logn)$</li></ul><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆的性质"><a href="#堆的性质" class="headerlink" title="堆的性质"></a>堆的性质</h3><ul><li>根节点命名为 1</li><li>对于任意节点 $i$<ul><li>左儿子为 $2i$</li><li>右儿子为 $2i + 1$</li><li>父节点为 $[\frac i 2]$</li></ul></li><li>堆中的每个三角形都要满足父节点小于儿子节点</li></ul><p>插入操作：</p><ul><li>在堆的末尾插入一个元素</li><li>与父节点做比较，如果自身更小，则与父节点交换位置</li><li>循环第二步直至成为树根节点，或自身比当前的父节点大</li></ul><p>取出操作：</p><ul><li>取出树根节点，将堆中的最后一个元素放置在根节点位置</li><li>与儿子节点比较，如果自身大于一个儿子则进行交换</li><li>循环第二步，直至成为叶子节点，或自身比两个儿子节点都小</li></ul><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><ul><li>以堆为数据结构进行的排序方式，堆的插入元素、取出最小元的时间均为 $O(log\ n)$，建堆的时间是 $O(n·log\ n)$</li><li>建堆可以优化为 $O(n)$ 的复杂度：先任意建立树形，再对每个非叶子节点进行大小比较的向下调整，调整过程中，深度越大的节点调整的次数越少（节点数也更多），越往上调整的次数越多</li></ul><h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><ul><li>非正式语言，表达算法的本质，但不拘泥细节；反映算法的流程，但不过于繁琐</li></ul><p>书写约定：</p><ul><li>定义算法的输入和输出</li><li>循环、条件等语句块需要缩进</li><li>赋值语句统一形式（等号、箭头）</li><li>注释使用 <code>//</code></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-TOP</title>
      <link href="/p/d4de58c7.html"/>
      <url>/p/d4de58c7.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OO-2023-文章传送门"><a href="#BUAA-OO-2023-文章传送门" class="headerlink" title="BUAA-OO-2023 文章传送门"></a>BUAA-OO-2023 文章传送门</h1><p>在这里，你可以跳转到站点里和 OO 有关的所有文章：</p><p><del>但是说到底也就只有四篇博客作业而已，再没多写其余的内容了</del></p><h1 id="博客作业（Unit1-Unit4）"><a href="#博客作业（Unit1-Unit4）" class="headerlink" title="博客作业（Unit1 - Unit4）"></a>博客作业（Unit1 - Unit4）</h1><ul><li><a href="36144.html">BUAA-OO-UNIT1-Summary</a></li><li><a href="32036.html">BUAA-OO-UNIT2-Summary</a></li><li><a href="60713.html">BUAA-OO-UNIT3-Summary</a></li><li><a href="56591.html">BUAA-OO-UNIT4-Summary</a></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>虽然都到了第二个学期才把这个小结补上，但 oo 要做的还是不会变的（）</p><p>最主要就在测试和架构上，算法性能先不要求多高，完成指标不要求多难，先把每个单元作业的正确性分数拿到就不会难看了。85%的正确分即使要求了所有数据点全对，但在完全不考虑性能的情况下仍然是相对容易的。切忌好高骛远直接冲性能满分，除非你真的对自己的架构或编程能力相当自信，否则很可能会出现中道崩殂的情况。</p><p>图稳就对了。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-CompilePrincipal-Chapter1</title>
      <link href="/p/43299.html"/>
      <url>/p/43299.html</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理笔记"><a href="#编译原理笔记" class="headerlink" title="编译原理笔记"></a>编译原理笔记</h1><p>第 01 讲 ~ 第 02 讲：概论、文法与语言</p><h1 id="第-01-讲-概论"><a href="#第-01-讲-概论" class="headerlink" title="第 01 讲 概论"></a>第 01 讲 概论</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ul><li>源程序：用汇编语言或高级语言书写的程序</li><li>目标程序：用目标语言书写的程序，也就是编译转换的目标</li><li>翻译程序：将源程序转换为目标程序的程序，是汇编程序、编译程序、变换程序的总称</li></ul><blockquote><p>源程序是翻译程序的<strong>输入</strong>，目标程序是翻译程序的<strong>输出</strong></p></blockquote><br><h3 id="编译与解释"><a href="#编译与解释" class="headerlink" title="编译与解释"></a>编译与解释</h3><ul><li>编译程序：对高级语言的源程序进行翻译的程序，过程称为<strong>编译</strong></li><li>汇编程序：特指能将汇编语言的源程序翻译成机器语言的翻译程序，过程称为<strong>汇编</strong></li></ul><p>相对而言，编译程序处理高级语言所以更加复杂，汇编程序处理机器码的方式相对固定，处理简单</p><p>除编译外，还有一种处理程序的方式：<strong>解释</strong>。解释对源程序进行解释执行，它们的区别在于：</p><ul><li>编译：先编译，后运行，语法、语义等报错产生在编译过程中，运行时也会产生错误</li><li>解释：解释程序对源代码边解释边运行，所有错误都是运行过程中产生的</li></ul><br><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>编译一般来说可以分为 5 个过程：</p><ul><li>词法分析：识别字母序列中合法的单词（token），一般而言语言具有四类词：<ul><li>关键字或保留字（如 <code>begin</code>、<code>end</code> 、<code>if</code>）、标识符、常数分界符 （运算符） （如 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>;</code>、<code>()</code> 等）</li></ul></li><li>语法分析：根据语法规则分辨语法成分、语句过程，并对语法进行正确性检查</li><li>语义分析、生成中间代码：对语法成分进行<strong>语义分析</strong>，产生对应的中间代码<ul><li><strong>中间代码</strong>：介于目标语言和源语言间的其他语言，有利于优化处理与编译程序的移植</li><li>分类有四元式、三元式、逆波兰表示等</li></ul></li><li>代码优化：获得更高质量的目标程序，节省程序运行开销</li><li>生成目标程序：由中间代码生成目标程序的过程</li></ul><br><h2 id="编译程序构造"><a href="#编译程序构造" class="headerlink" title="编译程序构造"></a>编译程序构造</h2><h3 id="编译的基本阶段"><a href="#编译的基本阶段" class="headerlink" title="编译的基本阶段"></a>编译的基本阶段</h3><p>按照上面的过程，我们可以把编译程序的逻辑划分为五段，每段都需要进行<strong>建表查表</strong>和<strong>出错处理</strong>两件事。</p><ul><li>符号表管理：在进行编译的过程中，我们需要时刻保证来自源程序和编译过程中产生的信息等级于各个符号中，并对符号进行管理（增删改查等）</li><li>出错处理：编译程序要对源程序中出现的各种问题进行筛查并予以反馈</li></ul><br><h3 id="遍"><a href="#遍" class="headerlink" title="遍"></a>遍</h3><blockquote><p>将源程序和中间程序从头到尾扫描，并做相关的加工处理，生成新的程序的过程被称为<strong>一遍</strong></p></blockquote><p>通常而言，遍和基本阶段没有明显关联，执行一遍可能能够完成多个基本阶段</p><p>一遍扫描即可完成整个编译工作的称为<strong>一遍扫描编译程序</strong></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309041735568.png" alt="image-20230904173545488"></p><br><h3 id="前端与后端"><a href="#前端与后端" class="headerlink" title="前端与后端"></a>前端与后端</h3><ul><li>前端：与源语言有关的处理部分，词法、语法的分析，以及到中间代码的生成，都属于前端的部分</li><li>后端：与目标语言有关的部分，通常是目标程序生成</li></ul><br><h1 id="第-02-讲-文法与语言"><a href="#第-02-讲-文法与语言" class="headerlink" title="第 02 讲 文法与语言"></a>第 02 讲 文法与语言</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><ul><li>符号串：符号形成的有穷序列，对字母集合 $\Sigma$ 上的符号串，其形式定义如下：<ul><li>$\varepsilon$（空串）是 $\Sigma$ 上的符号串</li><li>若 $x$ 是 $\Sigma$ 上的符号串，且 $a\in\Sigma$，则 $ax$ 与 $xa$ 都是符号串</li><li>$y$ 是 $\Sigma$ 上的符号串，$iff$ $y$ 可由前两条推出</li></ul></li><li>符号串集合的乘积运算：$A、B$ 为两符号串集合，则乘积为</li></ul><p>$$<br>AB={xy\ |\ x\in A,y\in B}<br>$$</p><p>类似地，${\varepsilon}A=A{\varepsilon}=A$，${}A=A{}=\emptyset$</p><ul><li>正闭包：对符号串集合 $A$，正闭包是所有幂运算的总和（不限长度的全排列）</li><li>闭包：正闭包 + 空串</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309050928145.png" alt="image-20230905092814069"></p><ul><li><strong>词法</strong>：若把字符看成符号，那么单词就是符号串，单词集合就是符号串集合</li><li><strong>句法</strong>：若把单词看成符号，那么句子就是符号串，句子集合就是符号串集合</li></ul><br><h2 id="文法与语言的定义"><a href="#文法与语言的定义" class="headerlink" title="文法与语言的定义"></a>文法与语言的定义</h2><ul><li>文法：文法是对语言结构的定义与描述，用于描述语言的结构</li><li>语法规则：通过语法规则定义句子的结构，使用 $::=$ 符号描述，表示“由…组成”</li><li>语法树：描述一个句子的语法结构，树中包含非终结符号和终结符号（单词形式）</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309061431157.png" alt="image-20230906143111051"></p><h3 id="文法"><a href="#文法" class="headerlink" title="文法"></a>文法</h3><p>我们通常通过以下方式定义文法 $G$：<br>$$<br>G=(V_n,V_t,P,Z)\<br>V_n:非终结符号集合\<br>V_t:终结符号的集合\<br>P:语法推导规则集合\<br>Z:开始推导时的符号<br>$$<br><br></p><ul><li>$V_n$ 包括所有在规则左侧出现过的符号，$V_t$ 则包含所有在规则出现、且未在 $V_n$ 中出现的符号</li></ul><p>由非终结符号和终结符号共同组成文法的<strong>字汇表</strong>，表示为 $V=V_n\or V_t$</p><p>等价文法：两个不同的文法（通常规则不同），能产生的所有句子的集合相同（语言一致），则说明这两个文法等价</p><h4 id="递归文法"><a href="#递归文法" class="headerlink" title="递归文法"></a>递归文法</h4><ul><li>递归规则：规则的右侧含有和左侧相同的符号（均为非终结符），相同符号位于左侧时为左递归、右侧为右递归，中间时为自嵌入递归</li><li>递归文法可以用有限条规则定义无穷的句子</li><li><strong>左递归文法</strong>不能用自顶向下的方法来进行语法分析，所以用右递归？</li></ul><h3 id="推导的形式定义"><a href="#推导的形式定义" class="headerlink" title="推导的形式定义"></a>推导的形式定义</h3><p>$$<br>G:v=xUy,w=xuy\<br>其中x、y\in V^*,U\in V_n,u\in V*\<br>若U::=u\in P, 则v\underset{G}\to w\<br>若x=y=\varepsilon,有U::=u,则U\underset{G}\to u<br>$$</p><p>简而言之，就是非终结符号根据语法规则，拆分出终结符号的过程。当符号串没有非终结符号时，推导就终止了</p><p>如果通过<strong>一次或以上的</strong>推导，最后将一个非终结符号转化为终结符号，可以用这样的符号表示：$U\underset{G}{\overset{+}\to} u$</p><p>如果两个符号是直等的，那么可以这样表示：$U\underset{G}{\overset{*}\to} u$</p><h4 id="规范推导"><a href="#规范推导" class="headerlink" title="规范推导"></a>规范推导</h4><p>规范推导实际上是从最右侧的非终结符号开始执行的推导，也就是<strong>最右推导</strong>，可以用 $=|=&gt;$ 表示</p><h3 id="句型、句子和语言"><a href="#句型、句子和语言" class="headerlink" title="句型、句子和语言"></a>句型、句子和语言</h3><ul><li>句型是非终结符号，或推导至一半的词</li><li>句子是推导后得到的只包含终结符号的词</li><li>语言（$L(G[Z])$）：是文法能产生的<strong>所有句子</strong>的集合，已知文法可以通过推导得出所有的语言</li></ul><p>编译器处理时，已知了句子，已知所有的文法，检测句子是否属于文法所形成的语言</p><h3 id="短语、简单短语和句柄"><a href="#短语、简单短语和句柄" class="headerlink" title="短语、简单短语和句柄"></a>短语、简单短语和句柄</h3><p>给定文法 $G[Z]$，$w=xuy\in V^+$ 为句型</p><ul><li><p>若 $Z\overset{*}{==&gt;} xUy$ ，且</p><ul><li> $U\overset{+}{==&gt;}u$，则 $u$ 是句型 $w$ 相对于 $U$ 的<strong>短语</strong></li></ul></li><li><p><strong>简单短语</strong>则将后半句的加号去掉</p></li></ul><p>简单来说，如果某个非终结符能够推出一些符号，那这部分符号就属于短语，如果能够一步直接得到，那么就是简单短语</p><ul><li>句柄：任一句型的<strong>最左简单短语</strong>为该句型的句柄</li></ul><p>对于找短语、简单短语而言，从语法树入手会比较简单。</p><h2 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h2><p>我们画出某个句型的语法树，然后遍历每个子树的根节点（包括自身根节点），然后把自身范围下的所有叶子节点连成一条线，即可找出这个子树的短语（叶子节点是子树相对于整个语法树的短语）；如果在这个过程中，某个树和自己的叶子节点之间没有子树，那这个短语就是直接短语</p><p>我们以下面这个树为例（$S\to (Sd(T)db)$）：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309061945667.png" alt="image-20230906194523613"></p><p>寻找这个树的短语，我们要从每个子树开始：</p><ul><li>左下角的 $T$：所有的叶子连起来是 $S$，短语就是 $S$，同时也是直接短语（不含子树根节点）</li><li>左下角的 $S$：叶子是 $(T)$，同时也是直接短语</li><li>上一层的 $T$：这里的叶子是 $Sd(T)$（只找最下面的一排然后连起来），因为有“左下角的 $T$ ”、“左下角的 $S$ ”两个子树，所以没有直接短语</li><li>再上一层的 $T$：同理，叶子是 $Sd(T)db$，也不是直接短语</li><li>右侧的 $S$：叶子是 $b$，是直接短语</li><li>最顶层的 $S$：相当于把所有叶子都连上，得到 $(Sd(T)db)$</li></ul><p>最后的句柄比较好找，从所有的直接短语找一个最靠左的就可以了，这里很显然是第一棵子树的叶子 $S$</p><h3 id="语法树的生成"><a href="#语法树的生成" class="headerlink" title="语法树的生成"></a>语法树的生成</h3><p>对于句型 $w$，以 $Z$ 为根节点，对其进行语法树的推导，最终使得所有叶子节点项链形成 $w$，这个过程就是句型 $w$ 的推导，生成的语法树就是 $w$ 的语法树。</p><ul><li><p>某些文法可以使用不同的推导序列（顺序不同），最后获得相同的语法树，某些文法则不能。</p></li><li><p>语法树的推导过程和语法树的生长过程是同步的</p></li><li><p>子树：由语法树的某个节点与其下派生的部分组成</p></li><li><p>某子树的叶子节点按序连接形成的是子树根的短语</p></li></ul><h3 id="推导与规约"><a href="#推导与规约" class="headerlink" title="推导与规约"></a>推导与规约</h3><p>自上而下地对语法树进行扩展，是句型的推导过程，而相反地，自下而上地对语法树进行剪枝，是语法树的规约过程。</p><ul><li>规范规约：每次都剪去语法树中的句柄，实现规约的过程</li><li>规范句型：能从规范推导、规范规约过程得到的句型</li></ul><h2 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h2><ul><li>对于一个文法的某一句子/句型，若存在两棵不同的语法树，说明其是二义性文法，若句子的推导过程不同，但只有一棵语法树，其也是无二义性的文法。</li><li>对语法树而言，若同一个<strong>规范句型</strong>具有两个不同的句柄就说明有二义性：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309131108285.png" alt="image-20230913110849148"></p><ul><li>语法的二义性是不可判定的：没有一个有限步骤的算法判定文法是否具有二义性</li></ul><h2 id="有害规则与多余规则"><a href="#有害规则与多余规则" class="headerlink" title="有害规则与多余规则"></a>有害规则与多余规则</h2><ul><li>有害规则：形如 $U::=U$ 的规则，会导致文法的二义性</li><li>多余规则：分为两种<ul><li>不可达符号：在推导文法中的所有句子时始终用不到的规则，左侧非终结符根本不出现在其他规则里</li><li>不活动符号：使用该规则会推导出一个非终结符，其不能推导出一个终结符号串（这个非终结符就相当于去不掉了）</li></ul></li><li>压缩文法：若文法中没有有害规则和多余规则，说明文法是压缩过的</li></ul><h2 id="形式语言和语言分类"><a href="#形式语言和语言分类" class="headerlink" title="形式语言和语言分类"></a>形式语言和语言分类</h2><ul><li>文法差别在于对规则的不同限制，分为0型、1型、2型、3型</li><li>0型，短语结构文法：左右均可为符号串</li><li>1型，上下文敏感文法：$U$ 只有确定 $xy$ 作为上下文时才能进行符号改写</li></ul><p>$$<br>P: xUy ::= xuy\<br>U\in V_n\<br>x, y, u\in V^*<br>$$</p><ul><li>2型：上下文无关文法：在改写的过程中不需要考虑上下文，直接改写（与 BNF 文法等价）</li><li>3型：正则文法：</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309131124520.png" alt="image-20230913112404895"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Compile Principle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Compile Principle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从负开始的 Vue 学习 (2)</title>
      <link href="/p/55443.html"/>
      <url>/p/55443.html</url>
      
        <content type="html"><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul><li><a href="10387.html">从负开始的 Vue 学习 (1)</a></li><li>从负开始的 Vue 学习 (2)</li></ul><br><h1 id="Vue-的组件化开发"><a href="#Vue-的组件化开发" class="headerlink" title="Vue 的组件化开发"></a>Vue 的组件化开发</h1><p>对大型网页、站点而言，如果单纯使用一个 Vue 文件会显得内容过于复杂，并且难以查错，于是出现了组件。</p><p>组件是带有名称的、可复用的实例，是页面的<strong>砖头</strong>，多个组件组合在一起分别行使不同功能，分离代码。当某个部分出现问题后可以第一时间定位组件进行修改，并且有利于进行代码复用。在进行迭代化开发时也可以快速修改所有应用的组件。</p><br><h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><p>组件使得我们把页面元素拆分成了各个部分，并单独进行处理。定义组件时，应定义在新 Vue 文件中（通常在 <code>./src/components</code> 目录下），并称为<strong>单文件组件</strong>（SFC）。通常情况下，组件文件名要<strong>大写开头</strong>。</p><h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><p>组件间通常是以父子关系存在的，使用子组件需要在父组件内进行导入。导入后还需要在父组件内进行<strong>注册</strong>，注册后就可以在 <code>&lt;template&gt;</code> 内使用这个标签化的组件了，如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Vue</span>/&gt;</span>             <span class="comment">&lt;!-- 子组件使用在此 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HelloVue</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Vue.vue&#x27;</span> <span class="comment">// 子组件引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="attr">components</span>: &#123; <span class="title class_">Vue</span> &#125;,                    <span class="comment">// 子组件注册</span></span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="attr">return</span>: &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>子组件可以在多个父组件内重用。且每个标签都代表着一个实例，这些重用的组件间数据不互通。关于组件的注册还分有全局注册和局部注册两种，粗略来看全局注册更便利，但局部注册更有利于项目维护，使得依赖关系更简洁。</p><br><h2 id="props-与数据传递"><a href="#props-与数据传递" class="headerlink" title="props 与数据传递"></a>props 与数据传递</h2><p>在父子组件间，难免需要进行数据通信，在这里先简单介绍一种最简单的数据绑定： <code>props</code></p><p>props 是标签上一种特殊的 attribute，它用于进行父 → 子之间的数据传递，通信方向是单向的。父组件通过 props 将数据发送给子组件，子组件从 props 中获取一个<strong>只读数据</strong>。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307170000115.png" alt="试图修改 props 数据" style="zoom:80%;" /><br><h3 id="props-使用"><a href="#props-使用" class="headerlink" title="props 使用"></a>props 使用</h3><p>要使用 props 数据，则需要先在<strong>子组件</strong>的 <code>&lt;script&gt;</code> 中对其进行声明：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="attr">default</span>: &#123;</span><br><span class="line">    <span class="attr">props</span>: [<span class="string">&#x27;data1&#x27;</span>, <span class="string">&#x27;data2&#x27;</span>] <span class="comment">// 注意要使用字符串形式标注变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>随后，当一个值被传递给 prop 时，它将成为该组件实例上的一个属性。该属性的值就在模板和组件的 <code>this</code> 上下文中访问了。props 不限数量，但是当父组件没有把实际值绑定给某个 props 时，它将在子组件中将<strong>没有定义</strong>。</p><p>随后<strong>父组件</strong>在调用子组件时使用 attribute 的形式对props 进行传值。这里自然可以使用 <code>v-bind</code> 进行动态绑定，你甚至可以给子组件用 <code>v-for</code>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">data1</span>=<span class="string">&quot;asdasd&quot;</span> <span class="attr">:data2</span>=<span class="string">&quot;message&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Childs</span> <span class="attr">v-for</span>=<span class="string">&quot;data in datas&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data1</span>=<span class="string">&quot;asdasd&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">:data2</span>=<span class="string">&quot;data.message&quot;</span> </span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="emit-与事件传递"><a href="#emit-与事件传递" class="headerlink" title="$emit 与事件传递"></a>$emit 与事件传递</h2><p>当子组件接收某种信息/事件，需要向父组件传递某个事件时，可以使用 <code>$emit</code> 方法上抛一个事件，在父组件中使用 <code>v-on</code> 进行<strong>事件监听</strong>，如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父组件实例化子组件，监听自定义事件 manmade-event --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Child</span> @<span class="attr">manmade-event</span>=<span class="string">&quot;someMethod&quot;</span>&lt;/<span class="attr">Child</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子组件自定义事件，并通过 $emit 触发上抛 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;$emit(&quot;</span><span class="attr">manmade-event</span>&quot;)&quot;&gt;</span>Emit!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 或在 script 中声明方法，调用 this.$emit(&quot;manmade-event&quot;) --&gt;</span></span><br></pre></td></tr></table></figure><br><p>这样父组件就直接监听到了子组件的信息事件，并能在对应函数 <code>someMethod</code> 中做出响应。在使用自定义事件前，需要在子组件 <code>export</code> 时进行声明，这里需要声明组件可能触发的所有事件。否则控制台会显示警告：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;aaaa&#x27;</span>],</span><br><span class="line">  <span class="attr">emits</span>: [<span class="string">&#x27;manmade-event&#x27;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="refs-和数据引用"><a href="#refs-和数据引用" class="headerlink" title="$refs 和数据引用"></a>$refs 和数据引用</h2><p>首先介绍一个 attribute：<code>ref</code></p><br><p>PREV：<a href="103">从负开始的 Vue 学习 (1)</a></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梦、世界与拯救——《白日梦的构想图》有感</title>
      <link href="/p/5829.html"/>
      <url>/p/5829.html</url>
      
        <content type="html"><![CDATA[<h1 id="梦、世界与拯救——《白日梦的构想图》有感"><a href="#梦、世界与拯救——《白日梦的构想图》有感" class="headerlink" title="梦、世界与拯救——《白日梦的构想图》有感"></a>梦、世界与拯救——《白日梦的构想图》有感</h1><p>已许久未动过笔了，希望语言不会过于粗浅。</p><p>今天来聊聊《白昼夢の青写真》，发售于2020年9月25日，是物理社（Laplacian）的第五部作品。也正是在这部作品中，绪乃ワサビ把“<strong>只想寻找与我们口味相符的人</strong>”的理念实践到了一个新的高度，同时也是物理社向着“不依赖浅层的角色性”的作品进行挑战的又一次尝试。伤感的元素比较强</p><p>无语音预计时长 11-13h，虽然有选择肢存在，但并不影响路线走向，只会调整剧情中不同故事出现的顺序，本质上为单线。Steam 有售并未采用代理发行，锁不锁国区就不了解了。是否购买很大程度上看你是不是能接受作品倒出的点了。</p><p>游戏由四部分组成，三个被称为 case 1 - case 3 的独立故事，以及指向真结局的 case 0。游戏开始会以随机顺序开始 1-3 这三个 case，并且进行一部分后会有中断和切换，后续可以按照喜好进行完整阅读。三个 case 结束后自动进入 case 0。</p><p>虽然 case 1-3 没有剧情关联，但是建议按照 case3 → case2 → case1 的顺序游玩，这和 case0 中剧情的引入顺序相关。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072357856.png" alt="image-20230707235724520" style="zoom:60%;" /><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>人们变得只会做同样一种梦了。<br>有的晚上是，女学生与教师的邂逅——<br>有的晚上是，剧作家与女演员超越身份地位的爱情剧幕——<br>还有的晚上是，逃学少年的与实习老师的淡淡的初恋——<br>人们变得只会反复做着这三种梦了。<br>为什么世人会持续做着相同的梦呢。<br>这是，一位被称作世界的少女的故事。</p><p>（摘自萌娘百科）</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072358714.png" alt="image-20230707235820367" style="zoom:60%;" /><h1 id="解"><a href="#解" class="headerlink" title="解"></a>解</h1><p>介绍中三个故事的顺序分别为 1、2、3，具体内容还是亲自体验更有感触。</p><p>为什么开头绪乃提到了“口味相符”这个词呢，因为如果不能接受故事中的某些设定 &amp; 点，会非常难以接受整个故事，这也是这部作品评价两极分化的原因，这些做法实在是很容易踩到玩家的雷区，如果想玩正常恋爱 gal 的朋友其实已经可以跑了（bushi 但这些雷点接续起来，正是剧情得以快速推动的“妙”计，但这种过于激进的事件最好还是不要出现了，这点在最重要的 case 0 中又尤为明显。我自己还好，除了前额叶让我麻了以外，整个故事还能够接受。</p><p>然后要吐槽的就是这个 UI，这个全屏适配做的实在是有点逆天，而且回想里故意不给我看音乐是吧（拳头硬了）</p><p>原画上，Getchu 赏作画部门 4 位。霜降和ぺれっと两位老师的画都很有特色，虽然四个女主全是白毛红瞳，可能是某些人的 xp 特攻，但我觉得男主那个有点沧桑的感觉实在是太传神了。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072251784.png" alt="image-20230707225104485" style="zoom: 60%;" /><p>最后花田和海边的图更是通过画面点燃了剧情蕴含的情感，稍后放在结尾的地方吧，case 1-3 的女主按顺序在文章的前三张图里。</p><p>顺带一提，本作为四个故事设置了四个带动画的 op 和独立的 ed，20 年 Getchu 赏的影片部门第一当之无愧（什么第二居然是 sprb？）这投入属实有点大（</p><p>音乐上，我想打 150 分。4op + 4ed + 每个 case 独立的配乐，整个游戏的 complete ost 收录音乐数量超过了 80 首，不仅数量豪华，质量上更是在线：case3 的 op 活泼的夏日感、case2 的则是浓郁的中世纪曲风；case1 读到的是宛转的情感，case0 则是情感在耳中毫无保留的绽放。四个 op 由同一个歌姬献唱，先行 mv 居然还是四个 ed 的混曲，太强了。。<del>但没办法，还是干不过麻子</del>，sprb 拿到了音乐部门第一，白日梦第二（憋笑</p><p>尤其是全线通后主页面的 case0 op 的 piano ver，故意让我哭哭是吧你</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072359701.png" alt="image-20230707235956393" style="zoom:60%;" /><h1 id="忆"><a href="#忆" class="headerlink" title="忆"></a>忆</h1><p>先前经历的三个 case 都是真女主世凪在不同时期写下的小说中人物，她们代表着世凪的记忆与心路历程，按照 3、2、1 这个顺序可以在 case0 中找到每一段投影，无论是少年时代的无忧与冒险，青年时的萌动与挑战，以及有所成就后的失意。推进 case0 时回想的全是前三个 case 的记忆，这些剧情的紧密程度实属让人拍案叫绝。case0 是剧本的核心，但巧妙的是，它只有依靠其他的故事碎片才能真正组成一个完整的故事，这种拼图的感觉是我在推剧情时的一大享受。</p><p>美中不足的是 case0 最终开始恢复世凪人格时的节奏太快了，给前面补坑的比重太大，有些地方显得不太自然，仍能容忍，以及，你家 ost 怎么 dl 版都卖 250 块啊，微博上还敢写自己价廉（插座挠头）。</p><p>前额叶我真不想再说了，没活可以想别的东西写。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072345954.png" alt="image-20230707234547698" style="zoom:60%;" /><h1 id="尽"><a href="#尽" class="headerlink" title="尽"></a>尽</h1><blockquote><p>The girl who’s called the world.</p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307080002855.png" alt="image-20230708000248605" style="zoom:60%;" /><p>这部作品致力于描写记忆和人格的关系：<br>三个平行世界不仅将过去作品的番外部分像集锦一样排列在一起，<br>在最后一章的CASE-0结束后，三个故事所叙述的必然性也被表现出来。<br>被唤作“个性”的真实面貌，不过是时至今日的记忆的积攒。<br>在对某物做出判断的时候，大多数人会以过去的经验作为线索。<br>——过去的数据支配了人的行为。<br>而人们也根据行为而判定他人的个性。<br>也就是说，我们间接定义了：人的过去=个性。<br>那么，如果到了能进行记忆删除、创造等操作的未来，那要根据什么来定义人的个性呢。<br>是否会存在不会动摇的个性呢？<br>这些就是此作的主题，通过讲述一位名为世凪的少女的故事，以得出一个答案为目的。</p><p>现实中世凪的个性已经消失了，海斗在唤醒世凪后潜入意识世界不停地传诵他们的故事，最终在意识世界中复苏了世凪。本以为 case0 会和其他 case 一样统统写成分离的结局，我也和海斗一样做好接受这种结局的准备了，送回来也好罢。</p><p>不建议废萌向玩家游玩，能避开雷区那当我没说。主题算是比较完整的，或许后半还有提升空间，无伤大雅。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072346885.png" alt="image-20230707234632543" style="zoom:60%;" /><blockquote><p>お帰りなさい，世凪</p></blockquote><p>下一个打算开樱云绯恋，之后感觉也写不出以前那么多字来了，但是从之前那种玩过许多但只选一篇写洋洋洒洒的文字，变成每一部都有所记录是不是也不错的尝试？</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-Python-Note</title>
      <link href="/p/56204.html"/>
      <url>/p/56204.html</url>
      
        <content type="html"><![CDATA[<h1 id="6-27"><a href="#6-27" class="headerlink" title="6.27"></a>6.27</h1><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><ul><li>Python 作为解释型语言，在执行过程中通过解释器逐行解释每一行源代码，执行速度要慢于编译型语言（C语言等），但编译时间更快、平台间的可移植性更好</li></ul><h2 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h2><h3 id="input"><a href="#input" class="headerlink" title="input()"></a><code>input()</code></h3><ul><li><code>input([prompt])</code> ：<code>prompt</code> 内容作为提示信息显示在控制台中，引导用户输入，默认读入的类型为 <code>str</code> 类型</li></ul><p>通常情形下需要进行格式转换，可以使用 <code>&lt;type&gt;(input())</code> 进行转换， <code>type</code> 是转换的目标格式类型</p><p>一行读入多个由空格等分隔符读入的信息可以用 <code>spilt()</code> 进行分割，如：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a, b = <span class="built_in">input</span>().spilt()</span><br><span class="line"><span class="comment"># 对多个同时读入的数据进行数据转换可以使用：</span></span><br><span class="line">a, b = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().spilt())</span><br><span class="line"><span class="comment"># 返回的数据可以再进行包装（外部加 list）</span></span><br></pre></td></tr></table></figure><p><code>type()</code> 函数可以提供输入变量的类型，可以 <code>print</code> 查看</p><h3 id="print"><a href="#print" class="headerlink" title="print()"></a><code>print()</code></h3><p>常用输出函数，当输出多个内容时使用 <code>,</code> 进行分隔，在控制台中会通过空格进行分隔，并输出在同一行内，输出结束后<strong>默认换行</strong></p><p>格式化输出方法：</p><ul><li>使用 <code>%</code> 符作为占位符：</li></ul><p>字符串内类似C语言写入占位符，在字符串结束后直接追加 <code>%(varName1, varName2)</code> 进行补充，括在一个 <code>%</code> 符号后</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">school = <span class="string">&quot;BUAA&quot;</span></span><br><span class="line">subject = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;this is %s %s class&#x27;</span> % (school, subject))</span><br></pre></td></tr></table></figure><ul><li><code>str.format()</code> 函数：</li></ul><p>通过大括号作为占位符，调用 <code>str</code> 类型的 <code>format()</code> 方法，可以用数字表示占位的变量顺序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">school = <span class="string">&quot;BUAA&quot;</span></span><br><span class="line">subject = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;this is &#123;1&#125; &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(subject, school))</span><br></pre></td></tr></table></figure><ul><li>f-string：</li></ul><p>Python 3.6 后添加的格式化方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">school = <span class="string">&quot;BUAA&quot;</span></span><br><span class="line">subject = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;this is <span class="subst">&#123;school&#125;</span> <span class="subst">&#123;subject&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><ul><li>block &amp; indentation：block 是代码块，在 Python 中以缩进（indentation）表示一个代码块，通常缩进为一个 tab</li><li>module：一个单独的 <code>.py</code> 文件，可以通过 <code>import</code> 的方式进行引入</li><li>package：多个 module 所在的文件夹，package 必定包含 <code>__init__.py</code> 文件</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>/ ：除法，返回为浮点型</li><li>// ：整数除法，返回除法<strong>向下取整</strong>后的整数结果</li><li>% ：取模，对负数而言可以带公式： $x - x\ //\ y * y$</li><li>** : 乘方运算，支持指数为负的情况</li><li>Python 的浮点数比较会自动控制精度，通常在 $10^{-8}$ 内即判断两数相等/不等</li><li>Bitwise Operation - 位运算 <code>&amp;|~</code> ：按位与或非</li><li>Logic Operation - 逻辑运算 <code>and or not</code>  ：逻辑与或非</li></ul><p>要注意的是，逻辑运算中的返回值：举例 <code>x and y</code> ，当 <code>x</code> 为真时，则会直接返回 <code>y</code> ，例如 <code>1 and 4</code> 则会直接返回 <code>4</code> 作为结果，并且 Python 逻辑运算也满足短路效应</p><h2 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h2><ul><li>Python 中不包含<strong>字符</strong>类型，单个字符也会被视为字符串；正向索引时从 0 开始，反向索引则从 -1 开始</li><li><strong>切片</strong>：便捷取出某些字符序列，<code>str[a:b:c]</code> 意为下标从 a 开始到 b 结束，以间隔为 c 取出字符返回一个字符串；特别的 <code>str[::-1]</code> 代表反转字符串，其中 a、b 的正负可以混用，切片方向由 c 决定</li><li>常用的一些函数：<code>len()</code> - 长度；<code>isdigit()</code> - 全数字；<code>isalpha</code> - 全字母；<code>startwith()</code> - 以特定字符开头</li></ul><h1 id="6-29"><a href="#6-29" class="headerlink" title="6.29"></a>6.29</h1><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>任何数据类型都可以转换为布尔类型，并且任何非空的数据几乎都会被判断为 <code>True</code>：</p><ul><li>非零数字类型</li><li>非空字符串</li><li>非空容器</li></ul><h2 id="常用容器"><a href="#常用容器" class="headerlink" title="常用容器"></a>常用容器</h2><h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list - 列表"></a>list - 列表</h3><p>列表使用方括号创建，构造方式如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = []</span><br><span class="line">list2 = <span class="built_in">list</span>()</span><br></pre></td></tr></table></figure><p>列表是有序可重复的，可以通过索引（下标）获取列表内容。值得注意的是，对一个 <code>str</code> 类型的数据使用 <code>list()</code> 进行包裹，会按字符将其切分并置入列表中</p><h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>同时列表的元素可以为任何类型，也就是说 <code>list1 = [[1, 2, 3], [1], []]</code> 这样一个列表也是合法的</p><p>在访问列表时可以使用下标进行索引（正负索引均可），同时也可以采用切片获取列表的子列表</p><p><code>in</code> 关键字可以查找列表中是否包含待查找的元素：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> element <span class="keyword">in</span> list1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><p>可以对索引出的列表元素进行直接修改，这样不会改变列表元素的数量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1[<span class="number">0</span>] = <span class="string">&quot;new element&quot;</span></span><br><span class="line">list1[<span class="number">1</span>:<span class="number">3</span>] = [<span class="string">&quot;new 1&quot;</span>, <span class="string">&quot;new 2&quot;</span>]</span><br></pre></td></tr></table></figure><p><strong>添加操作</strong>可以使用 <code>append</code>、<code>insert</code> 或 <code>extend</code> 几个函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1.append(<span class="string">&quot;new element&quot;</span>)       <span class="comment"># 追加至列表末尾</span></span><br><span class="line">list1.insert(<span class="number">0</span>, <span class="string">&quot;index = 0&quot;</span>)      <span class="comment"># 在 index 处插入元素</span></span><br><span class="line">list1.extend([<span class="string">&quot;new 1&quot;</span>, <span class="string">&quot;new 2&quot;</span>])  <span class="comment"># 追加容器内的所有元素</span></span><br></pre></td></tr></table></figure><p>其中 <code>extend</code> 方法不限制参数的元素类型（列表、元组、集合、字典等均可）</p><p><strong>删除操作</strong>可以使用 <code>remove</code>、<code>pop</code>、<code>clear</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1.remove(<span class="string">&quot;removed&quot;</span>) <span class="comment"># 删除指定内容的元素</span></span><br><span class="line">list1.pop(index)        <span class="comment"># 删除指定索引的元素</span></span><br><span class="line">list1.clear()           <span class="comment"># 清空整个列表</span></span><br></pre></td></tr></table></figure><h4 id="循环操作"><a href="#循环操作" class="headerlink" title="循环操作"></a>循环操作</h4><p>对列表的循环有时可以用<strong>列表推导式</strong>进行替换：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list2 = [x <span class="keyword">if</span> x == <span class="string">&quot;target&quot;</span> <span class="keyword">else</span> <span class="string">&quot;target&quot;</span> <span class="keyword">for</span> x <span class="keyword">in</span> list1]</span><br></pre></td></tr></table></figure><p>这个操作会遍历所有的元素，并将等于 target 的元素直接置入 list2，遍历到其余元素时，每个元素都会向列表插入一个 target 元素。列表表达式可以简化对列表的 for 循环操作</p><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><p>使用 <code>sort</code> 函数进行排序：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1.sort()  <span class="comment"># 字典序排序，默认升序</span></span><br><span class="line">list1.sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line">list1.sort(key=<span class="built_in">str</span>.lower) <span class="comment"># 使用小写作为 key 进行排序</span></span><br><span class="line">list1.sort(key=cmp_to_key(cmp1))</span><br></pre></td></tr></table></figure><p>关于第四项： python3 中不再支持使用比较函数 cmp 进行 sort 地比较，所以如若自定义函数控制排序顺序，可以使用 <code>cmp_to_key</code> 函数进行转化，从而在 key 字段使用，需要在代码使用前进行引入</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br></pre></td></tr></table></figure><h3 id="tuple-元组"><a href="#tuple-元组" class="headerlink" title="tuple - 元组"></a>tuple - 元组</h3><p>元组是一个有序、不可更改的容器，类似 const</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuple1 = <span class="built_in">tuple</span>()</span><br><span class="line">tuple2 = (<span class="number">1</span>, )</span><br></pre></td></tr></table></figure><p>在通过 <code>()</code> 创建单一元素的元组时，需要多加一个逗号进行分隔，否则会自动转型为其他数据类型。可以通过下标对元组进行访问</p><h4 id="修改操作-1"><a href="#修改操作-1" class="headerlink" title="修改操作"></a>修改操作</h4><p>元组创建后不可更改，但是可以令两个元组使用 <code>+</code> 运算符组合（类似 extend），但是不允许对元素进行删除</p><p>所以实在想改的话可以先通过 <code>list(tuple1)</code> <strong>变化为列表类型</strong>，随后对元素进行操作，最后再用 <code>tuple()</code> 将列表还原为元组</p><h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set - 集合"></a>set - 集合</h3><p>集合是一个无序容器，因此不允许同时出现两个相同的元素，使用 <code>&#123;&#125;</code> 进行标识，同时不能使用下标进行索引（毕竟无序）</p><h4 id="修改操作-2"><a href="#修改操作-2" class="headerlink" title="修改操作"></a>修改操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1.add(element)     <span class="comment"># 添加一个元素</span></span><br><span class="line">set1.update(set2)     <span class="comment"># 添加一个容器的所有元素</span></span><br><span class="line">set1.intersection_update(set2) <span class="comment"># 保留两集合交集</span></span><br><span class="line">set1.discard(element) <span class="comment"># 删除元素</span></span><br></pre></td></tr></table></figure><p><code>discard</code> 方法若删除不存在的元素时不会发生报错，使用 <code>remove</code> 则会，所以建议使用 <code>discard</code></p><h3 id="dictionary-字典"><a href="#dictionary-字典" class="headerlink" title="dictionary - 字典"></a>dictionary - 字典</h3><p>字典类似于 java 中的 map 容器，通过键值对进行索引，key 不允许重复。在 python 3.7 及其之后，字典是一个有序容器，在此之前是无序的。其访问通过下标索引，下标为 key 值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;key1: value1, key2: value2&#125;</span><br><span class="line">value = dict1[key1]</span><br><span class="line">keys = dict1.keys()</span><br><span class="line">values = dict1.values()</span><br><span class="line">items = dict1.items()</span><br></pre></td></tr></table></figure><h4 id="修改操作-3"><a href="#修改操作-3" class="headerlink" title="修改操作"></a>修改操作</h4><p>更改已有的键值对可以使用两种方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1[key] = newValue</span><br><span class="line">dict1.update(&#123;key: newValue&#125;)</span><br></pre></td></tr></table></figure><p>添加新的键值对同理，也是使用上面两个方法</p><p>删除时对 key 进行删除：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1.pop(key)</span><br></pre></td></tr></table></figure><h1 id="7-5"><a href="#7-5" class="headerlink" title="7.5"></a>7.5</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数使用 <code>def</code> 关键字进行声明，参数数量可以选择变长参数表进行处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">*<span class="built_in">tuple</span></span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">**<span class="built_in">dict</span></span>)</span><br></pre></td></tr></table></figure><p>使用一个星号可以把调用时所有的参数转化为一个元组，两个星号则是字典，第二种情况要求调用时必须写出 <code>argname=parameter</code> 的显式参数，否则字典就没有 key 用了（</p><h1 id="7-9"><a href="#7-9" class="headerlink" title="7.9"></a>7.9</h1><h2 id="lambda-函数"><a href="#lambda-函数" class="headerlink" title="lambda 函数"></a>lambda 函数</h2><p><code>lambda</code> 函数是一个单行的便捷函数，它可以接受若干参数，但只能进行一行表达式的执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> arg0, arg1 : expression <span class="comment"># 声明</span></span><br><span class="line">func(x, y)                            <span class="comment"># 使用</span></span><br></pre></td></tr></table></figure><p>可以通过 lambda 函数完成一些简单的函数功能</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类通过 <code>class</code> 关键字定义，创建对象时不需要使用 <code>new</code>。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sleep</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, para1, para2</span>):</span><br><span class="line">        self.para1 = para1</span><br><span class="line">        self._para2 = para2</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">toString</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Sleep now!&quot;</span>)</span><br><span class="line"></span><br><span class="line">sleep = Sleep(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">sleep.toString()</span><br></pre></td></tr></table></figure><p>继承与其他 oop 语言类似，使用 <code>super</code> 进行引用（<code>super.__init__()</code>）</p><p>Python 允许多重继承，并且方法的继承顺序按照 C3 linearization 进行标定，继承顺序可以通过 <code>class.mro()</code> 查看</p><h2 id="日期库-datetime"><a href="#日期库-datetime" class="headerlink" title="日期库 - datetime"></a>日期库 - datetime</h2><p>datetime 库通过创建一个变量来保存运行时的日期信息：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">x = datetime.datetime.now()</span><br><span class="line"><span class="built_in">print</span>(x, x.year)</span><br><span class="line"><span class="built_in">print</span>(x.strftime(<span class="string">&quot;&lt;Directive&gt;&quot;</span>))</span><br></pre></td></tr></table></figure><p>可以通过 <code>strftime</code> 方法对日期进行格式化输出，格式取决于字符串 &lt;Directive&gt;</p><h2 id="JSON-解析-json"><a href="#JSON-解析-json" class="headerlink" title="JSON 解析 - json"></a>JSON 解析 - json</h2><p>Python 内置了简单的 json 解析库：json。json 库能实现 json 字符串和字典的双向转化。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">json_str = <span class="string">&quot;&#123;&quot;</span>x<span class="string">&quot;: &quot;</span><span class="number">1</span><span class="string">&quot;, &quot;</span>y<span class="string">&quot;: &quot;</span><span class="number">2</span><span class="string">&quot;&#125;&quot;</span></span><br><span class="line">json_dict = json.loads(json_str) <span class="comment"># 解析 json 为字典</span></span><br><span class="line"><span class="built_in">print</span>(json_dict) <span class="comment"># 字典类型</span></span><br><span class="line"></span><br><span class="line">json_str = json.dumps(json_dict) <span class="comment"># 将字典转化为 json 字符串</span></span><br><span class="line"><span class="built_in">print</span>(json_str) <span class="comment"># 字符串</span></span><br></pre></td></tr></table></figure><br><h1 id="7-17"><a href="#7-17" class="headerlink" title="7.17"></a>7.17</h1><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h2 id="异常处理流程"><a href="#异常处理流程" class="headerlink" title="异常处理流程"></a>异常处理流程</h2><p>在 python 中使用 <code>try-except-finally</code> 块表示异常的捕获与处理，同时也可以尝试捕获不同类型的异常，进入不同的处理分支，如下例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(an_undifined_object)</span><br><span class="line"><span class="keyword">except</span> IndexError :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;print index error!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;print value error!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;print other exception!&quot;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;finish try-except&quot;</span>)</span><br></pre></td></tr></table></figure><br><p>最后使用的 <code>Exception</code> 指代所有异常，也就是说如果发生了除前两种异常外的异常时，会进入这个分支最后转入 <code>finally</code> 内。</p><br><h2 id="异常的触发"><a href="#异常的触发" class="headerlink" title="异常的触发"></a>异常的触发</h2><p>除了捕获原本定义的异常类型外，我们也可以通过 <code>raise</code> 关键字<strong>主动触发异常</strong>并申请程序处理。也可以定义一个新的异常类，如下例：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NewException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, msg</span>):</span><br><span class="line">        self.msg = msg</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> NewException(<span class="string">&quot;Manmade Exception!&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><br><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>正则表达式可以通过引入 <code>re</code> 软件包实现</p><br><h2 id="正则函数"><a href="#正则函数" class="headerlink" title="正则函数"></a>正则函数</h2><p>常用的函数如下：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res1 = re.findall([字符串 | 数组等容器], src)</span><br><span class="line"><span class="comment"># 返回按顺序匹配到的项，可以同时寻找多个词</span></span><br><span class="line">res2 = re.search(regex, src)</span><br><span class="line"><span class="comment"># 返回符合正则表达 regex 的串第一次出现的 Match 对象，未匹配则返回 None</span></span><br><span class="line">res3 = re.spilt(regex, src[, max_spilt_time])</span><br><span class="line"><span class="comment"># 返回匹配到 regex 后便拆分后的元素集合，通常用 &#x27;\s&#x27; 拆空白符，第三个参数可选，控制拆分操作的执行次数上限</span></span><br><span class="line">res4 = re.sub(regex, repl, src[, max_count])</span><br><span class="line"><span class="comment"># 将 src 中所有匹配 regex 的内容更换为 repl 指的字符串，同样可以选用第四个参数表示替换次数</span></span><br><span class="line"><span class="comment"># 需要额外注意 repl 亦可以使用函数，函数的参数默认只有一个，是当前匹配到的 Match 对象</span></span><br></pre></td></tr></table></figure><br><h2 id="Match-对象"><a href="#Match-对象" class="headerlink" title="Match 对象"></a>Match 对象</h2><p>当通过 <code>search</code> 或 <code>sub</code> 方法匹配后，会返回一个 Match 对象，它包含了这次匹配所用到的相关信息，常用的方法 or 属性共三个：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">matcher.span()  <span class="comment"># 匹配项所在的字符下标范围，为元组形式</span></span><br><span class="line">matcher.string  <span class="comment"># 匹配项的匹配文本</span></span><br><span class="line">matcher.group() <span class="comment"># 和 java 一样</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-TOP</title>
      <link href="/p/1727.html"/>
      <url>/p/1727.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-文章传送门"><a href="#BUAA-OS-2023-文章传送门" class="headerlink" title="BUAA-OS-2023 文章传送门"></a>BUAA-OS-2023 文章传送门</h1><p>在这里，你可以跳转到站点里和 OS 有关的所有文章：</p><h1 id="实验报告（Lab0-Lab6）"><a href="#实验报告（Lab0-Lab6）" class="headerlink" title="实验报告（Lab0 - Lab6）"></a>实验报告（Lab0 - Lab6）</h1><ul><li><a href="90ed62b0.html">BUAA-OS-2023-Lab0-Report</a></li><li><a href="54148.html">BUAA-OS-2023-Lab1-Report</a></li><li><a href="50884.html">BUAA-OS-2023-Lab2-Report</a></li><li><a href="2565.html">BUAA-OS-2023-Lab3-Report</a></li><li><a href="60484.html">BUAA-OS-2023-Lab4-Report</a></li><li><a href="8325.html">BUAA-OS-2023-Lab5-Report</a></li><li><a href="13765.html">BUAA-OS-2023-Lab6-Report</a></li></ul><h1 id="深入学习（Lab1-Lab6）"><a href="#深入学习（Lab1-Lab6）" class="headerlink" title="深入学习（Lab1 - Lab6）"></a>深入学习（Lab1 - Lab6）</h1><ul><li>Lab1 没写喵</li><li><a href="29513.html">BUAA-OS-2023-Lab2-Probe</a></li><li><a href="45960.html">BUAA-OS-2023-Lab3-Probe</a></li><li><a href="29129.html">BUAA-OS-2023-Lab4-Probe</a></li><li><a href="4322.html">BUAA-OS-2023-Lab5-Probe-Part1</a></li><li><a href="4514.html">BUAA-OS-2023-Lab5-Probe-Part2</a></li><li><a href="53603.html">BUAA-OS-2023-Lab5-Probe-Part3</a></li><li>Lab6 没写喵</li></ul><h1 id="上机总结（Lab0-Lab5）"><a href="#上机总结（Lab0-Lab5）" class="headerlink" title="上机总结（Lab0 - Lab5）"></a>上机总结（Lab0 - Lab5）</h1><ul><li>Lab0 的题因为历史原因，丢失在数据长河里了！</li><li><a href="44391.html">BUAA-OS-2023-Lab1-Exam</a></li><li>Lab2 Extra 没过，很伤心，所以没写总结</li><li><a href="20326.html">BUAA-OS-2023-Lab3-Exam</a></li><li><a href="17374.html">BUAA-OS-2023-Lab4-1-Exam</a></li><li>Lab4-2 Extra 40分，也很伤心，所以也没写总结</li><li><a href="36639.html">BUAA-OS-2023-Lab5-1-Exam</a></li><li><a href="48159.html">BUAA-OS-2023-Lab5-2-Exam</a></li></ul><h1 id="挑战性任务（Lab6）"><a href="#挑战性任务（Lab6）" class="headerlink" title="挑战性任务（Lab6）"></a>挑战性任务（Lab6）</h1><ul><li><a href="28193.html">BUAA-OS-2023-Lab6-Challenge</a></li></ul><h1 id="理论笔记（写的稀碎）"><a href="#理论笔记（写的稀碎）" class="headerlink" title="理论笔记（写的稀碎）"></a>理论笔记（写的稀碎）</h1><ul><li><a href="2574.html">第一章 引论</a></li><li><a href="2894.html">第二章 系统引导</a></li><li><a href="9209.html">第三章 内存管理 1</a></li><li><a href="8889.html">第三章 内存管理 2</a></li><li><a href="2510.html">第四章 进程调度与死锁</a></li><li><a href="51471.html">第五章 I/O 输入输出系统</a></li><li><a href="51279.html">第六章 磁盘与存储管理</a></li><li><a href="2190.html">第七章 文件系统</a></li></ul><h1 id="课程资源"><a href="#课程资源" class="headerlink" title="课程资源"></a>课程资源</h1><ul><li><a href="https://gitee.com/osbuaa/mos">课程组<strong>实验</strong>代码仓库（未填空）</a></li><li><a href="https://wwge.lanzoup.com/iVLAx0zql5ng">沃天宇老师理论课PPT</a></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>终于，os 课程随着这篇文章的完工走到了尾声，学的时候感觉很累，但走到最后回头看感觉又不是那么累。整体学下来的关键就是<strong>体系</strong>，我觉得每一个 Lab 都是相对完整 &amp; 独立的，学习前要事先认识内部各部分在当前 Lab 中的作用，从全局的角度看功能，再从功能的角度看代码。直接闷头鼓捣代码确实会有折腾半天却不知道自己在干什么的苦恼，所以先想后看算是很关键的一步。</p><p>再一个就是要多看吧，不要理所当然认为这里就执行一个怎样怎样的功能，要多去想它如何实现的，在哪一步、具体到哪些汇编实现的？想深点总是有好处的，毕竟 os 不是程序员的战场，不仅要会调用函数，也要知道函数如何实现。</p><p>然后上机别给太大压力，做不出来的话，课程组真的会想办法捞。去年的课下强测补实验分，今年的取消申优要求分数线，都能感觉出课程组捞人的强烈愿望了</p><p><strong>一定要平时多看理论，不要把精力全给实验，然后整的理论只能在期末之前临时自救，一定不要！</strong></p><p>os 行笔至此已告一段落，希望这些记录能助后来者微薄之力。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT4-Summary</title>
      <link href="/p/56591.html"/>
      <url>/p/56591.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计与构造第四单元总结"><a href="#面向对象设计与构造第四单元总结" class="headerlink" title="面向对象设计与构造第四单元总结"></a>面向对象设计与构造第四单元总结</h1><ul><li>总结本单元所实践的正向建模与开发</li><li>总结本单元作业的架构设计，并对比分析最终的代码设计和UML模型设计之间的追踪关系</li><li>总结自己在四个单元中架构设计思维的演进</li><li>总结自己在四个单元中测试思维的演进</li><li>总结自己的课程收获</li></ul><h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><ul><li>本单元第一次作业以一个图书馆模拟系统为例，锻炼同学们<strong>对程序架构的设计能力，以及加强对 UML 类图的绘制训练</strong>。</li><li>本单元第二次作业以多学校的联网图书馆模拟系统为例，锻炼同学们<strong>对程序架构的抽象能力，以及加强对 UML 状态图的绘制训练</strong>。</li><li>本单元第三次作业以前两次作业为基础，锻炼同学们<strong>对 UML 顺序图的绘制训练</strong>。</li></ul><p>总的来说，我们在第一次作业实现了一个图书馆的基础功能（借阅、预定、书目数量限制、还书、损毁&amp;修复、丢失等），功能难点主要围绕借阅无书时的预定环节。在第二次作业中，我们将单个图书馆的功能封装，并提升为多个，并加入了校际借阅流程与无书购买流程，难点主要在闭馆后对不能立刻处理的借书请求的分类处理&amp;处理顺序，整理日的动作顺序&amp;购书操作，学生获取到一本书籍后对预约/校际借阅/预购队列产生的影响。在第三次作业中，增添了逾期还书的处理方式，对程序主干逻辑没有过多变动。</p><p>在程序之外，本单元重点训练了 UML 类图、状态图和顺序图的绘制，并分别在三次作业中进行了考察。</p><p>类图针对程序代码中所有的类。状态图针对一本书在借阅过程中发生的状态转移。顺序图针对预定成功到成功取书之间程序的调用关系与顺序。</p><h1 id="正向建模与开发"><a href="#正向建模与开发" class="headerlink" title="正向建模与开发"></a>正向建模与开发</h1><p>单元第一次作业实现单机图书馆的构建。我将图书馆各个部门分装为静态类，将输出功能和日期转换功能封装为工具类，将书籍、学生和借阅请求封装为类，在主类中进行图书馆功能的分发与实现。</p><p>过程中遇到的问题主要在学生获取书籍后要对预约队列进行刷新，需要一些容器操作。</p><p>单元第二次作业将图书馆变为联机图书馆。首先将原本代表部门的类从静态类转换为一般类，便于每个学校分别 <code>new</code> 一个对应的部门进行处理；然后将原本主类的逻辑封装为一个 <code>School</code> 类，代表一个学校的图书馆，再在主类创建一个图书馆的容器进行存放。其他类模型未发生改变。当接受请求后，先获取所在图书馆，再分发到对应图书馆执行相应功能函数，完成请求功能。</p><p>问题主要集中在请求分类流程：当一个请求不能实时满足，需要在闭馆后统一进行处理，并根据书籍余量、状态判断是校际借阅、校内预定或校内购买。指导书在此的说明不够详细，前后要求还有改动，所以这部分完成的不是很顺利。主要还是与第一次的处理逻辑不同，导致了架构修改上的困难。</p><p>单元第三次作业更像是补偿性作业，上次一作业难度过高导致这一次作业的内容就相对较少，只需要新增并维护书籍的一个字段即可，并在借还时更新字段，调用相应方法。</p><h1 id="UML模型设计"><a href="#UML模型设计" class="headerlink" title="UML模型设计"></a>UML模型设计</h1><p>以第三次作业为例，对比分析最终的代码设计和UML模型设计之间的追踪关系。本次作业<strong>类图</strong>如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306131732858.svg" alt="Main" style="zoom: 33%;" /><p>程序核心为 <code>School</code> 类，它作为包含结构、处理请求的基底存在，包含多个字段和方法。</p><p>其左侧的是学校内含有的各个部门，它们在 <code>School</code> 类内的方法调用中出现，接收响应请求并处理，图中调用输出类 <code>PrintAction</code> 进行统一规格化输出。</p><p><code>School</code> 类右下侧的是学校包含的学生、书籍、请求。它们也在方法中被调用，完成相应属性、状态的转换。</p><p>第三次作业<strong>顺序图</strong>如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306131738146.svg" alt="SequenceDiagram1" style="zoom: 80%;" /><p>消息 1-10 是评测要求出现的从预定成功到获取书籍用到的顺序逻辑，再下面是其他正常需要用到的功能逻辑。 <code>Main</code> 类通过调用 <code>School</code> 类中的处理方法，实现对请求的初步处理，在处理方法中，<code>School</code> 类又利用自身字段进行具体的业务逻辑实现。</p><h1 id="架构设计思维的演进"><a href="#架构设计思维的演进" class="headerlink" title="架构设计思维的演进"></a>架构设计思维的演进</h1><h2 id="第一单元：递归下降与表达式处理"><a href="#第一单元：递归下降与表达式处理" class="headerlink" title="第一单元：递归下降与表达式处理"></a>第一单元：递归下降与表达式处理</h2><p>在第一单元，由于不了解层次化与架构的设计方式，课程组安排了多项式作为训练内容，它半强制地让我们使用层次化的程序结构进行编程，以此来加深我们对层次化设计的印象。层次化设计、递归下降和化简运算是本单元的重难点，也拉开了oo课程的帷幕。<del>（性能分从这里开始卷烂）</del></p><h2 id="第二单元：多线程设计与电梯调度"><a href="#第二单元：多线程设计与电梯调度" class="headerlink" title="第二单元：多线程设计与电梯调度"></a>第二单元：多线程设计与电梯调度</h2><p>第二单元，在我们已经初步了解层次化设计后，采用了多线程的方式进行考察。一方面，对共享数据的线程安全、多线程锁的应用等方面进行了考察；另一方面，电梯运行逻、请求分配、拆分调度等内部逻辑也是需要考虑的重点。我在本单元采用了黑板模式进行设计，中心黑板为调度器，通过单向的数据访问确保了线程安全；使用过程模拟来将请求分配到合适的电梯中。途中虽然遇到了诸多问题，第三次作业还出现了修到最后一刻也没修完的 bug，我还是觉得这是面向对象课程中设计最成功的一个单元。</p><h2 id="第三单元：JML-契约与社交网络模拟"><a href="#第三单元：JML-契约与社交网络模拟" class="headerlink" title="第三单元：JML 契约与社交网络模拟"></a>第三单元：JML 契约与社交网络模拟</h2><p>第三单元中，我们了解了一种表述 Java 程序需求的语言模型 JML。它通过格式化的要求，约定了需求提出者与程序实现者之间的契约。我们在 JML 的基础上进行了程序设计，模拟了一个社交网络，实现了与其相关的数据指标计算。很遗憾本单元在实现上偏离了 JML 单元设计的核心，而更注重了在执行需求下的程序性能，不幸地将 JML 单元变成了惨烈的算法单元。虽然这个单元的得分要比开始的两个单元要高，但是过程中的设计体验和实现过程并不如前者。</p><h2 id="第四单元：UML-模型与图书馆系统模拟"><a href="#第四单元：UML-模型与图书馆系统模拟" class="headerlink" title="第四单元：UML 模型与图书馆系统模拟"></a>第四单元：UML 模型与图书馆系统模拟</h2><p>第四单元，我们详细介绍了 UML 图与其对设计的引导作用。作为设计中十分重要的一环，绘制出 UML 类图对程序中类的设计、管理都有十分重要的作用。本单元以考察 UML 图的设计、程序功能实现为核心，在架构上并不做严格限制，详细考察了同学们对类图、状态图、顺序图绘制的能力。但稍有遗憾的是，单元第二次作业的功能增加过于复杂，许多要求与第一次作业发生冲突，难以迭代开发，迫不得已只能选择重构。并且功能描述不清，题干中许多情况也因为情况复杂而难以考虑周全，UML 步 JML 后尘，成了模拟功能的牺牲品。</p><h1 id="测试思维的演进"><a href="#测试思维的演进" class="headerlink" title="测试思维的演进"></a>测试思维的演进</h1><p>从第一次作业开始，直至第十三次作业，，中间的每一次作业都进行了测评机的构造，因为最后两次作业的数据限制较为复杂，保证不出现的情况较难通过设置规则在自动生成时规避，所以没有设计测评机。</p><p>最开始的测试使用 Python 语言编写，但是本身就没学过 py，所以效果不是很满意，于是后来选择迁移到 Java 上写测评。在设计测试程序的过程中不仅需要考虑到数据产生的合法性、是否符合数据限制、测试对于程序处理的覆盖性（分支、循环与边界），在写测试的过程中让我对自己的程序本身有了更完整的了解，能够明白坑点在哪里。但是由于测试程序基于我自己的思路来写的，所以可能不太容易找出自己的 bug，不过找别人的还是很灵（</p><h1 id="总结课程收获"><a href="#总结课程收获" class="headerlink" title="总结课程收获"></a>总结课程收获</h1><p>终于，oo 课程走到了尾声，这途中的十二次代码作业和四次博客作业对我而言都是十分珍贵的经历，在其中不仅初步掌握了 Java 语言的使用，还初窥了面向对象思想的门径。不同于大一时程设、DS这类面向过程编程的课程，oo 课利用多种场景教会了我面向对象、设计模式与其他的重要思想与技巧。虽然在课程的后半段出了点小问题，但课程的整体收获仍然十分充实。同时还告诉了我写程序时做测试的重要性。很遗憾因为时间问题我没有参选 oo 课程助教，但我也相信老师和新的助教们在新的一学年里能把 oo 课越办越好，办成干货满满的好课。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从负开始的 Vue 学习 (1)</title>
      <link href="/p/10387.html"/>
      <url>/p/10387.html</url>
      
        <content type="html"><![CDATA[<h1 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h1><ul><li>从负开始的 Vue 学习 (1)</li><li><a href="55443.html">从负开始的 Vue 学习 (2)</a></li></ul><br><h1 id="引入-Vue"><a href="#引入-Vue" class="headerlink" title="引入 Vue"></a>引入 Vue</h1><blockquote><p>Vue 为我们提供了四种引入的方法，各有优劣。</p><p>截至23年6月，官网已经把 CLI 和 Vite 方法替换为了 <code>create-vue</code> ，也就是只有下面的第1和4项可选</p></blockquote><br><h2 id="CDN、引入-js文件"><a href="#CDN、引入-js文件" class="headerlink" title="CDN、引入.js文件"></a><code>CDN</code>、引入<code>.js</code>文件</h2><p>借助 <code>script</code> 标签直接通过 <code>CDN</code> 引入<strong>全体源码</strong>的方式来使用  <code>Vue</code> ，具体可参考 <code>vue3</code> 官方文档，不建议在大型项目中使用这种方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br><blockquote><p>在后面的引入方法中，通常要使用 <code>npm</code> 命令对项目进行构建/启动，所以要先在终端上安装<code>node.js</code>，确保 <code>npm</code> 命令能够正常使用，安装可以参考网上文档，这里不再赘述。</p></blockquote><br><h2 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a><code>Vite</code></h2><p>通过 <code>Vite</code> 工具安装 <code>Vue</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When has npm 7+</span></span><br><span class="line">$ npm init vite@latest &lt;projectName&gt; -- --template vue</span><br><span class="line"></span><br><span class="line">$ npm install<span class="comment"># Install dependencies</span></span><br><span class="line">$ npm run dev<span class="comment"># Compile and run for development </span></span><br></pre></td></tr></table></figure><br><h2 id="CLI工具"><a href="#CLI工具" class="headerlink" title="CLI工具"></a><code>CLI</code>工具</h2><p><code>vue-cli</code> 脚手架使用 <code>webpack</code> 进行编译，比 <code>Vite</code> 构建的项目拥有更多的依赖与包，但同时速度比 <code>Vite</code> 要慢</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vue create my-project</span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">$ vue ui<span class="comment"># Create GUI for projects</span></span><br></pre></td></tr></table></figure><p>大概是22-23年，<code>Vue CLI</code> 进入了“维护模式”，官方推荐通过基于<code>Vite</code>的新引入方式创建新项目</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303161731567.png" alt="image-20230316173109517"></p><br><h2 id="create-vue"><a href="#create-vue" class="headerlink" title="create-vue"></a><code>create-vue</code></h2><p><code>create-vue</code> 是 <code>Vue</code> 官方近来推荐的新脚手架工具，它基于 <code>Vite</code> 开发，安装上和原本的 <code>cli</code> 区别不大</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm init vue@latest</span><br><span class="line"><span class="comment"># Initing your project settings</span></span><br><span class="line">$ <span class="built_in">cd</span> &lt;your-project-name&gt;</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>在<code>npm init</code>后，你将会看到一些诸如 <code>TypeScript</code> 和测试支持之类的可选功能提示（全No也能跑）</p><p>不得不说现在这新界面比原来好看多了，当然内容也更复杂了</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306121258805.png" alt="image-20230612125759650" style="zoom: 33%;" /><br><h1 id="创建一个应用"><a href="#创建一个应用" class="headerlink" title="创建一个应用"></a>创建一个应用</h1><blockquote><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p></blockquote><br><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p>在我们创建 vue 应用时，都是通过 <code>createApp</code> 函数创建一个新的<strong>应用实例</strong>并使用， <code>main.js</code> 内会包含这样一句话：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这里的 <code>createApp</code> 就通过 <code>App</code> 的数据<strong>创建了一个 vue 应用</strong>，并把这个应用 <code>mount</code> 进 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 这个 DOM 内，最后再把这个 DOM 写入 html 文件，实现元素的展示。</p><h2 id="根组件"><a href="#根组件" class="headerlink" title="根组件"></a>根组件</h2><p>还是同样的例子，我们传入 <code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p><p>单文件组件可以直接从文件中 <code>import</code> 根组件使用</p><br><h2 id="应用挂载"><a href="#应用挂载" class="headerlink" title="应用挂载"></a>应用挂载</h2><p>应用实例必须在调用了 <code>.mount()</code> 方法后才会渲染出来。该方法接收一个“<strong>容器</strong>”参数，可以是一个实际的 <strong>DOM 元素</strong>或是一个 CSS 选择器字符串</p><p><code>.mount(&quot;#app&quot;)</code> 的容器就是一个 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> 的 DOM 元素，经过 <code>createApp</code> 后产生的组件内容将会渲染在这个 DOM 元素中。</p><p><code>.mount()</code> 方法应该始终在整个应用配置和资源注册完成后被调用。</p><blockquote><p>同时请注意，不同于其他资源注册方法，它的返回值是<strong>根组件实例</strong>而非<strong>应用实例</strong>。也就是说，它会返回一个 <code>App</code> 元素（<code>createApp</code> 后产生的<strong>根组件实例</strong>）</p></blockquote><br><p>总结来说：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"><span class="comment">// 应用实例 根元素 挂载  DOM 元素</span></span><br></pre></td></tr></table></figure><br><h2 id="组件实例-property"><a href="#组件实例-property" class="headerlink" title="组件实例 property"></a>组件实例 <code>property</code></h2><p>我们通过组件选项，将用户定义的 <code>property</code> 添加到组件实例中，例如 data, methods, props, computed, inject, setup 等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">num</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">able</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件实例定义的所有 <code>property</code> 都可以在组件的<strong>模板</strong>（<code>template</code>）中进行访问</p><p>Vue 还在组件中定义了一部分内置 <code>property</code> ，它们在开头有一个 <code>$</code> 用于与用户定义的 <code>property</code> 相区分</p><br><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><blockquote><p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据<strong>绑定</strong>到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。</p></blockquote><p>vue 会自动将模板 template 编译为优化的 js 代码，当元素变动时会动态地更改渲染的操作，实现实时变动。</p><br><h2 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h2><p>文本插值，是最基础的数据绑定形式，使用双大括号进行绑定声明，这被称为 <code>Mustache</code> 语法。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>双大括号内的内容会被替换为<strong>组件实例中</strong>对应的属性的值，同时绑定的值也会随着属性的更改而实时更新。如果想要单次绑定，不进行更新，则需要使用 <code>v-once</code> 指令进行绑定：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="原始-html"><a href="#原始-html" class="headerlink" title="原始 html"></a>原始 html</h2><p>若直接将数据通过 <code>Mastache</code> 的文本形式进行绑定，将视为直接输出字符串。如果字符串是 <code>html</code> 代码，并想要其根据 <code>html</code> 格式显示，需要使用 <code>v-html</code> 指令进行绑定：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;prop1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line">span1: &quot;<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span> red <span class="tag">&lt;/<span class="name">span</span>&gt;</span>&quot;</span><br></pre></td></tr></table></figure><br><blockquote><p>请仅在内容安全可信时再使用 <code>v-html</code>，并且<strong>永远不要</strong>使用用户提供的 HTML 内容。</p></blockquote><br><h2 id="Attribute-绑定"><a href="#Attribute-绑定" class="headerlink" title="Attribute 绑定"></a>Attribute 绑定</h2><p>通过 <code>v-bind</code> 指令，可以动态地绑定一个标签，它指示 Vue 将元素的 <code>id</code> 标签与组件的指定属性保持一致。</p><p>可以用 <code>:attribute</code> 进行简写：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;dyid1&quot;</span>&gt;</span>id<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:id</span>=<span class="string">&quot;dyid1&quot;</span>&gt;</span>id<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上下两行效果一致，id 会动态绑定为 dyid1 包含的内容 --&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="Mustache-amp-js-表达式"><a href="#Mustache-amp-js-表达式" class="headerlink" title="Mustache &amp; js 表达式"></a>Mustache &amp; js 表达式</h2><p>Vue 在下面两种数据绑定内都支持完整的 JavaScript 表达式，但只能出现单一的表达式，语句、多表达式是不合法的输入。</p><ul><li>在文本插值中 (双大括号)</li><li>在任何 Vue 指令 (以 <code>v-</code> 开头的特殊 attribute) attribute 的值中</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:id</span>=<span class="string">&quot;`list-$&#123;id&#125;`&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><blockquote><p>指令是带有 <code>v-</code> 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 <code>v-bind</code> 和 <code>v-html</code>。</p></blockquote><p>指令的期望值为一个 JavaScript 表达式 (除 <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code> 外)</p><p>指令的任务是在其表达式的值变化时<strong>实时更新</strong> DOM。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>Now you see me<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>seen</code> 作为 bool 变量，通过 <code>v-if</code> 控制当前元素的存在与否</p><br><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>指令名冒号后的内容表示为参数，在 <code>v-bind</code> 中告知绑定的 attribute 是谁，在 <code>v-on</code> 中表示监听的事件名称（使用 <code>@</code> 进行缩写）</p><br><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p><strong>较少使用。</strong></p><p>在指令参数中使用 <code>[]</code> 将属性（一般为变量）包裹，可以对属性进行动态求值，如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:</span>[<span class="attr">idd</span>]=<span class="string">&quot;id&quot;</span>&gt;</span>example<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">cilck</span>=<span class="string">&quot;idd=class&quot;</span>&gt;</span>change<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击按钮后，上面动态绑定的参数就会变更为 <code>:class=&quot;id&quot;</code>。这样的修改同样可以应用于动态地事件绑定，也就是给 <code>[click]</code> 起一个变量名，随后改变其值</p><br><h1 id="计算属性-amp-监听器"><a href="#计算属性-amp-监听器" class="headerlink" title="计算属性 &amp; 监听器"></a>计算属性 &amp; 监听器</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>计算属性，是一种缓存数据的方式，计算属性会随着其依赖数据的变化而动态发生改变，其与 <code>method</code> 类似，但后者会反复求值，不会产生缓存。</p><p>使用计算属性可以提高在大数据范围内的运行效率</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">data1</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">reverse</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">        <span class="attr">full_data</span>: &#123;</span><br><span class="line">            <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">data</span>.<span class="title function_">reverse</span>();</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">data</span> = newValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>计算属性通常使用简写方式声明：如 <code>data1</code> 声明仅包含方法，返回值即该属性代表的内容。完整属性包含 <code>getter</code> 和 <code>setter</code> 两个方法，前者为简写方法的内容，后者不常用，但可以作为手动更新计算属性的操作（使用等号赋值）。</p><p>通常情况下，计算属性是<strong>只读的</strong>，所以一般不会调用 <code>setter</code> 方法</p><br><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>与计算属性类似，如果我们需要根据某个数据的变化来执行一些异步操作（如获取 api 等），也可以通过监听器 <code>watch</code> 完成。通过监听某个数据，并在数据变动时执行对应的函数。</p><p>在使用时要防止监听器的滥用，在执行异步操作上更推荐使用计算属性，并把逻辑封装在属性的 <code>getter</code> 内部。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">objecter</span>: &#123;</span><br><span class="line">            <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">newValue, oldValue</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>监听器方法中含有两个参数，命名不做限制，但顺序必须是先写新值，后写旧值。参数中 <code>oldValue</code> 可以不写</p><p>除了这种只包含方法的监听外，还可以直接对属性进行监听（格式类似于计算属性），如上文中对 <code>objecter</code> 的监听。这里的 <code>immediate</code> 字段说明在 vue 初始化页面时就会对初始值调用一次 <code>handler</code>，这里的 <code>handler</code> 就是开始谈到的监听函数。</p><p>也就是说这个以属性为标识的监听器实质上增加了一些额外的字段，便于进行设置</p><br><h2 id="对象的深度监听"><a href="#对象的深度监听" class="headerlink" title="对象的深度监听"></a>对象的深度监听</h2><p>监听器可以监听数据的变化，但如果监听<strong>对象</strong>，那么当对象内的字段发生变化时，监听器是不会生效的，也就是说，监听器只进行浅层监听，如下例中改变字段 <code>name</code>，则不会触发监听器：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">user</span>: &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&quot;name1&quot;</span>,</span><br><span class="line">            <span class="attr">age</span>: <span class="number">114514</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">user</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue.<span class="property">name</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若对对象进行深度监听，可以在<strong>对象形式的监听器</strong>内部添加参数 <code>deep: true</code>，来进行递归的监听过程。</p><p>若想对对象的某一部分进行监听，可以在深度监听的基础上将监听器的对象名改为用字符串包裹的对应部分，如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">user</span>: &#123; <span class="comment">// 对象全体的深度监听</span></span><br><span class="line">            <span class="attr">handler</span>: <span class="keyword">function</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;user.name&quot;</span>: &#123; <span class="comment">// 仅对某字段的监听</span></span><br><span class="line">            <span class="comment">// ... 监听器内容</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><br><h1 id="Class-与-Style-绑定"><a href="#Class-与-Style-绑定" class="headerlink" title="Class 与 Style 绑定"></a>Class 与 Style 绑定</h1><p><code>class</code> 和 <code>style</code> 都是元素的 <code>attribute</code>，它们可以通过 <code>v-bind</code> 进行绑定并渲染。在 <code>vue</code> 中不仅可以通过直接的字符串来指定这些字段，同时也可以使用<strong>对象或数组</strong>配合 <code>bind</code> 进行动态绑定</p><br><h2 id="Class-绑定"><a href="#Class-绑定" class="headerlink" title="Class 绑定"></a>Class 绑定</h2><h3 id="对象方式"><a href="#对象方式" class="headerlink" title="对象方式"></a>对象方式</h3><p>下面介绍通过<strong>对象</strong>绑定 class 的方法。</p><p>我们可以令 class 绑定到以下一个对象： <code>&#123;&lt;类名&gt;: &lt;boolean 数据名&gt;&#125;</code> 如若此做，在数据为真时，对应字段便会生效。这个对象不创建新的数据，冒号左侧来源于已有的 class，右侧来源于已有的 data，只不过这个对象本身也可以创建在 data 内。</p><p>在绑定时有以下几个规则：</p><ul><li>对象可以包含多个字段，并且可以有多个同时为真，此时会添加至两个类</li><li>通过对象绑定而声明的 class 可以和常规字符串指定的 class 共存</li><li>由于 <code>v-bind</code>，对象内数据的变化可以实时影响元素的 class 列表</li><li>更常见的方式是使用<strong>计算属性</strong>封装对象</li></ul><p>有以下例：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">data1</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">data2</span>: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">objectClass</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                by-<span class="attr">object1</span>: <span class="variable language_">this</span>.<span class="property">data1</span>,</span><br><span class="line">                by-<span class="attr">object2</span>: <span class="variable language_">this</span>.<span class="property">data2</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;by-string&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">:class:</span> &quot;&#123;<span class="attr">by-object1:</span> <span class="attr">data1</span>, <span class="attr">by-object2:</span> <span class="attr">data2</span>&#125;&quot;&gt;</span></span><br><span class="line">        content here</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    <span class="selector-class">.by-string</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.by-object1</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.by-object2</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这里 <code>&lt;div&gt;</code> 的 class 列表为 <code>by-string by-object1</code>，由于 <code>data2</code> 为 <code>false</code>，所以 <code>by-object2</code> 字段没有生效</p><br><h3 id="数组方式"><a href="#数组方式" class="headerlink" title="数组方式"></a>数组方式</h3><p>除对象外，也可以使用<strong>数组</strong>进行样式绑定，数组元素需要为<strong>数据</strong>、数据内容为指向的 class 名，因为不容易快速更改所以<strong>不常用</strong>。数组中也可以包含对象，不过没有必要做的这么麻烦了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[arrayClass1]&quot;</span>&gt;</span></span><br><span class="line">    content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="Style-样式"><a href="#Style-样式" class="headerlink" title="Style 样式"></a>Style 样式</h2><p><strong>基础字符串样式</strong>：直接通过字符串进行内联</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p style=&quot;color:red&quot;&gt;content&lt;/p&gt;</span><br></pre></td></tr></table></figure><br><h3 id="对象方式-1"><a href="#对象方式-1" class="headerlink" title="对象方式"></a>对象方式</h3><p><strong>对象方式</strong>：在模板处直接声明对象或使用 data 的对象，同样使用 <code>v-bind</code> 绑定。同样的，推荐使用计算属性进行绑定</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;color:&#x27;red&#x27;, fontSize:size + &#x27;px&#x27;&#125;&quot;</span>&gt;</span>content1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">&quot;object1&quot;</span>&gt;</span>content2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">size</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">object1</span>: &#123;</span><br><span class="line">            <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">            <span class="attr">fontSize</span>: <span class="string">&#x27;50px&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;background-color&quot;</span>: <span class="string">&#x27;pink&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的数据可以使用字符串拼接，对大小 <code>px</code> 的处理会更加方便。</p><p>内联样式需要使用<strong>驼峰命名</strong>，而非连字符（连字符需要使用引号）。</p><p>对象中格式为 <code>&#123;css 属性名&#125;: &#123;data 中属性&#125;</code></p><br><h3 id="数组方式-1"><a href="#数组方式-1" class="headerlink" title="数组方式"></a>数组方式</h3><p><strong>数组方式</strong>：和 class 的数组方式相同，只不过最终内含的元素均为 <code>&#123;css&#125;: &#123;data&#125;</code>，如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">:style</span>=<span class="string">&quot;[object1, &#123;color: blue&#125;]&quot;</span>&gt;</span>content3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h2><p><code>v-if</code> 可以通过简单的逻辑控制指定元素的<strong>加载</strong>与否，可以搭配 <code>v-else-if</code> 与 <code>v-else</code> 使用</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;digit&gt;5&quot;</span>&gt;</span>digit &gt; 5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;digit==5&quot;</span>&gt;</span>digit = 5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>=<span class="string">&quot;digit&lt;5&quot;</span>&gt;</span>digit &lt; 5<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>若想通过一个条件控制多个元素的显示，可以利用<strong>不可见的</strong> <code>&lt;template&gt;</code> 元素进行“打包”进而控制区域内的内容</p><br><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>作用与 <code>v-if</code> 类似，但 <code>v-show</code> 不论如何都会加载这个元素，只不过会根据表达式的值控制其<strong>可见</strong>与否，即 <code>display</code> 这个 CSS 字段。</p><p><code>v-show</code> 不支持对 <code>&lt;template&gt;</code> 进行控制，也不能使用 <code>v-else</code></p><br><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>简而言之，当元素需要经常切换、切换开销大时，使用 <code>v-show</code>；当切换不频繁时使用 <code>v-if</code></p><p>这是因为 <code>v-show</code> 有更高的初始渲染开销，应尽量避免使用；<code>v-if</code> 有更高的切换开销，在条件不为真时就不进行加载。切换频繁时 <code>v-if</code> 在元素创建、销毁时开销更大。</p><br><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><p>我们可以使用 <code>v-for</code> 基于<strong>数组或对象</strong>对列表进行渲染。每次迭代都会新增一个列表的项。迭代时使用 <code>in</code> 作为分隔符，同时也可以用 <code>of</code> 代替。当数组/对象发生改变时，渲染出的列表也会同时发生变化。</p><br><h3 id="数组方式-2"><a href="#数组方式-2" class="headerlink" title="数组方式"></a>数组方式</h3><p>使用数组方式迭代时，支持两个参数：元素、下标。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ui</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125; -&gt; &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h3 id="对象方式-2"><a href="#对象方式-2" class="headerlink" title="对象方式"></a>对象方式</h3><p>由于对象类似于字典类型，所以多支持一个参数：值、键、下标</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ui</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key, index) in items&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125; -&gt; &#123;&#123;key&#125;&#125; -&gt; &#123;&#123;index&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h3 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a>v-for 和 v-if</h3><p>和 <code>v-if</code> 类似，<code>v-for</code> 也可以通过 <code>&lt;template&gt;</code> 标签渲染一个包含多元素的块。但是并不建议<strong>在一个节点上</strong>同时使用 <code>v-for</code> 与 <code>v-if</code>（顺带一提后者的优先级更高），可以外层用 <code>for</code> 内层用 <code>if</code> 进行嵌套实现分离</p><br><h3 id="状态管理与-key"><a href="#状态管理与-key" class="headerlink" title="状态管理与 key"></a>状态管理与 <code>key</code></h3><blockquote><p>Vue 默认按照“就地更新”的策略对 <code>v-for</code> 元素进行更新。</p><p>这样做可以提高渲染性能。</p></blockquote><p>这也就是说，当数据发生顺序变动、增删等时，Vue 不会移动 DOM 元素的顺序，这可能会导致某些匹配出现错位。</p><p>为了 Vue 能够识别出每个元素，可以通过 <code>v-bind</code> <code>key</code> 属性对元素进行标注，注意这个属性必须<strong>唯一</strong>，并且需要使用基础类型，例如下标 <code>index</code> 或者随便一个不会重复的字段（字符串/ number）。如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ui</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125; -&gt; &#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ui</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一来，每个渲染出的节点就都包含了一个“标签”，与之关联的数据就不会错位了。</p><br><h2 id="数组更新检测"><a href="#数组更新检测" class="headerlink" title="数组更新检测"></a>数组更新检测</h2><p>Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。这些变更方法包括：</p><ul><li><code>push()</code>：末尾添加</li><li><code>pop()</code>：末尾删除</li><li><code>shift()</code>：首位删除</li><li><code>unshift()</code>：首位添加</li><li><code>splice()</code>：指定位置增删改<ul><li>模式：<code>list.splice(修改下标, 删除元素个数, 插入元素值)</code></li><li>删除个数为 0 即插入</li></ul></li><li><code>sort()</code>：排序，默认升序</li><li><code>reverse()</code>：元素顺序反转</li></ul><br><h1 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h1><h2 id="v-on-监听事件"><a href="#v-on-监听事件" class="headerlink" title="v-on 监听事件"></a>v-on 监听事件</h2><p>Vue 中使用 <code>v-on</code> 指令对事件进行监听并处理，其可以简写为 <code>@</code>。</p><p>事件可以为点击、聚焦等。事件处理器可以为<strong>内联事件处理器</strong>或<strong>方法事件处理器</strong>。</p><br><h3 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h3><p>内联事件处理器一般用于逻辑简单的事件，表现为一行内联的 JavaScript 代码。</p><p>方法事件处理器则会直接调用一个完整的方法，它可以传递参数。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:click</span>=<span class="string">&quot;addCount(2)&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h3 id="事件参数"><a href="#事件参数" class="headerlink" title="事件参数"></a>事件参数</h3><p>对于触发事件处理的这个事件，我们也可以将其传入方法内进行进一步的处理，需要使用带参数的方法调用，用 <code>$event</code> 代表这个 DOM 事件。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用 $event 变量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:click</span>=<span class="string">&quot;addCount(2, $event)&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用内联的箭头函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:click</span>=<span class="string">&quot;(event) =&gt; addCount(2, event)&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h3 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h3><p>事件修饰符是使用 <code>.</code> 表示的<strong>指令后缀</strong>，可以对事件进行一些说明，指定一些要求。常见的事件修饰符有以下几个：</p><ul><li><code>.stop</code>：停止事件的传递，通常阻止子元素的事件向父元素的同操作事件传递</li><li><code>.once</code>：事件只执行一次，只有重新加载才能再执行一次</li><li><code>.prevent</code>：阻止事件的默认操作，如 <code>submit</code> 操作对页面的重新加载</li><li><code>.self</code>：只有当事件来自自身时才进行处理，即忽视传递而来的事件</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 单击事件将停止传递 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件将不再重新加载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰语可以使用链式书写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 也可以只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当 event.target 是元素本身时才会触发事件处理器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 例如：事件处理器不来自子元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用修饰符时需要注意调用顺序，使用 <code>@click.prevent.self</code> 会阻止<strong>元素及其子元素的所有点击事件的默认行为</strong>（即 阻止事件+自身），而 <code>@click.self.prevent</code> 则只会阻止对元素本身的点击事件的默认行为（自身事件+阻止）。</p><br><h3 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h3><p>在监听键盘按键输入时，我们可能会监听诸如 <code>Enter</code> 键的输入。这时可以使用按键修饰符进行处理。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 仅在 `key` 为 `Enter` 时、松开时调用 `submit` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;submit&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><p>Vue 为一些<strong>常用按键</strong>提供了别名：</p><ul><li><code>.enter</code>、<code>.tab</code>、<code>.delete</code> (捕获 Delete 和 Backspace 两个按键)、<code>.esc</code>、<code>.space</code></li><li><code>.up</code>、<code>.down</code>、<code>.left</code>、<code>.right</code></li></ul><p>除此之外还有一些<strong>控制按键</strong>也可以进行监控：</p><ul><li><code>.ctrl</code>、<code>.alt</code>、<code>.shift</code></li><li><code>.meta</code>：在 Mac 上是 Command，在 Windows 上是 Win 键</li><li>简而言之，控制按键必须在满足事件其他条件时保持按住才能使得事件生效</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Alt + Enter，松开 Enter 并保持 Alt 按住（生效） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.alt.enter</span>=<span class="string">&quot;clear&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Ctrl + 点击，保持 Ctrl 按住（生效） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>Do something<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p><strong>鼠标按键</strong>也在修饰范围之内：</p><ul><li><code>.left</code>、<code>.right</code>、<code>.middle</code></li></ul><blockquote><p>请注意，系统按键修饰符和常规按键不同。与 <code>keyup</code> 事件一起使用时，该按键必须在事件发出时处于按下状态。换句话说，<code>keyup.ctrl</code> 只会在你仍然按住 <code>ctrl</code> 但松开了另一个键时被触发。若你单独松开 <code>ctrl</code> 键将不会触发。</p></blockquote><br><h4 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a><code>.exact</code> 修饰符</h4><p>这个修饰符用于选定系统按键。默认情况下，只要按下 <code>ctrl</code> 再点击，<code>@click.ctrl</code> 就会生效，其他的系统按键是否按下并不影响，而当 <code>.exact</code> 生效时，必须按下、且仅按下前缀的系统按键时才会使得事件生效，如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 仅当按下 Ctrl 且未按任何其他键时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 仅当没有按下任何系统按键时触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h1 id="表单输入绑定"><a href="#表单输入绑定" class="headerlink" title="表单输入绑定"></a>表单输入绑定</h1><br><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>指令 <code>v-model</code> 为我们提供了数据双向绑定的方法。通过它，我们可以令表单输入框中的内容与 js 中的数据进行同步，最简单的使用如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;data1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样 <code>input</code> 框中输入的内容就会自动和数据 <code>data1</code> 实时同步。实质上 <code>v-model</code> 是 <code>v-bind</code> 和 <code>v-on</code> 的结合：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;data1&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;event =&gt; data1 = event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这里我们首先使用 <code>v-bind</code> 令输入框内容受 <code>data1</code> 控制，正向更新；随后通过 <code>v-on</code> 侦听<strong>输入事件</strong>并获取内容 <code>target.value</code> 再更新数据，实现反向更新。</p><br><p><code>v-model</code> 在处理不同表单元素时会采用不同的绑定策略：</p><ul><li>文本类型：绑定 <code>value</code>，侦听 <code>input</code>；如 <code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code></li><li>单选类型：绑定 <code>checked</code>，侦听 <code>change</code>；如 <code>&lt;input type=&quot;checkbox&quot;&gt;</code>、<code>&lt;input type=&quot;radio&quot;&gt;</code></li><li>选择器：绑定 <code>value</code>，侦听 <code>change</code>；如 <code>&lt;select&gt;</code></li></ul><br><h2 id="演示实例"><a href="#演示实例" class="headerlink" title="演示实例"></a>演示实例</h2><ol><li>对多个<strong>勾选框</strong>，可以把数据导入到一个数组/集合内。在设置时先设置单选框的 <code>value</code> 值，传入数据时会选用这个值。对 <code>&lt;checkbox&gt;</code>（复选框） 和 <code>&lt;radio&gt;</code>（单选）均生效，单选可以不要这个 <code>value</code>，单选/多选选择器同理</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 首先在 data 处定义 names --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Checked names: &#123;&#123; names &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;jack&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Jack&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;jack&quot;</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;john&quot;</span> <span class="attr">value</span>=<span class="string">&quot;John&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;john&quot;</span>&gt;</span>John<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mike&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Mike&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;checkedNames&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mike&quot;</span>&gt;</span>Mike<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如此，在选中某个框后，names 处就会显示对应的 <code>value</code>，且元素顺序是单选框选中的顺序</p><ol start="2"><li>选择器的初始（禁用）值</li></ol><p>如果 <code>v-model</code> 表达式的初始值不匹配任何一个选择项，<code>&lt;select&gt;</code> 元素会渲染成一个“未选择”的状态。在 iOS 上，这将导致用户无法选择第一项（因为 iOS 在这种情况下不会触发一个 change 事件）。因此，我们建议提供一个空值的禁用选项，如下例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Chosen: &#123;&#123; selected &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">disabled</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>Please choose one<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>A<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>B<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span>&gt;</span>C<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在前面提到的向绑定元素传入值的 <code>value</code> 通常而言是预设的字符串，但如果这个传入的值需要是数据，我们可以使用 <code>v-bind</code> 进行绑定。</p><br><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p><code>v-model</code> 共支持三个修饰符：</p><ul><li><code>.lazy</code>：主要对输入框使用，将更新数据的<strong>事件</strong>由 <code>input</code> 更改为 <code>change</code>（失焦），节省更新次数与资源开销</li><li><code>.number</code>：自动将用户输入的值转变为 <code>number</code> 类型，可以使用该修饰符<ul><li>在转换为数字失败或输入为空时，仍会保留 <code>string</code> 类型</li></ul></li><li><code>.trim</code>：就是那个 <code>trim</code>，把两侧的空格去掉，用处不大，其实可以后期处理</li></ul><br><p>NEXT：<a href="55443.html">从负开始的 Vue 学习 (2)</a></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab6-Challenge</title>
      <link href="/p/28193.html"/>
      <url>/p/28193.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lab6-挑战性任务"><a href="#Lab6-挑战性任务" class="headerlink" title="Lab6 挑战性任务"></a>Lab6 挑战性任务</h1><h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>在 Lab6 的后半程，我们在 MOS 上实现了一个基本的外部指令 Shell，其能够通过不断创建 <code>sh.c</code> 的进程，并调用其他文件来处理用户指令。在 Lab6 的挑战任务中，我们要在这基础上对 Shell 进行迭代开发，使其能完成更丰富的服务要求。</p><h1 id="实现一行多命令"><a href="#实现一行多命令" class="headerlink" title="实现一行多命令"></a>实现一行多命令</h1><blockquote><p>用 <code>;</code> 分开同一行内的两条命令，表示<strong>依次</strong>执行前后两条命令。<code>;</code> 左右的命令都可以为空。</p></blockquote><p>在 Linux 的控制台中也支持这样的指令，例如在控制台输入如下指令会有对应的现象：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029503.png" alt="image-20230607102927426"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029406.png" alt="image-20230607102937379"></p><p>可以看到先实现了 <code>clear</code> 操作，后进行了 <code>echo</code> 操作。</p><p>我们要求，用 <code>;</code> 隔开的两条指令必须有执行的先后顺序，即<strong>先执行左侧指令，后执行右侧指令</strong>。利用 <code>gettoken</code> 中自支持的 <code>;</code> 在 <code>parsecmd</code> 中新添加判断分支即可实现对 <code>;</code> 的识别。</p><p>由于执行两条指令，并保证指令执行的先后顺序，则需要先 <code>fork</code> 进程并执行左侧指令，使用 <code>wait</code> 等待其执行完后再继续解析右侧指令（重复 <code>parsecmd</code> 即可）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">int</span> c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    debugf(<span class="string">&quot;parsed &#x27;;&#x27;, created %x\n&quot;</span>, *rightpipe);</span><br><span class="line">                    wait(*rightpipe);</span><br><span class="line"></span><br><span class="line">                    close(<span class="number">0</span>);close(<span class="number">1</span>);</span><br><span class="line">                    dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><ul><li>upd 23.6.16：这里需要处理重定向的问题，以防左侧指令修改了输出 fd ，但右侧指令的 fd 不仅没有恢复为控制台，修改的 fd 还被左侧指令关了的情况。所以需要调 <code>opencons</code> 把控制台重新开开，并且 <code>dup</code> 给两个 fd。</li></ul><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>为了体现 shell 的两条指令是分开执行的，这里采用不会实时结束的 <code>cat.b</code> 作为左端指令.</p><p>当运行 <code>cat.b</code> 并输入 <code>Ctrl + D</code> 时，应该继续右侧指令的解析与执行。现试输入 <code>cat.b ; ls.b</code> 和不包含单侧指令的数据测试功能：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat.b ; ls.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3004       // 识别到 <span class="string">&#x27;;&#x27;</span>，并创建新 Shell 3004</span><br><span class="line">llaabb66CChhaalllleennggee     // cat.b 执行内容，使用 Ctrl + D 结束</span><br><span class="line">[00003805] destroying 00003805 // cat.b 执行结束，终止其进程 3805</span><br><span class="line">[00003805] free <span class="built_in">env</span> 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004 // 子 Shell 执行完毕，终止其进程 3004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b // ls.b 执行内容</span><br><span class="line">[00004004] destroying 00004004 // ls.b 执行结束，终止其进程 4004</span><br><span class="line">[00004004] free <span class="built_in">env</span> 00004004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803 // 原 Shell 执行完毕，终止其进程 2803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ... </span><br><span class="line">$ cat.b;</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 5004</span><br><span class="line">ssssssssss</span><br><span class="line">[00005805] destroying 00005805</span><br><span class="line">[00005805] free <span class="built_in">env</span> 00005805</span><br><span class="line">i am killed ... </span><br><span class="line">[00005004] destroying 00005004</span><br><span class="line">[00005004] free <span class="built_in">env</span> 00005004</span><br><span class="line">i am killed ... </span><br><span class="line">[00004803] destroying 00004803 // 原有 Shell 无命令处理，直接终止进程 4803</span><br><span class="line">[00004803] free <span class="built_in">env</span> 00004803</span><br><span class="line">i am killed ... </span><br><span class="line"></span><br><span class="line">$ ;cat.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 6804</span><br><span class="line">[00006804] destroying 00006804 // 子 Shell 无命令处理，直接终止进程 6804</span><br><span class="line">[00006804] free <span class="built_in">env</span> 00006804</span><br><span class="line">i am killed ... </span><br><span class="line">aaaaaa</span><br><span class="line">[00007004] destroying 00007004</span><br><span class="line">[00007004] free <span class="built_in">env</span> 00007004</span><br><span class="line">i am killed ... </span><br><span class="line">[00006003] destroying 00006003</span><br><span class="line">[00006003] free <span class="built_in">env</span> 00006003</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><p>测试中 Shell 均能正常回显，可认为功能实现。</p><h1 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h1><blockquote><p>用 <code>&amp;</code> 分开同一行内的两条命令，表示<strong>同时</strong>执行前后两条命令。<code>&amp;</code> 左侧的命令应被置于后台执行，Shell 只等待 <code>&amp;</code> 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出。</p><p><strong>左侧命令不可为空</strong>。</p></blockquote><p>与 <code>;</code> 类似，<code>&amp;</code> 也要求实现两条指令的运行，但是要求其同时运行，只等待右侧指令。处理时同样要修改 <code>parsecmd</code> 的 <code>switch</code>，在这里要额外注意不要用 <code>rightpipe</code> 承载 <code>fork</code> 的返回值了。因为在 <code>runcmd</code> 中需要等待 <code>rightpipe</code> 执行结束才能完成，而 Shell 应该只等待右侧命令的执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            debugf(<span class="string">&quot;parsed &#x27;&amp;&#x27;, created %x\n&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line"><span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line"><span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;redirction_1: open file in shell failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd = r;</span><br><span class="line">dup(fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>不知道怎么测试合适，就先不测了（</p><h1 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h1><blockquote><p>实现引号支持后，shell 可以处理如： <code>echo.b &quot;ls.b | cat.b&quot;</code> 这样的命令。即 shell 在解析时，会将双引号内的内容看作单个字符串，将 <code>ls.b | cat.b</code> 作为一个参数传递给 <code>echo.b</code></p></blockquote><p>实质上我们要把引号中的这些内容当作一个 <code>w</code> 类型处理，所以与其修改 <code>parsecmd</code> 的逻辑，不如直接从 <code>_gettoken</code> 入手，直接把引号处理成一个内容再返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; _gettoken</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;parsed &#x27;\&quot;&#x27;: begin\n&quot;</span>);</span><br><span class="line">s++;</span><br><span class="line">*p1 = s;</span><br><span class="line">debugf(<span class="string">&quot;parsed: &quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (*s &amp;&amp; *(s++) != <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">debugf(<span class="string">&quot;%c&quot;</span>, *(s - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">*(s - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">*p2 = s;</span><br><span class="line">debugf(<span class="string">&quot;\nparsed &#x27;\&quot;&#x27;: end\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体实现相对简单，可以参照前后的解析方式，在面向对象第一单元的解析器也是一个道理（划</p><p>需要注意的就是 <code>p1</code> 和 <code>p2</code> 两个指针的定位， <code>p1</code> 应该指向 token 的起始字符，而 <code>p2</code> 应该指向 token 结束后的下一个字符；还有就是引号这个符号是要去掉的，也不要忘记用 0 将引号内的部分截断。</p><h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试主要看能否把引号内包含的 <code>SYMBOL</code> 正确解析为字符即可</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b <span class="string">&quot;sh.b | cat.b&quot;</span></span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: begin</span><br><span class="line">parsed: sh.b | cat.b</span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: end</span><br><span class="line">sh.b | cat.b</span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><h1 id="实现键入命令时任意位置的修改"><a href="#实现键入命令时任意位置的修改" class="headerlink" title="实现键入命令时任意位置的修改"></a>实现键入命令时任意位置的修改</h1><blockquote><p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p></blockquote><p>在 MOS 的 Shell 中，我们设计了 <code>readline</code> 函数处理指令的输入，它实际上利用了一个控制台，并从中逐个读取字符，从而解析读入的字符串。设计的核心，读入实际上一次只向目标缓冲区 <code>buf</code> 中读取一个字符：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(<span class="number">0</span>, buf + i, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>因为 <code>readline</code> 会直接向表示指令的 <code>buf</code> 中直接写入内容，当我们想要删除时可能会稍显麻烦，于是我们采用一个临时的 <code>char</code> 保存每次 <code>read</code> 获得的字符，并根据其值判断下一步该如何处理。由于在判断应该如何回显时需要注意光标的位置，所以我们用一个变量 <code>i</code> 代表光标所在下标，用变量 <code>len</code> 代表已经读入 <code>buf</code> 的总长度。在此基础上修改 <code>readline</code> 函数使其支持原生功能应该不是难事，不再赘述。</p><p>首先我们来处理<strong>键入光标时的左右移动</strong>。</p><p>在终端中，ANSI 标准声明左右方向键分别为 <code>\033[D</code> 和 <code>\033[C</code>，也就是说，在向控制台输入 “←” 时，实际上会<strong>解析成三个字符</strong>，即 <code>\033</code> 、<code>[</code>、 <code>D</code> 。那么我们就对暂时读入的字符（称为 <code>temp</code>）进行判断，如果是 <code>\033</code>，就进入方向键的判断，连续获取到左、右键代表的三个字符后，才能令光标变量做出对应的修改。</p><p>还有一点需要注意：光标在 0 字符时的 ← 与 光标在末端字符的 → 需要考虑其处理方式，首先不能修改光标变量的值了，否则会造成越界；其次可以让控制台显示的光标停在原地，这样就不会跑到左边的 <code>$</code> 字符那里了（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123;          <span class="comment">// get input ←</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;            <span class="comment">// have space for cursor to move left</span></span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[C&quot;</span>);   <span class="comment">// print a reverse arrow to pull back the cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;  <span class="comment">// get input →</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) &#123;         <span class="comment">// have space for cursor to move right</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[D&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>随后处理移动后的插入与删除。实际上我们实现的核心在这里就变成了字符串的操作，还有就是如何在终端上覆盖旧字符串，显示正确的新字符串。</p><p>注意到， <code>BackSpace</code> 键的 ASCII 码为 127 （<code>0x7f</code>），而在原程序的循环中已经为我们判断了 <code>buf[i] == 0x7f</code> 的分支判断，我们需要先删掉它然后新开一个 <code>case</code> （</p><p>类似的，<code>Delete</code> 键在读入时和 <code>~</code> 键的 ASCII 相同，所以也要做响应的处理，注意退格位置不同</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x7f</span>:</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;                   <span class="comment">// cursor at left bottom, ignore backspace</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = (--i); j &lt;= len - <span class="number">1</span>; j++) &#123; <span class="comment">// move chars already in buf</span></span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;                          <span class="comment">// cut the last char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, (i + <span class="number">1</span>), buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;~&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (i == len) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, i, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \033[%dD&quot;</span>, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>最后的 <code>printf</code> 用处是覆盖原有的字符串，再把新的字符串打印上去，打印后再控制光标的位置。这个操作可以分成三部分：</p><ul><li><code>\033[%dD</code>：终端的光标向左移动 <code>i + 1</code> 个字符</li><li><code>%s&lt;space&gt;</code>：把新字符串从光标所在处打印出来，<strong>追加一个空格</strong>（因为删除后字符串变短，需要覆盖掉多出来的一个字符）</li><li><code>\033[%dD</code>：终端的光标向左移动 <code>len - i + 1</code> 个字符</li></ul><p>至于为什么移动的字符是这些值，可以拿笔试一试，主要还是为了保证光标的位置不发生改变</p><h2 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试过程中发现如果网络不太稳定，就会输出 <code>[D</code> 之类的字符，不太理解原因，初步推断可能是因为传输字符速度慢，被解析成了分开的三个字符进行输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ha2Dhal3Dha[2Dh[1Djhalt</span><br><span class="line">spawn jhalt: -10</span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure><h1 id="实现程序名称中-b-的省略"><a href="#实现程序名称中-b-的省略" class="headerlink" title="实现程序名称中 .b 的省略"></a>实现程序名称中 <code>.b</code> 的省略</h1><blockquote><p>目前的用户程序被烧录到文件系统中后，其可执行文件以 <code>.b</code> 为后缀，为 shell 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 <code>.b</code> 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 <code>.b</code> 再打开。</p></blockquote><p>比较简单的一个小功能。</p><p>在 Shell 中具体运行外部命令的原理是创建一个子进程，加载命令对应的 ELF 文件，传递相应参数，然后 Shell 等待子进程上加载的程序运行结束后再循环执行。在创建子进程时，我们用到的是在 <code>runcmd</code> 中使用的 <code>spawn</code>，其参数为 <code>argv[0]</code>。我们只需要在打开 <code>argv[0]</code> 失败后再尝试打开追加 <code>.b</code> 后的 <code>argv[0]</code> 即可。如果仍然无法打开，说明指令名错误。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> child;</span><br><span class="line"><span class="keyword">if</span> ((child = spawn(argv[<span class="number">0</span>], argv)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">strcpy</span>(name, (<span class="type">const</span> <span class="type">char</span> *) argv[<span class="number">0</span>]);</span><br><span class="line">    name[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// add &#x27;.b&#x27; to old filename</span></span><br><span class="line">    child = spawn(name, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h2><p>尝试省略文件中的 <code>.b</code> 后进行调用，效果如下（已省略进程销毁输出）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">echo</span> aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b </span><br></pre></td></tr></table></figure><h1 id="实现更丰富的命令"><a href="#实现更丰富的命令" class="headerlink" title="实现更丰富的命令"></a>实现更丰富的命令</h1><blockquote><p>参考实验环境中的 Linux 命令 <code>tree</code>、<code>mkdir</code>、<code>touch</code> 来实现这三个命令，请尽可能地实现其完整的功能。</p></blockquote><h2 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a><code>tree</code> 命令</h2><p><code>tree</code> 命令，用于输出指定路径的文件树，使用字符码进行树状表示的生成。</p><p>本次实现的 <code>tree</code> 命令包括一个参数的实现：</p><blockquote><p><code>-d</code>：只输出目录文件，省略非目录的输出</p></blockquote><p>输出指定目录的文件树，可以分成以下几部分：</p><ul><li>打开指定目录的文件控制块</li><li>遍历目录中的每个文件，并进行输出</li><li>递归地对每个<strong>目录</strong>重复第二步，直至不存在子目录</li></ul><p>在这里需要注意输出的形式，由于需要保持缩进，于是我们在递归的过程中需要保留文件的深度；又由于目录中最后一个文件需要输出 <code>└──</code> 而不是 <code>├──</code> ，所以需要判断当前输出的文件是不是目录中的最后一个文件。同时需要注意输出缩进时的输出格式，如果不是本目录最后一个文件，中途的文件夹也应该输出 <code>│</code>，否则会出现以下的状况：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">├── testa</span><br><span class="line">    ├── testb</span><br><span class="line">        └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line">└── testb</span><br></pre></td></tr></table></figure><p>很显然 <code>testa</code> 文件夹中输出时没有输出最开头的 <code>│</code>，应该判断是不是最后一个文件，并且补上</p><p>一个更复杂的情况如下，不过这次的输出是正确的：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testa $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">│   └── a</span><br><span class="line">├── b</span><br><span class="line">│   ├── a</span><br><span class="line">│   ├── b</span><br><span class="line">│   │   └── c.c</span><br><span class="line">│   └── c.c</span><br><span class="line">└── c</span><br><span class="line">    ├── c.c</span><br><span class="line">    └── a</span><br><span class="line">        └── c.c</span><br></pre></td></tr></table></figure><ul><li>注意 a b 两文件夹下的内容输出时，必须在第一个字符输出 <code>│</code>，而 c 文件夹下内容则相反</li><li>内层文件夹也要递归地遵守这个规则</li></ul><p>输出使用到的函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printFile</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> depth, <span class="type">int</span> pos, <span class="type">int</span> isDir)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出预留的缩进</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; depth; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (poss[i] == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;│   &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos = 1 即最后一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;├── &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;└── &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDir == <span class="number">1</span>) &#123;      <span class="comment">// 目录文件会输出为蓝色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m\n&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归函数如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfsFile</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fdnum, size, va, j, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fdnum = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;open %s: %d&quot;</span>, path, fdnum); &#125;</span><br><span class="line">    fd = (<span class="keyword">struct</span> Fd *) num2fd(fdnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">struct</span> Filefd *) fd)-&gt;f_file.f_type != FTYPE_DIR) &#123;</span><br><span class="line">        fileCount++; <span class="comment">// 对文件计数，并返回（不存在子目录）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dircCount++; <span class="comment">// 对目录计数，准备输出其内的所有文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ((<span class="keyword">struct</span> Filefd *)fd)-&gt;f_file.f_size;</span><br><span class="line">    va = (<span class="type">int</span>) fd2data(fd);</span><br><span class="line">    <span class="comment">// 遍历目录中的每个文件（文件控制块）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2FILE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> File *) (va + i);</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得完整的路径名，为递归调用预留</span></span><br><span class="line">        <span class="type">char</span> fullPath[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(fullPath, path);</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(fullPath);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(file-&gt;f_name); j++) &#123;</span><br><span class="line">            fullPath[len + j] = file-&gt;f_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fullPath[len + j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否达到目录末尾，控制输出中的 &#x27;pos&#x27; 变量</span></span><br><span class="line">        <span class="type">int</span> pos = (i == size || (file + <span class="number">1</span>)-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="number">1</span> || file-&gt;f_type == FTYPE_DIR) &#123;</span><br><span class="line">            poss[depth] = pos; <span class="comment">// 把当前层是否为最后一个文件的状态保存，输出时使用</span></span><br><span class="line">            printFile(file-&gt;f_name, depth, pos, (file-&gt;f_type == FTYPE_DIR));</span><br><span class="line">        &#125;</span><br><span class="line">        dfsFile(fullPath, depth + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, fullPath);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要注意的是判断到达目录末尾的方式，一个是遍历到了目录的最后一个控制块，或者是下一个控制块<strong>名称为空</strong>（名称为空意味着文件不存在）</li></ul><p>顶层的调用函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tree</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入文件类型</span></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(path, &amp;st)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;stat %s: %d&quot;</span>, path, r); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123; user_panic(<span class="string">&quot;%s is not a directory!&quot;</span>, path); &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 开始递归</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    dfsFile(path, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后需要对输出进行计数</span></span><br><span class="line">    <span class="keyword">if</span> (directory == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories\n&quot;</span>, dircCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories, %d files\n&quot;</span>, dircCount, fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后文件的 <code>main</code> 函数可以封装如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ARGBEGIN &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            directory = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; ARGEND</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(argc == <span class="number">0</span>)</span> &#123; <span class="comment">// 默认为根目录</span></span><br><span class="line">        tree(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         <span class="comment">// 选定指定目录</span></span><br><span class="line">        tree(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 <code>tree.c</code> 后，需要回到 <code>user</code> 目录中修改 <code>include.mk</code>，在 <code>USERAPP</code> 中把 <code>tree.b</code> 加进去，这样刚写完的文件就会编译并烧录进磁盘了，这样就可以使用了</p><h2 id="mkdir-amp-touch-命令"><a href="#mkdir-amp-touch-命令" class="headerlink" title="mkdir &amp; touch 命令"></a><code>mkdir</code> &amp; <code>touch</code> 命令</h2><p>其实两个命令实现的功能类似，唯一差异在创建文件后的文件类型 <code>f_type</code>：<code>mkdir</code> 需要 <code>FTYPE_DIR</code> ， <code>touch</code> 则是 <code>FTYPE_REG</code></p><p>内核中其实已经在 <code>fs/fs.c</code> 中预留好了创建文件的函数，但是没有向用户态提供接口。我们可以通过新增 <code>fsipc</code> 类型从而让文件服务函数调用这个接口，从而实现文件的创建</p><p>Lab5 Probe 中已经详细介绍过创建 <code>fsipc_*</code> 的过程了，这里就只写代码了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/fsreq.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CREATE 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int f_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/fsipc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int f_type, <span class="keyword">struct</span> Fd* fd)</span> &#123;</span><br><span class="line">    u_int perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    req = (<span class="keyword">struct</span> Fsreq_create *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The path is too long.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">    req-&gt;f_type = f_type;</span><br><span class="line">    <span class="keyword">return</span> fsipc(FSREQ_CREATE, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (req) &#123;</span><br><span class="line">    <span class="keyword">case</span> FSREQ_CREATE:</span><br><span class="line">        serve_create(whom, (<span class="keyword">struct</span> Fsreq_create *)REQVA);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// touch 和 mkdir 的区别仅限于此，所以只需要控制这个值的传递就能实现两个函数</span></span><br><span class="line">    f-&gt;f_type = rq-&gt;f_type;</span><br><span class="line">    ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pfile)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, u_int, <span class="keyword">struct</span> Fd *)</span>;</span><br></pre></td></tr></table></figure><p>以上便创建了创建文件的 <code>fsipc</code> 请求。接下来两个函数实际上是对这个请求的调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unimplemented open modes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT 0x0100 <span class="comment">/* create if nonexistent */</span></span></span><br></pre></td></tr></table></figure><p>我们利用上面这个定义，对 <code>open</code> 函数做一些改动，使得当传入函数的 <code>omode</code> 包含 <code>O_CREAT</code> 时，就会触发文件创建的过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Prepare the &#x27;fd&#x27; using &#x27;fsipc_open&#x27; in fsipc.c.</span></span><br><span class="line">    <span class="comment">/* Exercise 5.9: Your code here. (2/5) */</span></span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; O_CREAT) == <span class="number">0</span>) &#123;   <span class="comment">// 如果不包含 O_CREAT 走正常的路线，不进行变动</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                       <span class="comment">// mkdir &amp; touch</span></span><br><span class="line">        mode &amp;= ~O_CREAT;</span><br><span class="line">        <span class="comment">// 如果打开文件失败就进行文件创建，反之则报错（已存在文件，不能再创建）</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fsipc_create(path, mode, fd); <span class="comment">// mode = f_type</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// already exist.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>当进入 <code>else</code> 分支时，此时的 <code>mode</code> 就不再是代表文件打开的方式了，它代表的是创建文件的类型，我们在这里不修改 <code>open</code> 的参数数量，而通过 <code>mode</code> 这个参数进行额外信息的传递</li></ul><p>最后顶层封装两个功能函数，加入相关的函数声明，并在对应的文件的 <code>main</code> 方法中调用即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c (实现在哪里其实不影响)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = open(path, O_CREAT | FTYPE_DIR)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir: path %s already exist!\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir %s: %d\n&quot;</span>, path, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-Shell-中重定向符的实现"><a href="#修改-Shell-中重定向符的实现" class="headerlink" title="修改 Shell 中重定向符的实现"></a>修改 Shell 中重定向符的实现</h2><p>在 Linux 的 Shell 中，我们可以通过重定向符 <code>&gt;</code> 将输出重定向到文件中，我们的 MOS 也可以实现类似的操作，但是不能创建新文件并进行输入，我们在这里对 <code>sh.c</code> 文件进行修改，使其能实现此功能</p><p>实现要点就是在原有要打开文件的地方进行判断，如果打开失败了就追加一句创建文件的函数</p><p>注意要<strong>再调用一次 <code>open</code></strong> 以传递新创建文件的文件管理符</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Open &#x27;t&#x27; for writing, dup it onto fd 1, and then close the original fd.</span></span><br><span class="line">    <span class="comment">/* Exercise 6.5: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = touch(t)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;redirction_2: create file in shell failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;redirction_2: open file in shell failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = r;</span><br><span class="line">    dup(fd, <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user_panic(&quot;&gt; redirection not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h2 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h2><p>三个函数的功能可以相互验证：先通过 <code>touch</code>、<code>mkdir</code> 创建新的文件/目录，再调用 <code>tree</code> 对这些文件的存在和位置进行检查，如果 <code>tree</code> 能检查并正确输出，说明文件创建和文件树的功能都是正常的。下面的输出隐藏了进程销毁信息</p><ul><li>本处的功能测试已经完成了相对目录的实现，故输入使用了相对目录</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> b.c</span><br><span class="line">created file: b.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a.c</span><br><span class="line">created file: a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa</span><br><span class="line">created path: /testdir/testa</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa/testb</span><br><span class="line">created path: /testdir/testa/testb</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/testb/a.c</span><br><span class="line">created file: testa/testb/a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/test.c</span><br><span class="line">created file: testa/test.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">└── testa</span><br><span class="line">    ├── testb</span><br><span class="line">    │   └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line"></span><br><span class="line">3 directories, 5 files</span><br></pre></td></tr></table></figure><h1 id="实现历史命令功能"><a href="#实现历史命令功能" class="headerlink" title="实现历史命令功能"></a>实现历史命令功能</h1><blockquote><p>在 Linux 的 shell 中我们输入的命令都会被保存起来，并可以通过 Up 和 Down 键回溯，这为我们的 shell 操作带来了极大的方便。在此项任务中，需要实现保存所有输入至 shell 的命令，并可以通过 <code>history.b</code> 命令输出所有的历史命令，以及通过上下键回溯命令并运行。</p></blockquote><p>实现这个功能的要点如下：</p><ul><li>首先需要在 <code>sh.c</code> 中调用 <code>touch</code> 函数生成 <code>.history</code> 文件</li><li>将每条解析的命令都输入进 <code>.history</code> 文件中，这里需要额外实现<strong>文件的追加写入</strong></li><li>在输入中实现对 Up/Down 键的识别，并回显对应的指令</li><li>实现 <code>history.c</code> 的 <code>history</code> 功能，读取 <code>.history</code> 文件，显示全部历史命令</li></ul><h2 id="history-文件的生成"><a href="#history-文件的生成" class="headerlink" title=".history 文件的生成"></a><code>.history</code> 文件的生成</h2><p>当我们在解析指令结束后，应该对指令进行保存，如果是第一次解析，则需要额外创建一个存放历史指令的 <code>.history</code> 文件。在这里我们使用一个变量 <code>int hisCount = 0</code> 表示已经处理过的历史指令数，当历史为空则进行文件的创建。</p><p>与光标的左右移动类似，我们需要一个表示当前指令所处行数的变量 <code>int curLine = 0</code>，用以指明当前输入显示的行数</p><h2 id="文件的追加输入模式-O-APPEND"><a href="#文件的追加输入模式-O-APPEND" class="headerlink" title="文件的追加输入模式 - O_APPEND"></a>文件的追加输入模式 - <code>O_APPEND</code></h2><p>在 MOS 系统中，我们只实现了从头打开文件，即 <code>f_offset = 0</code> 的打开方式，在这里为了便于我们对 <code>.history</code> 文件的输入，试实现文件的追加输入模式：<code>O_APPEND</code> 。</p><p>由于 <code>O_APPEND</code> 只是指定了文件打开时的偏移指针位置，原则上我们仍需要控制文件的打开方式。为了不遮盖原本的打开方式，可以把 <code>O_APPEND</code> 的控制位放大一点，以实现应有的功能。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_APPEND 0X00002000 <span class="comment">/* open file and redirect cursor to the last char */</span></span></span><br></pre></td></tr></table></figure><p>设置好后，接下来需要修改 <code>open</code> 函数以识别 <code>O_APPEND</code>，并尝试在文件服务进程中的 <code>serve_open</code> 函数中实现对偏移指针的定位，这样我们就不需要再更改 <code>open</code> 函数的逻辑了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c -&gt; serve_open</span></span><br><span class="line"></span><br><span class="line">o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// add here for O_APPEND</span></span><br><span class="line"><span class="keyword">if</span> (o-&gt;o_mode &amp; O_APPEND) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fff</span> =</span> (<span class="keyword">struct</span> Fd *) ff;</span><br><span class="line">fff-&gt;fd_offset = f-&gt;f_size; <span class="comment">// redirect the file pointer</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>回到 <code>sh.c</code>，完成写入历史命令和回显的功能。为了便于快速找到对应的指令数，我们事先实现一个数组 <code>int hisBuf</code>，其内存放第 $i$ 条指令所占的字节数，便于我们在 <code>.history</code> 中快速找到指定的行</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisCount, curLine;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisBuf[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure><p>然后在 <code>sh.c</code> 内实现一个快速读取第 <code>target</code> 行指令的函数，将其存入 <code>code</code> 指向的空间</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readPast</span><span class="params">(<span class="type">int</span> target, <span class="type">char</span> *code)</span> &#123;</span><br><span class="line"><span class="type">int</span> r, fd, spot = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> buff[<span class="number">10240</span>];</span><br><span class="line"><span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G1&quot;</span>);<span class="keyword">return</span> fd; &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target; i++) &#123;</span><br><span class="line">spot += (hisBuf[i] + <span class="number">1</span>); <span class="comment">// + &#x27;\n&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((r = readn(fd, buff, spot)) != spot) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G2&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">if</span> ((r = readn(fd, code, hisBuf[target])) != hisBuf[target]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G3&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="keyword">if</span> ((r = close(fd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G4&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">code[hisBuf[target]] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先读取 0 ~ target - 1条指令，并丢弃，然后读取第 target 条指令，保存在传入的参数 <code>code</code> 内。读取前面指令时需要根据预设的 <code>hisBuf</code> 控制读取的字符数，需要注意每一条语句后面都存放一个 <code>\n</code> 用以区分，所以需要多读一个字符。</li></ul><h2 id="历史指令的写入"><a href="#历史指令的写入" class="headerlink" title="历史指令的写入"></a>历史指令的写入</h2><p>相对简单的一部分。</p><p>当 Shell 检测到 换行符时，便会判断指令输入的结束，从而开始解析，我们就从这里开始写入历史命令。</p><p>在 <code>readline</code> 函数的 <code>switch</code> 分支内，针对 <code>case &#39;\r&#39;</code> 与 <code>case &#39;\n&#39;</code> 需要做写入文件的操作：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;hisCount: %d\n&quot;, hisCount);</span></span><br><span class="line">        <span class="keyword">if</span> (hisCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = touch(<span class="string">&quot;/.history&quot;</span>)) != <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hisFd;</span><br><span class="line">        <span class="keyword">if</span> ((hisFd = open(<span class="string">&quot;/.history&quot;</span>, O_APPEND | O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, buf, len)) != len) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)) != <span class="number">1</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = close(hisFd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        hisBuf[hisCount++] = len;</span><br><span class="line">        curLine = hisCount; </span><br><span class="line"><span class="comment">// cannot &#x27;curLine++&#x27;, otherwise usable instrctions will be [0, curLine + 1]</span></span><br><span class="line">        <span class="built_in">memset</span>(curIn, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(curIn));</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ul><li>这里要在每一条指令写入后追加一个和常规指令有区分的字符，为了方便这里就选了 <code>\n</code>，原因可以在 <code>history</code> 功能实现时再看。再注意写入时使用刚刚写好的（追加 + 只写）即可。</li><li>当按下回车时，不能简单地让 <code>curLine++</code> ，因为可能当前 <code>curLine</code> 并不在最底端，此时错误的自增操作会让 <code>curLine</code> 的值出错 </li></ul><h2 id="up-down-键的识别-amp-指令回显"><a href="#up-down-键的识别-amp-指令回显" class="headerlink" title="up/down 键的识别 &amp; 指令回显"></a>up/down 键的识别 &amp; 指令回显</h2><p>最后修改 <code>readline</code> 的逻辑，需要在键入方向键的分支处继续判断。同时为了能够恢复当前已经输入的字符，我们把已输入的字符也存入一个缓冲的字符数组 <code>char curIn</code> 内，在按下 down 键时视情况回显。</p><p>每次回显，都需要实时变动 <code>buf</code> 的内容，也包括显示的光标位置。因为我们可能会在此基础上修改 <code>buf</code>，或直接运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; readline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123; <span class="comment">// have space for left</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">// up</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[B&quot;</span>);     <span class="comment">// 恢复光标位置</span></span><br><span class="line">            <span class="keyword">if</span> (curLine != <span class="number">0</span>) &#123;   <span class="comment">// 处在第一行时应忽略 up 的输入</span></span><br><span class="line">                buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curLine == hisCount) &#123; <span class="comment">// 显示的是正在输入的字符</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(curIn, buf);    <span class="comment">// 暂时保存在 curIn 中，暂时视作一条指令</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用 &lt;space&gt; + 光标移动，清空当前行</span></span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 读入指定的历史指令并输出，重定位光标</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(--curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                len = i; <span class="comment">// redirect cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 同理</span></span><br><span class="line">            buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> + curLine &lt; hisCount) &#123;     <span class="comment">// 注意这里的判断</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(++curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(buf, curIn);</span><br><span class="line">                curLine = hisCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            len = i;</span><br><span class="line">            <span class="comment">// redirect cursor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><ul><li>这部分比较重要的就是边界情况的处理和写入后光标的定位。<ul><li>输入 up 键，需要把光标向下移动一行（固定，不要乱跑），使 <code>curLine--</code>，如果 <code>curLine == 0</code> （第一条指令）就不再响应</li><li>输入 down 键，光标不需移动，<code>curLine++</code>，如果 <code>curLine + 1 = hisCount</code> （即马上要从 <code>.history</code> 的最后一行换成最开始预存的缓冲输入时）需要特别处理；若 <code>curLine == hisCount</code> 则不再响应</li><li>无论输入 up/down 键，只要重新回显了字符，就需要借助 <code>printf(&quot;\033[A&quot;);</code> 等方法实现的光标移动和打印空格把当前行原本的内容清空后再输出</li></ul></li></ul><h2 id="history-b-功能的实现"><a href="#history-b-功能的实现" class="headerlink" title="history.b 功能的实现"></a><code>history.b</code> 功能的实现</h2><p>还是一样的，别忘了把 <code>history.b</code> 加入 <code>include.mk</code>，让程序进行编译并烧录磁盘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/history.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;history instruction:\n\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd, r, line = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">1</span>], print;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;history: %d&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no history instruction.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    print = temp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, line);</span><br><span class="line">    <span class="keyword">while</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, print);</span><br><span class="line">        <span class="keyword">if</span> (print == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, ++line);</span><br><span class="line">        &#125;</span><br><span class="line">        print = temp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\ntotal instruction: %d\nhistory finished.\n\n&quot;</span>, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是对文件的打开、读取、判断和输出。而判断是否为一条指令的标准就是 <code>\n</code>，这也就是在前面写入指令时要加入一个分隔符的理由。我们根据 <code>\n</code> 编排输出的方式，从而实现历史命令的输出。</p><h2 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="上下键指令回显"><a href="#上下键指令回显" class="headerlink" title="上下键指令回显"></a>上下键指令回显</h3><p>先在 Shell 中输入几条指令，随后输入半条还没有执行的指令，然后连续按上下键观察变化</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ input halfway</span><br><span class="line">[2000] /testdir $ tree             // press ↑</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a          // press ↑</span><br><span class="line">[2000] /testdir $ tree             // press ↓</span><br><span class="line">[2000] /testdir $ input halfway    // press ↓</span><br></pre></td></tr></table></figure><ul><li>并且可以随时修改回显的任意一条指令，并随时按下回车输出</li></ul><h3 id="history-指令功能"><a href="#history-指令功能" class="headerlink" title="history 指令功能"></a><code>history</code> 指令功能</h3><p>在上一测试的基础上直接输入 <code>history</code> 观察输出。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ <span class="built_in">history</span></span><br><span class="line"><span class="built_in">history</span> instruction:</span><br><span class="line"></span><br><span class="line">    1 : <span class="built_in">mkdir</span> testdir</span><br><span class="line">    2 : <span class="built_in">cd</span> testdir</span><br><span class="line">    3 : <span class="built_in">touch</span> a</span><br><span class="line">    4 : tree</span><br><span class="line">    5 : input half|<span class="built_in">cut</span>|way</span><br><span class="line">    6 : <span class="built_in">history</span></span><br><span class="line"></span><br><span class="line">total instruction: 6</span><br><span class="line"><span class="built_in">history</span> finished.</span><br><span class="line"></span><br><span class="line">[00007804] destroying 00007804</span><br></pre></td></tr></table></figure><p>检测到 <code>.history</code> 文件的内容可以正常写入、读出，并且 <code>history</code> 指令功能也正常实现</p><h1 id="选做部分-2：支持相对路径"><a href="#选做部分-2：支持相对路径" class="headerlink" title="选做部分 2：支持相对路径"></a>选做部分 2：支持相对路径</h1><blockquote><p>MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。</p><p>现在，我们需要在 MOS 中<strong>支持相对路径的输入与解析</strong>，并且当前工作路径的保存是进程级别的，也就是说不同进程的工作目录可能不同。</p></blockquote><p>首先我们要求：只有以 <code>/</code> 开头的目录才会被识别为绝对路径，此外的所有非 <code>/</code> 开头路径（包括 <code>./</code> ）都会被识别为相对路径并进行识别与处理。</p><p>需要完成的工作有以下几点：</p><ul><li>在内核态中为进程维护一个表示当前工作目录的字符数组 <code>char r_path</code></li><li>通过系统调用向用户态提供更改 <code>r_path</code> 的接口，实现用户调用函数 <code>chdir()</code> 和 <code>getcwd()</code></li><li>更改 <code>sys_exofork</code> 逻辑，使其能令子进程<strong>继承</strong>父进程的工作目录</li><li>修改 <code>sh.c</code> 实现<strong>内部命令</strong> <code>cd</code> 和<strong>外部命令</strong> <code>pwd</code></li><li>修改文件操作函数（Shell 已有命令能调用的只有 <code>open</code> 函数），识别并提供相对路径的功能支持</li><li>更改已实现的 Shell 命令对文件的操作</li><li>优化 Shell 输出界面</li></ul><h2 id="维护工作目录数组"><a href="#维护工作目录数组" class="headerlink" title="维护工作目录数组"></a>维护工作目录数组</h2><p>为了便于管理与复制，同时能够体现不同进程目录不同的特点，这里直接将字符数组放置在进程控制块中，当然在内核态中开一个大二维数组也是可行的，比修改进程控制块更安全。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/env.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> r_path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建进程时，也需要在创建进程的函数中初始化进程的目录为 <code>/ </code> 根目录</p><h2 id="系统调用设置接口-amp-实现用户调用函数"><a href="#系统调用设置接口-amp-实现用户调用函数" class="headerlink" title="系统调用设置接口 &amp; 实现用户调用函数"></a>系统调用设置接口 &amp; 实现用户调用函数</h2><p>为了便于用户态<strong>获取/修改</strong>当前进程所处的工作目录，我们添加两个系统调用为用户态提供接口。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SYS_get_rpath,</span><br><span class="line">    SYS_set_rpath,</span><br><span class="line">    MAX_SYSNO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(newPath) &gt; <span class="number">1024</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(curenv-&gt;r_path, newPath);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(dst, curenv-&gt;r_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *syscall_table[MAX_SYSNO] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_get_rpath] = sys_get_rpath,</span><br><span class="line">    [SYS_set_rpath] = sys_set_rpath,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_set_rpath, newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_get_rpath, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_set_rpath(newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_get_rpath(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在相应的头文件中添加声明</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure><p>实现用户态函数后，可以直接新建 <code>pwd.c</code> 文件，直接调用 <code>getcwd</code> 函数输出当前路径</p><h2 id="工作目录传递"><a href="#工作目录传递" class="headerlink" title="工作目录传递"></a>工作目录传递</h2><p>现在在单个进程中，我们已经完成了工作目录的修改，现在需要在<strong>所有会出现创建进程的位置</strong>添加对父进程工作目录的复制工作。算过来也就只有 <code>env_alloc</code>、<code>fork</code>、<code>spawn</code> 三个函数会创建进程，而它们最终也都会调用 <code>sys_exofork</code> 作为进程创建的核心函数。所以直接修改 <code>sys_exofork</code> 来实现父子进程中的工作目录复制。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">strcpy</span>(e-&gt;r_path, curenv-&gt;r_path); <span class="comment">// copy at here</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现内部命令-cd"><a href="#实现内部命令-cd" class="headerlink" title="实现内部命令 cd"></a>实现内部命令 <code>cd</code></h2><p>这里实现的 <code>cd</code> 指令需要作为<strong>内部指令</strong>，也就是执行后并不<strong>切换进程</strong>，而是继续处理。处理方法是在读入结束后、解析开始前的这一段空隙对输入指令做一次预处理，如果满足 <code>cd</code> 指令格式，就进行工作目录切换，切换后重新读入；反之则开始解析，准备调用外部命令。</p><p>要注意的是，Linux 中只输入 <code>cd</code> 相当于<strong>跳转至家目录</strong>，MOS 就直接跳根目录得了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parseCD(buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面一段在 main 函数中先预先判断是否存在 <code>cd</code>，如果存在，则不应创建进程，而直接解析，反之就应该创建子进程并运行指令。</p><p><code>parseCD</code> 函数实现时需要注意：<code>cd</code> 并不一定出现在指令开头，也可能出现在 <code>ins1; cd</code> 的格式中，所以需要对 <code>;</code> 和 <code>&amp;</code> 进行特判。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; runcmd</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;cd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">char</span> cur[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        cur[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; p += <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">        syscall_get_rpath(cur);</span><br><span class="line">        <span class="type">int</span> len1 = <span class="built_in">strlen</span>(cur);</span><br><span class="line">        <span class="type">int</span> len2 = <span class="built_in">strlen</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123; <span class="comment">// cur: &#x27;/&#x27;</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cur + <span class="number">1</span>, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         <span class="comment">// cur: &#x27;/a&#x27;</span></span><br><span class="line">            cur[len1] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(cur + len1 + <span class="number">1</span>, p);</span><br><span class="line">            cur[len1 + <span class="number">1</span> + len2] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cur:%s\n&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(cur, &amp;st)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not a directory\n&quot;</span>, cur);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);<span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = chdir(cur)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段函数的功能是获取 <code>cd</code> 后的绝对路径，并进行工作目录的切换；关键是输入的相对路径与工作路径之间的拼接。<code>cd</code> 大概可以分成以下几类， <code>if-else</code> 中的逻辑也是这么写的：</p><ul><li>输入路径为绝对路径（<code>/xxxx</code>、没有输入路径（默认为根目录 <code>/</code>））：不需要进行拼接，直接进行目录判断和跳转即可</li><li>输入路径为相对路径，形式上分两种（<code>./yyy</code> 、<code>zzz</code>）：根据形式不同，需要进行处理<ul><li>如果有 <code>./</code> 出现，需要先去掉，统一形式为 <code>zzz</code></li><li>获取工作目录，再进行字符串拼接，获取绝对目录</li></ul></li></ul><p>切换工作目录前要查看要跳转的路径是不是一个目录，若不是目录应不允许切换</p><h2 id="open-函数支持相对路径"><a href="#open-函数支持相对路径" class="headerlink" title="open 函数支持相对路径"></a><code>open</code> 函数支持相对路径</h2><p>我们已经实现的用户程序中，只有 <code>open</code> 会用到程序的路径名，并且 <code>ls</code>、<code>tree</code>、<code>mkdir</code>，甚至 <code>spawn</code> 都需要 <code>open</code> 函数支持，所以与其更改每个用户函数的接口，不如直接修改 <code>open</code> 函数逻辑，让文件系统支持输入相对路径。最后再在用户程序中做一些微调就能够正常使用了。</p><p>类似地， <code>open</code> 函数的输入路径也可能分为绝对路径和相对路径两种，这取决于用户的字符串输入。所以处理方式可以和上面 <code>cd</code> 的方式保持一致，直接 CV 都能用</p><h2 id="用户程序功能调整"><a href="#用户程序功能调整" class="headerlink" title="用户程序功能调整"></a>用户程序功能调整</h2><p>在已经实现好的用户程序中，大多数指令的默认情况都会以根目录为输入目录，如直接键入 <code>tree</code> 就会生成根目录文件树，现在我们就要把默认情况改为 <code>./</code> ，即输出当前工作目录的文件树</p><p>需要更改的文件有 <code>ls</code> 和 <code>tree</code></p><p>还有一个相对特殊的 <code>spawn</code>，它的默认打开路径就是只能从根目录开始，如果带上相对路径，那么在 <code>cd</code> 至其他路径后再输入外部命令，<code>spawn</code> 会先调用 <code>open</code>打开<strong>相对路径下的</strong>用户程序， Shell 就会因为 <code>spawn</code> 了错误的文件而无法运行。例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">// 此刻 Shell 中在尝试调用工作目录下的 ls.b ，也即 /test/ls.b，显然这个文件是不存在的</span><br></pre></td></tr></table></figure><p>所以为了避免 <code>open</code> 将指令解析成相对路径文件，直接在最前面加一个 <code>/</code> 声明为绝对路径就可以了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/spawn.c -&gt; spawn</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (prog[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(path + <span class="number">1</span>, prog);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, prog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Shell-界面优化"><a href="#Shell-界面优化" class="headerlink" title="Shell 界面优化"></a>Shell 界面优化</h2><p>既然已经支持了工作路径的使用，所以不如在 Shell 的工作状态下输出当前的工作目录，更符合 Linux 的界面风格</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = getcwd(curPath)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[%04x] %s $ &quot;</span>, syscall_getenvid(), curPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="纯指令功能"><a href="#纯指令功能" class="headerlink" title="纯指令功能"></a>纯指令功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure><h3 id="一条多语句测试"><a href="#一条多语句测试" class="headerlink" title="一条多语句测试"></a>一条多语句测试</h3><p>省略销毁进程输出</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /a $ <span class="built_in">mkdir</span> b ; <span class="built_in">cd</span> b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3803</span><br><span class="line">created path: /a/b</span><br><span class="line">cur:/a/b</span><br><span class="line"></span><br><span class="line">[2000] /a/b $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure><h3 id="spawn-amp-open-功能测试"><a href="#spawn-amp-open-功能测试" class="headerlink" title="spawn &amp; open 功能测试"></a>spawn &amp; open 功能测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">mkdir</span> testdir</span><br><span class="line">created path: /testdir</span><br><span class="line"></span><br><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a</span><br><span class="line">created file: a</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br></pre></td></tr></table></figure><ul><li>此处的 <code>touch</code> 在相对目录中使用 <code>spawn</code> 创建，可以正常打开根目录的用户程序</li><li><code>tree</code> 指令内部在 <code>open</code> 中使用了相对路径 <code>./</code> ，也可以正常解析</li></ul><p>lab6 挑战性任务需求的功能到这里就全部实现力，是时候休息一把了（×</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab6-Report</title>
      <link href="/p/13765.html"/>
      <url>/p/13765.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab6-Report"><a href="#BUAA-OS-2023-Lab6-Report" class="headerlink" title="BUAA-OS-2023-Lab6-Report"></a>BUAA-OS-2023-Lab6-Report</h1><h1 id="Thinking-6-1"><a href="#Thinking-6-1" class="headerlink" title="Thinking 6.1"></a>Thinking 6.1</h1><ul><li>示例代码中，父进程操作管道的写端，子进程操作管道的读端。如果现在想让父进程作为“读者”，代码应当如何修改？</li></ul><p>原有代码的分支语句如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程- 作为管道的读者*/</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端*/</span></span><br><span class="line">read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据*/</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 读取结束，关闭读端*/</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程- 作为管道的写者*/</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端*/</span></span><br><span class="line">write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据*/</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端*/</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，作为读者，子进程关掉了管道写端；相应的，父进程关掉了管道读端。那么我们只要将关闭的端交换，并修改写入/读取语句即可实现要求，即：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* 子进程- 作为管道的写者 */</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 关闭不用的读端 */</span></span><br><span class="line">write(fildes[<span class="number">1</span>], <span class="string">&quot;Hello world\n&quot;</span>, <span class="number">12</span>); <span class="comment">/* 向管道中写数据 */</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 写入结束，关闭写端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 父进程- 作为管道的读者 */</span></span><br><span class="line">close(fildes[<span class="number">1</span>]); <span class="comment">/* 关闭不用的写端 */</span></span><br><span class="line">        read(fildes[<span class="number">0</span>], buf, <span class="number">100</span>); <span class="comment">/* 从管道中读数据 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child-process read:%s&quot;</span>,buf); <span class="comment">/* 打印读到的数据 */</span></span><br><span class="line">close(fildes[<span class="number">0</span>]); <span class="comment">/* 读入结束，关闭读端 */</span></span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-6-2"><a href="#Thinking-6-2" class="headerlink" title="Thinking 6.2"></a>Thinking 6.2</h1><ul><li>上面这种不同步修改 <code>pp_ref</code> 而导致的进程竞争问题在 <code>user/lib/fd.c</code> 中的 <code>dup</code> 函数中也存在。请结合代码模仿上述情景，分析一下我们的 <code>dup</code> 函数中为什么会出现预想之外的情况？</li></ul><p>当我们调用 <code>dup</code> 函数时，会在进程中创建一个新的文件描述符 <code>newfd</code> ，这个文件描述符指向 <code>oldfd</code> 所拥有的文件表项，也就是在用户态中复制了一个文件的描述符。</p><p>实际上在执行复制的过程中，我们并不能一步把所有的数据都复制完，实际上是先对 <code>fd</code> 使用 <code>syscall_mem_map</code> 进行复制，再对它所属的 <code>data</code> 复制。</p><p>现在假设一个情景：子进程 <code>dup(pipe[1])</code> 后 <code>read(pipe[0])</code>，父进程 <code>dup(pipe[0])</code> 后 <code>write(pipe[1])</code> 。</p><p>先令子进程执行：顺序执行至 dup 完成后发生时钟中断，此时 <code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 1</code></p><p>随后父进程开始执行：执行至 dup 函数中 fd 和 data 的 map <strong>之间</strong>，此时 <code>pageref(pipe[0]) = 1</code>，<code>pageref(pipe) == 1</code></p><p>子进程再次开始执行：进入 read 函数，判断发现 <code>pageref(pipe[0]) == pageref(pipe)</code></p><p>这个非同步更改的 <code>pageref</code> 和管道关闭时的等式一致，这里会让 <code>read</code> 函数认为管道中已经没有了写者，于是关闭了管道的读端。</p><h1 id="Thinking-6-3"><a href="#Thinking-6-3" class="headerlink" title="Thinking 6.3"></a>Thinking 6.3</h1><ul><li>阅读上述材料并思考：为什么系统调用一定是原子操作呢？如果你觉得不是所有的系统调用都是原子操作，请给出反例。希望能结合相关代码进行分析说明</li></ul><p>我认为系统调用是原子操作。因为系统调用开始前，通过修改 SR 寄存器的值，关闭了外部中断，而在执行内核代码时，合理的内核设计应保证不出现其它类型的异常。所以这使得系统调用成为了原子操作。</p><h1 id="Thinking-6-4"><a href="#Thinking-6-4" class="headerlink" title="Thinking 6.4"></a>Thinking 6.4</h1><ul><li>仔细阅读上面这段话，并思考下列问题<ul><li>按照上述说法控制 pipe_close 中fd 和 pipe unmap 的顺序，是否可以解决上述场景的进程竞争问题？给出你的分析过程。</li><li>我们只分析了 close 时的情形，在 fd.c 中有一个 dup 函数，用于复制文件内容。试想，如果要复制的是一个管道，那么是否会出现与 close 类似的问题？请模仿上述材料写写你的理解。</li></ul></li></ul><ul><li>可以解决上述问题。<ul><li>最初 <code>pageref(pipe[0]) = 2</code>，<code>pageref(pipe[1]) = 2</code>，<code>pageref(pipe) = 4</code></li><li>子进程先运行，执行 <code>close</code> 解除了 <code>pipe[1]</code> 的文件描述符映射</li><li>发生时钟中断，此时 <code>pageref(pipe[0]) = 2</code>，<code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 4</code></li><li>父进程执行完<code> close(pipe[0])</code> 后，<code>pageref(pipe[0]) = 1</code>，<code>pageref(pipe[1]) = 1</code>，<code>pageref(pipe) = 3</code></li><li>可以发现此过程中不满足写端关闭的条件</li></ul></li><li>在 <code>Thinking 6.2</code> 中用到的样例就体现了问题发生的原理。如果先映射作为 <code>fd</code> 的 <code>pipe[0]</code>，就会暂时产生 <code>pageref(pipe) == pageref(pipe[0])</code> 的情况，会出现类似问题。</li></ul><h1 id="Thinking-6-5"><a href="#Thinking-6-5" class="headerlink" title="Thinking 6.5"></a>Thinking 6.5</h1><ul><li>思考以下三个问题。<ul><li> 认真回看Lab5 文件系统相关代码，弄清打开文件的过程。</li><li>回顾Lab1 与Lab3，思考如何读取并加载ELF 文件。<ul><li> 在Lab1 中我们介绍了data text bss 段及它们的含义，data 段存放初始化过的全局变量，bss 段存放未初始化的全局变量。关于memsize 和filesize ，我们在Note1.3.4中也解释了它们的含义与特点。关于Note 1.3.4，注意其中关于“bss 段并不在文件中占数据”表述的含义。</li><li>回顾Lab3 并思考：elf_load_seg() 和load_icode_mapper()函数是如何确保加载ELF 文件时，bss 段数据被正确加载进虚拟内存空间。bss 段在ELF 中并不占空间，但ELF 加载进内存后，bss 段的数据占据了空间，并且初始值都是0。请回顾elf_load_seg() 和load_icode_mapper() 的实现，思考这一点是如何实现的？</li></ul></li></ul></li></ul><ul><li>打开文件的过程：<ul><li>根据文件名，调用用户态的 <code>open</code> 函数，其申请了一个文件描述符，并且调用了服务函数 <code>fsipc_open</code> ，利用 <code>fsipc</code> 包装后向文件服务进程发起请求</li><li>文件服务进程接收到请求后分发给 <code>serve_open</code> 函数，创建 <code>Open</code> 并调用 <code>file_open</code> 函数从磁盘中加载到内存中，返回共享的信息，文件打开</li></ul></li><li>加载 ELF 文件：<ul><li>在进程中打开 ELF 文件后，先创建子进程，初始化其堆栈，做好前置工作</li><li>按段（Segment）解析 ELF 文件，利用 <code>elf_load_seg</code> 函数将每个段映射到子进程的对应地址空间中，在函数执行过程中，会对在文件中不占大小、在内存中需要补 0 的 <code>.bss</code> 段数据进行额外的映射（总文件大小与已经映射的大小的差值即为 <code>.bss</code> 段大小：追加在文件部分之后，并填充为 0）</li><li>实际的映射函数是 <code>spwan_mapper</code>，它利用 <code>syscall_mem_map</code> 将数据从父进程映射到子进程中，完成 ELF 文件的加载</li></ul></li></ul><h1 id="Thinking-6-6"><a href="#Thinking-6-6" class="headerlink" title="Thinking 6.6"></a>Thinking 6.6</h1><ul><li>通过阅读代码空白段的注释我们知道，将文件复制给标准输入或输出，需要我们将其 dup 到 0 或 1 号文件描述符 (fd)。那么问题来了：在哪步，0 和 1 被“安排”为标准输入和标准输出？请分析代码执行流程，给出答案。</li></ul><p>注释中进行了如下标记：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br></pre></td></tr></table></figure><p>这意味着用于 <code>reading</code> 的文件描述符会被 <code>dup</code> 到 <code>fd[0]</code>，过程如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line"><span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;redirction_1: open file in shell failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">fd = r;</span><br><span class="line">dup(fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>映射 <code>writing</code> 部分的描述符操作类似</p><h1 id="Thinking-6-7"><a href="#Thinking-6-7" class="headerlink" title="Thinking 6.7"></a>Thinking 6.7</h1><ul><li>在 shell 中执行的命令分为内置命令和外部命令。在执行内置命令时 shell 不需要 fork 一个子 shell，如 Linux 系统中的 cd 命令。在执行外部命令时 shell 需要 fork 一个子 shell，然后子 shell 去执行这条命令。</li><li>据此判断，在 MOS 中我们用到的 shell 命令是内置命令还是外部命令？请思考为什么 Linux 的 cd 命令是内部命令而不是外部命令？</li></ul><p>我们用到的 shell 命令均属于外部命令。在 shell 运行过程中，我们对指令调用 <code>runcmd</code> 进行处理，其内部调用了 <code>parsecmd</code> 进行解析，在指令解析后直接利用这个指令 <code>spwan</code> 了一个子进程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> child = spawn(argv[<span class="number">0</span>], argv);</span><br></pre></td></tr></table></figure><p>这也就是说，无论执行任何指令，MOS 中的 shell 都会将这个流程解析为：创建子进程、运行指令所指向的文件、完成所需功能</p><h1 id="Thinking-6-8"><a href="#Thinking-6-8" class="headerlink" title="Thinking 6.8"></a>Thinking 6.8</h1><ul><li>在你的shell 中输入命令ls.b | cat.b &gt; motd。<ul><li>请问你可以在你的shell 中观察到几次spawn ？分别对应哪个进程？</li><li>请问你可以在你的shell 中观察到几次进程销毁？分别对应哪个进程？</li></ul></li></ul><p>终端输出如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ ls.b | cat.b &gt; motd</span><br><span class="line">[<span class="number">00002803</span>] pipecreate </span><br><span class="line">[<span class="number">00003805</span>] destroying <span class="number">00003805</span></span><br><span class="line">[<span class="number">00003805</span>] <span class="built_in">free</span> env <span class="number">00003805</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00004006</span>] destroying <span class="number">00004006</span></span><br><span class="line">[<span class="number">00004006</span>] <span class="built_in">free</span> env <span class="number">00004006</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00003004</span>] destroying <span class="number">00003004</span></span><br><span class="line">[<span class="number">00003004</span>] <span class="built_in">free</span> env <span class="number">00003004</span></span><br><span class="line">i am killed ... </span><br><span class="line">[<span class="number">00002803</span>] destroying <span class="number">00002803</span></span><br><span class="line">[<span class="number">00002803</span>] <span class="built_in">free</span> env <span class="number">00002803</span></span><br><span class="line">i am killed ... </span><br></pre></td></tr></table></figure><ul><li>可以观察到2次 <code>spawn</code>：3805 和 4006 进程，这是 ls.b 命令和 cat.b 命令通过 shell 创建的进程</li><li>可以观察到4次进程销毁：3805、4006、3004、2803，按顺序是 ls.b 命令、cat.b 命令 spawn 出的进程、通过管道创建的 shell 进程和 main 函数的 shell 进程。</li></ul><h1 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h1><p>Lab6 实验共分为两部分。</p><p>第一部分是完善文件系统，为其增加管道、控制台两种文件属性，便于下一部分进行 shell 中命令等的传递。这其中需要注意的是非原子操作的进程安全问题，由于管道检测和 <code>dup</code> 函数的非原子性，可能会导致出现管道状态的错误判断，我们需要对其进行进程安全的保护。</p><p>第二部分是补充 shell 的相关代码，在 MOS 系统中实现一个通过外部命令驱动的 shell 。我们在代码中首先完成了使用指定 ELF 文件创建进程的 <code>spawn</code> 函数，这是我们 shell 创建子进程并实现功能的重点。随后通过解析输入命令，实现了对用户从终端输入命令的执行。但是在这个过程中我们填写的代码很少，也许不能有效地理清整个 shell 工作函数执行的顺序，还需要更进一步的分析和整理。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter7</title>
      <link href="/p/2190.html"/>
      <url>/p/2190.html</url>
      
        <content type="html"><![CDATA[<h1 id="第七章-文件系统"><a href="#第七章-文件系统" class="headerlink" title="第七章 文件系统"></a>第七章 文件系统</h1><h1 id="文件系统基本概念"><a href="#文件系统基本概念" class="headerlink" title="文件系统基本概念"></a>文件系统基本概念</h1><blockquote><p>为了解决计算机中数据无法长期保存、共享困难等问题，人们提出了文件的概念，把数据组织成文件的形式，用文件作为数据的存储、访问单位。</p></blockquote><ul><li><p>文件是一组带标识的、在逻辑上有完整意义的信息项的序列。信息项是构成文件内容的基本单位（字节/多字节）</p></li><li><p>所有的 I/O 设备、文本等资源都可以看成文件</p></li><li><p>典型的文件结构</p><ul><li>流式文件：构成文件的基本单位是字符。文件是字符的串构成的集合。</li><li>记录式文件：文件由若干条记录组成，可以按照记录进行读写等操作</li></ul></li><li><p>文件系统的定义：操作系统中与文件管理有关的软件、文件与需要的数据结构的总称。</p></li></ul><h2 id="文件系统模型的三个层次"><a href="#文件系统模型的三个层次" class="headerlink" title="文件系统模型的三个层次"></a>文件系统模型的三个层次</h2><h3 id="文件系统的接口"><a href="#文件系统的接口" class="headerlink" title="文件系统的接口"></a>文件系统的接口</h3><ul><li>命令行接口：用户（Shell）和文件系统交互的接口</li><li>程序接口：用户程序与文件系统的接口，<strong>通过系统调用的形式</strong>获取文件系统的服务</li></ul><h3 id="对象操作管理的软件集合"><a href="#对象操作管理的软件集合" class="headerlink" title="对象操作管理的软件集合"></a>对象操作管理的软件集合</h3><ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>文件逻辑地址 → 物理地址</li><li>文件读写管理</li><li>文件共享与保护功能</li></ul><h3 id="对象及其属性"><a href="#对象及其属性" class="headerlink" title="对象及其属性"></a>对象及其属性</h3><ul><li>文件：管理的直接对象</li><li>目录：包含文件的指针，组织管理文件</li><li>磁盘存储空间</li></ul><h1 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h1><h2 id="文件编排的结构"><a href="#文件编排的结构" class="headerlink" title="文件编排的结构"></a>文件编排的结构</h2><ul><li>逻辑结构：文件组织，逻辑地址连续，但是实际上不连续</li><li>物理结构：文件在存储介质上的位置，同一个文件可能物理地址不连续</li></ul><h3 id="连续结构"><a href="#连续结构" class="headerlink" title="连续结构"></a>连续结构</h3><p>单个文件所占据的空间是先后连续的，即物理结构相邻</p><p>结构简单易实现，支持顺序和随机存取；但不利于文件长度的动态变化</p><h3 id="串联结构"><a href="#串联结构" class="headerlink" title="串联结构"></a>串联结构</h3><p>文件的信息存于若干块中，并且这些块不一定连续</p><p>每个物理块的最后一个字作为<strong>链接字</strong>，指向后继块的物理地址，直至指向 NULL 代表文件结束。</p><p>当访问文件块时需要遍历该文件的所有前驱块，通过链接字进行访问</p><p>空间利用率高，动态修改文件大小；随机存取效率低，通过指针链接易出问题</p><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><ul><li>一个文件的信息存放在若干个不连续的物理块中。</li><li>系统以文件为单位创建了专用数据结构：索引表，索引表就是磁盘块的地址数组，是逻辑块号和物理块号的对照表</li></ul><p>文件若采用索引结构存储，则需要分索引区和数据区。索引区存放索引表，数据区存放数据文件本身。访问时：索引区查表 → 数据区获取磁盘块的信息</p><ul><li>顺序、随机存取效率高，也能满足地址动态地要求；但本身带来了空间（索引表结构占空间）和时间（访问索引表）的开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter6</title>
      <link href="/p/51279.html"/>
      <url>/p/51279.html</url>
      
        <content type="html"><![CDATA[<h1 id="第六章-磁盘存储管理"><a href="#第六章-磁盘存储管理" class="headerlink" title="第六章 磁盘存储管理"></a>第六章 磁盘存储管理</h1><h1 id="磁盘存储的工作原理"><a href="#磁盘存储的工作原理" class="headerlink" title="磁盘存储的工作原理"></a>磁盘存储的工作原理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>扇区：磁盘片上被分成许多的扇形区域</li><li>磁道：以磁盘片中心为圆心，半径不同的同心圆</li><li>柱面：同一半径的不同磁盘片形成的圆柱</li></ul><p>扇区是磁盘读取的单位，磁盘内容按扇区号顺序存储。</p><ul><li>磁盘访问时间包括寻道时间、旋转延迟时间、传输时间<ul><li>$寻道时间=磁盘启动时间+n条磁道×移动单次的时间$</li><li>$旋转延迟时间=\frac{1×旋转一圈的时间}{2}$</li><li>$传输时间=\frac{传输的字节数}{单个磁道上的字节数}×旋转一圈的时间$</li></ul></li></ul><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><ul><li>先来先服务算法</li></ul><p>形成一个磁道队列，按序访问各个磁道，从而进行数据读写</p><ul><li>最短寻道时间算法</li></ul><p>优先选择距离磁头当前最近的请求进行寻道，<strong>寻道优先</strong>。但会出现饥饿现象，即远处的请求长期无法满足</p><ul><li>扫描算法 - SCAN</li></ul><p>电梯算法，先向一个方向移动，处理沿途的请求，直至该方向无请求，掉头处理反方向请求</p><ul><li>循环扫描算法 - CSCAN</li></ul><p>相对扫描算法，将每次开始的磁道设为0号，当单方向访问完后，立刻强制返回0号磁道，再次循环。</p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><blockquote><p>廉价冗余磁盘阵列，把多块独立的磁盘按照不同方式组合为一个大型的逻辑磁盘，从而提供比单个磁盘更高的存储性能、数据冗余。</p></blockquote><ul><li>数据冗余：用户数据损坏后，可利用磁盘中冗余信息进行恢复</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305301700733.png" alt="image-20230530170015633"></p><p><del>好像后面不咋考，先不看了</del></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter5</title>
      <link href="/p/51471.html"/>
      <url>/p/51471.html</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-输入输出系统"><a href="#第五章-输入输出系统" class="headerlink" title="第五章 输入输出系统"></a>第五章 输入输出系统</h1><h1 id="I-O-硬件基本原理"><a href="#I-O-硬件基本原理" class="headerlink" title="I/O 硬件基本原理"></a>I/O 硬件基本原理</h1><h2 id="设备管理目标与功能"><a href="#设备管理目标与功能" class="headerlink" title="设备管理目标与功能"></a>设备管理目标与功能</h2><h3 id="管理目标"><a href="#管理目标" class="headerlink" title="管理目标"></a>管理目标</h3><ul><li>提高效率：提高 I/O 的访问效率，匹配 CPU 与外设间的速度差异</li><li>方便使用：便于用户使用</li><li>方便控制：便于操作系统内部对设备的控制</li></ul><h3 id="管理功能"><a href="#管理功能" class="headerlink" title="管理功能"></a>管理功能</h3><ul><li>提供设备使用的用户接口：命令接口、编程接口</li><li>设备分配和释放：使用设备前需要分配资源</li><li>设备的访问与控制：并发访问、差错处理</li><li>I/O 缓冲与调度：提高 I/O 效率</li></ul><h3 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h3><ul><li>组成：数据寄存器、控制寄存器、状态寄存器</li></ul><h1 id="I-O-软件基本原理"><a href="#I-O-软件基本原理" class="headerlink" title="I/O 软件基本原理"></a>I/O 软件基本原理</h1><h2 id="I-O-控制方式"><a href="#I-O-控制方式" class="headerlink" title="I/O 控制方式"></a>I/O 控制方式</h2><ul><li>程序控制 I/O：轮询方式，由 CPU 发出忙等指令，直至操作完成才能继续执行</li><li>中断驱动：当 I/O 操作结束后，主动通知工作已完成，不需轮询</li><li>DMA：直接存储器访问，由一个控制器完成内存与设备间的传输工作。</li><li>通道：一个内存数据传输的处理器</li></ul><h3 id="轮询工作方式"><a href="#轮询工作方式" class="headerlink" title="轮询工作方式"></a>轮询工作方式</h3><ul><li>进程提出访问请求</li><li>驱动程序检查并向设备发出控制命令</li><li>驱动持续轮询设备是否完成任务</li><li>完成后返回，进程继续工作</li></ul><p>实现简单，但 CPU 利用率低，轮询浪费资源</p><h3 id="中断驱动方式"><a href="#中断驱动方式" class="headerlink" title="中断驱动方式"></a>中断驱动方式</h3><ul><li>进程提出访问请求</li><li>驱动程序发出控制命令，并记录目标设备，CPU <strong>继续工作</strong></li><li>设备完成操作后向 CPU 申请中断，把结果返回给上一步的记录处</li><li>数据送达，进程继续工作</li></ul><h3 id="DMA-直接存储访问方式"><a href="#DMA-直接存储访问方式" class="headerlink" title="DMA - 直接存储访问方式"></a>DMA - 直接存储访问方式</h3><p>CPU 设置 DMA 控制器中的数值，驱动 DMA 进行访问。CPU 只需要准备数值启动，但每个设备都要占用一个 DMA 控制器。</p><ul><li>中断和 DMA 方式都使用中断，但中断控制方式数据传输由CPU 完成，DMA 中由 DMA 控制器完成，不需要 CPU 干预。</li><li>中断在每个数据传输结束后中断 CPU，而 DMA 在传送的一批数据结束后才中断 CPU</li></ul><h3 id="I-O-通道控制方式"><a href="#I-O-通道控制方式" class="headerlink" title="I/O 通道控制方式"></a>I/O 通道控制方式</h3><p>I/O 通道是专门负责输入输出的处理器，执行通道程序，在内存中处理复杂的 I/O 控制，比 DMA 的 CPU 干预要少。</p><p>通道独立处理 I/O 的功能更强；同时通道比 DMA 控制的设备数/种类更多</p><h2 id="缓冲技术"><a href="#缓冲技术" class="headerlink" title="缓冲技术"></a>缓冲技术</h2><p>利用缓冲可以提高外设的利用率，减少中断发生的次数，提高 CPU、I/O 设备的并行性。</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305301455584.png" alt="image-20230530145421259" style="zoom:80%;" /><h3 id="缓冲分类"><a href="#缓冲分类" class="headerlink" title="缓冲分类"></a>缓冲分类</h3><ul><li>单缓冲：CPU、外设轮流使用，等待对方处理</li><li>双缓冲：CPU 和外设工作互不干扰，要求两者速度相近</li><li>环形缓冲：允许处理速度相差大</li><li>缓冲池：分三个队列利用缓冲区</li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><p>由于外设资源有限，需要通过设备分配管理进程使用外设的过程</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>设备控制表：描述单个设备的特性、状态、连接情况</li><li>控制器控制表：描述设备控制器占用的中断号、数据通道等的分配情况</li><li>通道控制表：描述单个通道的工作状态</li><li>系统设备表：系统内的所有资源状态，记录设备状态与设备控制表地址</li></ul><p>设备分配分为 单通路/多通路 I/O 系统的设备分配</p><ul><li>步骤为：分配设备、分配设备控制器、分配通道</li></ul><h3 id="设备驱动共性"><a href="#设备驱动共性" class="headerlink" title="设备驱动共性"></a>设备驱动共性</h3><p>核心代码、核心接口、核心机制与服务、动态可加载、动态性</p><h2 id="假脱机技术-SPOOLing"><a href="#假脱机技术-SPOOLing" class="headerlink" title="假脱机技术 - SPOOLing"></a>假脱机技术 - SPOOLing</h2><blockquote><p>SPOOLing 技术，即虚拟设备技术。系统利用一个 SPOOLing 进程完成对设备的 I/O 操作。</p></blockquote><p>实际上，用户进程与 SPOOLing 程序进行数据交互，随后 SPOOLing 再和外设进行数据交换。虚拟 I/O 程序包含一个缓冲池：用户持续访问缓冲池，SPOOLing 对数据进行合适的处理。</p><ul><li>SPOOLing 实现了一个虚拟 I/O 的端口，提高了实现 I/O 的速度</li><li>通过对物理设备的修饰，原本独享的设备也可以在 SPOOLing 中<strong>提供虚拟设备</strong>，按序共享使用</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>在中断驱动方式中，CPU 以字节为单位干预；DMA 方式中以数据块为单位干预；I/O 通道方式中以一组数据块为单位干预</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter4</title>
      <link href="/p/2510.html"/>
      <url>/p/2510.html</url>
      
        <content type="html"><![CDATA[<h1 id="第四章-进程与并发程序设计"><a href="#第四章-进程与并发程序设计" class="headerlink" title="第四章 进程与并发程序设计"></a>第四章 进程与并发程序设计</h1><h1 id="4-1-进程与线程"><a href="#4-1-进程与线程" class="headerlink" title="4.1 进程与线程"></a>4.1 进程与线程</h1><h2 id="进程概念的引入"><a href="#进程概念的引入" class="headerlink" title="进程概念的引入"></a>进程概念的引入</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li><p>并发：只要某一时刻，活动1与活动2都处在运行状态，就称两者<strong>是并发执行的</strong>。</p></li><li><p>并行：两个程序在同一时刻运行在不同的处理机上，则称这两个程序是并行执行的</p></li><li><p>并发执行的特征：间断性、非封闭性、不可再现性</p><ul><li>间断性：并发程序具有“执行 - 暂停 - 执行”的间断性规律</li><li>非封闭性：存在共享资源，使得程序之间会相互影响</li><li>不可再现性：在初始条件相同时，程序<strong>结果依赖于执行顺序</strong></li></ul></li></ul><p>对于并发而言，偏重于开始 - 结束时间的区间上有重叠，两个程序不必在<strong>同一时刻</strong>都处于活跃状态；而并行则要求两个程序需要同时工作/活跃在 CPU 上，这需要多个处理机才能实现。<strong>并发的要求更加严格。</strong></p><h3 id="进程的定义与特征"><a href="#进程的定义与特征" class="headerlink" title="进程的定义与特征"></a>进程的定义与特征</h3><ul><li><p>进程是程序在一个数据集合上运行的过程，它是系统进行<strong>资源分配和调度</strong>的基本单位。</p></li><li><p>进程具有动态性、并发性、独立性、异步性</p><ul><li>动态性：进程是程序的一次调度过程，而程序是静态的实体</li><li>并发性：多个进程同时存在于内存中，能同时运行</li><li>独立性：进程是独立运行的基本单位</li><li>异步性：进程之间相互制约，存在相关联的关系</li></ul></li><li><p><strong>进程的结构</strong>：程序段、数据段、进程控制块 PCB</p></li><li><p>进程与程序之间的联系：</p><ul><li>进程是动态的，程序是静态的：进程是程序的执行过程</li><li>一个进程可以包括多个程序，一个程序也可以启动多个进程</li></ul></li></ul><h2 id="进程状态与控制"><a href="#进程状态与控制" class="headerlink" title="进程状态与控制"></a>进程状态与控制</h2><blockquote><p>进程控制的主要任务是创建和撤销进程，实现进程的状态转换。</p><p>大多由内核实现进程控制。</p><p>进程是系统进行<strong>资源分配</strong>的基本单位</p><p>线程是<strong>处理机调度和分派</strong>的基本单位</p></blockquote><h3 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h3><ul><li>原语：由若干条指令组成的指令序列，用于实现某个特定功能。</li></ul><p>原语是<strong>不可分割</strong>的，并且必须在<strong>内核态</strong>执行，常驻于内存。</p><h3 id="进程状态及其演变"><a href="#进程状态及其演变" class="headerlink" title="进程状态及其演变"></a>进程状态及其演变</h3><ul><li><strong>进程的三种基本状态</strong>：就绪态、执行态、阻塞态<ul><li>就绪态：尚未运行，但只要提供 CPU 就能直接开始执行</li><li>执行态：占用处理机资源，当没有进程可执行时，会自动执行系统的 idle 进程（开摆）</li><li>阻塞态：等待某种信号的进程，不占用处理机资源</li></ul></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304191336574.png" alt="image-20230419133656524"></p><ul><li><p>状态转换方式</p><ul><li>就绪态 → 运行态：调度程序选择就绪进程，开始运行</li><li>运行态 → 就绪态：分配的时间片耗尽；当前<strong>存在高优先级进程</strong>可被调度（抢占式）</li><li>运行态 → 阻塞态：需要等待资源、系统信号、IO 结果等<strong>外部信号</strong></li><li>阻塞态 → 就绪态：上述等待的信号处理完毕</li></ul></li></ul><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><ul><li><p>进程控制块：创建、撤销进程，进程的唯一标志，限制总进程数目</p></li><li><p>进程控制块的主要内容：</p><ul><li>进程标识符：env_id</li><li>现场保护区：env_tf</li><li>当前状态与程序数据地址等</li></ul></li></ul><h4 id="进程上下文切换-amp-陷入内核"><a href="#进程上下文切换-amp-陷入内核" class="headerlink" title="进程上下文切换 &amp; 陷入内核"></a>进程上下文切换 &amp; 陷入内核</h4><ul><li>进程上下文切换，通常由调度器执行，会切换内存映射</li><li>陷入内核：CPU 状态会进入内核态，由中断异常等引起，发生时需要保存执行时现场</li></ul><p>相较而言，陷入内核开销较小</p><h2 id="线程概念的引入"><a href="#线程概念的引入" class="headerlink" title="线程概念的引入"></a>线程概念的引入</h2><ul><li>线程是系统<strong>调度和分派的单位</strong>，它不基本拥有资源、数据，但有线程栈，同时可以访问所在进程的数据，同进程的所有线程也可以共享所有资源</li><li>引入线程可减少切换进程带来的开销、提升进程的并发速度（划分尺度更小），但线程必须依赖进程才能被执行</li></ul><h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><ul><li><strong>用户级线程 ULT</strong>：用户在进程空间中模拟出新的进程<ul><li>ULT 对于系统来说是不可见的，程序外观测不到额外线程</li><li>ULT 上下文切换快，本质上是用户对虚存空间与时间片的再分配</li><li>ULT 会因为内核阻塞而导致所有线程都被阻塞（内核看不到其他线程）；即使有多个处理器，ULT 进程也<strong>最多占用一个</strong>（内核看不到其他线程），<strong>无法实现多线程并行执行</strong></li></ul></li><li><strong>内核级线程 KLT</strong>：在内核中创建线程，支持线程的分发<ul><li>内核可以做到调度同进程的多个线程<strong>并行执行</strong></li><li>线程切换必须使用内核，切换的效率低</li></ul></li><li>混合实现方式：用户空间中可以创建管理线程，内核中存在多个内核线程，需要实现两类线程的映射</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304191414736.png" alt="image-20230419141435676" style="zoom:67%;" /><ul><li><p>线程映射方式：</p><ul><li>多用户 → 单内核：用户级线程不可见，用户进行调度，阻塞会全部阻塞</li><li>单用户 → 单内核：并发能力强，创建、切换线程开销大</li><li>多用户 → 多内核：折中</li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><strong>可重入</strong>不一定线程安全，但不可重入一定线程安全</li></ul><h1 id="4-2-同步与互斥"><a href="#4-2-同步与互斥" class="headerlink" title="4.2 同步与互斥"></a>4.2 同步与互斥</h1><h2 id="同步互斥"><a href="#同步互斥" class="headerlink" title="同步互斥"></a>同步互斥</h2><h3 id="访问与竞争"><a href="#访问与竞争" class="headerlink" title="访问与竞争"></a>访问与竞争</h3><blockquote><p>程序的并发执行，不可避免地使得共享数据会被多个进程访问，这就造成了资源的<strong>竞争</strong></p></blockquote><ul><li>竞争条件：多个进程并发访问、变更同一数据，且执行后结果与访问的顺序相关</li><li>临界资源：仅允许一个进程访问的资源；访问临界资源的代码称为<strong>临界区</strong></li></ul><h3 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h3><ul><li><p>进程互斥：间接制约关系</p><ul><li>两个或以上进程不能同时访问临界资源，否则会发生错误，是程序间的间接作用</li><li>互斥是无序访问</li></ul></li><li><p>进程同步：直接制约关系</p><ul><li>各进程间相互合作从而满足程序正常执行需求的过程；当需要前后进程交换信息时，通常使其进入等待，这种制约关系便是进程同步</li><li>同步是有序访问，通常同步已经实现了互斥（写入过程必然互斥）</li></ul></li></ul><p>临界区设计：空闲让进，忙则等待，有限等待，让权等待</p><h2 id="忙等待解决互斥"><a href="#忙等待解决互斥" class="headerlink" title="忙等待解决互斥"></a>忙等待解决互斥</h2><ul><li>忙等待方法的解决方法都是正确的，原理在于<strong>使用循环</strong>持续检查程序是否能进入临界区（不能进入会原地等待并继续查询）；但是因为使用 <code>while();</code> 会产生忙等待，而导致性能的浪费</li></ul><h3 id="软件互斥算法"><a href="#软件互斥算法" class="headerlink" title="软件互斥算法"></a>软件互斥算法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat:</span><br><span class="line">    entry section</span><br><span class="line">    critical section</span><br><span class="line">    exit section</span><br><span class="line">    remainder section</span><br><span class="line">Until false</span><br></pre></td></tr></table></figure><h4 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h4><ul><li><p>顾客进入面包店按照号码从小到大的次序购买面包，并且假定：</p><ul><li>面包店按照递增顺序发放号码，并且多个顾客可能拿到相同号码（即不严格递增）</li><li>当号码相同时，按照顾客名字排序</li></ul></li><li><p>当多个进程同时进行号码计算时可能拿到相同号码，此时则按照进程 id 决定进入临界区的顺序</p></li><li><p>使用 <code>while();</code> 来循环测试进入互斥区的条件，形成<strong>忙等待</strong>，消耗 CPU 资源</p></li></ul><h3 id="硬件互斥方法"><a href="#硬件互斥方法" class="headerlink" title="硬件互斥方法"></a>硬件互斥方法</h3><h4 id="中断屏蔽"><a href="#中断屏蔽" class="headerlink" title="中断屏蔽"></a>中断屏蔽</h4><ul><li>实现简单</li><li>单 CPU 系统中可以使用，多 CPU 会出现大幅性能损失</li><li>内核进程会少量使用来保证互斥</li></ul><h4 id="TS-原语"><a href="#TS-原语" class="headerlink" title="TS 原语"></a>TS 原语</h4><ul><li>TS(test-and-set)是一种原语，写入新的值后会将旧值传回</li><li>在多进程中，如果一个程序<strong>处于 TS 原语中</strong>，则其他进程不可以使用 TS 原语</li><li>相当于原子读写<strong>锁</strong>的内容，来保证临界区的互斥，但仍然需要忙等待 <code>while</code></li></ul><h4 id="swap-指令"><a href="#swap-指令" class="headerlink" title="swap 指令"></a>swap 指令</h4><ul><li>swap 是一种交换地址内容的原语，互斥描述如下：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> k = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> use = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (k != <span class="literal">false</span>) &#123;    <span class="comment">// check use == 0 ?</span></span><br><span class="line">    Swap(&amp;use, &amp;k); <span class="comment">// use cannot be changed by others now</span></span><br><span class="line">&#125;                   <span class="comment">// use has been changed by the program now</span></span><br><span class="line">criticalRegionCode();</span><br><span class="line">use = <span class="literal">false</span>;</span><br><span class="line">otherRegionCode();</span><br></pre></td></tr></table></figure><ul><li>swap 也会因为循环 swap 而导致忙等待</li></ul><h2 id="信号量解决同步互斥"><a href="#信号量解决同步互斥" class="headerlink" title="信号量解决同步互斥"></a>信号量解决同步互斥</h2><blockquote><p>信号量方法改变了忙等待的特质，使用了<strong>阻塞方式</strong>休眠进程，避免了不必要的性能损失</p></blockquote><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul><li>使用新的变量类型：<code>semaphore</code></li><li>信号量只能通过初始化和 <code>P(semaphore)</code> <code>V(semaphore)</code> 两个<strong>原语</strong>访问，不受进程调度的影响</li><li>S 的值为正时表示<strong>可用资源</strong>的个数、负表示<strong>等待资源</strong>的进程个数</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semapgore S = ableNumber;</span><br><span class="line">P(S) &#123;</span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>) &#123; blockProgram(S); &#125;  </span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V(S) &#123;</span><br><span class="line">    S++;</span><br><span class="line">    wakeProgram(S);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用信号量，能解决同步与互斥两类问题：</p><ul><li>互斥：<code>S = 1</code>，同时只有一个进程能申请资源（进入临界区）</li><li>有限并发：<code>S = const</code>，分配 n 个资源，允许 n 个进程同时使用</li><li>同步：<code>S = 0</code>，可以描述进程执行的先后关系，只有在前驱 <code>V</code> 后，自身的 <code>P</code> 才能解除 wait</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 互斥使用：每个进程都先 P 后 V</span></span><br><span class="line">P(S);</span><br><span class="line"><span class="comment">// CODE HERE</span></span><br><span class="line">V(S);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步使用：后继进程先 P，等待前驱进程 V，传递了可以执行的信号</span></span><br><span class="line">P(S);</span><br><span class="line"><span class="comment">// S != 0</span></span><br><span class="line"><span class="comment">// CODE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CODE</span></span><br><span class="line">V(S);</span><br><span class="line"><span class="comment">// S == 0</span></span><br></pre></td></tr></table></figure><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304200059552.png" alt="image-20230420005920486" style="zoom:50%;" /><ul><li>只有前驱任务发出信号后（“释放”资源），后继任务才能从阻塞中脱离（“占用”资源），开始执行任务</li></ul><h3 id="一般信号量集"><a href="#一般信号量集" class="headerlink" title="一般信号量集"></a>一般信号量集</h3><ul><li>SP(S,a,d)：每次申请d个资源，少于a个便不再分配</li><li>SP(S,1,1)：互斥信号量</li><li>SP(S,1,0)：每次申请0个资源，s=0时禁止进入临界区</li></ul><h4 id="PV-操作优缺点"><a href="#PV-操作优缺点" class="headerlink" title="PV 操作优缺点"></a>PV 操作优缺点</h4><ul><li>表达能力强，使用简单</li><li>使用不当易发生死锁</li></ul><h2 id="管程解决同步互斥"><a href="#管程解决同步互斥" class="headerlink" title="管程解决同步互斥"></a>管程解决同步互斥</h2><ul><li>管程把分散地临界区集中起来，可以以函数库的形式实现，是一种高级同步原语</li><li>管程由变量、过程、数据结构等组成</li><li>互斥：只能同时有一个活跃进程</li></ul><h3 id="管程的实现"><a href="#管程的实现" class="headerlink" title="管程的实现"></a>管程的实现</h3><ul><li><p>Hoare 管程：执行 signal 的进程等待，直至其他 signal 唤醒</p><ul><li>入口等待队列：由于互斥而等待的一般队列</li><li>紧急等待队列：由于唤醒操作而自身进入等待的进程队列，优先级高</li></ul></li><li><p>Hansen 管程：signal 放在最后执行，执行后立即退出管程</p></li><li></li></ul><h2 id="进程通信的方式"><a href="#进程通信的方式" class="headerlink" title="进程通信的方式"></a>进程通信的方式</h2><ul><li>低级通信：只能传递控制信号</li><li>高级通信：共享内存、消息系统、管道</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><ul><li>管道是<strong>半双工</strong>的，即单向流动信息，对于管道双方，管道是一个文件系统</li><li><strong>无名管道</strong>只能用于有亲缘关系的进程，<strong>有名管道</strong>支持不相关进程</li><li>数据传递先进先出，保持队列顺序</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><ul><li>依靠通信原语实现：send(dst, &amp;message), receive(src, &amp;message)，类似于我们实现的ipc_send</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304201058829.png" alt="image-20230420105758743" style="zoom:67%;" /><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li>避免缓冲复制，最快的 ipc 形式</li><li>实质是一块物理内存被同时映射到多个进程的虚拟内存空间，<strong>写机制需要同步约束</strong></li></ul><h2 id="经典同步互斥问题"><a href="#经典同步互斥问题" class="headerlink" title="经典同步互斥问题"></a>经典同步互斥问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><ul><li>生产者通过有限缓冲区向消费者发送数据，同时只有一个进程可对缓冲区操作</li></ul><p>生产者、消费者自身互斥，两者之间同步（先放后取）</p><h4 id="信号量设置"><a href="#信号量设置" class="headerlink" title="信号量设置"></a>信号量设置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex = 1; // 互斥访问量</span><br><span class="line">semaphore empty = N; // 同步使用，缓冲区空闲数量</span><br><span class="line">semaphore full = 0;</span><br></pre></td></tr></table></figure><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>生产者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(empty); <span class="comment">// 全满(empty = 0) 则无法放置</span></span><br><span class="line">P(mutex); <span class="comment">// 最后再申请互斥信号量，避免等待死锁</span></span><br><span class="line">putOne();</span><br><span class="line">V(mutex);</span><br><span class="line">V(full);</span><br></pre></td></tr></table></figure><p>消费者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(full);</span><br><span class="line">P(mutex);</span><br><span class="line">getOne();</span><br><span class="line">V(mutex);</span><br><span class="line">V(empty);</span><br></pre></td></tr></table></figure><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li><p>对共享资源的访问操作，写者只允许一个，读者可以不限制数量 ，但是读写也存在互斥</p></li><li><p>读写者有利：</p><ul><li>读者有利：只要有读者开始读，写者就必须一直等待到所有读者结束；写者需要确保没有读进程才能写，写完后允许读者进入</li><li>写者有利：输入写后不再允许后续读者进入（reader++操作）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写有利</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> read_count = <span class="number">0</span>, write_count = <span class="number">0</span>;</span><br><span class="line">semaphore read_mutex = <span class="number">1</span>, write_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;  <span class="comment">// 互斥访问共享数据</span></span><br><span class="line">semaphore read = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(write_count);</span><br><span class="line">        <span class="keyword">if</span> (write_count++ == <span class="number">0</span>) P(read);  <span class="comment">//只要有写者，就占着read</span></span><br><span class="line">        V(write_count);</span><br><span class="line"></span><br><span class="line">        P(data_mutex);</span><br><span class="line">        <span class="comment">// writing</span></span><br><span class="line">        V(data_mutex);</span><br><span class="line"></span><br><span class="line">        P(write_count);</span><br><span class="line">        <span class="keyword">if</span> (--write_count == <span class="number">0</span>) V(read);  <span class="comment">//没有写者才释放read</span></span><br><span class="line">        V(write_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(read);  <span class="comment">// 没有写者才能进入临界区</span></span><br><span class="line"></span><br><span class="line">        P(read_mutex);</span><br><span class="line">        <span class="keyword">if</span> (read_mutex++ == <span class="number">0</span>) P(data_mutex);</span><br><span class="line">        V(read_mutex);</span><br><span class="line"></span><br><span class="line">        V(read);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// reading</span></span><br><span class="line"></span><br><span class="line">        P(read_mutex);</span><br><span class="line">        <span class="keyword">if</span> (--read_mutex == <span class="number">0</span>) V(data_mutex);</span><br><span class="line">        V(read_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读有利：</p><p>写者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(wmutex);</span><br><span class="line">doWrite();</span><br><span class="line">V(wmutex);</span><br></pre></td></tr></table></figure><p>读者：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P(mutex);</span><br><span class="line"><span class="keyword">if</span> (reader == <span class="number">0</span>) &#123;</span><br><span class="line">    P(wmutex);</span><br><span class="line">&#125;</span><br><span class="line">reader++;</span><br><span class="line">V(mutex);</span><br><span class="line">doRead();</span><br><span class="line">P(mutex);</span><br><span class="line">reader--;</span><br><span class="line"><span class="keyword">if</span> (reader == <span class="number">0</span>) &#123;</span><br><span class="line">    V(wmutex);</span><br><span class="line">&#125;</span><br><span class="line">V(mutex);</span><br></pre></td></tr></table></figure><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304201128040.png" alt="image-20230420112817001"></p><ul><li>rwmutex 满足先到先得，谁先出现，谁先响应</li></ul><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul><li>五个哲学家坐成一圈，并且有五支筷子，哲学家动作包括思考和进餐，如何避免死锁，使得流程进行顺利？</li></ul><p>显然不能直接 PV 筷子，这样每人一支肯定会死锁，应该最多允许四个人<strong>尝试进餐</strong></p><h1 id="4-3-进程调度"><a href="#4-3-进程调度" class="headerlink" title="4.3 进程调度"></a>4.3 进程调度</h1><h2 id="调度的概念与问题"><a href="#调度的概念与问题" class="headerlink" title="调度的概念与问题"></a>调度的概念与问题</h2><ul><li>CPU 调度就是按照一定的策略，从就绪的进程队列中选择一个进程并开始运行的过程</li><li>进程调度主要需要考虑：进程调度的算法、进程调度的时机、进程切换的过程</li></ul><h3 id="调度的类型"><a href="#调度的类型" class="headerlink" title="调度的类型"></a>调度的类型</h3><ul><li>高级调度：又称宏观调度，通常上，高级调度的单位是分钟、小时或更大单位。它从用户工作流程的角度出发，关注宏观。</li><li>中级调度：主要涉及内外存交换，从不同级别的存储器中进行内容交换</li><li>低级调度：又称微观调度，通常单位是毫秒，特点是执行频率高，从 CPU 资源出发进行调度；<ul><li><strong>抢占式调度</strong>：进程在运行过程中，处理机可能被其他进程抢走（被迫停止）</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305031452166.png" alt="image-20230503145224087" style="zoom:80%" /><h3 id="调度时机与操作"><a href="#调度时机与操作" class="headerlink" title="调度时机与操作"></a>调度时机与操作</h3><p>实际上，只要操作系统能够获取到 CPU 的使用权（系统调用、时钟中断等进入内核态），就有可能发生进程的调度</p><p>在进行调度前，需要先给当前进程生成快照，保存信息；然后把进程控制块移动至队尾，最后选用其他的控制块并恢复其现场即可</p><h3 id="调度性能准则"><a href="#调度性能准则" class="headerlink" title="调度性能准则"></a>调度性能准则</h3><ul><li><p>周转时间：作业从提交到最后完成所经历的时间，包括所有等待、执行、输出等时间</p></li><li><p>等待时间：用户输入请求到系统开始处理任务所需要的时间</p></li><li><p>吞吐量、处理机利用率、资源利用率等</p></li></ul><h2 id="调度算法设计要点"><a href="#调度算法设计要点" class="headerlink" title="调度算法设计要点"></a>调度算法设计要点</h2><h3 id="进程优先级-数"><a href="#进程优先级-数" class="headerlink" title="进程优先级/数"></a>进程优先级/数</h3><p>优先数相当于把优先级用数字具体表示了出来，反映了某个优先级，可以采用静态/动态的方式组织优先级。<strong>按优先级排队方式</strong>就是按照不同进程优先级进行等待队列排序的一种调度方式。</p><h3 id="占用-CPU-的方式"><a href="#占用-CPU-的方式" class="headerlink" title="占用 CPU 的方式"></a>占用 CPU 的方式</h3><ul><li>不可抢占式方式：一旦 CPU 资源被分配，除非进程自身进入阻塞状态，或时间片耗尽外，不会让出 CPU</li><li>抢占式方式：就绪队列中一旦存在更高优先级进程，就直接进行进程调度</li></ul><h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片决定了 CPU 允许进程运行的时间长度：<strong>时间片短</strong>导致频繁切换进程，会产生大量开销；<strong>时间片长</strong>又会导致某些进程不能得到及时响应，调度能力退化；同时时间片的设置也与 CPU 硬件能力、进程执行的操作等相关</p><h3 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h3><ul><li>第一种分类方式：<ul><li>I/O 密集型：频繁进行 I/O，会花费很多时间进行阻塞等待</li><li>CPU 密集型：计算需求大，需要大量算力进行运算</li></ul></li><li>第二种分类方式：<ul><li>批处理进程：无需交互、响应，通常自行完成功能</li><li>交互式进程：I/O 等交互频繁，同时响应速度要求高</li><li>实时进程：实时性高，响应时间短，不能被低优先级进程阻塞，优先处理</li></ul></li></ul><h2 id="批处理系统的调度算法"><a href="#批处理系统的调度算法" class="headerlink" title="批处理系统的调度算法"></a>批处理系统的调度算法</h2><blockquote><p>批处理系统有以下几种常见的调度算法：先来先服务-FCFS，最短时间优先-SJF，最短剩余时间有限-SRTF，最高响应比优先-HRRF</p></blockquote><h3 id="先来先服务-FCFS"><a href="#先来先服务-FCFS" class="headerlink" title="先来先服务 - FCFS"></a>先来先服务 - FCFS</h3><p>进程按照就绪的顺序进行调度，并采用<strong>非抢占式</strong>执行，进程阻塞结束后也不会立即抢回 CPU 继续执行，而是重新进入队列排队</p><ul><li>FCFS 特点：</li><li>利于长时间作业，不利于短时间作业</li><li>利于 CPU 集中型作业，不利于 I/O、交互集中型作业</li></ul><h3 id="短作业优先-SJF"><a href="#短作业优先-SJF" class="headerlink" title="短作业优先 - SJF"></a>短作业优先 - SJF</h3><p>在 FCFS 的基础上改进，同样采用非抢占式执行，但<strong>进程的排队顺序变为占用时间长短</strong>，短进程优先执行，用以减少 CPU 的等待时间</p><ul><li>SJF特点：</li><li>提高系统吞吐量，缩短作业总等待时间</li><li>不能体现作业之间的优先级，同时对长作业很不利，可能长时间无法运行</li></ul><h3 id="最短剩余时间-SRTF"><a href="#最短剩余时间-SRTF" class="headerlink" title="最短剩余时间 - SRTF"></a>最短剩余时间 - SRTF</h3><p>一言蔽之，抢占式的短作业优先策略。</p><p>如果一个新就绪的进程如果时间比当前进程短，就会直接切换，即一直运行剩余时间最短的进程。</p><ul><li>持续的短任务可能会导致长任务一直无法运行/被抢占，导致长进程饥饿</li></ul><h3 id="最高响应比算法-HRRF"><a href="#最高响应比算法-HRRF" class="headerlink" title="最高响应比算法 - HRRF"></a>最高响应比算法 - HRRF</h3><p>HRRF 实际上是短作业优先与先到先服务两个算法的结合，即综合考虑作业等待时间和作业运行时间后再进行调度，同时系统是非抢占的。</p><p>在每次选择作业投入运行时，先计算每个作业的响应比（RR），然后选择权重最大的投入运行。<br>$$<br>RR=1+\frac{已等待时间}{要求运行时间}<br>$$</p><ul><li>HRRF特点：</li><li>短作业容易获得高权重（同等的等待时间时，其要求运行时间更短）</li><li>不会发生饥饿现象（由于等待时间能控制权重，所以长作业不会饥饿）</li><li>计算响应比需要时间开销，算法本身的性能较差</li></ul><h2 id="交互式系统的调度算法"><a href="#交互式系统的调度算法" class="headerlink" title="交互式系统的调度算法"></a>交互式系统的调度算法</h2><blockquote><p>交互式系统常见调度算法如下：时间片轮转算法、优先级算法、多级队列算法、多级反馈队列算法</p></blockquote><h3 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h3><p>各个进程通过轮换运行较短的时间片，使用进程切换来提高<strong>进程的并发性</strong>和<strong>响应时间</strong>等特性，从而提高资源利用率</p><h4 id="时间片轮转的步骤"><a href="#时间片轮转的步骤" class="headerlink" title="时间片轮转的步骤"></a>时间片轮转的步骤</h4><ul><li>按照插入时间形成调度队列</li><li>将 CPU 分配给队列头部进程，并运行一个时间片</li><li>时间片结束后使用时钟中断来暂停进程，并将该进程移动至队尾</li><li>重新分配 CPU，直至所有进程结束</li></ul><p>系统是非抢占式的，进程停止运行可以是时钟中断，或是自行让出（阻塞态）。时间片长度过长会导致算法退化为 FCFS，即每个进程都只在单个时间片内运行结束；过短则会导致进程频繁切换，切换上下文的过程中时间开销大。</p><h3 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h3><p>优先级算法平衡了各进程对响应时间的要求，优先级可以是静态/动态生成的。</p><ul><li>静态优先级：在创建进程时就确定该进程的优先级：进程类型（用户/内核），资源需求量、用户等级</li><li>动态优先级：在进程调度过程中可能发生动态更改；可以类似于一堆人等着吃饭，厨师看情况再决定给谁先做<ul><li>进程等待时间过长等可以导致优先级提高（等的时间长了就先做饭）</li><li>进程每次执行一个时间片就降低优先级（吃了一点了就后做）</li></ul></li></ul><h3 id="多级队列算法"><a href="#多级队列算法" class="headerlink" title="多级队列算法"></a>多级队列算法</h3><p>引入多个就绪队列，并给各个队列不同的优先级，以此调度进程。</p><p>不同的队列有不同的优先级、时间片长度、调度策略。例如系统进程和用户进程、不同用户的进程就可以放在不同的就绪队列中用以优先调度</p><h4 id="多级反馈队列算法"><a href="#多级反馈队列算法" class="headerlink" title="多级反馈队列算法"></a>多级反馈队列算法</h4><p>在多级队列算法和时间片轮转算法基础上发展而来，优先短进程以提高系统吞吐量、缩短平均周转时间；优先 IO 进程以获得更短的响应时间</p><p>实际操作：</p><ul><li>设置多个不同优先级的就绪队列，并保证<strong>优先级越低时间片越长</strong></li><li>新进入的进程从最高优先级队列开始插入，如果在该时间片结束后仍未结束，则对其“降级”，即插入下一级的队列中</li><li>只有当高优先级队列为空时才能调度低优先级队列中的进程；当出现抢占时，被抢占进程重新插入至原队列末尾，不改变优先级</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305071557744.png" alt="image-20230507155736703"></p><p>在这种算法下， I/O 进程通常在最高优先级队列/阻塞队列中，计算进程通常在低优先级队列中</p><h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><blockquote><p>优先级倒置是高优先级进程被低优先级进程阻塞，或在其之后运行的现象</p></blockquote><p>常见于高、低优先级进程共享临界资源时：当低优先级进程先获取了临界资源，随后被高优先级进程抢占，高优先级进程又需要该临界资源。此时高优先级进程只能阻塞，等待低优先级进程完成临界资源使用后才能恢复。</p><p>下图的 Task A 就被 Task C 阻塞了，这里的 Task B 就先于 Task A 运行，产生了优先级的倒置</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305071602070.png" alt="image-20230507160228040"></p><p>解决优先级倒置的方式是<strong>优先级继承</strong>：当高优先级进程阻塞后，可以令等待的目标进程获取和高优先级进程相同的优先级，这样就会立即运行拥有临界资源的进程。</p><p>也就是给 Task C 一个和 A 相同的优先级，当 Task A 阻塞后，B 的优先级没有继承后的 C 高，所以不会发生优先级倒置</p><h2 id="实时系统的调度算法"><a href="#实时系统的调度算法" class="headerlink" title="实时系统的调度算法"></a>实时系统的调度算法</h2><p>实时系统是一种时间起主导作用的系统，也就是说，计算机系统需要对某个外界产生的操作在合适的时间内做出响应，也就是说，操作响应的实时性在这类系统中十分重要。</p><p>实时系统的进程要求更详细的调度信息：资源要求、详细优先级、响应截止时间。采用<strong>抢占式调度</strong>，响应中断快速，采用较小的调度单位（更轻量的线程）</p><p>常见的实时调度算法有以下几种：静态表调度、单调速率调度，最早截止时间优先算法</p><h3 id="静态表调度算法"><a href="#静态表调度算法" class="headerlink" title="静态表调度算法"></a>静态表调度算法</h3><p>通过对所有周期性任务的分析预测，预先确定一个固定的调度方案。</p><ul><li>不需要计算，只按照固定的方案进行，调度的开销最小</li><li>拓展性差，只适用于固定的场景，要求系统中只有已知的进程</li></ul><h3 id="单调速率调度算法"><a href="#单调速率调度算法" class="headerlink" title="单调速率调度算法"></a>单调速率调度算法</h3><p>静态要求下最优的调度算法，开销小，灵活性相对好</p><ul><li><strong>任务的周期越小，优先度越高</strong>，按照优先级高低进行调度，对于同优先级进程随机调度</li><li>该调度是静态、抢占式的</li></ul><h3 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h3><p>按照任务的截止时间设置优先级，优先级越高的任务最先被调度，也就是说优先级是实时变化的，对同优先级进程随机调度。</p><h3 id="最低松弛度优先算法"><a href="#最低松弛度优先算法" class="headerlink" title="最低松弛度优先算法"></a>最低松弛度优先算法</h3><p>$$<br>松弛度=截止时间-剩余运行时间-当前时间<br>$$</p><p>该算法按照各进程的松弛度进行进程的调度，当某个进程的松弛度为0时会发生<strong>抢占式调度</strong>（此刻全力运行该进程才能刚好运行完，换句话说不抢占就完不成了）</p><h2 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h2><p>多处理机调度更注重整体的运行效率，对于单个处理机不过分注重其利用率，同时多调度机需要考虑访问的互斥问题；<strong>调度单位多为线程</strong></p><p>多处理机系统可分为非对称式和对称式两种。</p><ul><li>非对称式：各个处理器的地位不同，每个处理器有各自分工，存在一个<strong>主处理机</strong>向外分发任务</li><li>对称式：处理器地位相同，调度算法分集中、分散两种。</li></ul><h3 id="对称式处理系统的调度算法"><a href="#对称式处理系统的调度算法" class="headerlink" title="对称式处理系统的调度算法"></a>对称式处理系统的调度算法</h3><ul><li>静态分配（集中）：每个 CPU 设立一个就绪队列，进程分配给某个处理器后就不会变更处理器运行；调度算法的开销小，但是各处理器会<strong>忙闲不均</strong></li><li>动态分配（集中）：所有 CPU <strong>共享</strong>一个就绪队列，队首进程分派到空闲 CPU 中运行，能解决忙闲不均问题</li><li>自调度（分散）：系统采用一个公共就绪队列，处理机选取适当进程执行，易于移植，相对成熟<ul><li>不需要处理机进行任务分配，但是共享队列的同步、不同处理机的 cache 等缓存、线程协作等需要设计</li></ul></li><li>成组调度（分散）：分配和阻塞时的单位为<strong>一组线程</strong>，每次分配都为这组线程寻找一组合适的处理机<ul><li>成组调度提高了线程的并行度，有利于减少阻塞</li><li>可以减少调度次数，从而减少调度算法自身的开销</li><li>相当于面向进程分配任务，而不是面向线程</li></ul></li></ul><h1 id="4-4-死锁"><a href="#4-4-死锁" class="headerlink" title="4.4 死锁"></a>4.4 死锁</h1><h2 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a>死锁的定义</h2><p>一组进程中，每个进程都无限等待被其他进程所占用的资源，并且将永远获取不到对应资源而无法运行的现象。</p><h3 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h3><p>注意这里说的是<strong>必要条件</strong>，也就是说只要有一个条件被打破，死锁就不会存在</p><ul><li>互斥条件：存在互斥资源，并且只能由一个进程占用，只有该进程主动释放，其他进程才能再分配给其他进程</li><li>请求并占有条件：当进程无法获得所有资源请求，而被迫阻塞时，不会释放自己已经获得的资源（类似于 sleep 不放锁</li><li>不可剥夺条件：进程已获得的资源<strong>只能由</strong>进程在使用结束后释放</li><li>环路等待条件：发生死锁时，必然存在一条环状链将所有发生死锁的进程有序连接<ul><li>需要注意如果环路中的某个点同时可以请求环路外的某进程所持有的资源，这个环路将不成立，也就是这个回路不一定能锁上</li></ul></li></ul><h3 id="活锁和饥饿"><a href="#活锁和饥饿" class="headerlink" title="活锁和饥饿"></a>活锁和饥饿</h3><ul><li>活锁：执行者未被阻塞，但某些条件不满足，导致进程持续尝试（也持续失败<ul><li>活锁可能会在某次尝试中自行解开，死锁由于陷入等待，无法自救</li></ul></li><li>饥饿：资源分配策略不公平导致某些进程长时间等待，产生饥饿。<ul><li>通常在短任务优先等抢占式调度方式时，长作业就很容易饥饿</li></ul></li></ul><h2 id="处理死锁的方法"><a href="#处理死锁的方法" class="headerlink" title="处理死锁的方法"></a>处理死锁的方法</h2><blockquote><p>通常采用死锁预防、死锁避免、死锁检测三个方式对死锁进行处理。</p></blockquote><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><blockquote><p>死锁预防通过打破死锁的<strong>四个必要条件</strong>，阻止死锁的形成。是排除死锁的<strong>静态策略</strong>。</p></blockquote><ol><li>互斥条件：允许多个进程占用同一个互斥资源（通常不可实现）</li><li>申请且占有条件：实现资源的预分配，当系统能够满足进程的全部资源请求时一次性把所有资源全部分配，否则不分配任何资源<ul><li>资源的利用率低；同时计算一个动态进程需要的全部资源也很困难</li></ul></li><li>不可剥夺条件：当请求不能被满足时，进程立刻释放已有的全部资源并等待之后重新申请，相当于这部分已分配的资源被“剥夺”了</li><li>循环等待条件：实施资源有序分配的策略，将所有资源按号分配，并且所有资源请求都必须先申请小号资源，从而避免产生环路。<ul><li>编号带来的系统开销大；同时会预先占用可能不常用的资源，导致资源利用率低</li></ul></li></ol><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><blockquote><p>死锁避免不限制死锁的必要条件，而是动态地检测每一个申请资源的请求，然后再决定是否进行资源分配，是一种排除死锁的<strong>动态策略</strong>。</p></blockquote><p>安全序列：一个进程的序列，对于其中每一个进程而言，其占用的资源可以被系统可用资源 + <strong>已被序列靠前的进程</strong>占用的资源所满足</p><p>如果不存在这样一个序列，则系统是<strong>不安全的</strong>。但是系统不安全不一定会发生死锁，反之，死锁时系统一定处于不安全状态。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><blockquote><p>银行家把固定资金贷款给若干顾客，在过程中只要不出现超过最大值的请求，应能保证资金安全。</p></blockquote><ul><li>单次请求的最大需求量不超过现有现金时即可处理请求</li><li>一次请求中的金额可以分期支付，但总和不会超过请求的最大需求量</li><li>当现有现金不能满足请求的请求剩余的金额时，请求会被搁置，但总能处理</li><li>当满足了请求的所有需求后，会在一定时间内归还所有资金</li></ul><p>这里处理的资源就只有一种：“现金”，而在操作系统中，我们会对可能用到的所有种类的资源都进行如上的限制。</p><p>在银行家算法中，我们假定有 $n$ 个进程，同时有 $m$ 种类型的资源</p><h4 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h4><ul><li>可利用资源向量 <code>Available</code>：一个具有 $m$ 个元素的向量，向量的每一个值都代表对应类资源的<strong>可用资源数量</strong>。即 <code>Available[j] = k</code> 说明第 $j$ 类资源目前可用 $k$ 个。</li><li>最大需求矩阵 <code>Max</code>：一个大小为 $n × m$ 的矩阵，定义了所有进程对于所有资源的最大需求数量。即 <code>Max(i, j) = k</code> 说明第 $i$ 个进程最多需要 $k$ 个 $j$ 类资源</li><li>分配矩阵 <code>Allocation</code>：一个大小为 $n × m$ 的矩阵，定义已经分配给进程的资源数目，规则类似于 <code>Max</code> 矩阵</li><li>需求矩阵 <code>Need</code> ：一个大小为 $n × m$ 的矩阵，定义进程仍需的资源数目。</li></ul><p>根据三者关系，易得<br>$$<br>Need(i,j)=Max(i,j)-Allocation(i,j)<br>$$</p><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>当一个进程发出资源请求后，操作系统会按序进行检查：</p><ul><li>如果数量超过了 $Need(i,j)$，说明前提/请求出错</li><li>当数量超过了$Available(i,j)$，说明当前资源无法满足请求，<strong>进程等待</strong></li><li>尝试修改资源矩阵，并进行<strong>安全性算法</strong>检查；未通过则复原矩阵，拒绝请求</li></ul><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><ol><li>设置两个向量：<ul><li><code>Work</code>：一个 m 个元素的向量，表示系统可提供的资源数，初始值与$Available$相同</li><li><code>Finish</code>：表示系统是否有足够资源进行分配，初始时为 <code>false</code></li></ul></li><li>从进程集合中找到一个进程 $i$，满足：<ul><li>$Finish[i] = false\ \ &amp;&amp;\ \ Work \gt Need(i)$，说明进程 $i$ 可以正常结束，并释放 $Max(i)$ 所占用的全部资源</li><li>令 $Finish[i] = true\ \ &amp;&amp;\ \ Work\ += Allocation(i)$，并重复本过程，直至找不到满足条件的进程</li></ul></li><li>循环结束，检查此刻的 $Finish$ 向量，如果满足所有进程均为 <code>true</code>，则说明系统出于安全状态（能找到一个序列进行资源的分配）；否则系统将处于不安全状态</li></ol><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>允许互斥、资源部分分配、满足不可抢占、资源利用率高</li><li>要求进程预先计算最大资源请求，难以实现</li></ul><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><blockquote><p>保存资源的请求、分配信息，判断是否会在分配的过程中发生死锁</p></blockquote><h4 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h4><p><strong>资源分配图算法</strong>：一个有向图 $G$ 的顶点为<strong>资源或进程</strong>，这个图的边有两种属性：</p><ul><li>进程 → 资源：进程发起资源的<strong>请求</strong>，也叫<strong>请求边</strong></li><li>资源 → 进程：资源已经<strong>分配</strong>给进程，也叫<strong>分配边</strong></li></ul><p>对于它的进程顶点，也有两种属性：</p><ul><li>封锁进程：请求了超过系统中未分配的总数的资源</li><li>未封锁进程：与封锁进程相对应</li></ul><p>在这样的资源分配图中，若要发生死锁，则图中必须有环，<strong>反之则不然</strong>。</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305300040363.png" alt="有环无死锁案例"></p><p>图中 $R$ 为进程节点， $P$ 为资源节点</p><h4 id="资源分配图的化简"><a href="#资源分配图的化简" class="headerlink" title="资源分配图的化简"></a>资源分配图的化简</h4><p>对于一个非封锁进程，有如下的化简流程：</p><ul><li>对于所有请求边，都转化为分配边</li><li>当进程只含有分配边时，说明程序所需的所有资源请求都已满足，这时等待程序结束释放资源</li><li>释放资源时将所有的分配边也去掉，只保留进程和资源的节点</li></ul><h4 id="死锁定理"><a href="#死锁定理" class="headerlink" title="死锁定理"></a>死锁定理</h4><p>系统处于死锁状态，当且仅当资源分配图不可完全化简；换言之，若能消去所有边，即说明资源请求关系已被处理，则系统不处于死锁状态。</p><h2 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h2><p>死锁解除要求释放资源的进程恢复到原来的状态，保证程序的正常运行。</p><ul><li>资源剥夺法：先挂起一些进程，暂时释放它们拥有的资源，供其他进程调度<ul><li>保证不总是剥夺一个进程的资源，均匀处理</li></ul></li><li>撤销进程法：使全部进程按照某种顺序回退，直至死锁状态消除<ul><li>经济合算的算法使得进程回退带来的开销最小</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305300057566.png" alt="死锁小结"></p><h1 id="章节总结"><a href="#章节总结" class="headerlink" title="章节总结"></a>章节总结</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><ul><li>进程由程序段、数据、进程控制块三部分构成</li><li></li><li>管道机制允许两个进程按<strong>生产者 - 消费者</strong>方式进行通信</li><li>内核级线程需要进入内核切换，用户级线程不需要；内核级线程可以按线程阻塞，用户级只能按进程</li><li>并发进程失去<strong>封闭性</strong>，指并发进程共享变量，其执行结果与速度有关（可受到外界影响）</li><li>关于数据结构的存放：<ul><li>正文段：全局<strong>变量</strong>（赋值 → <code>.data</code>、未赋值 → <code>.bss</code>），常量</li><li>进程控制块：进程优先级</li><li>堆区：<code>malloc</code> 等动态申请的存储区域</li><li>栈区：函数调用传递的参数、未赋值的局部<strong>变量</strong></li></ul></li><li><strong>进程唤醒</strong>指的是重新进入就绪态，并不能直接进入运行态，唤醒类似于 <code>notifyAll</code>，同时要区分唤醒（阻塞 → 就绪）与调度（就绪 → 运行）的区别</li><li>用户级线程可以在任意操作系统中执行，因为其实现基于用户程序</li></ul><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><ul><li>对短作业不利的是先进先出算法，所有因抢占式处理不当可能出现饥饿的调度算法都对长作业不利</li><li>考虑紧急作业时使用剥夺式优先级算法，提前运行特定任务；考虑人机交互时使用时间片轮转算法，均衡运行各个任务</li><li>优先级算法是绝对可抢占的</li><li>$响应比=\frac{等待时间+运行时间}{运行时间}$</li><li>$周转时间=处理结束时间-任务进入系统的时间$ ，计算平均周转时间时要记得减去任务进入的时间点</li></ul><h2 id="同步与互斥-1"><a href="#同步与互斥-1" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>临界区是指并发进程访问临界资源（共享变量）的代码程序</li><li>对并发进程同步的原因是并发进程是异步的</li><li>临界区的执行可以被中断，例如申请 I/O，但内核态的临界区不会中断</li><li>管程定义了共享数据结构和各种进程在该数据结构上的全部操作</li><li>用信号量实现互斥，初值为 1；实现同步，由用户决定</li><li>当采用“读/写者优先”的策略时，有可能会使得另一种角色发生<strong>饥饿</strong></li><li>管程中的 <code>signal</code> 与 <code>V</code> 操作不同，V一定释放信号量，signal 可能没有待唤醒的进程</li><li>并发进程是时间上重合的，可能有交互也可能没关系</li><li>信箱通信是一种间接通信方式</li></ul><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ul><li>破坏四个必要条件的方式：<ul><li>循环等待：资源有序分配策略</li><li>不剥夺：暂时释放已有资源</li><li>请求并保持：预先静态分配，运行前一次性申请所有资源</li><li>无法破坏互斥条件</li></ul></li><li>资源分配图是一个有向图，用于表示某时刻<strong>系统资源</strong>与<strong>进程</strong>之间的关系</li><li>当每种资源都只有一个，且出现环路时，必然死锁；若没有前提限制，则不一定死锁</li><li>产生死锁的根本原因是系统资源分配不足和进程推进顺序非法</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter3-2</title>
      <link href="/p/8889.html"/>
      <url>/p/8889.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-内存管理-Part2"><a href="#第三章-内存管理-Part2" class="headerlink" title="第三章 内存管理 - Part2"></a>第三章 内存管理 - Part2</h1><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><blockquote><p>通过分页式存储管理可以把一个逻辑地址连续的程序装入到若干不连续的物理地址中，这可充分利用存储空间、减少移动带来的开销</p></blockquote><p>主要针对的问题：</p><ul><li>动态内存分配</li><li>碎片、紧凑问题</li></ul><p>定义：</p><ul><li>页：每个作业的<strong>地址空间</strong>分成的<strong>大小相同</strong>的片</li><li>存储块/页框：主存的<strong>存储空间</strong>也被分为与页相同大小的片</li></ul><h2 id="分页地址结构"><a href="#分页地址结构" class="headerlink" title="分页地址结构"></a>分页地址结构</h2><blockquote><p><code>页号 | 偏移量</code></p></blockquote><p>分页式结构下，地址由两部分组成，页号可以是物理块号也可以是逻辑页号，两者可以转换</p><ul><li><p>逻辑地址、物理地址在同一系统内的页/块内偏移位数（大小）一致</p></li><li><p>给定一个逻辑地址空间中的地址为 A ，页面的大小为 L ，则页号 P 和页内地址 d（从0 开始编号）为</p><ul><li>$P=INT[\frac A L],d=[A]modL$</li></ul></li><li><p><strong>页面大小</strong>是由硬件决定的，通常选用$2^n$作为页大小，最常用的页面大小为4KB</p><ul><li>若采用小页面：页内碎片、内存碎片减少，提高内存利用率；页面数多，<strong>页表</strong>占用内存大；换进换出速度降低，但<strong>效率高</strong>；若采用大页面则特点相反</li><li>分页开销为$\frac{se}p+\frac p 2$（页面大小$p=\sqrt{2se}$，进程平均字节s，页表项e）</li></ul></li><li><p>逻辑上相邻的页，在物理地址上不一定相邻</p></li></ul><h2 id="页表数据结构"><a href="#页表数据结构" class="headerlink" title="页表数据结构"></a>页表数据结构</h2><ul><li>进程页表：每个进程具有一个页表，描述该进程逻辑页与物理块的映射关系</li><li>物理页面表：整个系统只拥有一个物理页面表，描述物理空间的分配情况</li><li>请求表：整个系统有一个请求表，描述系统内各进程页表的大小额位置，用于地址转换</li></ul><p>页表的作用：</p><ul><li>记录进程的内存分配情况</li><li>实现进程运行时的动态重定位</li><li>访问内存数据需要访问内存两次（页表+内存地址）</li></ul><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>当逻辑地址较大时会导致页表增大，可以采用多级页表或动态调入页表的方式解决</p><ul><li>动态调入页表：只把部分页表项调入内存，待需要其他页面时再调入</li></ul><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><ul><li>逻辑地址划分：<code>二级页表|一级页表|页内地址</code></li><li>将一级页表再进行分页，将页表分散地存放在物理块中，再使用外部页表记录这些页</li><li>正在运行的进程必须调入二级页表，但是一级页表可以按需调入内存</li><li>对多级页表来说，各级页表存放的都是<strong>物理块号</strong>，他们指向内存中的下级页表或真正的被访问页</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201213740.png" alt="image-20230220121318596" style="zoom:67%;" /><h2 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h2><p>逻辑地址转换为物理地址：</p><ul><li>根据页号在页表中查询对应的项（页表始址+页号*页表项长度）</li><li>读出页表项对应的物理块号</li><li>使用<code>块号+页内地址</code>合成出物理地址</li></ul><h2 id="纯分页系统"><a href="#纯分页系统" class="headerlink" title="纯分页系统"></a>纯分页系统</h2><blockquote><p>若系统不支持内存主存的页面对换功能，就必须把程序的页一次性地装入内存；若当前内存不足则必须等待空闲</p></blockquote><p>优点</p><ul><li>没有外碎片，每个内碎片小于页大小（毕竟按页分块）</li><li>程序不必连续在内存中存放，系统可以轻易完成该进程新数据的装载</li></ul><p>缺点：</p><ul><li>程序需要一次性全部装入内存，占用开销大</li></ul><h2 id="MMU（Memory-Management-Unit）"><a href="#MMU（Memory-Management-Unit）" class="headerlink" title="MMU（Memory Management Unit）"></a>MMU（Memory Management Unit）</h2><blockquote><p>CPU为了提高地址转换效率，添加了一个硬件单元MMU，其主要包括：</p><ul><li>快表TLB：存放于虚拟地址相关的物理地址</li><li>TLB控制单元：TLB内容的填充覆盖、越界检查</li><li>页表查找单元：当TLB未命中时查找页表并输送给TLB单元</li></ul></blockquote><ul><li>MMU的工作流程：<ul><li>先在TLB中查询，成功匹配则分段查询（如果有多级页表）页表并得到物理地址；若未匹配则到外部页表中查询并置换进TLB中</li><li>根据TLB项判断是否符合访问规范</li><li>符合规范后再分段查询页表，返回物理地址</li></ul></li></ul><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><blockquote><p>TLB，即Translation Lookaside Buffer，是专门针对页表项的高速缓存Cache，其<strong>内容是</strong>页表中的一部分或全部内容</p></blockquote><ul><li>TLB的工作流程<ul><li>接收CPU产生的逻辑地址并将其分解为虚拟页码和页内地址</li><li>根据页码号在TLB中寻找有无对应的条目：成功匹配则返回物理块；若未命中则前往完整页表中寻找，并将页表项复制进TLB中</li><li>最终合成出物理块+页内地址形式的物理地址</li></ul></li><li>通常TLB的条目数在$64\textasciitilde1024$之间，并且有些条目有可能不能被替换出TLB（比如内核代码）</li><li><code>ASID</code>：其可以用来唯一地标识进程，只有当申请访问的程序和页表项对应的进程一致（<code>ASID</code>相同）才允许访问，否则即说明<strong>页表项失效</strong><ul><li>（说明不同的程序正在访问相同的虚拟页码，因不同程序的映射规则不同，对应的物理块也不会一致，此时存放的物理块号是错误的）</li><li>如果允许TLB同时包含多个进程的页表项时，每次选择页表TLB都必须被<code>flushed</code>或删除，以确保下一个进程不会使用不匹配的映射</li></ul></li></ul><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><blockquote><p>一般意义上的页表构造了一个虚拟页$\to$物理块的映射，当虚拟页数量大时会消耗大量内存；而反置页表则是构建了一个物理块$\to$虚拟页的映射，其为每个物理块都说明了对应的虚拟页</p></blockquote><ul><li>反置页表项：<code>进程ID|逻辑页号</code></li><li>反置页表中，每一个物理块$i$都对应着反置页表的第$i$项，而第$i$项的信息则提示了这个物理块属于哪个进程、<strong>对应了哪个逻辑页</strong></li><li>通过构造反向的映射，<strong>反置页表的大小</strong>只与物理内存的大小相关</li><li><strong>反置页表的工作流程</strong>：<ul><li>利用进程ID和虚拟页号在反置页表中<strong>遍历所有项</strong>（相当于查询所有物理块）</li><li>如<strong>第$i$项</strong>产生匹配，则该虚拟页对应的**物理块号就为$i$**；如未发生匹配，则说明此虚拟页未存放在内存中，申请从主存中调页</li><li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282220544.png" alt="image-20230220183050472" style="zoom:67%;" /></li></ul></li><li>可以借助哈希表，将反置页表改造成反置链表：通过虚拟页码指向对应链表的头，进而仅查询该链表中的表项，从而减少遍历带来的时间消耗<ul><li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201834843.png" alt="image-20230220183423808" style="zoom:67%;" /></li><li>（只查询图中<code>Page Table</code>中的<code>Chain</code>内容即可）</li></ul></li><li>采用反置页表的系统难<strong>共享内存</strong>：每个物理块只对应一个虚拟页条目</li></ul><h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><ul><li>页的共享：对于多个程序需要共享同一个物理块的数据/程序时，应让它们包含该块的虚拟地址全部指向相同的物理块</li><li>共享带来的问题：<ul><li>若共享、不共享数据被划分在同一块内，将泄露数据；可以采用分段存储管理的方式专门对公开数据进行共享</li></ul></li><li>页的保护：<ul><li>地址越界保护</li><li>在页表中设置保护位：定义访问时的操作权限（有可能不同进程对相同的共享数据拥有不同的权限）</li></ul></li></ul><h1 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h1><blockquote><p>对于一个程序的各组成部分来说，他们对内存的需求并不相同</p></blockquote><ul><li>编程用户<ul><li>用户一般按照<strong>逻辑关系</strong>对作业分段，并根据名字访问程序段和数据段</li></ul></li><li>信息共享<ul><li>共享是以信息的<strong>逻辑单位</strong>——段，为基础的；而存储却是以物理单位——页，进行的</li><li>共享段的难度要比共享页的难度高</li></ul></li><li>信息保护<ul><li>一个页中可能存放了多个程序的内容，简单的页分享可能会导致数据的错误泄露</li><li>可以对信息采取段为单位进行分享和保护</li></ul></li><li>动态增长<ul><li>在进程运行的过程中，某些数据段可能会不断增长，存储管理方法存在困难</li></ul></li><li>动态链接<ul><li>在程序运行时才把目标程序和主程序进行链接</li></ul></li></ul><h2 id="分段地址空间"><a href="#分段地址空间" class="headerlink" title="分段地址空间"></a>分段地址空间</h2><blockquote><p>将<strong>段</strong>作为地址的分割依据，使得地址空间由各个分段组成，这些段可以不相连，但一个段的内部地址一定连续</p></blockquote><ul><li><strong>逻辑地址结构</strong>：<code>段号|位移量</code><ul><li>分区：按照磁盘的物理地址对内存进行划分</li><li>分页：按照固定大小的页对内存进行划分</li><li>分段：按照程序段长度对内存进行划分（分段长度自由，前两者都已固定）</li></ul></li></ul><h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><ul><li>段表记录了段号与内存物理地址的对应关系，并存放于内存当中</li><li>基址与长度由段表寄存器给出</li><li>优点：<ul><li>易于实现段的共享与保护</li></ul></li><li>缺点：<ul><li>处理地址花费时间，也要考虑段表的占用内存</li><li>为满足分段的动态增长、减少外碎片，要采用拼接内存的手段</li><li>在辅存中难管理不定长度的分段</li><li>分段尺寸受到内存大小的限制，不能超出内存空间</li></ul></li></ul><h3 id="地址变换过程-1"><a href="#地址变换过程-1" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul><li>查询申请访问的段号是否在段表内，如果超界则产生中断</li><li>检查段内位移量是否超出段的长度，如果超界则产生中断</li><li>若均为越界，则返回对应段号所在的物理地址<strong>基址</strong>，与段内位移量相加则得到物理地址</li></ul><h3 id="段共享"><a href="#段共享" class="headerlink" title="段共享"></a>段共享</h3><blockquote><p>若对于某一个程序/程序段，会被众多用户/程序调用，那么就可以共享这个段，声明其为<strong>可重入的</strong>，这样只需要保留一份<strong>只读代码</strong>在内存当中即可</p></blockquote><h1 id="分页式与分段式的比较"><a href="#分页式与分段式的比较" class="headerlink" title="分页式与分段式的比较"></a>分页式与分段式的比较</h1><ul><li>分页式地址空间是一维线性的；分段式则是二维地址空间</li><li><strong>页</strong>是信息的物理单位，其大小固定；<strong>段</strong>是信息的逻辑单位，其大小不定（但总具有完整的意义）</li><li>分页用户不可见，系统直接操作内存；分段用户可见</li></ul><p>分页有效解决了碎片问题，同时使得程序可以不连续存放</p><p>分段实现了数据高效共享与保护，可便捷所需空间动态增长的程序，也利于动态链接</p><h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><blockquote><p>段页式内存管理是分段、分页原理的结合：系统先将程序分为若干段，再把每段按照固定大小进行分页</p></blockquote><ul><li><strong>逻辑地址结构</strong>：<code>段号|段内页号|页内地址</code></li><li>访问时先访问内存的段表，找到<strong>对应页表</strong>的起始地址；再查该段的页表，找到段内页号对应的物理块号，最后根据物理块和页内地址访问物理内存</li><li>在逻辑上，程序被分成了长度不同的段，<strong>段内连续</strong>；在空间上，程序的段被分为了长度相同的页，<strong>段内不连续</strong></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202002672.png" alt="image-20230220200154810"></p><h2 id="x86的段页式实现（待补）"><a href="#x86的段页式实现（待补）" class="headerlink" title="x86的段页式实现（待补）"></a>x86的段页式实现（待补）</h2><h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><blockquote><p>覆盖，就是一个相对独立的程序单位。一个大的程序可以划分为一系列的覆盖</p></blockquote><ul><li>覆盖段：程序执行时并不要求同时装入主存的一组覆盖；这个覆盖段被分到同一个存储区域（覆盖区）</li><li>使用覆盖则必须在编程时提前确定模块间的覆盖关系，时间换空间</li></ul><blockquote><p>交换，把暂时不用的数据/程序从内存转移到辅存中，再把使用的数据转入主存</p></blockquote><ul><li>交换可以增加并发的程序数目；提供适当的响应时间</li><li>交换会增加处理机开销；没有考虑执行过程中地址访问的统计特性</li></ul><blockquote><p>因为<strong>在同一个覆盖段内</strong>的两个覆盖不会同时使用，所以可以对两个覆盖进行交换</p></blockquote><h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><blockquote><p>局部性原理指在执行过程中的一个较短的时间内执行的指令和其操作数的地址都在都某区域内并受到约束</p></blockquote><ul><li>时间局部性：一条指令、一段数据的前后两次访问集中在某时间内</li><li>空间局部性：邻近的几条指令，访问的数据集中在某区域内</li><li>当程序出现对某数据结构的多次操作，通常局限在较小的范围内</li></ul><blockquote><p>快排的局部性比堆排好：堆排使得数据在整个数组内做大范围的跳动，而快排的数据访问间隔比较小，显然快排的空间局部性更好</p></blockquote><h1 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h1><blockquote><p>虚拟存储为每个进程提供了一个连续完整的地址空间，利用了主存和磁盘的特点（类似于Cache和主存的关系，下沉了一层，但两者<strong>有一定区别</strong>）</p></blockquote><blockquote><p>虚拟内存把地址空间定义为连续的虚拟内存地址，欺骗程序在使用一大段连续地址</p></blockquote><ul><li>每个进程都认为自己正在独占系统的所有内存；但并不是所有内容都直接放置在内存中，操作系统遵循<strong>覆盖</strong>的规则保留一部分内容</li><li>虚存保护了每个进程的地址访问操作，防止出现冲突</li><li>虚拟存储在主存和硬盘存储间<strong>交换</strong>，利用了主存的快速、硬盘的大空间特点</li></ul><h2 id="虚拟存储的基本原理"><a href="#虚拟存储的基本原理" class="headerlink" title="虚拟存储的基本原理"></a>虚拟存储的基本原理</h2><ul><li>按需装载：只需要将当前需要的分页/分段读入内存，后续需要的页/程序段在使用时再读入</li><li>缺页调入：在执行过程中发生缺页/缺段时从磁盘调入内存</li><li>不用调出：操作系统将内存不常用的页/段归还磁盘外存，调出后的空间供新的页/段调入使用</li></ul><h2 id="虚拟存储的特征"><a href="#虚拟存储的特征" class="headerlink" title="虚拟存储的特征"></a>虚拟存储的特征</h2><ul><li>离散性：物理内存分配上的不连续性、虚拟地址使用上的不连续性</li><li><strong>多次性</strong>：（<strong>分时复用</strong>）分多次调用程序进入内存，使得虚拟存储具有了在逻辑上<strong>扩大内存</strong>的功能；这时虚拟存储最重要的特征</li><li>对换性：内存、外存可进行交换，提高内存利用率</li><li>虚拟性：虚拟存储允许程序从逻辑的角度上访问存储器，而不需考虑实际的物理空间</li></ul><blockquote><p>虚拟性以多次性和对换性为基础</p><p>多次性、对换性以离散性为基础</p></blockquote><p>优点：</p><ul><li>程序调用的内存限制扩大，通常大于物理内存</li><li>可容纳更多的程序并发执行</li><li>不影响编程时的程序结构（与覆盖技术相比）</li></ul><p>缺点：</p><ul><li>时间换空间，以CPU工作时间和内外存交互的长时间为代价</li></ul><p>限制：</p><ul><li><strong>虚拟内存的最大容量由计算机的地址结构决定</strong></li></ul><h2 id="虚拟内存与Cache"><a href="#虚拟内存与Cache" class="headerlink" title="虚拟内存与Cache"></a>虚拟内存与Cache</h2><p>相同点：</p><ul><li>都为分层存储体系：充分利用高速存储器的速度和低速存储器的容量</li><li>原理相同：利用程序的局部性原理，进行信息的部分调用</li></ul><p>不同点：</p><ul><li>Cache侧重访问低速存储器的速度问题，虚存侧重高速存储器的容量问题（+内存管理、保护等）</li><li>CPU可直接访问内存；但不能直接访问外存，仍需要调取至内存才能访问</li><li>透明性不同：Cache作为硬件对程序员透明；虚存采用软件管理，受操作系统控制（对实现存储管理的系统程序员不透明，对应用管理员透明）</li><li>损失不同：主存未命中的损失远大于Cache未命中的损失</li></ul><h2 id="虚拟内存名词解释"><a href="#虚拟内存名词解释" class="headerlink" title="虚拟内存名词解释"></a>虚拟内存名词解释</h2><h3 id="进程的逻辑空间（虚拟空间）"><a href="#进程的逻辑空间（虚拟空间）" class="headerlink" title="进程的逻辑空间（虚拟空间）"></a>进程的逻辑空间（虚拟空间）</h3><p>使用虚存技术后对单个程序可见的空间，从0开始编址。这段空间逻辑上连续，但并不实际存在于内存/外存中</p><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230220212737131.png" alt="image-20230220212737131" style="zoom: 60%;" /><h3 id="虚拟地址空间与虚拟存储（内存）空间"><a href="#虚拟地址空间与虚拟存储（内存）空间" class="headerlink" title="虚拟地址空间与虚拟存储（内存）空间"></a>虚拟地址空间与虚拟存储（内存）空间</h3><p>进程的虚拟地址空间是进程在内存中存放的逻辑视图</p><p>一个程序的虚拟地址空间与虚拟存储空间大小相同</p><h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>一段按页划分的磁盘空间，对用户不可见</p><p>在物理内存不足时存放内存数据，为其他进程解放物理内存</p><h2 id="虚拟内存需要解决的问题"><a href="#虚拟内存需要解决的问题" class="headerlink" title="虚拟内存需要解决的问题"></a>虚拟内存需要解决的问题</h2><ul><li>地址映射问题：<strong>进程的逻辑空间</strong>到实际内存的映射问题</li><li>调入问题：调入机制、调入块的选择</li><li>替换问题：调出相关问题</li><li>更新问题：内存、外存数据的同步</li><li>其他问题：存储保护、程序重定位等</li></ul><h2 id="虚存的地址映射"><a href="#虚存的地址映射" class="headerlink" title="虚存的地址映射"></a>虚存的地址映射</h2><ul><li>内核在进程创建时没有把程序与数据交换进物理内存中（此时仅建立<code>虚存-磁盘</code>的映射），等到需要使用时才会通过<strong>缺页机制</strong>交换数据</li><li>用户可执行文件和共享库都以文件的形式存储在磁盘中，在页表中类型为<code>file backed</code></li><li><code>heap</code>和<code>stack</code>在磁盘上没有对应的文件，类型为<code>anonymous</code>，<strong>地址为空</strong></li><li><strong>未分配部分</strong>没有对应的页表项，只有当<code>malloc</code>申请内存时才建立页表项</li></ul><h2 id="虚存的调用机制"><a href="#虚存的调用机制" class="headerlink" title="虚存的调用机制"></a>虚存的调用机制</h2><blockquote><p>调入主存的数据有两类：</p><ul><li>OS的核心程序与数据</li><li>正在运行的用户进程相关的程序与数据</li></ul><p>借助<strong>缺页错误处理</strong>机制进行调用</p></blockquote><ul><li><p>调用时间：</p><ul><li>OS在系统启动时调入</li><li>用户数据调入有不同策略：预调页、按需调页</li></ul></li><li><p>预调页：同时将<strong>所有页</strong>都调入内存中，阻止大量开始运行时产生的页错误</p></li><li><p>按需调页：只有当缺页时才进行调用，类似使用<strong>交换</strong>的分页系统</p></li><li><p><strong>缺页错误处理机制过程</strong>：</p><ul><li>现场保护：发现异常进入内核态，保存现场信息</li><li><strong>页面定位</strong>：查找异常的虚拟页面</li><li>权限检查：检查虚拟地址有效性、安全保护位，出错则<code>kill</code></li><li>新页面调入1：通过页面置换找到一个需要换出的物理页</li><li><strong>旧页面写回</strong>：把这个物理页写回外存（需要置为忙状态，以防被其他进程抢占）</li><li><strong>新页面调入2</strong>：将虚存所需的页面从外存调入内存</li><li><strong>更新页表</strong>：项操作系统发出中断，更新内存的页表项</li><li>恢复现场</li></ul></li></ul><h1 id="实存管理与虚存管理"><a href="#实存管理与虚存管理" class="headerlink" title="实存管理与虚存管理"></a>实存管理与虚存管理</h1><p>实存管理方法：分区、分页、分段、段页式</p><p>虚存管理方法：（向外存）请求分页、请求分段、请求段页式</p><h2 id="请求分页-段式系统"><a href="#请求分页-段式系统" class="headerlink" title="请求分页/段式系统"></a>请求分页/段式系统</h2><p>与原本的分页/段式类似，只不过内存中只存放了部分的程序和数据，待其启动后再按需从外存中以页/段为单位进行调用即可</p><ul><li>硬件支持：页表/段表机制、缺页/缺段时的中断机构和地址变换机构</li><li>软件支持：请求调页/段、请求页/段置换的功能</li><li>页表项：<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202155726.png" alt="image-20230220215555699" style="zoom:67%;" /><ul><li>驻留位：1-在内存；0-在外存</li><li>保护位：只读、可写、可执行</li><li>修改位：此页在内存中有无修改操作</li><li>访问位：用于页面置换算法</li></ul></li></ul><h2 id="虚存页面置换策略"><a href="#虚存页面置换策略" class="headerlink" title="虚存页面置换策略"></a>虚存页面置换策略</h2><h3 id="最优置换策略"><a href="#最优置换策略" class="headerlink" title="最优置换策略"></a>最优置换策略</h3><blockquote><p>把所有页中未来最久不会被使用的页替换出去</p></blockquote><ul><li>具有最低的页错误率，然而这种方法不可能被实现</li></ul><h3 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h3><blockquote><p>当需要替换页时，把最先进入的页替换出去</p></blockquote><ul><li>借助一个队列，新访问的页面插入队尾，替换的页从队首出队</li><li><strong>性能较差</strong>：较早调入的页访问通常较多</li><li>Belady现象：分配的页面数增多，但缺页率却增高的现象</li></ul><blockquote><p>FIFO的置换特征，与进程访问内存的动态特征是矛盾的</p></blockquote><h3 id="Second-Chance策略、Clock（最近未使用算法）策略"><a href="#Second-Chance策略、Clock（最近未使用算法）策略" class="headerlink" title="Second Chance策略、Clock（最近未使用算法）策略"></a>Second Chance策略、Clock（最近未使用算法）策略</h3><blockquote><p>Second Chance是改进后的FIFO法，给每一个页面一个标记位，记录此页面是否被访问过</p></blockquote><ul><li>如果将要被换出的页面曾被访问过，就清除标记位，放至队尾重新入队；否则直接出队</li><li>当所有页面<strong>都被访问过</strong>时，也直接出队</li></ul><blockquote><p>Clock在Second Chance的基础上变更为了<strong>环形队列</strong>；在注意指针移动的基础上，其余操作保持一致</p></blockquote><ul><li><strong>FIFO类算法对比</strong>：<ul><li>命中率：Clock = Second &gt; FIFO</li><li>复杂度：Second &gt; Clock &gt; FIFO</li><li>代价：Second &gt; Clock &gt; FIFO</li></ul></li></ul><h3 id="LRU（最近最少使用）策略"><a href="#LRU（最近最少使用）策略" class="headerlink" title="LRU（最近最少使用）策略"></a>LRU（最近最少使用）策略</h3><blockquote><p>根据页面的历史访问记录进行替换：最近使用过的数据将来的访问几率更高</p><p>这种算法是局部性原理的合理近似，但硬件开销较大</p></blockquote><ul><li>设置一个栈，保存当前的所有页面号</li><li>当某个页面被访问时，取出栈中的页面号，重新压栈</li><li>当需要替换时，退出栈底的元素</li></ul><h4 id="AGING（老化算法）策略（-待补）"><a href="#AGING（老化算法）策略（-待补）" class="headerlink" title="AGING（老化算法）策略（*待补）"></a>AGING（老化算法）策略（*待补）</h4><blockquote><p>AGING是LRU的一种简化，性能上接近LRU，但减少了硬件开销</p></blockquote><ul><li>为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入。</li></ul><h3 id="虚存同步更新问题"><a href="#虚存同步更新问题" class="headerlink" title="虚存同步更新问题"></a>虚存同步更新问题</h3><blockquote><p>当一个页面被换出时，为了保持内存外存信息的一致性，必要时需要进行信息的更新</p></blockquote><ul><li>换出页面为<code>file backed</code>类，并未被修改：直接<code>discard</code>，因外存含有副本</li><li>换出页面为<code>file backed</code>类，但有修改：写回原有位置，因外存副本过期</li><li>换出页面为<code>anonymous</code>类，若第一次换出+未修改：写入<code>Swap</code>区；否则<code>discard</code></li><li>换出页面为<code>anonymous</code>类，且有修改：写入<code>Swap</code>区</li></ul><h2 id="工作集与驻留集管理"><a href="#工作集与驻留集管理" class="headerlink" title="工作集与驻留集管理"></a>工作集与驻留集管理</h2><blockquote><ul><li><strong>工作集</strong>：<strong>过去一段时间内</strong>进程访问的页面集合</li><li><strong>驻留集</strong>：进程被分配的物理页集合</li></ul></blockquote><h3 id="工作集策略"><a href="#工作集策略" class="headerlink" title="工作集策略"></a>工作集策略</h3><blockquote><p>引入工作集是为了调整驻留集的大小</p></blockquote><p>当进程开始执行后，工作集随着页面加载逐渐稳定；当进程的局部性区域变化时，工作集进行一次快速扩张和收缩，再到达一个稳定的值</p><h1 id="页表与自映射"><a href="#页表与自映射" class="headerlink" title="页表与自映射"></a>页表与自映射</h1><blockquote><p>假设页式内存管理中，一页大小为 a Byte，一个页表项的大小为 b Byte，且页表起始地址为 x（保证<strong>页对齐</strong>），求页目录（自映射）的地址？</p></blockquote><p>在实验课中我们很容易就能回答，答案是 x + x &gt;&gt; 10，但是怎么来的还是要有自己的理解。</p><p>首先可知，页表在所有页面的第 x / a 页上，那么页目录就应该从页表的起始地址向后数和页面数同样多的页表项数，这样取到的页表项就恰好对应页表的起始地址，也就是向后数 (x / a) * b Byte</p><p>最后再加上起始的页表基地址，结果为 <strong>x + (x / a) * b</strong></p><p>在这里代入 MOS 的数据，就是 x + (x / 4096) * 4 = x + x &gt;&gt; 10了</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter3-1</title>
      <link href="/p/9209.html"/>
      <url>/p/9209.html</url>
      
        <content type="html"><![CDATA[<h1 id="第三章-内存管理-Part1"><a href="#第三章-内存管理-Part1" class="headerlink" title="第三章 内存管理 - Part1"></a>第三章 内存管理 - Part1</h1><h1 id="存储器的管理"><a href="#存储器的管理" class="headerlink" title="存储器的管理"></a>存储器的管理</h1><ul><li>存储层次：寄存器-cache-主存-外存</li><li>存储管理的基本目标：<strong>地址独立</strong>（程序地址与物理地址无关）、地址保护（程序之间不能访问）</li><li>存储管理的核心问题：分配和回收</li><li>地址变换：可执行文件生成中的链接技术、程序加载时的重定位技术，进程运行时硬件和软件的地址变换技术和机构。</li><li>存储共享与保护：代码数据共享对地址空间的访问权限</li><li>存储器扩充：存储器的逻辑组织和物理组织</li><li><strong>地址空间与存储空间</strong><ul><li>地址空间（<strong>虚拟地址</strong>）：程序编译后限定于地址空间内，是<strong>逻辑地址</strong>的集合</li><li>存储空间（<strong>物理地址</strong>）：主存存储单元相关，是<strong>物理地址</strong>的集合</li></ul></li></ul><h1 id="单程序的内存管理"><a href="#单程序的内存管理" class="headerlink" title="单程序的内存管理"></a>单程序的内存管理</h1><blockquote><p>此情况下内存中只有操作系统和一个用户程序</p></blockquote><ul><li>操作系统只占用固定空间</li><li>用户程序永远从同一个地方开始运行，地址在运行前可以进行计算</li></ul><ul><li>方法：<ul><li>静态地址翻译：在程序运行前计算出所用的物理地址（可以由程序加载器实现），且无需地址翻译，运行速度快</li></ul></li><li>缺点：<ul><li>比物理内存大的程序无法加载、运行</li><li>不区分常用数据导致资源浪费</li></ul></li></ul><h1 id="多程序的内存管理-分区式内存管理"><a href="#多程序的内存管理-分区式内存管理" class="headerlink" title="多程序的内存管理 - 分区式内存管理"></a>多程序的内存管理 - 分区式内存管理</h1><blockquote><ul><li>把内存分为相等或不等的分区，操作系统占用一个分区，每个程序占用一个/多个分区</li><li>支持多程序并发执行，但难以进行内存分区的<strong>共享</strong></li></ul></blockquote><h2 id="静态式分区分配：程序适应分区"><a href="#静态式分区分配：程序适应分区" class="headerlink" title="静态式分区分配：程序适应分区"></a>静态式分区分配：程序适应分区</h2><ul><li>存储空间被分为任意大小的区域，区域大小不能更改，每次获取一部分分区进行作业</li><li>分区数据统计：分区表</li><li>分区分配：以待分配程序构成的队列<ul><li>单队列：所有程序在一条队列中等待任意一个空白分区</li><li>多队列：每个分区都有若干大小相近的程序等待</li></ul></li><li>优点：开销小，实现简单</li><li>缺点：<strong>内碎片浪费</strong>、分区数目受限</li></ul><p>静态式分区也被叫做固定式分区，其<strong>允许不同分区大小不同</strong></p><h2 id="动态式分区分配：分区适应程序"><a href="#动态式分区分配：分区适应程序" class="headerlink" title="动态式分区分配：分区适应程序"></a>动态式分区分配：分区适应程序</h2><ul><li>分区的边界可以进行移动，即动态地改变分区大小，以适应程序需要</li><li>优点：无内碎片</li><li>缺点：<strong>有外碎片</strong></li></ul><h2 id="可变分区分配（不常用）"><a href="#可变分区分配（不常用）" class="headerlink" title="可变分区分配（不常用）"></a>可变分区分配（不常用）</h2><ul><li>内存分配使用两张表：已分配分区表和未分配分区表；<ul><li>每张表单项为存储控制块<code>MCB</code>，分配了的即<code>AMCB</code>(allocated)，未分配即<code>FMCB</code>(free)</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181509788.png" alt="image-20230218150958760" style="zoom:67%;" /><ul><li>空闲分区中的一小部分作为<strong>存储控制块</strong>按次序形成<code>FMCB</code>链表结构；当分区被分配后，前后指针无意义</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181512892.png" alt="image-20230218151214857" style="zoom:50%;" /><h1 id="系统中的碎片"><a href="#系统中的碎片" class="headerlink" title="系统中的碎片"></a>系统中的碎片</h1><blockquote><p>内存中无法被利用的存储空间被称为<strong>碎片</strong></p></blockquote><ul><li>内部碎片：<ul><li>分区分配后，区块内没被使用的内存</li><li><strong>分区大小固定</strong>的存储管理方式均会出现内部碎片</li><li>内部碎片无法整理，只能等待程序结束后释放整个分区，从而释放这些碎片</li></ul></li><li>外部碎片：<ul><li>系统无法利用的空闲分区、分区<strong>间</strong>存在的内存，空间小且不连续</li><li>动态分区管理会产生外部碎片</li><li>外部碎片是<strong>造成内存系统性能下降的主要原因</strong>，对分区进行<strong>紧凑处理</strong>可消除外部碎片</li></ul></li></ul><h2 id="闲置空间的管理"><a href="#闲置空间的管理" class="headerlink" title="闲置空间的管理"></a>闲置空间的管理</h2><blockquote><p>操作系统跟踪内存的两种方法：位图表示法（<strong>分区表</strong>）、链表表示法（<strong>分区链表</strong>）</p></blockquote><ul><li>位图表示法：给每个分区赋予一个字位，记录该单元是否闲置（例如取0代表闲置，取1代表占用）<ul><li>空间成本固定：仅依赖于内存分区数量，与程序数量无关</li><li>时间成本低：直接对位图修改即可</li><li>无容错能力：若位图因错误访问被更改，其本身不具有检错的能力</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181459310.png" alt="image-20230218145920225" style="zoom:67%;" /><ul><li>链表表示法：将给程序分配的单元按照位图的形式连接起来，再在不同程序间采用链表进行连接<ul><li>空间成本不定：取决于程序数量</li><li>时间成本：链表遍历、修改、插入删除较慢</li><li>有一定容错能力：链表有被占用的标志位，可以一定程度上互相验证</li></ul></li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181502696.png" alt="image-20230218150205665" style="zoom:67%;" /><h1 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h1><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><ul><li>实现内存分配的流程：<ul><li>规定<code>size</code>为不再切割的剩余分区的大小、请求的分区大小为<code>u.size</code>，空闲分区的大小为<code>m.size</code></li><li>若<code>m.size - u.size &lt;= size</code>，则将整个分区都分配给请求者（按最小单位也分不开了，就全给了吧）</li><li>否则从该分区内划分一部分并进行分配，余下部分保留在空闲分区表/链表中</li></ul></li><li>流程图如下：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302181519733.png" alt="image-20230218151956700" style="zoom:50%;" /><h2 id="回收内存"><a href="#回收内存" class="headerlink" title="回收内存"></a>回收内存</h2><ul><li>回收分区上下紧邻空闲分区时，直接进行<strong>合并</strong>，合并后修改空闲分区表/链表中的首地址和大小</li><li>回收分区不邻接空闲分区时，在空闲分区表/链表中<strong>新建</strong>表项，记录分区的首地址和大小</li></ul><h2 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h2><ul><li>首次适应算法：按地址递增顺序<strong>从头查询</strong>，选择第一个空间符合要求的分区分配<ul><li>优先利用低地址的空闲分区，开始时查找简单，但易在低地址产生大量不能利用的碎片，增加了后续查找的开销</li></ul></li><li>下次适应算法：按地址递增顺序<strong>从上次分配的地址</strong>开始查询（到达最大值后循环），选择第一个符合要求的分区<ul><li>均匀利用所有分区，不会产生密集的碎片，但使得内存中不存在大空间的分区</li></ul></li><li>最佳适应算法：总寻找<strong>大小最接近</strong>作业所需区域的分区进行分配<ul><li>由于选取大小最接近的分区，划分后的碎片几乎没有办法应用，所以极易产生大量碎片</li></ul></li><li>最坏适应算法：只寻找<strong>最大</strong>的空白分区并进行分配<ul><li>内存中大空间的分区较难保留，大任务难处理，但碎片相对少</li></ul></li></ul><p>为了提高搜索空闲分区的速度，大中型系统使用基于索引搜索的动态分区分配算法</p><ul><li>快速适应算法：把空闲分区按照容量大小进行分类，根据程序所需找到能容纳它的最小的空闲区链表，取下第一块进行分配<ul><li>可以保留大的分区，也不会产生碎片；但归还内存时系统开销大</li></ul></li></ul><h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><blockquote><p>伙伴系统是介于固定分区和可变分区间的动态分区方法</p><p>在分配存储块时将一个大块分裂成两个<strong>相同大小</strong>的小块（伙伴）</p></blockquote><ul><li>伙伴系统内所有分区的大小都是$2^k$，其中$n\le k\le m$，$2^n$表示最小的分区大小，$2^m$表示整个可分配内存的大小</li><li>在不断划分分区的过程中，可能形成若干个<strong>不连续的</strong>空闲分区</li><li>内存管理模块包含多个空闲块链表，单个链表内部都指向相同大小的空分区</li><li><strong>内存分配时</strong>：程序提出一个$2^k$字节（应大于所需内存字节数，同时保证$k$最小）大小的申请，从链表中查找一个$2^{k+1}$字节大小的空分区，一半供给程序，另一半放入空闲块链表中</li><li><strong>内存回收时</strong>：考虑能否和伙伴块合并为一个更大的块，再递归此操作（注意不能和<strong>非伙伴块</strong>合并）</li><li>特点：<ul><li>回收内存时只需要搜索一部分块（同大小的）进行查询</li><li>会产生内部碎片</li></ul></li></ul><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230218212431919.png" alt="image-20230218212431919" style="zoom: 67%;" /><img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230218212528666.png" alt="image-20230218212528666" style="zoom: 67%;" /><h2 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h2><p>定时地、或在内存紧张时，移动已分配区域的数据，把外部碎片和空白的分区合并为一个大的连续区域</p><ul><li>以时间换空间</li><li>对系统的性能开销要求大</li></ul><h1 id="程序的链接和装入"><a href="#程序的链接和装入" class="headerlink" title="程序的链接和装入"></a>程序的链接和装入</h1><blockquote><p>一个用户源程序在内存中通常需要如下处理：</p><ul><li>编译：使用编译程序将源程序编译成若干个模块</li><li>链接：将目标模块和使用的库函数链接成可装载模块（可执行文件）</li><li>装入：将可装载模块装入内存空间   </li></ul></blockquote><h2 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h2><blockquote><p>系统编译C程序时，是以<code>.c</code>文件作为编译单元的，每个文件都会生成一个<code>.o</code>文件，但这些文件<strong>无法知晓地址</strong></p><p><strong>链接</strong>则是将这些<code>.o</code>文件组合到一起，形成最终的可执行文件，并将未填写的地址补充（<strong>重定位</strong>），组合的本质是将相同的程序段段合并到一起</p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302192022325.png" alt="image-20230219202217260" style="zoom: 67%;" /><ul><li><strong>重定位</strong>：在符号解析基础上将有关联的模块合并，确定符号在<strong>虚拟地址空间中的地址</strong>，在符号的引用处重定位引用的地址；总的来说就是把和地址跳转相关的数值/地址值全部修改成能保证运行时地址正确的值</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">Elf32_Addr r_offset;</span><br><span class="line">    <span class="comment">/* 给出了使用重定位的地址地点*/</span></span><br><span class="line">    Elf32_Word r_info;(symbol:<span class="number">24</span>; type:<span class="number">8</span>)</span><br><span class="line">    <span class="comment">/* 给出了与修改地点相关的符号表索引和重定位类型*/</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure><p>对于使用重定位动作的地点：</p><ul><li><p>重定位文件：从节起始处到收重定位影响的存储单元的<strong>字节偏移量</strong></p></li><li><p>可执行文件、共享目标文件：受重定位影响的存储单元的<strong>虚拟地址</strong></p></li><li><blockquote><p>一个源程序可以采用静态链接或动态链接的方式完成链接这一操作</p></blockquote></li><li><p>静态链接：把共享库代码直接链接入程序代码时使用静态链接</p></li><li><p>动态链接：仅当需要某些目标模块时才进行链接工作，节省内存但速度较慢</p></li></ul><h2 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h2><blockquote><p>程序一般采用动态运行时装入方式</p></blockquote><ul><li>程序在内存中的物理位置（绝对地址）会根据系统需求发生改变，为了保证能够便捷更改位置，装入程序在程序运行时才把相对地址转换为绝对地址（需要一个重定位寄存器支持这个功能）</li><li>名空间、地址空间与存储空间：<ul><li>名空间：包括符号指令、数据说明、I/O说明</li><li>地址空间：从0开始，到程序结束的一段空间</li><li>存储空间：从装入地址开始到程序结束的一段空间</li></ul></li><li>多重分区分配：一个作业常由多段相对独立的程序、数据段组成，把这些片段分别装入存储空间的不同区域的过程被称为多重分区分配</li></ul><h2 id="程序段"><a href="#程序段" class="headerlink" title="程序段"></a>程序段</h2><blockquote><p>一个程序本质上是由<code>.bss</code>段、<code>.data</code>段、<code>.text</code>段三部分组成的</p><p>一个装入内存的程序还需要一个<code>stack</code>和一个<code>heap</code></p></blockquote><ul><li><code>bss</code>段：程序中<strong>未初始化</strong>的全局变量的存放空间，采用<strong>静态内存分配</strong></li><li><code>data</code>段：<strong>已初始化</strong>的全局变量（和<code>static</code>修饰的变量）的存放空间，采用<strong>静态内存分配</strong></li><li><code>text</code>段：存放程序代码的一段空间，大小确定，大多为<strong>只读</strong>（可能包含只读常量）</li></ul><p>这三部分中，<code>.data</code>和<code>.text</code>从可执行文件中加载到内存中，<code>.bss</code>段由系统进行初始化</p><ul><li>程序段内存示意图：</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302182309978.png" alt="image-20230218230855885" style="zoom: 60%;" /><ul><li><code>stack</code>段：存放、交换临时数据的区域；用于临时存放<strong>函数中的</strong>局部变量、保存或恢复函数现场</li><li><code>heap</code>段：存放进程中动态分配的内存段；<strong>大小并不固定</strong>，使用<code>malloc</code>或<code>free</code>等函数时内存变动都在<code>heap</code>上进行</li></ul><blockquote><p><code>gcc</code>编译+链接时使用的工具：</p><ul><li>预处理器+编译器：<code>cc1</code></li><li>汇编器：<code>as</code></li><li>链接器：<code>collect2</code></li></ul></blockquote><h1 id="程序的装载与运行"><a href="#程序的装载与运行" class="headerlink" title="程序的装载与运行"></a>程序的装载与运行</h1><h2 id="程序的装载"><a href="#程序的装载" class="headerlink" title="程序的装载"></a>程序的装载</h2><ul><li>装载前调用<code>fork()</code>，创建<strong>子进程</strong></li><li>该子进程调用<code>execve()</code>加载需要执行的程序</li><li>加载器查询<code>ELF</code>文件中与<code>segment</code>相关的信息，其中<code>Type</code>为<code>Load</code>的<code>segment</code>是需要被加载到<strong>内存中</strong>的</li><li><code>segment</code>在<strong>文件中</strong>的大小<strong>小于</strong>在<strong>内存中</strong>的大小，如果出现此种情况在载入内存时需要<strong>补零</strong>使其达到内存所占用的大小</li></ul><h3 id="程序的装载流程"><a href="#程序的装载流程" class="headerlink" title="程序的装载流程"></a>程序的装载流程</h3><ul><li>读取<code>ELF</code>文件的开头魔数进行比对</li><li>根据<code>ELF</code>文件中的段表信息（起始位置在文件中偏移、段表大小、包含了多少项）找到<strong>段表项</strong></li><li>解析各段应当被加载的虚地址、文件中的偏移、内存中/文件中的大小</li><li>根据段在内存中的大小分配物理页并映射到虚地址上，并拷贝文件至内存中</li><li>设置进程块中PC为<code>ELF</code>记录的入口地址，进程开始执行</li></ul><h3 id="可执行文件的内存映像（x86）"><a href="#可执行文件的内存映像（x86）" class="headerlink" title="可执行文件的内存映像（x86）"></a>可执行文件的内存映像（x86）</h3><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302192125234.png" alt="image-20230219212547198" style="zoom:67%;" /><h2 id="程序、进程和作业"><a href="#程序、进程和作业" class="headerlink" title="程序、进程和作业"></a>程序、进程和作业</h2><ul><li>程序是静态的可执行文件，存放在磁盘上</li><li>进程是动态的，<strong>是程序的执行过程</strong>、用户分配资源的基本单位；进程可以创建其他的进程<ul><li>系统进程：完成操作系统功能的进程</li><li>用户进程：完成用户功能的进程</li></ul></li><li>作业是用户要求计算机完成工作的集合；一个作业由至少一个进程构成<ul><li>作业常用于批处理系统，进程常用于分时系统、多道程序系统</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作业 - 若干进程 - 程序 + 数据集合 + 进程控制块</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter2</title>
      <link href="/p/2894.html"/>
      <url>/p/2894.html</url>
      
        <content type="html"><![CDATA[<h1 id="第2章-系统引导"><a href="#第2章-系统引导" class="headerlink" title="第2章 系统引导"></a>第2章 系统引导</h1><p>计算机启动前必须使得硬件处在最安全、通用、功能最弱的状态，并在启动过程中对硬件进行设置，逐步提升硬件处理能力</p><ul><li>必须使用启动程序对计算机进行启动</li><li>启动程序必须运行在启动好的计算机上</li></ul><blockquote><p>OS启动是一个逐步释放系统灵活性的过程</p></blockquote><p>启动的流程：BIOS → MBR → BootLoader → OS</p><h1 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a><code>BootLoader</code></h1><blockquote><p><strong>引导加载程序</strong>，是系统加电后运行的第一段代码，在操作系统内核启动前运行</p></blockquote><ul><li><code>Booter</code>：初始化并运行系统硬件</li><li><code>Loader</code>：将操作系统代码<strong>加载到内存</strong>中，并跳转运行</li></ul><p>嵌入式系统经常用<code>U-boot</code>作为OS装载程序，<code>X86</code>常使用<code>LILO</code>和<code>GRUB</code></p><h1 id="计算机的启动过程（MIPS）"><a href="#计算机的启动过程（MIPS）" class="headerlink" title="计算机的启动过程（MIPS）"></a>计算机的启动过程（<code>MIPS</code>）</h1><blockquote><p><code>MIPS</code>架构使用的<code>U-boot</code>分为<code>stage1</code>和<code>stage2</code>两个阶段，通常<code>stage1</code>使用汇编语言实现，<code>stage2</code>使用C语言实现</p><ul><li><code>stage1</code>实现简单的功能，初始化设备</li><li><code>stage2</code>在<code>stage1</code>的基础上可以实现更复杂的功能</li></ul></blockquote><h2 id="MIPS的基本地址空间"><a href="#MIPS的基本地址空间" class="headerlink" title="MIPS的基本地址空间"></a><code>MIPS</code>的基本地址空间</h2><blockquote><p>在32位系统下，程序地址空间（共4GB）被划分为四个区域，不同区域具有不同的属性：</p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172039803.png" alt="image-20230217203905712" style="zoom:67%;" /><p>按物理地址自下而上地，具有自己的特征：</p><ul><li><code>kuseg</code>：用户态可用地址，只有在<code>MMU</code>建立好后才能使用这2GB的地址</li><li><code>kseg0</code>：去除最高位后，能直接映射到地址从0开始的区域；只有在<code>cache</code>设置好后才能访问这段地址<ul><li>几乎访问这段地址时都需要经过<code>cache</code></li><li>对于有<code>MMU</code>的系统，<strong>操作系统核心</strong>存放在这个区域</li></ul></li><li><code>kseg1</code>：去除高三位后与<code>kseg0</code>类似，但非<code>cache</code>存取<ul><li><code>kseg1</code>是<strong>唯一</strong>在系统重启时能正常工作的地址空间：<code>MIPS</code>系统的启动入口地址为<code>0xBFC00000</code>，就位于<code>kseg1</code>段内</li></ul></li><li><code>kseg2</code>：仅核心态可用地址，同样需要先建立<code>MMU</code></li></ul><h2 id="MIPS启动stage1"><a href="#MIPS启动stage1" class="headerlink" title="MIPS启动stage1"></a><code>MIPS</code>启动<code>stage1</code></h2><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172046694.png" alt="image-20230217204603657"></p><h2 id="MIPS启动stage2"><a href="#MIPS启动stage2" class="headerlink" title="MIPS启动stage2"></a><code>MIPS</code>启动<code>stage2</code></h2><blockquote><p><code>stage2</code>开始时在<code>board_init_f</code>中初始化并分配内存、堆和栈，把<code>U-boot</code>代码复制至<code>ram</code>上运行，在结束时启动<code>Linux kernel</code></p></blockquote><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172050022.png" alt="image-20230217205011993" style="zoom:67%;" /><h1 id="MIPS下Linux系统引导过程"><a href="#MIPS下Linux系统引导过程" class="headerlink" title="MIPS下Linux系统引导过程"></a><code>MIPS</code>下<code>Linux</code>系统引导过程</h1><ul><li><code>BootLoader</code>将<code>Linux</code>内核移动到指定的物理地址处，确定内核开始执行的第一条指令地址</li><li>第一阶段从<code>head.s</code>文件开始，初始化堆栈、内存等</li><li>第二阶段从<code>start_kernel()</code>开始初始化硬件平台相关的代码</li></ul><h1 id="计算机的启动过程（X86）"><a href="#计算机的启动过程（X86）" class="headerlink" title="计算机的启动过程（X86）"></a>计算机的启动过程（<code>X86</code>）</h1><blockquote><p>计算机首先跳转至<code>BIOS</code>处运行寻找硬件设备，随后读取<code>MBR</code>区段并把控制权转移给操作系统的<code>BootLoader</code></p></blockquote><h2 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a><code>BIOS</code></h2><blockquote><p><code>BIOS</code>设置程序是在<code>ROM</code>上固定的一组程序，为电脑提供最底层的硬件控制，与硬件系统集成在一起</p></blockquote><ul><li>系统上电时会自动跳转至<code>BIOS</code>存放的地址开始运行，等待<code>BIOS</code>提供硬件等信息</li><li><code>Power-On Self-Test</code>：<code>BIOS</code>支持上电自检，保证关键组件都能启动并正确初始化</li><li><code>BIOS</code>可更改启动引导设备</li></ul><h3 id="UEFI与BIOS"><a href="#UEFI与BIOS" class="headerlink" title="UEFI与BIOS"></a><code>UEFI</code>与<code>BIOS</code></h3><ul><li><code>EFI</code>使用模块化、C语言风格的参数堆栈传递方式，动态链接的形式构建的系统，突破了<code>BIOS</code>16位的寻址限制</li></ul><h2 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a><code>MBR</code></h2><blockquote><p>硬盘上第0磁头第0磁道第1扇区被称为<code>MBR</code>(Master Boot Record)，大小为<code>512B</code></p></blockquote><ul><li><code>MBR</code>中存放了<code>BootLoader</code>和驱动器的逻辑分区信息：前446字节为启动代码与数据（<code>BootLoader</code>），随后是16字节的分区数据*4个分区（分区数据意义见课件<code>P39</code>），最后的两个字节应存放<code>AA 55</code>，他们被称为幻数（当<code>BIOS</code>读取<code>MBR</code>时，如果末位无幻数就认为这是一个没有分区的硬盘）</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172113489.png" alt="image-20230217211343465" style="zoom:67%;" /><ul><li>硬盘分区共三种：主磁盘分区、扩展磁盘分区、逻辑分区</li><li><code>MBR</code>限制磁盘至多只能有4个主分区，系统必须位于主分区上</li><li>单一硬盘最多4个主分区，最多一个拓展分区，（并且主+扩不超过4），逻辑分区可有若干个</li><li>主分区只能有一个为激活状态</li></ul><h1 id="X86下的Linux系统引导过程"><a href="#X86下的Linux系统引导过程" class="headerlink" title="X86下的Linux系统引导过程"></a>X86下的<code>Linux</code>系统引导过程</h1><blockquote><p>当<code>MBR</code>被读取到内存中后，其中的<code>BootLoader</code>接管系统，并初始化硬件设备、建立内存映射，为启动系统做好准备</p></blockquote><ul><li><code>BIOS</code>将<code>MBR</code>读入<code>0x7C00</code>处，检查<code>0x7DFE</code>是否为<code>0xAA55</code>后，执行<code>MBR</code>程序</li><li>将自身复制至<code>0x0600</code></li><li>搜索<strong>激活的主分区</strong>，将其第一个扇区（<code>Boot Sector</code>）读入<code>0x7C00</code>处，检查<code>0x7DFE</code>是否为<code>0xAA55</code>，跳转<code>0x7C00</code>执行特定系统的启动程序</li></ul><h2 id="MBR与分区引导扇区Boot-Sector"><a href="#MBR与分区引导扇区Boot-Sector" class="headerlink" title="MBR与分区引导扇区Boot Sector"></a><code>MBR</code>与分区引导扇区<code>Boot Sector</code></h2><ul><li>启动顺序有先后。PC机启动时，先执行MBR，再根据选择执行某个分区下的boot sector。<ul><li>（选择执行的boot sector所在分区就是活动分区。“用户选择一个操作系统” 实际上也就是选择一个分区作为活动分区。）</li></ul></li><li>boot sector可以为空（没装系统），但MBR必须包含内容。</li><li>MBR必须被读取并执行；引导扇区根据选择执行，有的甚至可以不执行（即上文中的”数据是无效的”）。</li><li>MBR实际上包含的内容也比boot sector广泛，MBR中相当于包含了硬盘整体层面上的引导扇区(自举装入程序）、根目录区（分区表）。</li><li>MBR选择Boot Sector，Boot Sector驱动分区内的操作系统</li></ul><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302172133565.png" alt="image-20230217213348532" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Theory-Chapter1</title>
      <link href="/p/2574.html"/>
      <url>/p/2574.html</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-引论"><a href="#第1章-引论" class="headerlink" title="第1章 引论"></a>第1章 引论</h1><h1 id="一些小点"><a href="#一些小点" class="headerlink" title="一些小点"></a>一些小点</h1><ul><li><p>操作系统的工作</p><ul><li><p>程序的执行</p></li><li><p>完成与硬件有关的工作</p></li><li><p>完成于应用无关的工作</p></li><li><p>计算机系统的效率与安全问题</p></li></ul></li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><blockquote><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务。</p></blockquote><ul><li>提供了用户与硬件间的接口</li><li>控制、管理计算机硬软件资源</li><li>组值计算机系统工作流程，改善系统性能</li></ul><h1 id="操作系统的特征与功能"><a href="#操作系统的特征与功能" class="headerlink" title="操作系统的特征与功能"></a>操作系统的特征与功能</h1><p>特征：并发、共享、虚拟、异步</p><p>功能：</p><ul><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>作业控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-2-Exam</title>
      <link href="/p/48159.html"/>
      <url>/p/48159.html</url>
      
        <content type="html"><![CDATA[<p>完结撒花，感谢陪伴（？）</p><h1 id="Exam-打开相对路径文件"><a href="#Exam-打开相对路径文件" class="headerlink" title="Exam - 打开相对路径文件"></a>Exam - 打开相对路径文件</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 Lab5 的课下内容中，我们实现了通过<strong>绝对路径</strong>，也即相对于磁盘根目录而言的路径，打开文件，为其获取 <code>struct Open</code> 与 <code>struct File</code> 的函数—— <code>open</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>现在，为了拓展打开文件的方式，我们计划额外实现一个通过指定目录 + 相对路径打开指定文件的函数：<code>openat</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span>;</span><br></pre></td></tr></table></figure><p>在这里，我们保证：</p><ul><li>目录代表的文件已经在文件管理系统中（占据 <code>Open</code>）与当前进程中（占据 <code>Fd</code>）被打开，即可以通过其 <code>fdnum</code> 对应的 <code>struct Fd</code> 获取信息</li><li>调用 <code>open</code>、<code>openat</code> 的所有目录/文件均存在，且 <code>openat</code> 只会打开普通文件（非目录）</li><li>调用 <code>openat</code> 打开的路径均为相对路径，即不会以 <code>/</code> 开头</li></ul><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>我们可以按照通过<strong>新建 <code>fsipc</code> 的种类</strong>以实现目标功能。那对于实现新 <code>fsipc_*</code> 的全过程，有必要进行总结</p><ul><li><code>user/include/fsreq.h</code> <ul><li>增加一个对于文件服务进程的请求类型 <code>FSREQ_OPENAT</code> 和请求结构体 <code>struct Fsreq_openat</code>；<strong>完成基础的数据结构准备</strong></li></ul></li><li><code>user/lib/file.c</code> <ul><li>仿照 <code>open</code> 函数实现 <code>openat</code> 函数；<strong>供用户程序直接启动 <code>openat</code> 流程</strong></li></ul></li><li><code>user/lib/fsipc.c</code> <ul><li>仿照 <code>fsipc_open</code> 实现 <code>fsipc_openat</code>；完成对 <code>Fsreq_openat</code> 各个字段的赋值；<strong>使其能发送 <code>openat</code> 的请求</strong></li></ul></li><li><code>fs/serv.c</code>：<ul><li>修改 <code>serve</code> 函数，使其能转发 <code>FSREQ_OPENAT</code> 请求</li><li>仿照 <code>serve_open</code> 实现 <code>serve_openat</code> 函数；<strong>实现 <code>openat</code> 整体的功能</strong></li></ul></li><li><code>fs/fs.c</code>：<ul><li>仿照 <code>walk_path</code> 实现 <code>walk_path_at</code>；<strong>从文件层面实现按相对路径 <code>path</code> 查找文件的功能</strong></li><li>仿照 <code>file_open</code> 实现 <code>file_openat</code> ，类似地调用 <code>walk_path_at</code> 函数；<strong>封装功能，供文件服务进程调用</strong></li></ul></li><li>头文件：<ul><li><code>user/include/lib.h</code>：增加 <code>openat</code> 、 <code>fsipc_openat</code> 声明</li><li><code>fs/serv.h</code>：增加 <code>file_openat</code> 声明</li></ul></li></ul><p>过程中仍然保留了 <code>openat</code> 字样，实际可以根据情况自由调整。除了 <code>fs.c</code> 中功能具体实现的方式不同之外，基本上面几个文件的修改都是有规律的，和 Lab4 添加系统调用类似。</p><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>因为比较繁琐，所以就把提示塞代码里了，顺序是按照刚才介绍的顺序来的</p><h3 id="user-include-fsreq-h"><a href="#user-include-fsreq-h" class="headerlink" title="user/include/fsreq.h"></a><code>user/include/fsreq.h</code></h3><p>没什么好说的，直接写就完了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPENAT 8         <span class="comment">// serve 函数分发时的标准</span></span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_openat</span> &#123;</span></span><br><span class="line">    u_int dir_fileid;          <span class="comment">// 相对的 &#x27;根目录&#x27; 打开的文件 id </span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN]; <span class="comment">// 打开的文件的相对路径</span></span><br><span class="line">    u_int req_omode;           <span class="comment">// 打开文件的模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="user-lib-file-c"><a href="#user-lib-file-c" class="headerlink" title="user/lib/file.c"></a><code>user/lib/file.c</code></h3><p>供用户进程调用的 <code>openat</code> 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">dir</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">filefd</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="comment">/* Step 1: 获取相对目录在进程中的 fd，申请待打开的文件的 fd */</span></span><br><span class="line">  fd_lookup(dirfd, &amp;dir);</span><br><span class="line">  <span class="keyword">if</span> ((r = fd_alloc(&amp;filefd)) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Step 2: 根据目录在文件服务进程中的 fileid，发送请求 */</span></span><br><span class="line">  <span class="type">int</span> dir_fileid = ((<span class="keyword">struct</span> Filefd *)dir)-&gt;f_fileid;</span><br><span class="line">  <span class="keyword">if</span> ((r = fsipc_openat(dir_fileid, path, mode, filefd)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *va;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">  u_int size, fileid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 获取到文件的 fd，对 fd 字段进行赋值，把内容 map 到 data 区域 */</span></span><br><span class="line">  va = fd2data(filefd);</span><br><span class="line">  ffd = (<span class="keyword">struct</span> Filefd *)filefd;</span><br><span class="line">  size = ffd-&gt;f_file.f_size;</span><br><span class="line">  fileid = ffd-&gt;f_fileid;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2BLK) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_map(fileid, i, (<span class="type">void</span> *)(va + i))) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 4: 返回文件的 fd 号 */</span></span><br><span class="line">  <span class="keyword">return</span> fd2num(filefd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="user-lib-fsipc-c"><a href="#user-lib-fsipc-c" class="headerlink" title="user/lib/fsipc.c"></a><code>user/lib/fsipc.c</code></h3><p>向文件服务进程发送请求的 <code>fsipc_*</code> 函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fsipc_openat</span><span class="params">(u_int dir_fileid, <span class="type">const</span> <span class="type">char</span> *path, u_int omode, <span class="keyword">struct</span> Fd *fd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_openat</span> *<span class="title">req</span>;</span>   <span class="comment">// 注意这里的结构体类型为 openat</span></span><br><span class="line">    u_int perm;</span><br><span class="line">    req = (<span class="keyword">struct</span> Fsreq_openat *)fsipcbuf;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    req-&gt;req_omode = omode;</span><br><span class="line">    req-&gt;dir_fileid = dir_fileid;</span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fsipc(FSREQ_OPENAT, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fs-serv-c"><a href="#fs-serv-c" class="headerlink" title="fs/serv.c"></a><code>fs/serv.c</code></h3><p>类似于 <code>serve_open</code> 的接收请求的 <code>serve_openat</code> 函数，同时也别忘了改 <code>serve</code> 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_openat</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_openat *rq)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;dir_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span> =</span> pOpen-&gt;o_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = file_openat(dir, rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    o-&gt;o_file = f;</span><br><span class="line"></span><br><span class="line">    ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;</span><br><span class="line">    ff-&gt;f_file = *f;</span><br><span class="line">    ff-&gt;f_fileid = o-&gt;o_fileid;</span><br><span class="line">    o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">    ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">    ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">    ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="fs-fs-c"><a href="#fs-fs-c" class="headerlink" title="fs/fs.c"></a><code>fs/fs.c</code></h3><p>底层直接执行文件打开的函数，类似于 <code>walk_path</code> &amp; <code>file_open</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">walk_path_at</span><span class="params">(<span class="keyword">struct</span> File *par_dir, <span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start at the par_dir</span></span><br><span class="line">  file = par_dir;</span><br><span class="line">  dir = <span class="number">0</span>;</span><br><span class="line">  name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pdir) &#123;</span><br><span class="line">    *pdir = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// find the target file by name recursively.</span></span><br><span class="line">  <span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">    dir = file;</span><br><span class="line">    p = path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123; path++; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(name, p, path - p);</span><br><span class="line">    name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    path = skip_slash(path);</span><br><span class="line">    <span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lastelem) &#123; <span class="built_in">strcpy</span>(lastelem, name); &#125;</span><br><span class="line"></span><br><span class="line">        *pfile = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;</span><br><span class="line"></span><br><span class="line">  *pfile = file;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_openat</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> walk_path_at(dir, path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>这个题考察了如何添加新的文件服务请求的种类，这个信息的流动通路是文件系统中的很重要一环。实现文件的相对路径打开也是比较实用的功能，可以参考这一点实现 Lab6 挑战性任务中的<strong>支持相对路径</strong>功能</p><h1 id="Extra-实现符号链接文件"><a href="#Extra-实现符号链接文件" class="headerlink" title="Extra - 实现符号链接文件"></a>Extra - 实现符号链接文件</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 MOS 中我们只实现了两种文件类型：常规文件 &amp; 目录文件。现在我们需要实现一种新的文件类型：<strong>符号链接文件</strong>。这类文件会指向一个存在于文件系统中的文件（也可能是符号链接文件），当使用 <code>open</code> 访问这些文件时，会等效于访问了他们所指向的文件，类似于 Windows 中的快捷方式</p><h3 id="小示例"><a href="#小示例" class="headerlink" title="小示例"></a>小示例</h3><p>同学们可以在 Linux 终端使用 <code>ln -s &lt;目标文件&gt; &lt;链接文件的路径&gt;</code> 命令来创建一个符号链接。同学们可以在开发机中依次执行下面的命令来了解<strong>符号链接的概念</strong>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ~/test</span><br><span class="line">$ <span class="built_in">cd</span> ~/test</span><br><span class="line">$ <span class="built_in">echo</span> 2023 &gt; target <span class="comment"># 创建名为 target 的文件，内容为 2023</span></span><br><span class="line">$ <span class="built_in">ln</span> -s target symlink <span class="comment"># 创建一个符号链接 symlink，指向 target</span></span><br><span class="line">$ <span class="built_in">ls</span> -l <span class="comment"># 可以展示当前目录下链接文件的相关信息，可以看到输出显示了 symlink -&gt; target，这表明 symlink 指向 target</span></span><br><span class="line">$ <span class="built_in">cat</span> symlink <span class="comment"># 看看命令输出了什么</span></span><br></pre></td></tr></table></figure><p>继续<strong>在这个目录下</strong>创建一个名为 <code>test_open.c</code> 的文件，写入下面的代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;symlink&quot;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">char</span> buf[<span class="number">8</span>];</span><br><span class="line"><span class="type">int</span> len = read(fd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>);</span><br><span class="line">buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令 <code>gcc test_open.c &amp;&amp; ./a.out</code> 来编译运行该程序，可以看到输出为<code>2023</code>，即 <code>target</code> 文件的内容。</p><h2 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h2><ul><li>符号链接指向的文件一定是使用<strong>绝对路径</strong>表示，并且文件一定存在；</li><li>符号链接文件只会指向普通文件和符号链接文件（也就是不会指向目录文件）<ul><li>链接不会出现环</li><li>文件名长度合法</li></ul></li></ul><h2 id="一种可行的做法-1"><a href="#一种可行的做法-1" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><ul><li>在 <code>user/include/fs.h</code> 中，定义新的文件类型</li><li>修改 <code>tools/fsformat.c</code>，使得 <code>fsformat</code> 工具在写入文件时根据传入的各个文件的类型来决定写入磁盘镜像的文件的类型（<code>FTYPE_LNK</code>、<code>FTYPE_DIR</code> 或 <code>FTYPE_REG</code>）。以下是一种修改的思路：<ul><li>将 <code>main()</code> 函数中调用的 <code>stat()</code> 函数改为 <code>lstat()</code>（参数不用改变）。<code>stat()</code> 或 <code>lstat()</code> 的作用都是将一个文件的相关信息储存在 <code>statbuf</code> 结构体中。它们的区别在于：<code>stat()</code> 函数会跟踪链接，会解析链接最终指向的文件；而<code>lstat()</code> 不会跟踪链接，直接解析链接文件本身。而我们需要读取链接文件本身的信息，所以需要使用 <code>lstat()</code> 函数替换 <code>stat()</code> 函数（直接改函数名即可，这两个函数都是 Linux 的库函数）。</li><li>修改 <code>main()</code> 函数，在 <code>if else</code> 结构中增加一个分支，调用 <code>write_symlink()</code> 函数（下面自行编写），使其不仅支持目录和普通文件的读取，还可以支持符号链接文件的读取。可以使用 <code>S_ISLNK(stat_buf.stmode)</code> 判断命令行参数对应的文件是否为符号链接。</li><li>修改 <code>write_directory()</code>函数，在 <code>if else</code> 结构中增加一个分支，调用你编写的 <code>write_symlink()</code> 函数，使其不仅支持目录和普通文件的读取，还可以支持符号链接文件的读取。结构体 <code>dirent</code> 的成员变量 <code>d_type</code> 可能会用到以下取值：<code>DT_DIR</code>（目录）、<code>DT_LNK</code>（符号链接）、<code>DT_REG</code>（普通文件）。</li><li>可以仿照 <code>write_file()</code> 函数编写 <code>write_symlink()</code> 函数，实现向磁盘镜像写入符号链接文件的功能。你可以调用 Linux 库函数 <code>int readlink(char *pathname, char *buf, int bufsiz)</code> 来读取一个链接文件指向的<strong>目标路径</strong>（这个函数将路径 <code>pathname</code> 处的符号链接指向的<strong>目标路径</strong>写入 <code>buf</code> 指向的缓冲区，最多写入 <code>bufsiz</code> 个字节，返回值是写入的字节数量。详细说明可以在开发机中使用 <code>man 2 readlink</code> 命令查阅）。一种可能的实现框架如下所示：</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_symlink</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line"><span class="comment">// Your code here: 使用 readlink() 函数读取链接文件指向的路径，将其写入到下一个可用的磁盘块</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">fname++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fname = path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Your code here: 设置链接文件的文件名、大小（指向路径的字符串的长度）、类型属性</span></span><br><span class="line"></span><br><span class="line">save_block_link(target, <span class="number">0</span>, next_block(BLOCK_DATA));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改文件系统的实现，使其满足：用户程序使用 <code>open()</code> 函数打开一个符号链接文件的时候，实际上打开的是其<strong>最终</strong>指向的文件，返回最终指向的文件的文件描述符。被打开的文件可以正常地读写，就像直接打开了最终指向的文件一样。</li></ul><p>看起来可能步骤很多，实际上就是：</p><ul><li>实现一个新的文件种类，文件的内容存放的是它指向的实际文件路径（字符串）</li><li>在 <code>fsformat.c</code> 烧录磁盘文件时需要给这个链接文件分配合适大小的空间，写入合适的内容<ul><li>在 Lab5-Probe 里可能写了：我们的磁盘是通过 <code>fsformat.c</code> 通过数组的形式进行保存的，最后再把这个数组烧录为一个 <code>.img</code> 文件，分配空间、些内容也都是对这个数组进行操作</li></ul></li><li>在 MOS 中需要对链接文件进行处理，获取它内容中（也就是指向的文件）的文件控制块并返回</li></ul><h3 id="user-include-fs-h"><a href="#user-include-fs-h" class="headerlink" title="user/include/fs.h"></a><code>user/include/fs.h</code></h3><p>新建一个文件种类的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// File types</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTYPE_LNK 2 <span class="comment">// Symbolic link file</span></span></span><br></pre></td></tr></table></figure><h3 id="user-lib-file-c-1"><a href="#user-lib-file-c-1" class="headerlink" title="user/lib/file.c"></a><code>user/lib/file.c</code></h3><p>修改 <code>open</code> 函数打开链接文件时的处理方式</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (((<span class="keyword">struct</span> Filefd *)fd)-&gt;f_file.f_type == FTYPE_LNK) &#123;</span><br><span class="line"></span><br><span class="line">  va = fd2data(fd);</span><br><span class="line">  ffd = (<span class="keyword">struct</span> Filefd *)fd;</span><br><span class="line">  size = ffd-&gt;f_file.f_size;</span><br><span class="line">  fileid = ffd-&gt;f_fileid;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc_map(fileid, i, (<span class="type">void</span> *)(va + i))) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// debugf(&quot;type = %d\n&quot;, ((struct Filefd *)fd)-&gt;f_file.f_type);</span></span><br><span class="line">  <span class="comment">// debugf(&quot;name = %s\n&quot;, ((struct Filefd *)fd)-&gt;f_file.f_name);</span></span><br><span class="line">  <span class="comment">// debugf(&quot;content = %s\n&quot;, (char *)va);</span></span><br><span class="line">  fd_alloc(&amp;nfd);</span><br><span class="line">  fd = nfd;</span><br><span class="line"></span><br><span class="line">  fsipc_open((<span class="type">char</span> *)va, mode, fd);  <span class="comment">// va 存放是文件的内容，也就是符号链接指向的路径名，直接通过 fsipc 打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tools-fsformat-c"><a href="#tools-fsformat-c" class="headerlink" title="tools/fsformat.c"></a><code>tools/fsformat.c</code></h3><p>文件烧录的过程</p><h4 id="main：-修改-stat-amp-if-else-分支"><a href="#main：-修改-stat-amp-if-else-分支" class="headerlink" title="main： 修改 stat &amp; if-else 分支"></a><code>main</code>： 修改 <code>stat</code> &amp; <code>if-else</code> 分支</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; i++) &#123;</span><br><span class="line">    <span class="type">char</span> *name = argv[i];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    <span class="type">int</span> r = lstat(name, &amp;stat_buf);  <span class="comment">// stat 修改在此处</span></span><br><span class="line">    assert(r == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);</span><br><span class="line">      write_directory(&amp;super.s_root, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">      write_file(&amp;super.s_root, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISLNK(stat_buf.st_mode)) &#123;   <span class="comment">// 在这里为 LNK 类型提供支持</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;writing symlinking file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">      write_symlink(&amp;super.s_root, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name,</span><br><span class="line">              stat_buf.st_mode);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="编写-write-symlink"><a href="#编写-write-symlink" class="headerlink" title="编写 write_symlink"></a>编写 <code>write_symlink</code></h4><p>在所给模板的基础上填写内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_symlink</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line">    <span class="comment">// Your code here: 使用 readlink()</span></span><br><span class="line">    <span class="comment">// 函数读取链接文件指向的路径，将其写入到下一个可用的磁盘块</span></span><br><span class="line">    <span class="type">char</span> target_name[<span class="number">1025</span>];</span><br><span class="line">    <span class="type">int</span> name_length = readlink(path, target_name, <span class="number">1024</span>);</span><br><span class="line">    target_name[name_length] = <span class="string">&#x27;\0&#x27;</span>;   <span class="comment">// 注意写 &#x27;&#x27;\0&#x27; 的位置，处理覆写问题</span></span><br><span class="line">    <span class="type">int</span> bno = next_block(BLOCK_FILE);  <span class="comment">// 标定所使用的 blcok 的属性</span></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">void</span> *)disk[nextbno].data, (<span class="type">const</span> <span class="type">void</span> *)target_name);</span><br><span class="line">    </span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fname) &#123;</span><br><span class="line">        fname++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fname = path;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Your code here:</span></span><br><span class="line">    <span class="comment">// 设置链接文件的文件名、大小（指向路径的字符串的长度）、类型属性</span></span><br><span class="line">    <span class="built_in">strcpy</span>(target-&gt;f_name, fname); <span class="comment">// 设置文件基础信息</span></span><br><span class="line">    target-&gt;f_type = FTYPE_LNK;</span><br><span class="line">    target-&gt;f_size = <span class="built_in">strlen</span>(target_name);</span><br><span class="line"></span><br><span class="line">    save_block_link(target, <span class="number">0</span>, next_block(BLOCK_DATA));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="main-amp-write-dirctory：调用-write-symlink"><a href="#main-amp-write-dirctory：调用-write-symlink" class="headerlink" title="main &amp; write_dirctory：调用 write_symlink"></a><code>main</code> &amp; <code>write_dirctory</code>：调用 <code>write_symlink</code></h4><p>两处都是添加新的 <code>if-else</code> 分支，这就不再去写了</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>这次 Extra 没从 MOS 的实现出发，而是从文件烧录上下了功夫，从其他的角度考察了对于文件系统逻辑的把控。但说实话感觉有点偏门（）</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-Report</title>
      <link href="/p/8325.html"/>
      <url>/p/8325.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab5-Report"><a href="#BUAA-OS-2023-Lab5-Report" class="headerlink" title="BUAA-OS-2023-Lab5-Report"></a>BUAA-OS-2023-Lab5-Report</h1><h1 id="Thinking-5-1"><a href="#Thinking-5-1" class="headerlink" title="Thinking 5.1"></a>Thinking 5.1</h1><ul><li>如果通过kseg0 读写设备，那么对于设备的写入会缓存到Cache 中。这是一种错误的行为，在实际编写代码的时候这么做会引发不可预知的问题。请思考：这么做这会引发什么问题？对于不同种类的设备（如我们提到的串口设备和IDE 磁盘）的操作会有差异吗？可以从缓存的性质和缓存更新的策略来考虑。</li></ul><p>如果使用 kseg0 段读写设备，那么对于外设而言，在系统读取外设时就会不可避免地先在 Cache 中查找设备对应的地址，如果查询到就会返回缓存的值。但如果在上一次缓存过后，设备的值已经发生了改变，这时我们从 Cache 中读取到的就是过时的错误信息。</p><p>对于写入也是同理，我们会优先写入到 Cache 中对应的地址处，那么下一次写就会覆盖上一次写的结果，导致外设并不能及时、正确地读取到我们写入的值。</p><p>对于不同的外设种类而言，这个现象会有些微差异。串口设备由于其即时性与高使用频率，会更容易出现这样的错误，对于磁盘而言则不太容易。</p><h1 id="Thinking-5-2"><a href="#Thinking-5-2" class="headerlink" title="Thinking 5.2"></a>Thinking 5.2</h1><ul><li>查找代码中的相关定义，试回答一个磁盘块中最多能存储多少个文件控制块？一个目录下最多能有多少个文件？我们的文件系统支持的单个文件最大为多大？</li></ul><p>首先根据定义 <code>BY2BLK</code> 可知一个磁盘块大小为 4096 Byte。同时一个文件控制块 <code>File</code> 大小为 256 Byte。则一个磁盘块中最多能存储 $4096 / 256 = 16$ 个文件控制块。</p><p>一个目录可以通过 <code>f_indirect</code> 字段指向 1024 个指向其内包含的<strong>磁盘块</strong>的指针，那么一个目录下最多有 $1024 * 16 = 16384$ 个文件。</p><p>对于单个文件也是同理，<code>f_indirect</code> 字段会指向 1024 个包含其内容的磁盘块指针，这样一个文件最大大小就是 $1024 * 4KB = 4MB$</p><h1 id="Thinking-5-3"><a href="#Thinking-5-3" class="headerlink" title="Thinking 5.3"></a>Thinking 5.3</h1><ul><li>请思考，在满足磁盘块缓存的设计的前提下，我们实验使用的内核支持的最大磁盘大小是多少？</li></ul><p>由于 MOS 中一个进程可以拥有 4 GB 的虚拟内存空间，并且对于文件管理进程而言， <code>DISKMAP</code> 到 <code>DISKMAP + DISKMAX</code> 这一段虚存地址空间 (0x10000000-0x4fffffff) 会作为作为磁盘块的缓冲区。那么最大的磁盘大小就是 <code>DISKMAP</code>，即 1 GB。</p><h1 id="Thinking-5-4"><a href="#Thinking-5-4" class="headerlink" title="Thinking 5.4"></a>Thinking 5.4</h1><ul><li>在本实验中，fs/serv.h、user/include/fs.h 等文件中出现了许多宏定义，试列举你认为较为重要的宏定义，同时进行解释，并描述其主要应用之处。</li></ul><p>其实文件控制块和超级块都比较好理解</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span><span class="comment">//文件控制块，是文件系统用于管理文件的数据结构</span></span><br><span class="line">    u_char f_name[MAXNAMELEN];  <span class="comment">// filename</span></span><br><span class="line">    u_int f_size;           <span class="comment">// file size in bytes</span></span><br><span class="line">    u_int f_type;           <span class="comment">// file type</span></span><br><span class="line">    u_int f_direct[NDIRECT];</span><br><span class="line">    u_int f_indirect;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span>     <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">u_char f_pad[BY2FILE - MAXNAMELEN - <span class="number">4</span> - <span class="number">4</span> - NDIRECT * <span class="number">4</span> - <span class="number">4</span> - <span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC    0x68286097  <span class="comment">// Everyone&#x27;s favorite OS class</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span> <span class="comment">// 根目录块</span></span><br><span class="line">    u_int s_magic;      <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    u_int s_nblocks;    <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span> <span class="comment">// Root directory</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fsreq 的请求分类</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE    6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC  7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> req_fileid;</span><br><span class="line">    u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_set_size</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> req_fileid;</span><br><span class="line">    u_int req_size;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// continue</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fs/serv.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  u_int req, whom, perm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    perm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    req = ipc_recv(&amp;whom, (<span class="type">void</span> *)REQVA, &amp;perm);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// All requests must contain an argument page</span></span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_V)) &#123;</span><br><span class="line">      debugf(<span class="string">&quot;Invalid request from %08x: no argument page\n&quot;</span>, whom);</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// just leave it hanging, waiting for the next request.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (req) &#123;</span><br><span class="line">    <span class="keyword">case</span> FSREQ_OPEN:</span><br><span class="line">      serve_open(whom, (<span class="keyword">struct</span> Fsreq_open *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_MAP:</span><br><span class="line">      serve_map(whom, (<span class="keyword">struct</span> Fsreq_map *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_SET_SIZE:</span><br><span class="line">      serve_set_size(whom, (<span class="keyword">struct</span> Fsreq_set_size *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_CLOSE:</span><br><span class="line">      serve_close(whom, (<span class="keyword">struct</span> Fsreq_close *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_DIRTY:</span><br><span class="line">      serve_dirty(whom, (<span class="keyword">struct</span> Fsreq_dirty *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_REMOVE:</span><br><span class="line">      serve_remove(whom, (<span class="keyword">struct</span> Fsreq_remove *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_SYNC:</span><br><span class="line">      serve_sync(whom);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> FSREQ_OPENAT:</span><br><span class="line">      serve_openat(whom, (<span class="keyword">struct</span> Fsreq_openat *)REQVA);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      debugf(<span class="string">&quot;Invalid request code %d from %08x\n&quot;</span>, whom, req);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syscall_mem_unmap(<span class="number">0</span>, (<span class="type">void</span> *)REQVA);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是我们进行ipc通讯后，对数据进行分发的场所，我们会根据收获到的req的不同，将用于接受信息（文件系统接受，由用户发来）的REQVA解读为不同的结构体，并传入不同的服务函数进行实现。</p><p>整个分发实现是文件系统与外界的接口，文件系统内部的实现是相对自由的（你可以进行系统调用、使用用户态函数、操作磁盘等等），只要反馈给用户进程的结果对就行</p><h1 id="Thinking-5-5"><a href="#Thinking-5-5" class="headerlink" title="Thinking 5.5"></a>Thinking 5.5</h1><ul><li>在 Lab4 “系统调用与 fork” 的实验中我们实现了极为重要的 fork 函数。那么 fork 前后的父子进程是否会共享文件描述符和定位指针呢？请在完成上述练习的基础上编写一个程序进行验证。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code here</span></span><br><span class="line"><span class="type">int</span> r, fdnum, n; </span><br><span class="line"><span class="type">char</span> buf[<span class="number">200</span>]; </span><br><span class="line"></span><br><span class="line">fdnum = open(<span class="string">&quot;/newmotd&quot;</span>, O_RDWR); </span><br><span class="line"><span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123; </span><br><span class="line">    n = read(fdnum, buf, <span class="number">4</span>); </span><br><span class="line">    debugf(<span class="string">&quot;[child] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    n = read(fdnum, buf, <span class="number">4</span>); </span><br><span class="line">    debugf(<span class="string">&quot;[father] buffer is \&#x27;%s\&#x27;\n&quot;</span>, buf); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// file here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">welcome to MOS with a file system.</span><br><span class="line"></span><br><span class="line"><span class="comment">// output here</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">[father] buffer is <span class="string">&#x27;welc&#x27;</span></span><br><span class="line">[child] buffer is <span class="string">&#x27;ome &#x27;</span></span><br></pre></td></tr></table></figure><p>显然，父子进程也会同样共享相同的文件描述符和定位指针。其原因在于页面是 <code>PTE_LIBRARY</code> 的而非 <code>PTE_COW</code> 的。</p><h1 id="Thinking-5-6"><a href="#Thinking-5-6" class="headerlink" title="Thinking 5.6"></a>Thinking 5.6</h1><ul><li>请解释 File, Fd, Filefd 结构体及其各个域的作用。比如各个结构体会在哪些过程中被使用，是否对应磁盘上的物理实体还是单纯的内存数据等。说明形式自定，要求简洁明了，可大致勾勒出文件系统数据结构与物理实体的对应关系与设计框架。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span> <span class="comment">//文件描述符；用户用于描述该文件，单纯的内存数据，关机就消失；</span></span><br><span class="line">    u_int fd_dev_id; <span class="comment">//该文件对应的设备id</span></span><br><span class="line">    u_int fd_offset; <span class="comment">//读写偏移量</span></span><br><span class="line">    u_int fd_omode; <span class="comment">//允许用户进程对文件的操作权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span> <span class="comment">//单纯的内存数据，关机就消失，是便于文件系统查看的结构；</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span> <span class="comment">//文件描述符</span></span><br><span class="line">    u_int f_fileid; <span class="comment">//文件系统为打开的文件进行的编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span> <span class="comment">//对应文件的文件控制块</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span> <span class="comment">// 文件系统用来保存已打开的文件信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// 指向文件控制块的指针</span></span><br><span class="line">    u_int o_fileid; <span class="comment">// 文件打开后的编号</span></span><br><span class="line">    <span class="type">int</span> o_mode; <span class="comment">// 允许用户进程对文件的操作权限</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span> <span class="comment">// 指向该文件描述符的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这部分的部分内容借鉴了学长的报告</li></ul><h1 id="Thinking-5-7"><a href="#Thinking-5-7" class="headerlink" title="Thinking 5.7"></a>Thinking 5.7</h1><ul><li>图 5.7 中有多种不同形式的箭头，请解释这些不同箭头的差别，并思考我们的操作系统是如何实现对应类型的进程间通信的。</li></ul><ol><li>同步消息，用黑三角箭头搭配黑实线表示：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111105489.png" alt="image-20230511110441745"></p><p>同步意义：消息的发送者把进程控制传递给消息的接收者，然后<strong>暂停活动</strong>，<strong>等待</strong>消息接收者的回应消息。</p><ol><li><p>返回消息，用开三角箭头搭配黑色虚线表示：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111105896.png" alt="image-20230511110455875"></p></li></ol><p>返回消息和同步消息结合使用，因为异步消息不进行等待，所以不需要知道返回值。</p><p>对于文件系统，通过特定调用号使得文件系统知道请求者有何种需求，然后文件系统进入相应处理函数中处理，将结果通过ipc_send传回用户进程。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>纵观 Lab5，MOS 在其中为我们构造了一个通配的文件系统。</p><p>它通过统一的结构体 <code>Fd</code> <strong>层次化地</strong>管理所用可用的设备。<strong>向上</strong>，在 <code>fd.c</code> 中为用户提供统一的操作函数；<strong>向下</strong>，不同设备通过 <strong>implements 实现</strong> <code>Dev</code> 的功能函数，达到同一调用的效果。</p><p>在此之下，<code>file.c</code>、<code>console.c</code>、<code>pipe.c</code> 三文件实现了 <code>Dev</code> 中的”抽象函数“。为了优化函数实现的效果，我们建立了一个为所有进程管理纯文件 file 的文件服务进程 <code>serv.c</code>，并通过 <code>fsipc.c</code> 借助 进程间 IPC 通信机制实现数据传输。</p><p>对文件服务进程而言，它通过 IPC 通信与用户进程（请求方）通信，利用文件级、磁盘块级的交互函数 <code>fs.c</code> 与磁盘进行交互，并利用块缓存的机制对磁盘块进行管理，以满足请求者<strong>对指定文件的特定文件块</strong>的访问。</p><p>再细化到最后一步，所有的磁盘交互函数都是利用<strong>系统调用</strong>访问 <code>KSEG1</code> 段实现与外设的直接交互，并在最底层的函数中实现了以块、甚至扇区为单位的读写，即 <code>ide.c</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part3</title>
      <link href="/p/53603.html"/>
      <url>/p/53603.html</url>
      
        <content type="html"><![CDATA[<h1 id="用户态定义与接口"><a href="#用户态定义与接口" class="headerlink" title="用户态定义与接口"></a>用户态定义与接口</h1><p>在之前的分析中，我们已经完成了文件管理进程中的函数实现。现在我们来分析用户态中用户直接可用的函数接口与数据结构定义</p><p>我们还是从距离文件系统<strong>最近</strong>的函数与文件开始：<code>user/lib/fsipc.c</code> 和 <code>user/include/fsreq.h</code></p><p>首先明确用户进程和文件管理进程<strong>使用 IPC 通信进行交互</strong>。在文件管理进程的运行的核心、分发函数 <code>serve</code> 中，我们通过 <code>ipc_recv</code> 从用户进程获取到了一片虚拟地址 <code>REQVA</code>，并且针对不同的信息，将 <code>REQVA</code> 转换成了不同的数据结构，进行处理。这些数据结构就定义在 <code>fsreq.h</code> 文件中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_OPEN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_MAP 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SET_SIZE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CLOSE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_DIRTY 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_REMOVE 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_SYNC 7</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_open</span> &#123;</span></span><br><span class="line"><span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">u_int req_omode;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_map</span> &#123;</span></span><br><span class="line"><span class="type">int</span> req_fileid;</span><br><span class="line">u_int req_offset;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// CONTINUE...</span></span><br></pre></td></tr></table></figure><p>篇幅所限不再全部排列。</p><p>那这片 <code>va</code> 到底是谁发送来的呢？在用户态中存在一个专门的分发函数：<code>fsipc</code></p><h2 id="fsipc-c-文件请求服务函数"><a href="#fsipc-c-文件请求服务函数" class="headerlink" title="fsipc.c - 文件请求服务函数"></a><code>fsipc.c</code> - 文件请求服务函数</h2><ul><li>我们规定在 MOS 系统中，文件管理进程必须为第二个进程（<code>envs[1]</code>），以保证传输正确性</li><li>可以看出，本接口通过 <code>fsreq</code> 参数传输页面，<code>type</code> 参数传输申请的服务类型</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Send an IPC request to the file server, and wait for a reply.</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fsipc</span><span class="params">(u_int type, <span class="type">void</span> *fsreq, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">u_int whom;</span><br><span class="line"><span class="comment">// Our file system server must be the 2nd env.</span></span><br><span class="line">ipc_send(envs[<span class="number">1</span>].env_id, type, fsreq, PTE_D);</span><br><span class="line"><span class="keyword">return</span> ipc_recv(&amp;whom, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个用户态的每一个<strong>请求服务函数</strong>中，即 <code>fsipc_*</code> 函数，都会用到一个临时的页面用来传输数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_char fsipcbuf[BY2PG] __attribute__((aligned(BY2PG)));</span><br></pre></td></tr></table></figure><p>通过修改页面内的数据，搭配不同的服务函数，让文件管理进程<strong>以不同的方式去解析这片地址空间</strong>，以实现传输相同页面却能实现不同功能的效果。例如我们要实现的函数 <code>fsipc_remove</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  请求文件系统移除某文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查文件名长度 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt; MAXPATHLEN || <span class="built_in">strlen</span>(path) == <span class="number">0</span>) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 2: 把预留的临时地址 **视作** Fsreq_remove 结构 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_remove</span> *<span class="title">req</span> =</span> (<span class="keyword">struct</span> Fsreq_remove *)fsipcbuf;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 3: 修改传输页面的数据，以实现 remove 功能 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (2/3) */</span></span><br><span class="line"><span class="built_in">strcpy</span>((<span class="type">char</span> *) req-&gt;req_path, path);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* Step 4: 发送操作类型 FSREQ_REMOVE 和所需数据 req ，启动服务 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.12: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">return</span> fsipc(FSREQ_REMOVE, req, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上每个函数中，对 <code>fsipc_req</code> 这片第地址的类型转换都不同，也会写入不同的信息。</p><h2 id="file-c-纯文件操作函数"><a href="#file-c-纯文件操作函数" class="headerlink" title="file.c - 纯文件操作函数"></a><code>file.c</code> - 纯文件操作函数</h2><p>再向上一层，调用这些用户态中的请求服务函数 <code>fsipc_*</code> 的函数位于 <code>user/lib/file.c</code> 中。</p><p>它们是用户态中能<strong>直接执行特定文件操作</strong>的函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Returns the file descriptor, 也就是 Fd 号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">int</span> mode)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 申请一个 Fd</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (1/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 2: 调用服务函数 fsipc_open，同时指定 Fd 的工作模式</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (2/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 3: Set &#x27;va&#x27; to the address of the page where the &#x27;fd&#x27;&#x27;s data is cached, using</span></span><br><span class="line"><span class="comment">// &#x27;fd2data&#x27;. Set &#x27;size&#x27; and &#x27;fileid&#x27; correctly with the value in &#x27;fd&#x27; as a &#x27;Filefd&#x27;.</span></span><br><span class="line"><span class="type">char</span> *va;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ffd</span>;</span></span><br><span class="line">u_int size, fileid;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (3/5) */</span></span><br><span class="line">va = fd2data(fd);</span><br><span class="line">ffd = (<span class="keyword">struct</span> Filefd *) fd;</span><br><span class="line">size = ffd-&gt;f_file.f_size;</span><br><span class="line">fileid = ffd-&gt;f_fileid;</span><br><span class="line"><span class="comment">// Step 4: Alloc pages and map the file content using &#x27;fsipc_map&#x27;.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (4/5) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fsipc_map(fileid, i, (<span class="type">void</span> *) (va + i))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 5: 返回执行函数用到的 Fd 对应的 Fd 号</span></span><br><span class="line"><span class="comment">/* Exercise 5.9: Your code here. (5/5) */</span></span><br><span class="line"><span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">remove</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// Call fsipc_remove.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exercise 5.13: Your code here. */</span></span><br><span class="line"><span class="keyword">return</span> fsipc_remove(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但我们在用户程序中通常不使用这些函数，具体的原因在下一个文件中说。</p><h3 id="fsipc-c-amp-file-c"><a href="#fsipc-c-amp-file-c" class="headerlink" title="fsipc.c &amp; file.c"></a>fsipc.c &amp; file.c</h3><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192207570.png?imageMogr2/format/webp" alt="user_lib_in_lab5" style="zoom:67%;" /><h2 id="fd-c-文件系统顶层函数"><a href="#fd-c-文件系统顶层函数" class="headerlink" title="fd.c - 文件系统顶层函数"></a><code>fd.c</code> - 文件系统顶层函数</h2><h3 id="struct-Dev"><a href="#struct-Dev" class="headerlink" title="struct Dev"></a>struct Dev</h3><p>对于整个文件系统而言，总共能操作的设备共有三种：（纯）文件设备、控制台和管道。而我们在 <code>file.c</code> ，甚至 Lab5 之前部分中实现的都是对<strong>文件设备</strong>的操作，而剩余两个部分是 Lab6 的内容了。</p><blockquote><p>其实本来是没有括号这个“纯”字的，但是个人觉得比较好区分“操作 fd “和”操作 file “两个层次，于是就瞎分了分</p></blockquote><p>上面提到的这三类设备，都是 dev （即 <code>file device</code>）的一种，我们在 <code>fd.c</code> 的最顶层函数中也是直接对 <code>dev</code> 进行对应的操作，表层并无法分辨“文件”这一概念。所以应该对每个操作涉及到的不同设备类型进行<strong>分发</strong>，让每个设备对应一个执行任务的函数，再把分发函数封装在执行功能的函数内。</p><p>这三类设备平等，并且在文件系统中视角来看，都属于 <code>Fd</code> ，即 file descriptor 的一种（继承？）。每类设备拥有自己的<strong>功能函数</strong>以处理对应的请求，结构体定义中的 3-7 字段就是存放功能函数的指针。三种设备的信息统一存放在一个 <code>Dev</code> 数组内，设备具体又分别定义在各自功能函数的头文件内。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> &#123;</span></span><br><span class="line"><span class="type">int</span> dev_id;</span><br><span class="line"><span class="type">char</span> *dev_name;</span><br><span class="line"><span class="type">int</span> (*dev_read)(<span class="keyword">struct</span> Fd *, <span class="type">void</span> *, u_int, u_int);</span><br><span class="line"><span class="type">int</span> (*dev_write)(<span class="keyword">struct</span> Fd *, <span class="type">const</span> <span class="type">void</span> *, u_int, u_int);</span><br><span class="line"><span class="type">int</span> (*dev_close)(<span class="keyword">struct</span> Fd *);</span><br><span class="line"><span class="type">int</span> (*dev_stat)(<span class="keyword">struct</span> Fd *, <span class="keyword">struct</span> Stat *);</span><br><span class="line"><span class="type">int</span> (*dev_seek)(<span class="keyword">struct</span> Fd *, u_int);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">devtab</span>[] =</span> &#123;&amp;devfile, &amp;devcons, &amp;devpipe&#125;; <span class="comment">// 纯文件、控制台、管道</span></span><br></pre></td></tr></table></figure><h3 id="struct-Fd"><a href="#struct-Fd" class="headerlink" title="struct Fd"></a>struct Fd</h3><p>其次是文件描述符 <code>Fd</code>，<strong>每一个用户进程</strong>可以同时操控多个设备，为了对这些设备加以区分，就引入了文件描述符的定义。通过访问对应设备的文件描述符，就能得知它的设备种类（<code>dev_lookup</code>），因此我们只需要传入文件描述符，就能自动地获得 <code>Dev</code> 中存放的函数指针并执行。这也许是一种面向对象的处理方式。</p><p>同时，每个进程的文件描述符上限为 <strong>32</strong> 个，每个描述符<strong>单独占用一个虚拟页</strong>，并且还<strong>对应</strong>一个 <code>PDMAP</code> 大小的 data 空间处理该设备打开后处理的内容。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> &#123;</span></span><br><span class="line">u_int fd_dev_id;  <span class="comment">// 此设备对应的 Dev 类型</span></span><br><span class="line">u_int fd_offset;  <span class="comment">// 目前的文件指针距离起始的偏移量，类似 ftell 的文件指针</span></span><br><span class="line">u_int fd_omode;   <span class="comment">// 该设备的读写模式，只读、读写等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们对文件描述符的访问，通过它在空间中的顺序（下标）实现。对外界，<strong>文件描述符相当于一个整数</strong>，服务函数 <code>fd_lookup</code>、<code>fd2data</code> 等和宏定义通过“翻译”这个整数，获得文件描述符的地址和它对应的 <code>data</code> 空间。存放的地址如下：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192217962.png?imageMogr2/format/webp" alt="fd_in_memory" style="zoom:40%;" /><p>为了我们更容易实现对纯文本的操作，所以又再次对 <code>Fd</code> 结构进行了封装，实现了一个专门为 file 使用的 <code>FileFd</code> 结构，它包含了更多的信息，能够更容易地处理 file 类的操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file descriptor + file</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> <span class="title">f_fd</span>;</span></span><br><span class="line">u_int f_fileid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">f_file</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实际上可以直接把 <code>FileFd</code> 当作普通的 <code>Fd</code> 用，因为字段原因，所以内存上读起来是这样的效果</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192221386.png?imageMogr2/format/webp" alt="fd_and_filefd" style="zoom:60%;" /><p>我们之前提到， <code>Open</code> 结构体类似于一个文件服务进程使用的“窗口”，实际上文件描述符 <code>Fd</code> 也<strong>类似一个在用户态中的窗口</strong>，只不过它的范围更广，可以包含除了 <code>File</code> 以外的其他设备，但同时它也只为自己的进程而服务。</p><p>如何根据 <code>Fd</code> 执行功能函数？</p><ul><li>根据 <code>Fd</code> 号找到对应的 <code>Fd</code> 数据</li><li>判断其 <code>Dev</code> 种类，获取执行该操作的函数指针</li><li>直接调用函数指针，实现该 <code>Dev</code> 自行实现的底层函数，完成操作。</li></ul><p>我们以 <code>read</code> 一个<strong>设备</strong>（Fd）为例，分析以上过程</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Read at most &#x27;n&#x27; bytes from &#x27;fd&#x27; at the current seek position into &#x27;buf&#x27;.</span></span><br><span class="line"><span class="comment">//  read(fdnum, (char *)buf + tot, n - tot);</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fdnum, <span class="type">void</span> *buf, u_int n)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> *<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 1: 根据 fdnum 获取 Fd 结构体和 Dev 种类</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (1/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((r = fd_lookup(fdnum, &amp;fd)) &lt; <span class="number">0</span> || (r = dev_lookup(fd-&gt;fd_dev_id, &amp;dev)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 2: 检查 fd 的开启模式</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (2/4) */</span></span><br><span class="line"><span class="keyword">if</span> ((fd-&gt;fd_omode &amp; O_ACCMODE) == O_WRONLY) &#123; <span class="keyword">return</span> -E_INVAL; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 3: 调用该 dev 提供的 dev_read 函数</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (3/4) */</span></span><br><span class="line">r = dev-&gt;dev_read(fd, buf, n, fd-&gt;fd_offset);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Step 4: 更新文件指针的偏移</span></span><br><span class="line"><span class="comment">/* Exercise 5.10: Your code here. (4/4) */</span></span><br><span class="line"><span class="keyword">if</span> (r &gt; <span class="number">0</span>) &#123; fd-&gt;fd_offset += r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致思路如上，所以我们实际上只需要准备好这个 <code>dev_*</code> 函数即可完成功能。</p><p>接着以定义在 <code>file.c</code> 中的 <code>devfile</code> 为例，由于 <code> .dev_read = file_read</code>，所以我们之前编写的读 file 的函数 <code>file_read</code> 就会在顶层的 <code>read</code> 中被直接执行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dev</span> <span class="title">devfile</span> =</span> &#123;</span><br><span class="line">    .dev_id = <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    .dev_name = <span class="string">&quot;file&quot;</span>,</span><br><span class="line">    .dev_read = file_read,</span><br><span class="line">    .dev_write = file_write,</span><br><span class="line">    .dev_close = file_close,</span><br><span class="line">    .dev_stat = file_stat,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>终于，我们在用户态直接对某个设备调用顶层的功能函数，就能直接获得响应了。</p><h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>纵观 Lab5，MOS 在其中为我们构造了一个通配的文件系统。</p><p>它通过统一的结构体 <code>Fd</code> <strong>层次化地</strong>管理所用可用的设备。<strong>向上</strong>，在 <code>fd.c</code> 中为用户提供统一的操作函数；<strong>向下</strong>，不同设备通过 <strong>implements 实现</strong> <code>Dev</code> 的功能函数，达到同一调用的效果。</p><p>在此之下，<code>file.c</code>、<code>console.c</code>、<code>pipe.c</code> 三文件实现了 <code>Dev</code> 中的”抽象函数“。为了优化函数实现的效果，我们建立了一个为所有进程管理纯文件 file 的文件服务进程 <code>serv.c</code>，并通过 <code>fsipc.c</code> 借助 进程间 IPC 通信机制实现数据传输。</p><p>对文件服务进程而言，它通过 IPC 通信与用户进程（请求方）通信，利用文件级、磁盘块级的交互函数 <code>fs.c</code> 与磁盘进行交互，并利用块缓存的机制对磁盘块进行管理，以满足请求者<strong>对指定文件的特定文件块</strong>的访问。</p><p>再细化到最后一步，所有的磁盘交互函数都是利用<strong>系统调用</strong>访问 <code>KSEG1</code> 段实现与外设的直接交互，并在最底层的函数中实现了以块、甚至扇区为单位的读写，即 <code>ide.c</code>。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part1/">See Part1 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part2/">See Part2 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part2</title>
      <link href="/p/4514.html"/>
      <url>/p/4514.html</url>
      
        <content type="html"><![CDATA[<p>当实现完 Part1 中的函数后，磁盘就通过 <code>fsformat</code> 程序成功地生成了。在继续之前，建议大家看一看指导书的这个图，这个文章的顺序大概是：文件系统服务进程→交互区→用户进程</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305181232771.png?imageMogr2/format/webp" alt="lab5_total"></p><p>接下来我们正式进入内核，处理后续工作。</p><h1 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h1><ul><li><strong>块缓存</strong>指的是借助虚拟内存来实现磁盘块缓存的设计。</li></ul><p>在 MOS 系统中，文件管理“系统”，是以一个进程的形式存在的，它通过从磁盘中读写数据，并与其他用户进程交互来实现文件的管理，这些被使用到的文件就会先被<strong>缓存</strong>在文件服务进程的进程空间中。类似于批发商从生产商处取货，存储在自己的仓库里，使用时再拿出来给下级的经销商（x）</p><p>我们规定，文件管理进程使用大小为 <code>DISKMAX</code> 字节的空间作为磁盘块的缓存区，并且缓存区的存取<strong>单位为磁盘块</strong>。每个磁盘块都应该在内存中有<strong>单独相对应的位置</strong>进行缓存，这样就限制了我们内核支持的最大磁盘大小。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure><p>为了在磁盘块和内存之间进行交换，我们需要准备一系列辅助和工作函数，而这系列的共 35 个函数都被放置在 <code>fs/fs.c</code> 文件中。（file service？）</p><h2 id="fs-c-中的磁盘块操作函数"><a href="#fs-c-中的磁盘块操作函数" class="headerlink" title="fs.c 中的磁盘块操作函数"></a><code>fs.c</code> 中的磁盘块操作函数</h2><p>我们通过简单的函数，一步一步组合执行复杂的功能，有以下函数：</p><h3 id="diskaddr-Exercise-5-6"><a href="#diskaddr-Exercise-5-6" class="headerlink" title="diskaddr - Exercise 5.6"></a>diskaddr - Exercise 5.6</h3><p>和上文的块缓存相对应，返回某个特定块在文件管理系统进程内存中<strong>应该被放置到</strong>的虚拟地址，实际上就按照上面提的线性映射就行了，一块一块挨着排</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.6: Your code here. */</span></span><br><span class="line">u_int addr = DISKMAP + blockno * BY2BLK;</span><br><span class="line"><span class="keyword">if</span> (addr &gt; DISKMAX + DISKMAP) &#123;</span><br><span class="line">debugf(<span class="string">&quot;illegal blockno_addr!\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *) <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *) addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="va-is-mapped-amp-block-is-mapped"><a href="#va-is-mapped-amp-block-is-mapped" class="headerlink" title="va_is_mapped &amp; block_is_mapped"></a>va_is_mapped &amp; block_is_mapped</h3><p><code>va_is_mapped</code> 检查文件管理进程中某个虚拟地址是否被使用</p><p>通常情况下不会单独使用，一般配合 <code>diskaddr</code> 在 <code>block_is_mapped</code> 中使用</p><p><code>block_is_mapped</code> 则检查特定的磁盘块是否使用块缓存装入了内存。其实觉得应该叫 block is mapped <strong>at</strong> 比较合适，因为返回的是映射所在的地址（返回 NULL 说明映射在空气里了）</p><p>由于块缓存是<strong>一一对应</strong>的，所以只要查虚拟地址的使用，就能获得独一的磁盘块是否有了缓存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this disk block is mapped in cache.</span></span><br><span class="line"><span class="comment">//  Returns the virtual address of the cache page if mapped, 0 otherwise.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);  <span class="comment">// 获取块映射的缓存虚拟地址</span></span><br><span class="line"><span class="keyword">if</span> (va_is_mapped(va)) &#123;        <span class="comment">// 查一下虚拟地址用没用</span></span><br><span class="line"><span class="keyword">return</span> va;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map-block-amp-unmap-block"><a href="#map-block-amp-unmap-block" class="headerlink" title="map_block &amp; unmap_block"></a>map_block &amp; unmap_block</h3><p>光检查还不行，也得有形成/解除映射的函数不是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 如果已经映射，返回 0 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (1/5) */</span></span><br><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 使用系统调用申请一个含 PTE_D 的页面，通过 diskaddr 查询映射的虚拟地址 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (2/5) */</span></span><br><span class="line"><span class="keyword">return</span> syscall_mem_alloc(syscall_getenvid(), diskaddr(blockno), PTE_D |PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 获得指定块的映射地址，没映射就是 NULL */</span></span><br><span class="line"><span class="type">void</span> *va;</span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (3/5) */</span></span><br><span class="line">va = block_is_mapped(blockno);</span><br><span class="line"><span class="keyword">if</span> (va == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 如果磁盘中块仍使用，缓存还 DIRTY 了，解除映射之前要先写回 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (4/5) */</span></span><br><span class="line"><span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">write_block(blockno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Step 3: 通过系统调用解除地址映射 */</span></span><br><span class="line"><span class="comment">/* Exercise 5.7: Your code here. (5/5) */</span></span><br><span class="line">syscall_mem_unmap(syscall_getenvid(), va);</span><br><span class="line"></span><br><span class="line">user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="write-block-amp-read-block"><a href="#write-block-amp-read-block" class="headerlink" title="write_block &amp; read_block"></a>write_block &amp; read_block</h3><p>形成映射的下一步，就是把数据写到内存之中了</p><p>要注意 <code>write_block</code> 是写到磁盘里，<code>read_block</code> 是写到内存里，也就是 write <strong>to</strong> block &amp; read <strong>from</strong> block</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查内存中是否映射，没映射 = 没数据，肯定没法写回 */</span></span><br><span class="line"><span class="keyword">if</span> (!block_is_mapped(blockno)) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;write unmapped block %08x&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step2: 使用 ide_write 把当前缓存块写回 */</span></span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">ide_write(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  **blk != 0 ，则向 *blk 中存入写入后的虚拟地址</span></span><br><span class="line"><span class="comment">//  **isnew != 0，则按照以下规则更新 *isnew：</span></span><br><span class="line"><span class="comment">//  *isnew = 0: 虚拟地址原本就被写入过</span></span><br><span class="line"><span class="comment">//  *isnew = 1: 虚拟地址此前没有写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  (Isnew lets callers like file_get_block clear any memory-only </span></span><br><span class="line"><span class="comment">//  fields from the disk blocks when they come in off disk.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 检查 blockno 的合法性 */</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123; user_panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line"><span class="comment">/* Step 2: 检查磁盘中块是否有效，如果磁盘块是 free 的，说明里面没东西 */</span></span><br><span class="line"><span class="comment">// Hint: 读之前要先读一下 bitmap 是不是倒进内存里了</span></span><br><span class="line"><span class="comment">//  If the bitmap is NULL, indicate that we haven&#x27;t read bitmap from disk to memory</span></span><br><span class="line"><span class="comment">//  until now. So, before we check if a block is free using `block_is_free`, we must</span></span><br><span class="line"><span class="comment">//  ensure that the bitmap blocks are already read from the disk to memory.</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123; user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line"><span class="comment">/* Step 3: 找到待写入的虚拟地址 */</span></span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="comment">/* Step 4: 读入内存，更新 *isnew */</span></span><br><span class="line"><span class="comment">// Hint: 如果已经 mapped 则只更新 isnew，否则先 alloc 页面，再 read</span></span><br><span class="line"><span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">// 已经 mapped</span></span><br><span class="line"><span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 未 mapped</span></span><br><span class="line"><span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">1</span>; &#125;</span><br><span class="line">syscall_mem_alloc(<span class="number">0</span>, va, PTE_D);                <span class="comment">// 申请页面</span></span><br><span class="line">ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);  <span class="comment">// 使用 ide_read 读入页面</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Step 5: 赋值 *blk */</span></span><br><span class="line"><span class="keyword">if</span> (blk) &#123; *blk = va; &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="block-is-free-amp-free-block"><a href="#block-is-free-amp-free-block" class="headerlink" title="block_is_free &amp; free_block"></a>block_is_free &amp; free_block</h3><p>这两个函数改变的是内存中存放的 <code>bitmap</code> 数组，检查磁盘中是否使用了这个块/操作块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  通过内存中的 bitmap 检查 block 是否在磁盘中有效</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">    <span class="comment">// blockno 不合法，一定不有效</span></span><br><span class="line"><span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 查 bitmap，如果指定位为 1，说明有效</span></span><br><span class="line"><span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 其余情况无效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark a block as free in the bitmap.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="comment">/* Step 1: 如果 blockno 不合法，不更改 bitmap */</span></span><br><span class="line"><span class="comment">/* Exercise 5.4: Your code here. (1/2) */</span></span><br><span class="line"><span class="comment">// if blockno = 0, the boot sector will have the chance to be overwrited</span></span><br><span class="line"><span class="keyword">if</span> (blockno == <span class="number">0</span> || blockno &gt; super-&gt;s_nblocks) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"><span class="comment">/* Step 2: 通过位运算改变 bitmap 的值，使指定位置为 1. */</span></span><br><span class="line"><span class="comment">/* Exercise 5.4: Your code here. (2/2) */</span></span><br><span class="line">bitmap[blockno / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放第 blockno 个磁盘块时，就需要先找到 <code>bitmap</code> 的对应位，bitmap 的类型是 32 位的，也就是说第 blockno 个磁盘块应该位于第 blockno / 32 个数组元素中，再利用位运算把代表 blockno 的那一位置 1 即可。</p><h3 id="alloc-block-num-amp-alloc-block"><a href="#alloc-block-num-amp-alloc-block" class="headerlink" title="alloc_block_num &amp; alloc_block"></a>alloc_block_num &amp; alloc_block</h3><p>这两个函数主要负责管理内存中的 <code>bitmap</code>，带 <code>num</code> 的函数负责申请块，不带的则直接完成了申请+映射</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Search in the bitmap for a free block and allocate it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> blockno;</span><br><span class="line"><span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line"><span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line"><span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line"><span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="comment">// the block is free</span></span><br><span class="line">bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">write_block(blockno / BIT2BLK + <span class="number">2</span>); <span class="comment">// write to disk.</span></span><br><span class="line"><span class="keyword">return</span> blockno;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// no free blocks.</span></span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Allocate a block -- first find a free block in the bitmap, then map it into memory.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> r, bno;</span><br><span class="line"><span class="comment">// Step 1: find a free block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123; <span class="comment">// failed.</span></span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">bno = r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">free_block(bno);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: return block number.</span></span><br><span class="line"><span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-super-amp-read-bitmap"><a href="#read-super-amp-read-bitmap" class="headerlink" title="read_super &amp; read_bitmap"></a>read_super &amp; read_bitmap</h3><p>在这两个函数中，我们完成了文件管理进程的<strong>基础数据准备</strong>：读取了磁盘的超级块（获得基础信息），同时得到了磁盘的位图 <code>bitmap</code>（占用情况）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_super</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="comment">/* Step 1: 读取 super 块，blockno = 1 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">user_panic(<span class="string">&quot;cannot read superblock: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line">super = blk; <span class="comment">// 把 super 块缓存地址所在的指针赋给进程中的变量 super，便于后续使用</span></span><br><span class="line"><span class="comment">/* Step 2: 检查 MAGIC NUMBER */</span></span><br><span class="line"><span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC) &#123; user_panic(<span class="string">&quot;bad file system magic number %x %x&quot;</span>, super-&gt;s_magic, FS_MAGIC); &#125;</span><br><span class="line"><span class="comment">/* Step 3: 检查磁盘大小，超过块缓存允许的大小就会 panic，对应了 Thinking */</span></span><br><span class="line"><span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKMAX / BY2BLK) &#123; user_panic(<span class="string">&quot;file system is too large&quot;</span>); &#125;</span><br><span class="line">debugf(<span class="string">&quot;superblock is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Read and validate the file system bitmap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  把磁盘中表示 bitmap 的几个磁盘块全读取到内存中，并设置一个数组指向它们，代表内存中的 bitmap</span></span><br><span class="line"><span class="comment">//  For each block i, user_assert(!block_is_free(i))) to check that they&#x27;re all marked as in use.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">u_int i;</span><br><span class="line"><span class="type">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* Step 1: 计算块数量，并进行  */</span></span><br><span class="line">u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bitmap = diskaddr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 确保特殊块为 in-use 状态 */</span></span><br><span class="line"><span class="comment">// Hint: use `block_is_free`</span></span><br><span class="line">user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: 确保 bitmap 对应的块为 in-use 状态 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">debugf(<span class="string">&quot;read_bitmap is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="va-is-dirty-amp-block-is-dirty"><a href="#va-is-dirty-amp-block-is-dirty" class="headerlink" title="va_is_dirty &amp; block_is_dirty"></a>va_is_dirty &amp; block_is_dirty</h3><p>与上文类似，之不过检查的是对应的 <code>PTE_DIRTY</code> 位，也就是检查块缓存是否发生了更改</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this block is dirty. (check corresponding `va`)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_dirty</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_dirty</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> vpt[VPN(va)] &amp; PTE_DIRTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dirty-block"><a href="#dirty-block" class="headerlink" title="dirty_block"></a>dirty_block</h3><p>既然能够对块缓存进行写入，那就一定要有一个能产生 <code>PTE_DIRTY</code> 的函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark this block as dirty (cache page has changed and needs to be written back to disk).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dirty_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line"><span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line"><span class="keyword">if</span> (!va_is_mapped(va)) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125;</span><br><span class="line"><span class="keyword">if</span> (va_is_dirty(va)) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, PTE_D | PTE_DIRTY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fs-init"><a href="#fs-init" class="headerlink" title="fs_init"></a>fs_init</h3><p>这个函数初始化了文件系统.初始化后，<code>super</code> 和 <code>bitmap</code> 都被缓存到了文件管理进程中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Initialize the file system.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  1. read super block.</span></span><br><span class="line"><span class="comment">//  2. check if the disk can work.</span></span><br><span class="line"><span class="comment">//  3. read bitmap blocks from disk to memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">read_super();         <span class="comment">// 缓存 super 块</span></span><br><span class="line">check_write_block();  <span class="comment">// 一个测试函数</span></span><br><span class="line">read_bitmap();        <span class="comment">// 缓存 bitmap 所用块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，与磁盘块相关的函数就结束了。<code>fs.c</code> 中剩余的函数均以文件为读取单位，它们基于我们刚刚分析的读取块的函数而实现，等文件说完再回来看。</p><h2 id="struct-File"><a href="#struct-File" class="headerlink" title="struct File"></a>struct File</h2><p>在 MOS 中，描述文件使用文件控制块 File，其定义于 <code>user/include/fs.h</code>，每个控制块的大小为 256 Byte</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line"><span class="type">uint32_t</span> f_size; <span class="comment">// file size in bytes</span></span><br><span class="line"><span class="type">uint32_t</span> f_type; <span class="comment">// file type</span></span><br><span class="line"><span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line"><span class="type">uint32_t</span> f_indirect; <span class="comment">// points to a block contains pointers</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line"><span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128</span></span><br></pre></td></tr></table></figure><p>基础的文件结构不再赘述，需要注意文件控制块中包含一个指向目录的控制块指针，可以用来表示位置；同时还使用 <code>f_pad</code> 域将控制块补全至 256 字节，使得一个 Block 能包含整数个文件块。</p><p>前面说了那么多，大部分是从<strong>物理单位</strong>（块、扇区）对磁盘进行操作，实际上我们真正要对磁盘操作时，应该从<strong>逻辑单位</strong>（文件）操作。说白了，文件/磁盘块有点类似于页式存储中段/页的概念。在 <code>load_icode</code> 中我们以页为单位进行了读入，实际上还是为了把整个二进制 ELF 全部读入；文件也类似，要读写文件，最终也是以块为单位出发去实现的。</p><h1 id="serv-c-文件系统服务进程"><a href="#serv-c-文件系统服务进程" class="headerlink" title="serv.c - 文件系统服务进程"></a><code>serv.c</code> - 文件系统服务进程</h1><p>与指导书介绍顺序不同，我们这里先讲一下文件系统服务进程。</p><h2 id="struct-Open"><a href="#struct-Open" class="headerlink" title="struct Open"></a>struct Open</h2><p>在文件服务进程的源代码中，我们找到了一个新数据结构的定义：<code>Open</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">u_int o_fileid;     <span class="comment">// file id</span></span><br><span class="line"><span class="type">int</span> o_mode;         <span class="comment">// open mode</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span> <span class="comment">// va of filefd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构可以看成是文件服务的<strong>柜台窗口</strong>，文件管理进程想要打开/操作一个文件，必须先获取一个窗口，然后再在窗口上进行操作。其中的 <code>o_ff</code> 字段大小为一页，我个人把他叫做这个<strong>窗口的工作区</strong>，在工作区中存放了当前操作文件的 <code>Filefd</code> ，并且经常要发生赋值和写入（为了更新文件状态）。</p><p>同样的，我们设置了一个管理窗口的数组 <code>opentab</code>，可以对其<strong>标识符</strong> <code>o_fileid</code> 进行遍历，从而获取指定窗口。具体存放结构如图：</p><p>总而言之，文件系统进程通过 Open 来管理文件的打开与否，但文件信息大多还是需要 File 和 Filefd</p><p>插播一个很巧妙的函数：<code>open_alloc</code>，也即申请空闲窗口的函数。</p><h3 id="open-alloc"><a href="#open-alloc" class="headerlink" title="open_alloc"></a>open_alloc</h3><p>为什么说它巧，因为它利用了 <code>pp_ref</code> 字段判断窗口当前是否处于使用中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span> &#123;</span><br><span class="line"><span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find an available open-file table entry</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line"><span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, opentab[i].o_ff, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">*o = &amp;opentab[i];</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span> *)opentab[i].o_ff, <span class="number">0</span>, BY2PG);</span><br><span class="line"><span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在下面的开启文件的函数中，最后一步是把窗口的工作区<strong>映射并共享</strong>给请求者，这使得 <code>pp_ref</code> 必然 ≥ 2（自身 + 不少于一个请求者）。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br></pre></td></tr></table></figure><p>当遍历所有窗口的工作区时，一旦发现 <code>pp_ref == 1</code>，则意味着<strong>所有</strong>请求者都主动释放了该页面（文件不再使用后请求者会自行释放，但文件服务进程永远不会主动释放）。也就意味着当前工作区无人使用，就拿来再次分配了。</p><h2 id="文件块-amp-磁盘块-amp-块缓存"><a href="#文件块-amp-磁盘块-amp-块缓存" class="headerlink" title="文件块 &amp; 磁盘块 &amp; 块缓存"></a>文件块 &amp; 磁盘块 &amp; 块缓存</h2><p>开始还有点不解，不是说每个磁盘块都要装到固定的块缓存中吗，在 <code>file_map_block</code> 中指定了块号为什么随便 <code>alloc</code> 了一个就用了呢？</p><p>前半句确实是正确的，这是<strong>磁盘块缓存</strong>的要求，但是我们这里“指定”的块号是<strong>文件块号</strong>，它代表文件中的第 filebno 块，而在磁盘中具体怎么存放我们并不关心。</p><p>更通俗的讲，可以把文件看成虚拟内存，而磁盘看成物理内存：</p><ul><li>文件块是逻辑上连续的，每个文件都是如此</li><li>磁盘块是物理上连续的，同时，它在装入块缓存时又是一一对应的</li><li>相邻的文件块可以通过 <code>alloc_block</code> 函数<strong>映射到</strong>不相邻的磁盘块内</li></ul><p>但和存储管理不同的是，我们这里并没有什么页表去存放映射关系，<strong>保存映射的是文件管理块</strong>。所以 pgdir_walk 查的是页表， file_block_walk 查的是文件块和文件块内部的数据，如图：</p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305161150782.png?imageMogr2/format/webp" alt="mapping_relation" style="zoom: 10%;" /><h2 id="fs-c-中的文件操作函数"><a href="#fs-c-中的文件操作函数" class="headerlink" title="fs.c 中的文件操作函数"></a><code>fs.c</code> 中的文件操作函数</h2><p>在文件系统服务函数中，我们可以发现它们大多使用了 <code>file_*</code> 类型的函数，他们来自之前剩一点没讲的 <code>fs.c</code>，剩下的部分是以文件为单位进行交互的函数集合。</p><p>现在我们就对这些函数做一些分析。</p><h2 id="一图流"><a href="#一图流" class="headerlink" title="一图流"></a>一图流</h2><blockquote><p>包含了前面的块操作函数</p></blockquote><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236155.svg" alt="fs.c"></p><h3 id="file-create"><a href="#file-create" class="headerlink" title="file_create"></a>file_create</h3><ul><li>创建 <code>path</code> 指向的文件，返回文件控制块</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Create &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *file to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">/* Step 1: 主要获取 path 包含的目录，顺便查一下文件是否存在 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123; <span class="keyword">return</span> -E_FILE_EXISTS; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 路径、过程中的路径不存在，返回错误 */</span></span><br><span class="line"><span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 在指定目录下申请一个文件 */</span></span><br><span class="line"><span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 向文件赋名，返回 */</span></span><br><span class="line"><span class="built_in">strcpy</span>(f-&gt;f_name, name);</span><br><span class="line">*file = f;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-open-amp-walk-path"><a href="#file-open-amp-walk-path" class="headerlink" title="file_open &amp; walk_path"></a>file_open &amp; walk_path</h3><p>直接调用了另一个函数：<code>walk_path</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  从根目录开始，搜索 path 指向的文件，返回路径目录的控制块和文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">walk_path</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir, <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"><span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// start at the root.</span></span><br><span class="line">path = skip_slash(path);</span><br><span class="line">file = &amp;super-&gt;s_root;</span><br><span class="line">dir = <span class="number">0</span>;</span><br><span class="line">name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = <span class="number">0</span>; &#125;</span><br><span class="line">*pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// find the target file by name recursively.</span></span><br><span class="line"><span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">dir = file;</span><br><span class="line">p = path;</span><br><span class="line"><span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123; path++; &#125;</span><br><span class="line"><span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line"><span class="built_in">memcpy</span>(name, p, path - p);  <span class="comment">// 截断路径并存入 name 数组中</span></span><br><span class="line">name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">path = skip_slash(path);</span><br><span class="line"><span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125; <span class="comment">// 检查途径目录的状态</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 若正常，则应递归查找 path</span></span><br><span class="line"><span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// dir_lookup：path 结束且找不到文件</span></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;</span><br><span class="line"><span class="keyword">if</span> (lastelem) &#123; <span class="built_in">strcpy</span>(lastelem, name); &#125;</span><br><span class="line">*pfile = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;  <span class="comment">// 成功递归出 file 的位置</span></span><br><span class="line">*pfile = file;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Open &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *pfile to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们的查找从根目录开始（<code>super</code>），一直到路径结束前，都采用递归的形式对路径中每个用“/”分开的文件夹进行<strong>搜索</strong>（dir_lookup）</li><li>dir_lookup：如果进入异常退出的分支，则意味着 <code>r == -E_NOT_FOUND</code>（目录里没有这个文件） &amp;&amp; <code>*path == &#39;\0&#39;</code>（找到文件所在的最底一层目录了），也就是文件不存在，应当退出。</li></ul><h3 id="file-get-block-amp-file-map-block-amp-file-block-walk"><a href="#file-get-block-amp-file-map-block-amp-file-block-walk" class="headerlink" title="file_get_block &amp; file_map_block &amp; file_block_walk"></a>file_get_block &amp; file_map_block &amp; file_block_walk</h3><ul><li>file_block_walk：类似 pgdir_walk，获取文件 f 的第 filebno 块在磁盘中的磁盘块号；如果在非直接指针区域、没有间接指针块，会创建一个间接块（但是没有申请 filebno 的块）</li><li>file_map_block：上一个函数的封装，获取第 filebno 块在磁盘中的块号；如果文件块 → 磁盘块的映射不存在，则会申请磁盘块形成一个映射</li><li><strong>file_get_block</strong>：先获取第 filebno 块在磁盘中的块号，再把数据从磁盘中<strong>读到内存中</strong>（read_block）</li></ul><p>第三个函数是在服务进程中申请某个地址的内容时使用的，用于把指定地址所在的块一并加载，供用户使用。最后实现时需要把直接指针和间接指针块对外包装出<strong>同等的访问方式</strong>，因此需要在内部处理差异。</p><p>前两个是比较底层的工具函数，没有在 fs.c 之外的文件内出现，所以没什么印象也没关系的吧（大嘘</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Set *blk to point at the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int diskbno;</span><br><span class="line">u_int isnew;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到文件 f 第 filebno 个块在磁盘中对应的磁盘号</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 从磁盘中读该磁盘号的数据到 blk 中</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OVerview:</span></span><br><span class="line"><span class="comment">//  Set *diskbno to the disk block number for the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="comment">//  If alloc is set and the block does not exist, allocate it.</span></span><br><span class="line"><span class="comment">//  完整的封装</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到指定块的地址，存在 ptr 里</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 目标块的地址不存在，根据 alloc 决定是否申请</span></span><br><span class="line"><span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">*ptr = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 类似的，给指针赋值</span></span><br><span class="line">*diskbno = *ptr;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  获取指定文件 f 的指定块在磁盘中的块号，alloc == 1 &amp;&amp; NINDIRECT 时需要申请指针块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  Return 0 on success, and set *ppdiskbno to the pointer to the target block.</span></span><br><span class="line"><span class="comment">//  Return -E_NOT_FOUND if the function needed to allocate an indirect block, but alloc was 0.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_MEM if there&#x27;s not enough memory for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_INVAL if filebno is out of range (&gt;= NINDIRECT).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line"><span class="type">uint32_t</span> *blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line"><span class="comment">// Step 1: 直接指针，则 ptr 直接指向指定的块</span></span><br><span class="line">ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line"><span class="comment">// Step 2: 非直接指针，根据 alloc 决定是否需要为文件申请一个指针块</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;      <span class="comment">// 申请失败，返回</span></span><br><span class="line">&#125;</span><br><span class="line">f-&gt;f_indirect = r; <span class="comment">// 申请成功，建立连接</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 把指针块映射到文件管理进程的内存中，这时并没有为目标块创建块缓存</span></span><br><span class="line"><span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span> **)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">ptr = blk + filebno;  <span class="comment">// 令 ptr 指向指针块中的第 filebno 项，也就是第 filebno 块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 保存 ptr 的值，返回</span></span><br><span class="line">*ppdiskbno = ptr;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush"><a href="#file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush" class="headerlink" title="file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush"></a>file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush</h3><p>函数的作用是设定指定文件的大小，其中还会调用三个底层函数</p><ul><li>file_truncate：释放文件缩小后占用多余的块</li><li>file_clear_block：实际释放块使用的函数</li><li>file_flush：同步文件内容至磁盘，此处用于更新被修改文件的目录，也就是同步目录中的所有文件</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  设定文件的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_set_size</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 若文件变小，则需要释放多余的块 */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_size &gt; newsize) &#123; file_truncate(f, newsize); &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 更新文件的大小 */</span></span><br><span class="line">f-&gt;f_size = newsize;</span><br><span class="line"><span class="comment">/* Step 3: */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件多余的占用块，同时注意清理间接指针块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_truncate</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">u_int bno, old_nblocks, new_nblocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 设定缩小前后所占用的块数量 */</span></span><br><span class="line">old_nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">new_nblocks = newsize / BY2BLK + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (newsize == <span class="number">0</span>) &#123; new_nblocks = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 释放多余的块缓存；同时如果缩小到不需要使用间接指针块，则释放间接块 */</span></span><br><span class="line"><span class="keyword">if</span> (new_nblocks &lt;= NDIRECT) &#123;</span><br><span class="line"><span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">file_clear_block(f, bno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_indirect) &#123;</span><br><span class="line">free_block(f-&gt;f_indirect);</span><br><span class="line">f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 否则只单纯释放块缓存，保留间接块 */</span></span><br><span class="line"><span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">file_clear_block(f, bno);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 更新文件大小 */</span></span><br><span class="line">f-&gt;f_size = newsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_clear_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">uint32_t</span> *ptr;</span><br><span class="line">    <span class="comment">/* Step 1: 找到 filebno 指定的块地址 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 释放指定块的块缓存 */</span></span><br><span class="line"><span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">free_block(*ptr);</span><br><span class="line">*ptr = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  同步块缓存中的文件内容至磁盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_flush</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line"><span class="comment">// Your code here</span></span><br><span class="line">u_int nblocks;</span><br><span class="line">u_int bno;</span><br><span class="line">u_int diskno;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 1: 对文件中所有占用的块遍历 */</span></span><br><span class="line"><span class="keyword">for</span> (bno = <span class="number">0</span>; bno &lt; nblocks; bno++) &#123;</span><br><span class="line">        <span class="comment">/* Step 2: 获取文件中第 bno 块的磁盘块号 diskno */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, bno, &amp;diskno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">/* Step 3: 如果磁盘块在加载到缓存后被更新过，则写回 */</span></span><br><span class="line"><span class="keyword">if</span> (block_is_dirty(diskno)) &#123;</span><br><span class="line">write_block(diskno);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-close"><a href="#file-close" class="headerlink" title="file_close"></a>file_close</h3><ul><li>比较简单，但是断档继续写的时候，我已经快忘了 <code>file_flush</code> 是干嘛的了（悲</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Close a file.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line"><span class="comment">// 将文件本身 + 目录同步回磁盘块中</span></span><br><span class="line">file_flush(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">file_flush(f-&gt;f_dir);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-dirty"><a href="#file-dirty" class="headerlink" title="file_dirty"></a>file_dirty</h3><ul><li>调用了前面的函数 <code>dirty_block</code>，实现了对指定文件的特定地址的 DIRTY 标识。（在写入 <code>offset</code> 后，为了保证能够同步块缓存和磁盘的数据，需要调用这个函数了）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  标记指定文件地 offset 所在的块为 DIRTY </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_dirty</span><span class="params">(<span class="keyword">struct</span> File *f, u_int offset)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int diskbno;</span><br><span class="line">    <span class="comment">// 使用 file_map_block 找到 offset 对应的磁盘块号</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_map_block(f, offset / BY2BLK, &amp;diskbno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">// 把指定磁盘块的块缓存置为 DIRTY</span></span><br><span class="line"><span class="keyword">return</span> dirty_block(diskbno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-remove"><a href="#file-remove" class="headerlink" title="file_remove"></a>file_remove</h3><ul><li>通过字符串展示的路径先查询到文件控制块，然后使用将自身大小减为 0 的方式解除所有占用的内存块；最后同步至磁盘内</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_remove</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: 找到要 remove 的文件，指针存到 f 内</span></span><br><span class="line"><span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: 将体积缩小为 0</span></span><br><span class="line">file_truncate(f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: 清除名称，查询是否文件是否占用时看的就是 f_name[0]</span></span><br><span class="line">f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 4: 同步自身内容和目录内容至磁盘内</span></span><br><span class="line">file_flush(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="file-sync"><a href="#file-sync" class="headerlink" title="file_sync"></a>file_sync</h3><ul><li>啊我整个大的.jpg</li></ul><p>对于整个块缓存空间来说，同步所有写入过的块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Sync the entire file system.  A big hammer.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_sync</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (block_is_dirty(i)) &#123;</span><br><span class="line">write_block(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dir-lookup-Exercise-5-8"><a href="#dir-lookup-Exercise-5-8" class="headerlink" title="dir_lookup - Exercise 5.8"></a>dir_lookup - Exercise 5.8</h3><ul><li>遍历目录中的每个文件，查找名称是否相同；同时，遍历的方式是先块后文件，详细可以看代码</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  查找当前路径下 dir 中字符串 name 指向的文件，返回文件控制块 file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="comment">/* Step 1: 通过占用块计算目录 dir 大小 */</span></span><br><span class="line">u_int nblock;</span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (1/3) */</span></span><br><span class="line">nblock = dir-&gt;f_size / BY2BLK + (dir-&gt;f_size % BY2BLK == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* Step 2: 遍历目录中的每个文件： */</span></span><br><span class="line">    <span class="comment">// 2.1: 遍历每个文件块</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line"><span class="comment">// 获取目录中的每个磁盘块</span></span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (2/3) */</span></span><br><span class="line">file_get_block(dir, i, &amp;blk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">files</span> =</span> (<span class="keyword">struct</span> File *)blk;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2: 遍历块中的每个文件</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line"><span class="comment">// 比较文件名，相同则返回</span></span><br><span class="line"><span class="comment">/* Exercise 5.8: Your code here. (3/3) */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(f-&gt;f_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">*file = f;</span><br><span class="line">f-&gt;f_dir = dir;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 所有文件内均未找到，返回 -E_NOT_FOUND */</span></span><br><span class="line"><span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dir-alloc-file"><a href="#dir-alloc-file" class="headerlink" title="dir_alloc_file"></a>dir_alloc_file</h3><ul><li>在目录中查找空白文件管理块，并返回这个块。当目录已满时需要自动扩容</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  在给定的路径 dir 中申请一个文件空间，返回文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_alloc_file</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">u_int nblock, i, j;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 1: 遍历所有目录的磁盘块（按文件控制块大小遍历），尝试发现空白的控制块 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line"><span class="comment">// read the block.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f = blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line">            <span class="comment">/* Step 2: 发现空白控制块，直接返回 */</span></span><br><span class="line"><span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">*file = &amp;f[j];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 3: 目录中已有的所有块都占用，通过 file_get_block 尝试申请新磁盘块，并把文件放在新块里 */</span></span><br><span class="line">dir-&gt;f_size += BY2BLK;</span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">f = blk;</span><br><span class="line">*file = &amp;f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数把 <code>file_get_block</code> 这个函数用得很灵活，一是执行其最基本的方法，即实现文件块到磁盘块的映射；同时在 Step 3 中还充当了为文件 <code>alloc_block</code> 的磁盘块申请者（映射肯定也同时生成在文件控制块中了）</p><h2 id="serv-c-文件系统进程服务函数"><a href="#serv-c-文件系统进程服务函数" class="headerlink" title="serv.c 文件系统进程服务函数"></a><code>serv.c</code> 文件系统进程服务函数</h2><p>里面函数太多了，偷个懒</p><h3 id="一图流-1"><a href="#一图流-1" class="headerlink" title="一图流"></a>一图流</h3><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236561.svg" alt="serv.c"></p><h3 id="serve-open"><a href="#serve-open" class="headerlink" title="serve_open"></a>serve_open</h3><p>根据输入，申请一个工作区后打开文件并保存文件信息，完成后直接 ipc_send 返回。</p><p>重点体现在后面这个保存信息上了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a file id.</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123; ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line"><span class="comment">// Open the file.</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Save the file pointer.</span></span><br><span class="line">o-&gt;o_file = f;                       <span class="comment">// file_open 里获取到的文件指针给窗口保管</span></span><br><span class="line"><span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;       <span class="comment">// 把工作区当成 Filefd 准备写入</span></span><br><span class="line">ff-&gt;f_file = *f;                     <span class="comment">// 工作区存放文件</span></span><br><span class="line">ff-&gt;f_fileid = o-&gt;o_fileid;          <span class="comment">// 文件的 id 来自于窗口的 id</span></span><br><span class="line">o-&gt;o_mode = rq-&gt;req_omode;           <span class="comment">// 窗口工作类型由输入决定</span></span><br><span class="line">ff-&gt;f_fd.fd_omode = o-&gt;o_mode;       <span class="comment">// Filefd 里的工作类型也进行更新</span></span><br><span class="line">ff-&gt;f_fd.fd_dev_id = devfile.dev_id; <span class="comment">// 意义不明，待补</span></span><br><span class="line"></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve-map"><a href="#serve-map" class="headerlink" title="serve_map"></a>serve_map</h3><ul><li>将目标文件 <code>offset</code> 处的磁盘块的内容映射（分享）给发起请求的用户进程</li></ul><p>用户进程请求获取文件块内容时，文件管理进程会使用这个函数，它先根据文件块和 <code>offset</code> 获取到实际所在的磁盘块，最后再把在文件管理进程中缓存的信息以共享页面的形式发送给用户进程。</p><p>这里也是一个有一个从文件块→磁盘块的映射</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_map</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_map *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">u_int filebno;</span><br><span class="line"><span class="type">void</span> *blk;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filebno = rq-&gt;req_offset / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 2: 获取映射的地址和磁盘块 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 将找到的磁盘块对应的块缓存分享给请求的用户进程 */</span></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, blk, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serve-set-size"><a href="#serve-set-size" class="headerlink" title="serve_set_size"></a>serve_set_size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_set_size</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_set_size *rq)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/* Step 2: 利用窗口中存放的文件控制块更改文件大小 */</span></span><br><span class="line"><span class="keyword">if</span> ((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的 <code>serve_*</code> 函数实际上也类似，大部分都是对<strong>文件交互函数</strong> <code>file_*</code> 函数的调用，这里函数充当接口，统一化处理信息。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part1/">See Part1 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part3/">See Part3 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab5-Part1</title>
      <link href="/p/4322.html"/>
      <url>/p/4322.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lab5-文件系统"><a href="#Lab5-文件系统" class="headerlink" title="Lab5 文件系统"></a>Lab5 文件系统</h1><p>到 Lab4 为止，我们已经基本处理了操作系统中内存和进程的管理，现在已经能够执行基础的功能了。然而实际上我们并不能把所有数据都存放在内存中，这时我们就需要引入文件系统这一概念，把数据交由磁盘进行存储。</p><p>Lab5 中主要涉及到以下内容：</p><ul><li>硬件外设与读写驱动</li><li>磁盘结构与驱动</li><li>文件系统服务进程操作</li></ul><h1 id="硬件外设与读写驱动"><a href="#硬件外设与读写驱动" class="headerlink" title="硬件外设与读写驱动"></a>硬件外设与读写驱动</h1><p>本次实验中，我们要实现的驱动都使用 MMIO 技术进行编写，也就是直接向内存中某个空间写入以达成对外设的访问。具体到我们的 MOS 实验中，需要访问的外设共有三个：控制台、硬盘、时钟。<strong>在这一部分，我们需要实现的就是供这些外设使用的读写驱动（接口），为后面的文件系统的访问做准备。</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">** ---------------------------------*</span><br><span class="line">*|   device   | start addr | length |</span><br><span class="line">** -----------+------------+--------*</span><br><span class="line">*|  console   | <span class="number">0x10000000</span> | <span class="number">0x20</span>   | (dev_cons.h)</span><br><span class="line">*|  IDE disk  | <span class="number">0x13000000</span> | <span class="number">0x4200</span> | (dev_disk.h)</span><br><span class="line">*|    rtc     | <span class="number">0x15000000</span> | <span class="number">0x200</span>  | (dev_rtc.h)</span><br><span class="line">** ---------------------------------*</span><br></pre></td></tr></table></figure><p>首先我们需要回顾一下之前完成的实验代码：</p><ul><li>我们在 Lab2 中已经完成了对实时钟 rtc 的写入，并且只需要在内核态提供为数不多的操作，不需要处理用户态试图访问、修改时钟的情况，也就不需要额外编写驱动。</li><li>在 Lab1 中，我们通过内核态中的 <code>printcharc</code> 函数实现了 <code>printk</code> 函数，并使之可以在用户态使用（<strong>写外设</strong>）；并且内核中的 <code>kern/console.c</code> 也实现了单个字符的读取（<strong>读外设</strong>）。实际上这也就是一种驱动。</li></ul><p>那么我们也就剩下一种外设缺少驱动程序了，那就是 <strong>IDE 磁盘</strong>，它恰好是文件管理系统中的关键部分。</p><h2 id="硬件外设的访问"><a href="#硬件外设的访问" class="headerlink" title="硬件外设的访问"></a>硬件外设的访问</h2><p>在 Report 中我们已经知道，访问外设需避免向 Cache 中写入，所以我们通过访问 kseg1 段，来实现对物理内存的访问。例如 console 设备物理地址为 <code>DEV_CONS_ADDRESS</code>，那么我们要写入的虚拟地址应该为 <code>DEV_CONS_ADDRESS | KSEG1</code> 。</p><h3 id="内核态实现"><a href="#内核态实现" class="headerlink" title="内核态实现"></a>内核态实现</h3><p>内核态中，我们访问的虚拟地址空间不受限制，所以可以直接访问对应地址。</p><p>例如函数 <code>printcharc</code> 就通过直接访问内存实现向控制台的输入：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意使用 volatile 关键字以避免写入操作被优化</span></span><br></pre></td></tr></table></figure><h3 id="用户态实现-Exercise-5-1-5-2"><a href="#用户态实现-Exercise-5-1-5-2" class="headerlink" title="用户态实现 - Exercise 5.1 5.2"></a>用户态实现 - Exercise 5.1 5.2</h3><p>由于我们采用微内核的思路进行设计，所以文件系统需要工作于用户态中，那么就必须要实现用户态中的读写操作。MOS 采用<strong>系统调用</strong>的方式，先<strong>陷入内核态</strong>，再直接利用上一种方法读写，最后完成信息等的传递。这也就是 Exercise 5.1 + 5.2 的实现内容</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  从 va 处读数据，并写入指定外设的地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *  Data within [va, va+len) is copied to the physical address &#x27;pa&#x27;.</span></span><br><span class="line"><span class="comment"> *  Return 0 on success.</span></span><br><span class="line"><span class="comment"> *  Return -E_INVAL on bad address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: 使用 kseg1 段虚拟地址访问外设.</span></span><br><span class="line"><span class="comment"> * Hint: 使用 &#x27;is_illegal_va_range&#x27; 检测 va 有效性.</span></span><br><span class="line"><span class="comment"> * Hint: You MUST use &#x27;memcpy&#x27; to copy data after checking the validity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  All valid device and their physical address ranges:</span></span><br><span class="line"><span class="comment"> ** ---------------------------------*</span></span><br><span class="line"><span class="comment"> *|   device   | start addr | length |</span></span><br><span class="line"><span class="comment"> ** -----------+------------+--------*</span></span><br><span class="line"><span class="comment"> *|  console   | 0x10000000 | 0x20   | (dev_cons.h)</span></span><br><span class="line"><span class="comment"> *|  IDE disk  | 0x13000000 | 0x4200 | (dev_disk.h)</span></span><br><span class="line"><span class="comment"> *|    rtc     | 0x15000000 | 0x200  | (dev_rtc.h)</span></span><br><span class="line"><span class="comment"> ** ---------------------------------*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_write_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (1/2) */</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa &lt; <span class="number">0x10000000</span> || pa &gt; <span class="number">0x15000200</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TEST 5-1: Forget to think about the illegal_pa in this part</span></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000021</span> &amp;&amp; pa &lt; <span class="number">0x13000000</span>) || </span><br><span class="line">(pa &gt;= <span class="number">0x13004201</span> &amp;&amp; pa &lt; <span class="number">0x15000000</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000000</span> &amp;&amp; pa &lt;= <span class="number">0x10000020</span> &amp;&amp; (pa + len) &gt; <span class="number">0x10000020</span>) ||</span><br><span class="line">    (pa &gt;= <span class="number">0x13000000</span> &amp;&amp; pa &lt;= <span class="number">0x13004200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x13004200</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x15000000</span> &amp;&amp; pa &lt;= <span class="number">0x15000200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *) (KSEG1 + pa), (<span class="type">const</span> <span class="type">void</span> *) va, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  从外设指定地址中读取数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hint: You MUST use &#x27;memcpy&#x27; to copy data after checking the validity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_read_dev</span><span class="params">(u_int va, u_int pa, u_int len)</span> &#123;</span><br><span class="line"><span class="comment">/* Exercise 5.1: Your code here. (2/2) */</span></span><br><span class="line"><span class="keyword">if</span> (is_illegal_va_range(va, len)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pa &lt; <span class="number">0x10000000</span> || pa &gt; <span class="number">0x15000200</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000021</span> &amp;&amp; pa &lt; <span class="number">0x13000000</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x13004201</span> &amp;&amp; pa &lt; <span class="number">0x15000000</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((pa &gt;= <span class="number">0x10000000</span> &amp;&amp; pa &lt;= <span class="number">0x10000020</span> &amp;&amp; (pa + len) &gt; <span class="number">0x10000020</span>) ||</span><br><span class="line">    (pa &gt;= <span class="number">0x13000000</span> &amp;&amp; pa &lt;= <span class="number">0x13004200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x13004200</span>) ||</span><br><span class="line">(pa &gt;= <span class="number">0x15000000</span> &amp;&amp; pa &lt;= <span class="number">0x15000200</span> &amp;&amp; (pa + len) &gt; <span class="number">0x15000200</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>((<span class="type">void</span> *) va, (<span class="type">const</span> <span class="type">void</span> *) (KSEG1 + pa), len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exercise 5.2 是实现在用户态中的 <code>msyscall</code> 接口，实现方式与其他系统调用类似。</p><h2 id="IDE-磁盘与读写"><a href="#IDE-磁盘与读写" class="headerlink" title="IDE 磁盘与读写"></a>IDE 磁盘与读写</h2><p>在 MOS 系统中，GXemul 为我们提供了模拟的 IDE 磁盘，每次读写的单位是一个扇区（512 Byte）。和其他的外设一样，在指定位置读写可以实现和磁盘的交互，地址表如下：</p><table><thead><tr><th align="center">偏移</th><th align="center">效果</th><th align="center">位宽</th></tr></thead><tbody><tr><td align="center">0x0000</td><td align="center">写：下一次读写操作的<strong>偏移字节数</strong></td><td align="center">4 Byte</td></tr><tr><td align="center">0x0008</td><td align="center">写：设置高 32 位偏移</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0010</td><td align="center">写：下一次读写的磁盘号</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0020</td><td align="center">写：开始操作（0读/1写）</td><td align="center">4 Byte</td></tr><tr><td align="center">0x0030</td><td align="center">读：上一次操作的返回值（0成功/非0失败）</td><td align="center">4 Byte</td></tr><tr><td align="center">0x4000 - 0x414f</td><td align="center">读/写：512 Byte 的一个扇区</td><td align="center">none</td></tr></tbody></table><ul><li>读操作后需要从缓冲区取出数据，写操作前需要事先写入缓冲区内</li></ul><h3 id="内核态实现-1"><a href="#内核态实现-1" class="headerlink" title="内核态实现"></a>内核态实现</h3><p>课程组在指导书中给出了内核态的访问实现，但实际上我们的 MOS 中并不需要这一函数去实现驱动，因为我们采用微内核架构，将访问磁盘的操作交给用户态完成，这里的代码只起到示例作用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义 - C</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">read_sector</span><span class="params">(<span class="type">int</span> diskno, <span class="type">int</span> offset)</span>;</span><br><span class="line"><span class="comment">// 实现 - MIPS</span></span><br><span class="line">LEAF(read_sector)</span><br><span class="line">    sw a0, <span class="number">0xB3000010</span>  <span class="meta"># choose the IDE id, must 0 in our MOS</span></span><br><span class="line">    sw a1, <span class="number">0xB3000000</span>  <span class="meta"># offset in the disk</span></span><br><span class="line">    li t0, <span class="number">0</span></span><br><span class="line">    sw t0, <span class="number">0xB3000020</span>  <span class="meta"># launch a <span class="string">&#x27;read&#x27;</span> action</span></span><br><span class="line">    lw v0, <span class="number">0xB3000030</span>  <span class="meta"># get the result of the action</span></span><br><span class="line">    nop</span><br><span class="line">    jr ra</span><br><span class="line">    nop</span><br><span class="line"><span class="title function_">END</span><span class="params">(read_sector)</span></span><br></pre></td></tr></table></figure><h3 id="用户态实现-Exercise-5-3"><a href="#用户态实现-Exercise-5-3" class="headerlink" title="用户态实现 - Exercise 5.3"></a>用户态实现 - Exercise 5.3</h3><p>在 MOS 中，实际完成对磁盘读写操作的是 <code>fs/ide.c</code> 中的两个函数，他们可在用户态使用，充当磁盘驱动。在这里我们就相当于复刻了前面的内核态驱动，使用 C 语言替代 MIPS，并使用系统调用来完成写入地址的操作。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  read data from IDE disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Parameters:</span></span><br><span class="line"><span class="comment">//  diskno: disk number.</span></span><br><span class="line"><span class="comment">//  secno: start sector number.</span></span><br><span class="line"><span class="comment">//  dst: destination for data read from IDE disk.</span></span><br><span class="line"><span class="comment">//  nsecs: the number of sectors to read.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: Use syscalls to access device registers and buffers.</span></span><br><span class="line"><span class="comment">// Sample: ide_read(0, blockno * SECT2BLK, va, SECT2BLK);</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_read</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *dst, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT;</span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sample: ide_read(0, blockno * SECT2BLK, va, SECT2BLK);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (1/2) */</span></span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_ID), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">//select disk_id</span></span><br><span class="line">        </span><br><span class="line">temp = begin + off;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_OFFSET), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// select reading offset_address</span></span><br><span class="line">        </span><br><span class="line">temp = DEV_DISK_OPERATION_READ;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// select operation</span></span><br><span class="line">        </span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_STATUS), <span class="keyword">sizeof</span>(temp))); </span><br><span class="line">        <span class="comment">// get reading result</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">panic_on(temp == <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev((<span class="type">void</span> *) ((u_int) dst + off), (DEV_DISK_ADDRESS | DEV_DISK_BUFFER), DEV_DISK_BUFFER_LEN));</span><br><span class="line">            <span class="comment">// pull from buffer</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ide_write</code> 同理，不再添加注释</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  write data to IDE disk.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ide_write</span><span class="params">(u_int diskno, u_int secno, <span class="type">void</span> *src, u_int nsecs)</span> &#123;</span><br><span class="line">u_int begin = secno * BY2SECT;</span><br><span class="line">u_int end = begin + nsecs * BY2SECT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (u_int off = <span class="number">0</span>; begin + off &lt; end; off += BY2SECT) &#123;</span><br><span class="line"><span class="type">uint32_t</span> temp = diskno;</span><br><span class="line"><span class="comment">/* Exercise 5.3: Your code here. (2/2) */</span></span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(src + off, (DEV_DISK_ADDRESS | DEV_DISK_BUFFER), BY2SECT));</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_ID), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">temp = begin + off;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_OFFSET), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">temp = DEV_DISK_OPERATION_WRITE;</span><br><span class="line">panic_on(-E_INVAL == syscall_write_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_START_OPERATION), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line">panic_on(-E_INVAL == syscall_read_dev(&amp;temp, (DEV_DISK_ADDRESS | DEV_DISK_STATUS), <span class="keyword">sizeof</span>(temp)));</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">panic_on(temp == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在函数中设置读写的偏移量时（例如 read 的 26 行），这里的偏移量不是 off 提供的偏移，而是读写地址相对于磁盘起始的偏移，也就是 <code>secno * BY2SECT + off</code>，如图：</p><p>完成这两个函数后，我们就可以通过在用户态调用 <code>ide_read/write</code> 来对磁盘进行操作了，这里的读写操作并不限制我们读写的大小（扇区数），但一定是<strong>整数个扇区（section）</strong>。通过对磁盘的自由读写，我们就能在此基础上建立合适的文件系统了。</p><h1 id="硬盘结构"><a href="#硬盘结构" class="headerlink" title="硬盘结构"></a>硬盘结构</h1><p>首先我们要区分两种磁盘的常见空间单位：</p><ul><li>扇区（section）：物理上划分磁盘的一个单位，大小通常为 512 Byte</li><li>磁盘块（block）：为了便于磁盘管理而虚拟出的一个单元，在 MOS 中大小为 4 KB</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span><br><span class="line"><span class="type">uint8_t</span> data[BY2BLK];</span><br><span class="line"><span class="type">uint32_t</span> type;</span><br><span class="line">&#125; disk[NBLOCK];</span><br></pre></td></tr></table></figure><p>通常情况下我们以磁盘块作为逻辑上管理磁盘的单位，每个 Block 的大小为 4100 字节</p><p>其次是两个特殊的磁盘块，分别代表磁盘上的第0块和第1块：引导扇区+分区表、超级块（Super Block）</p><ul><li>引导扇区+分区表：这部分在理论课的第二单元系统引导中已经涉及，主要与 BootLoader 和硬件处理相关，我们在 Gxemul 中不需要考虑这部分</li><li>超级块：包含磁盘的一些判断信息，同时充当<strong>当前磁盘的根目录</strong></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    u_int s_magic;         <span class="comment">// FS_MAGIC</span></span><br><span class="line">    u_int s_nblocks;       <span class="comment">// number of blocks = 1024</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>    <span class="comment">// root directory of the disk</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>其中 <code>s_root</code> 的类型为 <code>FTYPE_DIR</code>，<code>f_name</code> 为 <code>&quot;/&quot;</code></li></ul><p>在 MOS 中，我们通过设置结构体 Block 的数组 disk 来对磁盘进行表示，每个 Block 就代表一个磁盘块，data是具体的空间，type是磁盘块用途/状态的标记。</p><h2 id="磁盘状态与更改"><a href="#磁盘状态与更改" class="headerlink" title="磁盘状态与更改"></a>磁盘状态与更改</h2><p><code>tools/fsformat.c</code></p><p>在实验中的 IDE 磁盘中，我们占用了一些磁盘块用来充当标记是否已分配磁盘块的<strong>位图数组</strong>，通过读取数组的状态来得知磁盘块的分配情况，这点与内存管理中我们使用的链表不同。</p><p>通常情况下这部分磁盘块紧跟磁盘的<strong>超级块</strong></p><h3 id="磁盘文件的创建"><a href="#磁盘文件的创建" class="headerlink" title="磁盘文件的创建"></a>磁盘文件的创建</h3><p>我们使用 <code>tools/fsformat.c</code> 的 <code>main</code> 函数来在 Linux 中创建一个可供我们 MOS 使用的磁盘镜像文件。<code>Usage: fsformat &lt;img-file&gt; [files or directories]...</code> 意味着函数的 <code>argv[1]</code> 代表着生成镜像的路径，后面的每个参数都代表准备写入的文件/目录路径。</p><p>我们来分析一下 <code>fsformat.c</code> 是怎样创建一个磁盘镜像的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> File) == BY2FILE);</span><br><span class="line">init_disk();  <span class="comment">// 初始化磁盘</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: fsformat &lt;img-file&gt; [files or directories]...\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="type">char</span> *name = argv[i];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line"><span class="type">int</span> r = stat(name, &amp;stat_buf);</span><br><span class="line">assert(r == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(stat_buf.st_mode)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing directory &#x27;%s&#x27; recursively into disk\n&quot;</span>, name);</span><br><span class="line">write_directory(&amp;super.s_root, name); <span class="comment">// 向 root 写入该目录/文件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(stat_buf.st_mode)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;writing regular file &#x27;%s&#x27; into disk\n&quot;</span>, name);</span><br><span class="line">write_file(&amp;super.s_root, name);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;&#x27;%s&#x27; has illegal file mode %o\n&quot;</span>, name, stat_buf.st_mode);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">flush_bitmap();</span><br><span class="line">finish_fs(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序逻辑如下：</li><li>磁盘空间分配：在 <code>main</code> 开始前，创建全局数组 <code>disk</code> 代表磁盘的<strong>全部空间</strong>，相当于在程序内存当中开辟了一块磁盘等待处理</li><li>写入前的初始化：检查 <code>File</code> 大小符合规格后，调用 <code>init_disk</code> 函数对磁盘块信息进行初始化。随后执行参数检查，不符合规格将无法创建磁盘镜像</li><li>文件信息获取：遍历每个文件，获取文件属性（主要区分是目录文件还是常规文件）</li><li>文件写入：获取文件属性后在不同的 <code>if-else</code> 分支中执行不同的写入函数</li><li>封装磁盘镜像：全部文件写入后，执行函数对位图进行更新，同时封装磁盘镜像，结束程序</li></ul><p>最后，在 <code>make</code> 的过程中会编译 <code>fsformat.c</code> 并调用程序，过程中的命令行与输出，<code>fs</code> 目录下的 Makefile 如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../tools/fsformat ../target/fs.img \</span><br><span class="line">$(<span class="built_in">printf</span> <span class="string">&#x27;%s\n&#x27;</span> rootfs/motd rootfs/newmotd   | awk -F/ <span class="string">&#x27;&#123; ns[$NF]=$0 &#125; END &#123; for (n in ns) &#123; print ns[n] &#125; &#125;&#x27;</span>)</span><br><span class="line">writing regular file <span class="string">&#x27;rootfs/newmotd&#x27;</span> into disk</span><br><span class="line">writing regular file <span class="string">&#x27;rootfs/motd&#x27;</span> into disk</span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="variable">$(user_dir)</span>/<span class="keyword">include</span>.mk</span><br><span class="line">USERLIB     := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(user_dir)</span>/, <span class="variable">$(USERLIB)</span>)</span></span><br><span class="line">USERAPPS    := <span class="variable">$(<span class="built_in">addprefix</span> <span class="variable">$(user_dir)</span>/, <span class="variable">$(USERAPPS)</span>)</span></span><br><span class="line">FSIMGFILES  := rootfs/motd rootfs/newmotd <span class="variable">$(USERAPPS)</span> $(fs-files)</span><br><span class="line"></span><br><span class="line"><span class="section">image: <span class="variable">$(tools_dir)</span>/fsformat</span></span><br><span class="line">dd if=/dev/zero of=../target/fs.img bs=4096 count=1024 2&gt;/dev/null</span><br><span class="line"><span class="comment"># using awk to remove paths with identical basename from FSIMGFILES</span></span><br><span class="line"><span class="variable">$(tools_dir)</span>/fsformat ../target/fs.img \</span><br><span class="line">$<span class="variable">$(printf &#x27;%s\n&#x27; <span class="variable">$(FSIMGFILES)</span> | awk -F/ &#x27;&#123; ns[$$NF]=$$0 &#125; END &#123; for (n in ns)</span> &#123; print ns[n] &#125; &#125;&#x27;)</span><br></pre></td></tr></table></figure><p>具体而言，Makefile 会把 <code>rootfs/motd</code> <code>rootfs/newmotd</code> <code>USERAPPS</code> <code>fs-files</code> 这几类文件写入磁盘镜像中，但是在 <code>user/include.mk</code> 中，Lab5 处并没有定义 <code>USERAPP</code>，所以只有前两个文件被写入磁盘（）</p><h4 id="写入前的初始化-init-disk"><a href="#写入前的初始化-init-disk" class="headerlink" title="写入前的初始化 - init_disk"></a>写入前的初始化 - init_disk</h4><p>在 init_disk 中，我们需要对位图和特殊的磁盘块进行初始化。</p><ul><li>初始化引导扇区块（Step 1）和超级块（Step 3）</li><li>将所有位图需要的磁盘块标记为 BMAP 类</li><li>对这些块的 data 域进行初始化（全置为可用）</li><li>修订位图数组：删去那些本<strong>不存在</strong>、又被位图初始化的磁盘块</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_disk</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> i, diff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Mark boot sector block.</span></span><br><span class="line">disk[<span class="number">0</span>].type = BLOCK_BOOT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Initialize boundary.</span></span><br><span class="line">nbitblock = (NBLOCK + BIT2BLK - <span class="number">1</span>) / BIT2BLK;</span><br><span class="line">nextbno = <span class="number">2</span> + nbitblock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 2: Initialize bitmap blocks.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line">disk[<span class="number">2</span> + i].type = BLOCK_BMAP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitblock; ++i) &#123;</span><br><span class="line"><span class="built_in">memset</span>(disk[<span class="number">2</span> + i].data, <span class="number">0xff</span>, BY2BLK);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (NBLOCK != nbitblock * BIT2BLK) &#123;</span><br><span class="line">diff = NBLOCK % BIT2BLK / <span class="number">8</span>;</span><br><span class="line"><span class="built_in">memset</span>(disk[<span class="number">2</span> + (nbitblock - <span class="number">1</span>)].data + diff, <span class="number">0x00</span>, BY2BLK - diff);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 3: Initialize super block.</span></span><br><span class="line">disk[<span class="number">1</span>].type = BLOCK_SUPER;</span><br><span class="line">super.s_magic = FS_MAGIC;</span><br><span class="line">super.s_nblocks = NBLOCK;</span><br><span class="line">super.s_root.f_type = FTYPE_DIR;</span><br><span class="line"><span class="built_in">strcpy</span>(super.s_root.f_name, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FS_MAGIC 0x68286097 <span class="comment">// Everyone&#x27;s favorite OS class （6.828是吧</span></span></span><br></pre></td></tr></table></figure><ul><li>由于我们不应修改引导扇区的内容，所以在 Step 1 中只进行了状态的标记；超级块则应该在 Step 3 中把包括状态在内的多个字段初始化。</li><li>Step 2 中，<code>nbitblock</code> 代表的是位图所需的磁盘块数量，最后的一个 <code>if</code> 判断将未对齐的尾端进行删除。</li></ul><h4 id="文件信息获取-struct-stat"><a href="#文件信息获取-struct-stat" class="headerlink" title="文件信息获取 - struct stat"></a>文件信息获取 - struct stat</h4><ul><li><code>struct stat</code> 这个结构体是用来描述一个 Linux 系统文件系统中的文件属性的结构。可以通过 stat 函数获取文件的所有相关信息，一般情况下，我们关心文件大小和创建时间、访问时间、修改时间。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>; <span class="comment">// 返回值为 0 说明成功获取</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fdnum, <span class="keyword">struct</span> Stat *stat)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">        <span class="type">mode_t</span>     st_mode;       <span class="comment">// - 文件对应的模式，文件，目录等</span></span><br><span class="line">        <span class="type">ino_t</span>      st_ino;        <span class="comment">// inode节点号</span></span><br><span class="line">        <span class="type">dev_t</span>      st_dev;        <span class="comment">// 设备号码</span></span><br><span class="line">        <span class="type">dev_t</span>      st_rdev;       <span class="comment">// 特殊设备号码</span></span><br><span class="line">        <span class="type">nlink_t</span>    st_nlink;      <span class="comment">// 文件的连接数</span></span><br><span class="line">        <span class="type">uid_t</span>      st_uid;        <span class="comment">// 文件所有者</span></span><br><span class="line">        <span class="type">gid_t</span>      st_gid;        <span class="comment">// 文件所有者对应的组</span></span><br><span class="line">        <span class="type">off_t</span>      st_size;       <span class="comment">// 普通文件，对应的文件字节数</span></span><br><span class="line">        <span class="type">time_t</span>     st_atime;      <span class="comment">// - 文件最后被访问的时间</span></span><br><span class="line">        <span class="type">time_t</span>     st_mtime;      <span class="comment">// - 文件内容最后被修改的时间</span></span><br><span class="line">        <span class="type">time_t</span>     st_ctime;      <span class="comment">// - 文件状态改变时间</span></span><br><span class="line">        <span class="type">blksize_t</span> st_blksize;     <span class="comment">// 文件内容对应的块大小</span></span><br><span class="line">        <span class="type">blkcnt_t</span>   st_blocks;     <span class="comment">// 伟建内容对应的块数量</span></span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>S_ISDIR(stat_buf.st_mode)</code> 是一个宏，查询当前的结构体是否为目录（isDir），<code>ISREG</code> 同理，说明是常规文件，我们据此将文件分类</li></ul><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><p>我们实现了两种写入函数，分别处理<strong>目录文件</strong>和<strong>常规文件</strong>的写入。这两类函数的基础是 POSIX 标准库函数，我们在 Linux 环境中利用这些函数把待写入的文件转写到磁盘镜像中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Write directory to disk under specified dir.</span></span><br><span class="line"><span class="comment">//  Notice that we may use POSIX library functions to operate on</span></span><br><span class="line"><span class="comment">//  directory to get file infomation.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_directory</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">DIR *dir = opendir(path); <span class="comment">// 获取路径所在信息</span></span><br><span class="line"><span class="keyword">if</span> (dir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">perror(<span class="string">&quot;opendir&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">pdir</span> =</span> create_file(dirf); <span class="comment">// 创建目录文件</span></span><br><span class="line"><span class="built_in">strncpy</span>(pdir-&gt;f_name, basename(path), MAXNAMELEN - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pdir-&gt;f_name[MAXNAMELEN - <span class="number">1</span>] != <span class="number">0</span>) &#123; <span class="comment">// 过程中的目录名称超长度</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;file name is too long: %s\n&quot;</span>, path);</span><br><span class="line"><span class="comment">// File already created, no way back from here.</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdir-&gt;f_type = FTYPE_DIR; <span class="comment">// 设置目录类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> dirent *e; (e = readdir(dir)) != <span class="literal">NULL</span>;) &#123; <span class="comment">// 递归地获取所有当前目录下的文件，并创建目录与文件</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;.&quot;</span>) != <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(e-&gt;d_name, <span class="string">&quot;..&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="type">char</span> *buf = <span class="built_in">malloc</span>(<span class="built_in">strlen</span>(path) + <span class="built_in">strlen</span>(e-&gt;d_name) + <span class="number">2</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;%s/%s&quot;</span>, path, e-&gt;d_name);</span><br><span class="line"><span class="keyword">if</span> (e-&gt;d_type == DT_DIR) &#123;</span><br><span class="line">write_directory(pdir, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">write_file(pdir, buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">closedir(dir);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>readdir</code> 函数循环读取当前目录中的下一个<strong>目录进入点</strong>，大概可以理解为遍历内容中的文件/目录。需要注意，代表当前目录的 <code>.</code> 和父目录的 <code>..</code> 也在循环中可被读取，所以循环中要把他们去掉。</li></ul><p><code>writefile</code> 逻辑相对简单：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Write file to disk under specified dir.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">write_file</span><span class="params">(<span class="keyword">struct</span> File *dirf, <span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line"><span class="type">int</span> iblk = <span class="number">0</span>, r = <span class="number">0</span>, n = <span class="keyword">sizeof</span>(disk[<span class="number">0</span>].data);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">target</span> =</span> create_file(dirf);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* in case `create_file` is&#x27;t filled */</span></span><br><span class="line"><span class="keyword">if</span> (target == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fd = open(path, O_RDONLY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get file name with no path prefix.</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *fname = <span class="built_in">strrchr</span>(path, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> (fname) &#123;</span><br><span class="line">fname++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fname = path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(target-&gt;f_name, fname);</span><br><span class="line"></span><br><span class="line">target-&gt;f_size = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">target-&gt;f_type = FTYPE_REG;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start reading file. 从 Linux 的环境中读到 disk 中存储</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"><span class="keyword">while</span> ((r = read(fd, disk[nextbno].data, n)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">save_block_link(target, iblk++, next_block(BLOCK_DATA));</span><br><span class="line">&#125;</span><br><span class="line">close(fd); <span class="comment">// Close file descriptor.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中也同样调用了一些本文件的函数，做一些基本介绍</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Allocate an unused &#x27;struct File&#x27; under the specified directory.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  Use &#x27;make_link_block&#x27; to allocate a new block for the directory if there are no existing unused</span></span><br><span class="line"><span class="comment">//  &#x27;File&#x27;s.</span></span><br><span class="line"><span class="keyword">struct</span> File *<span class="title function_">create_file</span><span class="params">(<span class="keyword">struct</span> File *dirf)</span> &#123;</span><br><span class="line"><span class="type">int</span> nblk = dirf-&gt;f_size / BY2BLK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Step 1: Iterate through all existing blocks in the directory.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblk; ++i) &#123;</span><br><span class="line"><span class="type">int</span> bno; <span class="comment">// the block number</span></span><br><span class="line"><span class="comment">// If the block number is in the range of direct pointers (NDIRECT), get the &#x27;bno&#x27;</span></span><br><span class="line"><span class="comment">// directly from &#x27;f_direct&#x27;. Otherwise, access the indirect block on &#x27;disk&#x27; and get</span></span><br><span class="line"><span class="comment">// the &#x27;bno&#x27; at the index.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (1/3) */</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; NDIRECT) &#123;</span><br><span class="line">bno = dirf-&gt;f_direct[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">bno = ((u_int *)(disk[dirf-&gt;f_indirect].data))[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Get the directory block using the block number.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate through all &#x27;File&#x27;s in the directory block.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">struct</span> File *f = blk; f &lt; blk + FILE2BLK; ++f) &#123;</span><br><span class="line"><span class="comment">// If the first byte of the file name is null, the &#x27;File&#x27; is unused.</span></span><br><span class="line"><span class="comment">// Return a pointer to the unused &#x27;File&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (2/3) */</span></span><br><span class="line"><span class="keyword">if</span> (f-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Step 2: If no unused file is found, allocate a new block using &#x27;make_link_block&#x27; function</span></span><br><span class="line"><span class="comment">// and return a pointer to the new block on &#x27;disk&#x27;.</span></span><br><span class="line"><span class="comment">/* Exercise 5.5: Your code here. (3/3) */</span></span><br><span class="line"><span class="type">int</span> bno = make_link_block(dirf, dirf-&gt;f_size / BY2BLK);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">blk</span> =</span> (<span class="keyword">struct</span> File *)(disk[bno].data);</span><br><span class="line"><span class="keyword">return</span> blk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的磁盘镜像就生成完毕了，接下来完成的就是真正文件管理的内容。</p><blockquote><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part2/">See Part2 at here</a></p><p><a href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part3/">See Part3 at here</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT3-Summary</title>
      <link href="/p/60713.html"/>
      <url>/p/60713.html</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象设计与构造第三单元总结"><a href="#面向对象设计与构造第三单元总结" class="headerlink" title="面向对象设计与构造第三单元总结"></a>面向对象设计与构造第三单元总结</h1><ul><li>分析本单元的测试过程<ul><li>谈谈你对黑箱测试、白箱测试的理解</li><li>对单元测试、功能测试、集成测试、压力测试、回归测试的理解</li><li>是否使用了测试工具</li><li>数据构造有何策略</li></ul></li><li>梳理本单元的架构设计，分析自己的图模型构建和维护策略<ul><li>分析作业中出现的性能问题及其修复情况，谈谈自己对规格与实现分离的理解</li></ul></li><li>本单元中同学们实现了OK测试方法，请同学们思考OK测试对于检验代码实现与规格的一致性的作用，有何改进何建议</li><li>本单元学习体会</li></ul><h1 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h1><ul><li>单元第一次作业，需要完成的任务为实现简单社交关系的模拟和查询，学习目标为 <strong>入门级JML规格理解与代码实现</strong>。</li><li>单元第二次作业，需要完成的目标是进一步实现社交关系模拟系统中的群组和消息功能，学习目标为<strong>进一步掌握JML规格的理解与实现</strong>。</li><li>单元第三次作业，需要完成的目标是进一步实现社交关系系统中不同消息类型以及相关操作，学习目标是<strong>理解JML规格在面向对象设计与构造中的重要意义，并掌握利用JML规格提高代码质量的能力</strong></li></ul><p>这个单元主要根据课程组提供的类、方法及其相关的 JML 指导，由我们自行书写的这些要求的实现。本单元指导书内容较少，主要的信息来源是我们的官方代码包。阅读 JML 并提取信息，完成代码实现是本单元的主要难点和内容。</p><h1 id="思路重点"><a href="#思路重点" class="headerlink" title="思路重点"></a>思路重点</h1><p>由于我们实现的类 <code>Person</code>、<code>Group</code>、<code>Network</code> 含有包含关系，并且每个类中都含有不同的字段和相关信息。对于整个代码的实现，我们要考虑的点有以下几个：</p><ol><li>这些信息由输入提供，所以就需要合理选择数据结构对其内的对象进行管理。</li><li>由于会出现大量的 <code>query</code>（查询）操作，所以如何快速获取对象、查询信息是提高程序效率的一大关键。</li><li>同时在后两次作业中，还出现了修改、破坏已有数据的修改操作，对已有数据的维护需要着重考虑。</li><li>在最后一次作业中出现了某个节点的最小环查询，我们需要提高图论中的算法效率以满足大量的查询请求。</li></ol><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><h2 id="本单元测试过程"><a href="#本单元测试过程" class="headerlink" title="本单元测试过程"></a>本单元测试过程</h2><p>本单元构造了自动数据生成器，针对网络中节点数、组的数量、关系的数量和抛出异常的综合性进行了考虑，通过与同学输出等进行对拍的形式进行<strong>黑盒测试</strong>。检测出了多个异常、Group 计算中发生的错误。</p><h2 id="黑箱测试-amp-白箱测试"><a href="#黑箱测试-amp-白箱测试" class="headerlink" title="黑箱测试 &amp; 白箱测试"></a>黑箱测试 &amp; 白箱测试</h2><blockquote><p><strong>黑箱测试</strong>又称为“功能测试”，是将测试对象看做一个黑盒，在并不考虑软件产品的内部结构和处理过程的基础上对软件产品进行功能测试。</p><p><strong>白箱测试</strong>是测试人员要了解程序结构和处理过程，按照程序内部逻辑测试程序，检查程序中的每条通路是否按照预定要求正确工作。它主要的针对被测程序的源代码，测试可以完全不考虑程序的功能。</p></blockquote><p>简单来说，黑盒测试不关注程序的内部构造、数据的存储与处理方式，只关心输出的结果是否有效、程序的最终效率如何。黑盒测试更多地用在系统级别的验收、检测上。因为系统中的黑盒范围大，各个模块能够产生更多的交互，检验模块间的组合正确性。</p><p>而白箱测试考虑的方向则大相径庭。白箱测试更注重信息在程序的各个方法（模块）内部的流动，保证其在单个方法内的正确性，再将多个方法的接口连接，从而检查整个系统的正确性。白箱测试由系统逻辑而来，需要测试人员知晓程序的工作方式，并据此进行测试用例的编写，并对覆盖情况进行分析。</p><h2 id="单元测试、功能测试、集成测试、压力测试、回归测试"><a href="#单元测试、功能测试、集成测试、压力测试、回归测试" class="headerlink" title="单元测试、功能测试、集成测试、压力测试、回归测试"></a>单元测试、功能测试、集成测试、压力测试、回归测试</h2><blockquote><p><strong>单元测试</strong>：完成最小的软件设计单元（模块）的验证工作，目标是确保模块被正确的编码，使用过程设计描述作为指南，对重要的控制路径进行测试以发现模块内的错误，通常情况下是白盒的，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，及早的发现和解决不易显现的错误。</p></blockquote><p>单元测试大多为静态的白盒测试，它从系统的功能指导书出发，静态地检测代码的功能，避免要求读错等基础错误。</p><blockquote><p><strong>功能测试</strong>：使用人工和自动手段来运行或测试某个系统的过程。其目的在于检验它是否满足规定的需求或弄清楚预期结果与实际结果之间的差别。</p></blockquote><p>功能测试，一般是对单个模块测试，提供指定输入后检测输出，从而检测功能实现的正确与否。</p><blockquote><p><strong>集成测试</strong>：通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构，应当避免一次性的集成（除非软件规模很小），而采用增量集成。</p><ul><li>自顶向下集成：模块集成的顺序是首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去。</li><li>自底向上集成：从原子模块开始来进行构造和测试，因为模块是自底向上集成的，进行时要求所有隶属于某个给顶层次的模块总是存在的，也不再有使用稳定测试桩的必要。</li></ul></blockquote><p>集成测试，则是将经过单元的功能测试后的模块进行一定程度组合，检测其能不能满足某种实际情况的应用。这种测试要求的综合性更强。</p><blockquote><p><strong>压力测试</strong>是一种基本的质量保证行为，它是每个重要软件测试工作的一部分。通过在有限时间内进行大量功能上的请求和并行请求以测试程序处理的效率与可靠性。</p></blockquote><p>在通过集成测试后，我们可以认为程序已经有了处理基础请求的能力。下一步进行的压力测试就是检测程序的效率和可靠程度。</p><blockquote><p><strong>回归测试</strong>：回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现。根据修复好了的缺陷再重新进行测试。回归测试的目的在于验证以前出现过但已经修复好的缺陷不再重新出现。一般指对某已知修正的缺陷再次围绕它原来出现时的步骤重新测试。</p></blockquote><p>在检测过程中如果发生了修改与版本迭代，为了保证原有正确的样例、功能仍然可用，我们需要进行回归测试，保证之前正确的功能仍然正确，并且能把错误的样例修复。我们的 bug 修复采用的也是这种回归测试的思路。</p><h2 id="测试工具-amp-数据构造"><a href="#测试工具-amp-数据构造" class="headerlink" title="测试工具 &amp; 数据构造"></a>测试工具 &amp; 数据构造</h2><p>课程组推荐我们进行单元测试，但限于网络资源的覆盖性与时效性，我个人没有使用单元测试工具进行白箱测试，而是使用了数据构造并对拍的黑盒测试方式进行测试。</p><p>在进行自行数据构造的过程中，我主要对人数进行了限制，这样可以保证边、组等信息更加集中，查询数据时返回不为无效值的期望也会更高，测试的效果更好。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="图模型"><a href="#图模型" class="headerlink" title="图模型"></a>图模型</h2><p>本次作业的图结构中，节点是 <code>Person</code> 类型，边是 <code>person</code> 之间存在的 <code>acquaintance</code> 关系。我将 <code>acquaintance</code> 保存在每个 <code>Person</code> 结构体内，也就是说通过查询节点，可以获得与其相关的边。</p><p>同时，网络结构由 <code>Network</code> 结构实现，其中包含了一个所有 <code>Person</code> 的集合 <code>people</code>，以及包含所有边的集合 <code>arcPool</code>。他们都以 <code>HashMap</code> 的形式存在，便于对整个网络进行查询、获取操作。</p><h2 id="维护策略"><a href="#维护策略" class="headerlink" title="维护策略"></a>维护策略</h2><p>由于本单元作业存在大量的查询、计算操作，所以对数据进行动态维护十分重要，良好的动态维护结构能降低多次重复查询时的高消耗</p><p>对于指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query_group_value_sum <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">query_group_age_var <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><p>由于 <code>Person</code> 的年龄不会发生改变，所以在 <code>addToGroup</code> 指令发生时，对 <code>Group</code> 的 age 进行动态维护就可以避免反复的方差计算。由于只有 <code>addToGroup</code>、<code>addRelation</code>、<code>modifyRelation</code> 三个途径可以更改 <code>value</code>（前者直接改变 <code>Group</code>后两者通过更改 <code>Person</code> 的 <code>value</code> 来实现对所属的<strong>所有</strong> <code>Group</code> 进行改变），同理此时应该进行动态维护。</p><p>对于指令：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">query_best_acquaintance <span class="title function_">id</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">query_couple_sum</span><br></pre></td></tr></table></figure><p>由于 <code>acquaintance</code> 和 <code>couple</code> 只在 <code>addRelation</code> 和 <code>modifyRelation</code> 时发生改变，所以直接在这两类指令后进行更新即可，其余情况直接返回缓存的状态值即可满足要求。</p><h2 id="性能与修复"><a href="#性能与修复" class="headerlink" title="性能与修复"></a>性能与修复</h2><p>在前两次作业中，由于动态维护的实现较为完备，所以没有出现性能问题。在第三次作业中由于课程组劝导我们不要过度卷算法，所以在查询最小块时造成的部分性能损耗没有做修订，最后导致一个点出现了超时的情况。在 BUG 修复环节，对于这部分损耗的性能做了部分优化，通过了修复的回归测试。</p><h1 id="规格与实现"><a href="#规格与实现" class="headerlink" title="规格与实现"></a>规格与实现</h1><p>课程组提示我们要考虑<strong>规格与实现分离</strong>，我个人认为，规格是程序开发者对于程序功能的一种约束，它从黑盒的角度出发，只对输入、结果、副作用做了约束。而实现则不仅需要考虑以上这些，还要考虑程序内部的逻辑结构。实现可以不完全按照规格的要求，如果能保证输入、输出、副作用等前后置条件满足，也能称其<strong>满足</strong>了规则。</p><h1 id="OK-测试"><a href="#OK-测试" class="headerlink" title="OK 测试"></a>OK 测试</h1><p>对于检验代码实现与规格的一致性的作用</p><p>我认为 OK test 对于编写代码没有什么有效的帮助，因为在我们实现的 OK test 中，并没有存在检查出被检测方法错误的情况，反倒是这个 OK test 出过问题。</p><p>但它对于<strong>完全按照</strong>规格实现方法的程序员的还有点作用，它能帮你看出发生错误的操作具体在哪一步，从而根据当前状况反推、修改代码，修复 bug。而且我没有查出什么是“规格的一致性”。。。在这我无法做出解释。</p><h1 id="总结体会"><a href="#总结体会" class="headerlink" title="总结体会"></a>总结体会</h1><p>实际上，尽管本单元整体难度低，往届的学长也说第三单元的难度略有降低，但是实现的效果或者说最终成绩却和前两单元基本持平。最后一次作业在课程组的压力测试下没有抗住。</p><p>在实现规格时，不仅要考虑规格的要求，即完成度；也要考虑能否通过完善的方法去改进算法的实现，即效率。没有效率，你再对也没用，没有完成度，算的再快也没用。</p><p>本单元在设计方面的主要收获是学会了一种严谨的表达设计的方式。通过实现 JML 书写的方法引导，我对于如何表达设计以及准确表达自己的设计的重要性有了更深入的理解。</p><p>但可惜没有抗住，无言。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab5-1-Exam</title>
      <link href="/p/36639.html"/>
      <url>/p/36639.html</url>
      
        <content type="html"><![CDATA[<p>本次上机还算中规中矩，能够完全理解题意后，写起来还是很顺手的。<del>（实际上，根本读题的信息都读不全）</del></p><h1 id="Exam-时间查询与计算"><a href="#Exam-时间查询与计算" class="headerlink" title="Exam - 时间查询与计算"></a>Exam - 时间查询与计算</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 Lab5 与 Lab2 中，我们分别实现了不同种类外设的读写操作，现在我们需要实现一个能够获取当前物理时间的函数，和一个要求进程必须等待指定时间后才能运行的函数。现在我们介绍如何获取<strong>实时间</strong>。</p><p>GXemul 中除了磁盘 <code>disk</code> 还存在另一类外设——实时时钟 <code>rtc</code> (Real-Time Clock)，其中记录了 Unix 时间戳，即从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数。为了进一步精确 Unix 时间戳， <code>rtc</code> 中还记录了一个微秒字段。</p><p>当我们需要读取 <code>rtc</code> 中存放的时钟的值时，需要<strong>先触发时钟更新</strong>，才能获取到正确的数据，未更新时首次读取默认是 0（别问我怎么知道的）</p><p>在 GXemul 的手册中我们能查阅到 <code>rtc</code> 的起始地址为 <code>0x15000000</code>，且不同偏移量下的读写效果如下：</p><table><thead><tr><th>偏移</th><th>效果</th><th>数据位宽</th></tr></thead><tbody><tr><td><code>0x0000</code></td><td>读/写：触发时钟更新</td><td>4 bytes</td></tr><tr><td><code>0x0010</code></td><td>读：从格林威治时间 1970 年 01 月 01 日 00 时 00 分 00 秒起至现在的总秒数</td><td>4 bytes</td></tr><tr><td><code>0x0020</code></td><td>读：为精确 Unix 时间戳而记录的微秒数，范围为 0 到 999999 微秒（1秒内）</td><td>4 bytes</td></tr></tbody></table><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>本题需要完成两个用户态中的函数，并要求在 <code>user/include/lib.h</code> 中声明，<code>user/lib/ipc.c</code> 中实现</p><ol><li><code>u_int get_time(u_int *us)</code></li></ol><p>从 <code>rtc</code> 中读取<strong>总秒数</strong>和<strong>微秒数</strong>，总秒数作为该函数的返回值，微秒数通过指针参数 <code>us</code> 返回。</p><ol start="2"><li><code>void usleep(u_int us)</code></li></ol><p>在任一用户态进程进入 <code>usleep</code> 函数后，必须停留 <code>us</code> 微秒后才能退出函数。这其中允许时间片的轮转，也就是说<strong>在等待调度的过程中仍然计时</strong></p><ul><li>请避免单位换算时可能发生的整数溢出</li><li><code>u_int</code> 为无符号整数，如果需要进行减法得到有符号整数，请在<strong>运算前</strong>使用 <code>(int)</code> 进行强制类型转换</li><li>课程组给出的一种 <code>usleep</code> 的实现：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">usleep</span><span class="params">(u_int us)</span> &#123;</span><br><span class="line"><span class="comment">// 读取进程进入 usleep 函数的时间</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 读取当前时间</span></span><br><span class="line"><span class="keyword">if</span> (<span class="comment">/* 当前时间 &gt;= 进入时间 + us 微秒*/</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 进程切换</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><ul><li><code>ipc.c</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">get_time</span><span class="params">(u_int *us)</span> &#123; <span class="keyword">return</span> syscall_get_time(us); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">usleep</span><span class="params">(u_int us)</span> &#123;</span><br><span class="line">  u_int inUs = <span class="number">0</span>;</span><br><span class="line">  u_int nowUs = <span class="number">0</span>;</span><br><span class="line">  u_int inTime = get_time(&amp;inUs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    u_int nowTime = get_time(&amp;nowUs);</span><br><span class="line">    <span class="type">int</span> del = (<span class="type">int</span>)nowTime - (<span class="type">int</span>)inTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (del * <span class="number">1000000</span> + ((<span class="type">int</span>)nowUs - (<span class="type">int</span>)inUs) &gt; us) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>syscall_all.c</code>：增加了一个系统调用，用于直接访问用户态无权访问的 KSEG1 段内存</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">sys_get_time</span><span class="params">(u_int *us)</span> &#123;</span><br><span class="line">  u_int time = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;time, (KSEG1 + <span class="number">0x15000000</span>), <span class="keyword">sizeof</span>(u_int));  <span class="comment">// flush rtc to get correct time</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;time, (KSEG1 + <span class="number">0x15000010</span>), <span class="keyword">sizeof</span>(u_int));  <span class="comment">// store time in &#x27;time&#x27;</span></span><br><span class="line">  <span class="built_in">memcpy</span>(us, (KSEG1 + <span class="number">0x15000020</span>), <span class="keyword">sizeof</span>(u_int));     <span class="comment">// store utime in &#x27;us&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>其实读取时间的那部分还蛮简单的，直接写系统调用进入内核态，再向 KSEG1 区用 <code>memcpy</code> 就能实现读外设。真正能卡人的部分在时间比较上。<del><strong>哦，还有人忘了更新时钟</strong></del></p><p>关于时间比较上，群友们提供了以下几种可行的方法：</p><ol><li><strong><code>u_int</code> 溢出？我直接上 <code>long long</code>！</strong></li></ol><p>直接用 <code>long long</code> 类型存储时间，这样在 秒 → 微秒 的换算上就能避免溢出的问题，直接就能比较</p><ol start="2"><li><strong>我是守序善良者，我要选用合理的方法处理溢出</strong></li></ol><p>先获取微秒，再计算时间差就会溢出，那我先把大单位的秒相减，再移动不就溢出不了了？也就是先进行秒相减，随后再换算成微秒单位进行比较。在这个基础上还有混乱善良者，让（秒 - 秒）、（微秒 - 微秒），最后再换算相加作比较，实际上是一个意思</p><ol start="3"><li><strong>无所谓，我会 <code>% 100</code></strong></li></ol><p>还有一些同学对大单位的秒进行了<strong>取模运算</strong>，实际上这并不安全，有可能两次比较的时间的后三位分别跨在 100 这个线两边，然后相减可能就出锅了。不过没关系，我们的测评很宽松，而且这种看脸的几率也很小，因为题目要求 us 大小上小于 5 秒</p><h1 id="Extra-SSD-硬盘模拟"><a href="#Extra-SSD-硬盘模拟" class="headerlink" title="Extra - SSD 硬盘模拟"></a>Extra - SSD 硬盘模拟</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>在 MOS 的实现中，我们使用的是 GXemul 提供的 IDE 磁盘作为外挂的文件存储。现在我们使用固态硬盘 SSD 的概念对 IDE 磁盘进行模拟，即按照操作 SSD 的方法去操作我们的磁盘。</p><p>SSD 的特点是每个块存储数据后必须<strong>先擦除才能写入</strong>。同时闪存块是有擦写次数上限的，为了平衡各个块的擦写次数，SSD 引入了<strong>磨损平衡</strong>机制。我们在本次模拟过程中规定，模拟 SSD 的<strong>读、写、擦除</strong>均以块为单位，每块的大小都是 512 Bytes；且对于每个物理块，必须<strong>先擦除，才能写入数据</strong>。</p><p>我们定义如下几个概念：</p><p><strong>逻辑块号</strong>：文件系统读写的逻辑硬盘块编号，在物理上不一定连续，每个块的大小为512Bytes</p><p><strong>物理块号</strong>：SSD实际读写的闪存的物理编号，在物理上连续，每个块的大小都是512Bytes</p><p><strong>闪存映射表</strong>：记录逻辑块号对应物理块号信息的表</p><p><strong>物理块位图</strong>：记录各个物理块的状态信息</p><p>实际上，我们要先实现一个逻辑硬盘块到物理硬盘块的映射表，同时维护每个物理块的使用情况与擦除次数。并根据这些信息模拟正常的 SSD 工作流程。</p><p>首先说明，外界访问 SSD 时使用的是其逻辑块号，我们需要经<strong>闪存映射表</strong>获得其物理块号后，在 IDE 磁盘的对应<strong>扇区</strong>执行相关操作。</p><p>我们先规定 SSD 硬盘可能出现的四种操作：</p><ol><li><strong>初始化硬盘</strong>：清空闪存映射表，在物理块位图中将SSD的所有物理块初始化为可写状态，SSD各物理块的累计擦写次数清 0。（保证只在开始时调用一次）</li><li><strong>读取逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。如果为空，则返回 <code>-1</code> ；若不为空，就去读取对应的物理块，返回物理块内的数据，并返回 <code>0</code>。</li><li><strong>写入逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。若为空（初次写），则分配一个可写的物理块，在闪存映射 表中填入此映射关系，将数据写入该物理块，并标记此物理块为不可写；若不为空（覆盖写），则擦除原来的物理块并清除该逻辑块号的映射，并按相同方法分配一 个物理块向其写入数据。</li><li><strong>擦除逻辑块</strong>：查询闪存映射表，找到逻辑块号对应的表项。若为空，不做处理；若不为空，则将对应的物理块擦除（擦除表示将物理块数据全部清 0，下同）并清除此映射关系。</li></ol><p>为了描述上面需要的状态，我们需要在代码中定义如下数据结构：</p><ul><li><strong>闪存映射表</strong>：记录逻辑块号对应物理块号信息的表</li><li><strong>物理块位图</strong>：记录各个物理块是否可写。每次向可写的物理块中写入数据后，都需要标记物理块为不可写</li><li><strong>物理块累计擦除次数表</strong>：记录各个物理块的累计擦除次数</li></ul><p>在完成上述基础机制后，我们还需要实现一个简单实现磨损平衡的分配函数，在这里就不展开逻辑了。</p><h2 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h2><p>在本题中，<strong>你需要使用IDE 0号硬盘（<code>diskno = 0</code>）的第0~31个扇区来模拟SSD的第0~31个物理块</strong>，之后根据 <strong>题目描述部分</strong> 的描述，在 <code>fs/ide.c</code> 中实现下列函数：</p><p><strong>1. 初始化硬盘：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_init</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><ul><li>功能：初始化闪存映射表、物理块位图、物理块累计擦除次数表。</li></ul><p><strong>2. 读取逻辑块：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ssd_read</span><span class="params">(u_int logic_no, <span class="type">void</span> *dst)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li><code>dst</code>: 硬盘数据要加载到的内存地址</li><li>功能：读取逻辑块 <code>logic_no</code> 的数据到 <code>dst</code>，成功返回 <code>0</code>，失败返回 <code>-1</code></li></ul><p><strong>3. 写入逻辑块：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_write</span><span class="params">(u_int logic_no, <span class="type">void</span> *src)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li><code>src</code>: 要写入到硬盘中的数据的起始内存地址</li><li>功能：向逻辑块号对应的硬盘块写入以 <code>src</code> 为起始地址的512字节数据</li></ul><p><strong>4. 擦除逻辑块</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_erase</span><span class="params">(u_int logic_no)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>logic_no</code>：逻辑块号</li><li>功能：擦除逻辑块 <code>logic_no</code> 上的数据，并取消 <code>logic_no</code> 到物理块号的映射关系</li></ul><p>评测时将会调用上面的接口做一系列操作，验证操作执行结果是否正确，并会在操作的任何阶段读取硬盘数据以检查实现的正确与否。</p><p>为了实现上面的函数，你可能还需要自行实现以下两个函数，但我们不对函数的定义做具体要求：</p><ul><li>擦除物理块：将全 0 的数据写入到物理块中，物理块累计擦除次数加一，并置为可写状态</li><li>分配新物理块：按“题目描述”部分的方法分配，需要用到物理块位图和物理块累计擦除次数两个信息</li></ul><h2 id="一种可行的做法-1"><a href="#一种可行的做法-1" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>其实闪存映射表直接用一维的数组就足够了，下标代表逻辑号，内容代表物理号，无所谓，写完了才意识到。</p><p>首先按照合适的逻辑规定好数据结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int ssd_bitmap[<span class="number">32</span>];    <span class="comment">// 标记物理块是否可用，1 = free, 0 = using</span></span><br><span class="line">u_int ssd_cleanmap[<span class="number">32</span>];  <span class="comment">// 标记物理第 i 块的擦除次数</span></span><br><span class="line">u_int ssd_logic[<span class="number">32</span>];     <span class="comment">// 映射表中第 i 项映射的逻辑块号</span></span><br><span class="line">u_int ssd_physics[<span class="number">32</span>];   <span class="comment">// 映射表中第 i 项映射的物理块号</span></span><br></pre></td></tr></table></figure><p>然后顺手写好初始化函数：</p><h3 id="ssd-init"><a href="#ssd-init" class="headerlink" title="ssd_init"></a>ssd_init</h3><p>初始化标记可用的位图，闪存映射表。</p><p>擦除次数默认为 0，又写成了全局变量，所以直接跳过初始化。注意不要让映射表<strong>不存在映射时保存 0</strong>，否则可能会识别为第 0 块存在的某个映射，这里按照课程组建议写了 <code>0xffffffff</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_init</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        ssd_bitmap[ssdno] = <span class="number">1</span>;</span><br><span class="line">        ssd_physics[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">        ssd_logic[ssdno]   = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后可以先实现比较简单的读函数，因为它不需要检查/改变硬盘块状态</p><h3 id="ssd-read"><a href="#ssd-read" class="headerlink" title="ssd_read"></a>ssd_read</h3><p>为了给这个蹩脚的数据结构一些便利，我自己又写了个获取映射块的函数，多此一举。</p><p>注意下真正的读取函数还是 <code>ide_read</code>，要注意读取的扇区号和大小，其他的比较简单</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ssd_read</span><span class="params">(u_int logic_no, <span class="type">void</span> *dst)</span> &#123;</span><br><span class="line">    u_int physics_no = get_physics(logic_no);</span><br><span class="line">    <span class="keyword">if</span> (physics_no == (u_int)<span class="number">0xffffffff</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line">    ide_read(<span class="number">0</span>, physics_no, dst, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后是两个比较复杂的操作，我的建议是先写擦除的函数，因为写之前免不了要进行擦除</p><h3 id="ssd-erase"><a href="#ssd-erase" class="headerlink" title="ssd_erase"></a>ssd_erase</h3><p>这里又写了一个专门擦除的 <code>erase</code> 函数，没什么实际意义，需要注意别忘了<strong>消除原有的映射</strong>。同时，当且仅当磁盘块在进行擦除时（<code>erase</code> 函数）会发生 <code>cleanmap</code> 数组值的变化，其他地方就不要写这个数组了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_erase</span><span class="params">(u_int logic_no)</span> &#123;</span><br><span class="line">    u_int physics_no = get_physics(logic_no);</span><br><span class="line">    <span class="keyword">if</span> (physics_no == (u_int)<span class="number">0xffffffff</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找映射，并使用 erase 函数擦除物理块，同时消除映射</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == logic_no) &#123;</span><br><span class="line">            erase(ssd_physics[ssdno]);</span><br><span class="line">            ssd_logic[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">            ssd_physics[ssdno] = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">erase</span><span class="params">(u_int physics_no)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    ssd_cleanmap[physics_no]++;  <span class="comment">// 擦除次数 + 1</span></span><br><span class="line">    ssd_bitmap[physics_no] = <span class="number">1</span>;  <span class="comment">// 擦除后标记为可用块</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">        buf[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ide_write(<span class="number">0</span>, physics_no, buf, <span class="number">1</span>);  <span class="comment">// 使用 ide_write 进行实际的 &#x27;擦除&#x27; 工作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后是相对最复杂的写操作。因为这个函数中，不仅要完成写操作，主要是在写之前需要分配物理块，这其中的重点是实现磨损平衡的分配函数。</p><p>首先讲讲磨损平衡的实现方法：</p><ol><li>在低负荷状态下，我们优先选取擦除次数最少的、<strong>当前状态为可用的</strong>（<code>ssd_bitmap[i] = 1</code>）磁盘块（若同次数选物理块号小的），并将其返回，直接结束</li><li>在高负荷状态下，即当前可用块<strong>最小擦除次数大于等于 5</strong>，此时就需要考虑非可用块了（避免长期驻留的数据影响块的擦除数）。首先按照和第一步相同的逻辑，选出<strong>非可用块</strong>中擦除次数最少的块。随后我们进行一个简单的内容替换：</li></ol><p>将选出的非可用块包含的内容转存到选出的可用块中，这也包含<strong>将映射到该物理块的闪存表项同时更改</strong>；同时擦除非可用块，并进行分配。（有点像 Lab2 Extra 那味了）</p><p>总结一下，<strong>高负荷状态下需要</strong>：</p><ol><li>将原可用块状态标记为不可写</li><li>更新替换块的原有映射</li><li>复制<strong>替换块</strong>的内容到<strong>原可用块</strong>中</li><li>对替换块执行一次擦除操作，标记为可用</li></ol><h3 id="alloc-physics"><a href="#alloc-physics" class="headerlink" title="alloc_physics"></a>alloc_physics</h3><p>这个函数写的很臃肿，而且废话很多，怎么说呢，能跑就行（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">alloc_physics</span><span class="params">()</span> &#123;</span><br><span class="line">    u_int target_no   = <span class="number">1000</span>;  <span class="comment">// 低负荷下选出的可用块</span></span><br><span class="line">    u_int erase_time  = <span class="number">1000</span>;  <span class="comment">// 标记最少擦除次数</span></span><br><span class="line">    u_int exchange_no = <span class="number">1000</span>;  <span class="comment">// 高负荷下选出的替换块</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];             <span class="comment">// 用作转存时使用的中介</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 根据选择逻辑获得擦除最少的可用物理块块号和擦除次数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_cleanmap[ssdno] &lt; erase_time &amp;&amp; ssd_bitmap[ssdno] == <span class="number">1</span>) &#123;</span><br><span class="line">            target_no = ssdno;</span><br><span class="line">            erase_time = ssd_cleanmap[ssdno];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 低负荷状态可以直接结束函数，同时恭喜你拿到了 80 分 */</span></span><br><span class="line">    <span class="keyword">if</span> (erase_time &lt; <span class="number">5</span>) &#123; <span class="keyword">return</span> target_no; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: 高负荷状态下，按照选择逻辑再次获得替换块*/</span></span><br><span class="line">    erase_time = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_bitmap[ssdno] == <span class="number">0</span> &amp;&amp; ssd_cleanmap[ssdno] &lt; erase_time) &#123;</span><br><span class="line">            exchange_no = ssdno;</span><br><span class="line">            erase_time = ssd_cleanmap[ssdno];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 初始化转存的区域，不写也行 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123; buf[i] = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 替换块擦除，做出提到的相应更新 */</span></span><br><span class="line">    ssd_bitmap[target_no] = <span class="number">0</span>;                   <span class="comment">// 1.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;   <span class="comment">// 2.</span></span><br><span class="line">        <span class="keyword">if</span> (ssd_physics[ssdno] == exchange_no) &#123;</span><br><span class="line">            ssd_physics[ssdno] = target_no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ide_read(<span class="number">0</span>, exchange_no, buf, <span class="number">1</span>);            <span class="comment">// 3.</span></span><br><span class="line">    ide_write(<span class="number">0</span>, target_no, buf, <span class="number">1</span>);</span><br><span class="line">    ssd_cleanmap[exchange_no]++;                 <span class="comment">// 4.</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> exchange_no;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Step 5 里完全忘记用 <code>erase</code> 函数了，无所谓</li><li>第一次写的时候，到后面逻辑就乱了，直接把 <strong>可用块</strong> 的内容复制给 <strong>替换块</strong> 了，导致最后一个高负荷的点跑不出来</li></ul><h3 id="ssd-write"><a href="#ssd-write" class="headerlink" title="ssd_write"></a>ssd_write</h3><p>实现分配逻辑函数后，写入就变得很简单了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ssd_write</span><span class="params">(u_int logic_no, <span class="type">void</span> *src)</span> &#123;</span><br><span class="line">    u_int physics_no = (u_int)<span class="number">0xffffffff</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 1: 先擦除原有物理块，销毁映射 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == logic_no) &#123;</span><br><span class="line">            physics_no = ssd_physics[ssdno];</span><br><span class="line">            <span class="keyword">if</span> (physics_no != (u_int)<span class="number">0xffffffff</span>) &#123;</span><br><span class="line">                ssd_erase(logic_no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 2: 根据分配逻辑申请一个新物理块，同时新建映射，标记使用情况 */</span></span><br><span class="line">    u_int save_no = alloc_physics();</span><br><span class="line">    ssd_bitmap[save_no] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// debugf(&quot;alloc physics %d\n&quot;, save_no);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ssdno = <span class="number">0</span>; ssdno &lt; <span class="number">32</span>; ssdno++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ssd_logic[ssdno] == (u_int)<span class="number">0xffffffff</span>) &#123;</span><br><span class="line">            ssd_logic[ssdno] = logic_no;</span><br><span class="line">            ssd_physics[ssdno] = save_no;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Step 3: 最后进行写入的操作 */</span></span><br><span class="line">    ide_write(<span class="number">0</span>, save_no, src, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>其实说到底，最后实现的核心就是<strong>模拟</strong>，说是模拟 SSD 硬盘，但实际上完成的内容又和之前的<strong>页表映射</strong>有点像。 Lab2 Extra 要求实现的换入换出，到这里就变成了写磁盘读磁盘。不过之前 Extra 并没有限制换页的分配函数，这次却着重写了这个分配的逻辑，只能说侧重点不同吧。</p><p>这次 Extra 里数据结构的选取也相对关键，比如标记使用情况的结构就选用了 <code>bitmap</code>（虽然当成 <code>intmap</code> 来用了，不过总归还是位图）；但标记映射实际上应该用个一维数组就够了，我仓皇之中选用的结构给之后写代码无形中增添了很多负担（主要是每次查都要遍历)。没关系，<del>能跑就行</del>下次一定</p><p>最后附一张课上的疯狂涂鸦，也许能提供一些结构上的思路，等告一段落之后再换成能看的图罢：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305160042914.png?imageMogr2/format/webp" alt="image-20230516004219883"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab4</title>
      <link href="/p/29129.html"/>
      <url>/p/29129.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lab4-系统调用与进程创建"><a href="#Lab4-系统调用与进程创建" class="headerlink" title="Lab4 - 系统调用与进程创建"></a>Lab4 - 系统调用与进程创建</h1><p>Lab4 中主要涉及到以下内容：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><blockquote><p>首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，<strong>请善用目录！</strong> 其实最不好理解的部分是在汇编代码和C代码之间切换的部分，可能一些宏定义、编译器的一些操作就会漏掉很多细节。 所以，时不时用用 <code>make objdump</code> 吧！努力成为 buaa-os 领域大神（？</p></blockquote><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在计算机组成原理实验 P7 与 Lab3 中，我们大致已经能够理清异常的原因、怎样产生与处理的方式了，但在 MOS 之前提到的异常大多不能由用户主动触发（时钟中断、TLB MISS 等），接下来我们就要深入了解一种特殊的、可以<strong>由用户主动发起的异常</strong>：系统调用 <code>syscall</code></p><ul><li>  异常发生的原因：出现某些不符合操作规范的指令、外部中断、syscall 指令</li><li>  产生地点（硬件）：指令流水至（M级）时 CP0 协处理器分析异常，修改 SR、Cause 等寄存器，使得当前 PC 跳转至异常处理程序入口（<code>0x80000000</code>）</li><li>  异常处理（软件）：异常处理程序对 CP0 记录的信息进行分析，选择对应的 handler 函数并跳转；对应 handler 处理结束后通过 ret_from_exception 汇编函数返回 EPC，程序继续执行</li></ul><p>我们想要使用 syscall 指令，为的就是<strong>进入内核态</strong>，让操作系统为用户执行某些任务，这些任务出于安全等考虑，只有内核才能完成，所以在调用 syscall 时，就不可避免地要进行 CPU 状态的切换（标记于 SR 寄存器的 KUc 位中）</p><h2 id="系统调用在干啥（）"><a href="#系统调用在干啥（）" class="headerlink" title="系统调用在干啥（）"></a>系统调用在干啥（）</h2><p>在详细了解系统调用前，还有必要再补充一下进程运行时的虚拟空间知识（<strong>可以补充在Lab3中？</strong>） 每个进程，都有相同的虚拟地址划分方式，并按照 mmu.h 文件中所示进行排布。每个进程都具有一张这样的表。同时每个进程的 kseg0、kseg1 段也都存放（或者说映射）着内核相关的数据结构，存在于所有进程的虚拟空间中，相当于被所有进程<strong>只读共享</strong>。所以为了方便使用，它们被整体映射到物理地址的固定区域；对于 kuseg 段，用户的页表和虚拟地址相结合，会指向物理内存中的某些空间，不同进程可能对物理空间进行共享。 执行系统调用，<strong>汇编层面上</strong>就是从 kuseg 段的汇编指令跳转至 kseg0 段，（进入内核态）并执行特定序列（系统调用函数），最后返回用户态 EPC 。<strong>C层面上</strong>就是用户态函数和内核态的系统调用函数之间的调用跳转。</p><h2 id="系统调用过程概览"><a href="#系统调用过程概览" class="headerlink" title="系统调用过程概览"></a>系统调用过程概览</h2><p>我觉得 os 学的就是一个全局观，先把需求和路线理清了，细节咱们随后再细说（</p><ul><li>  用户提出请求：<code>syscall_</code> 函数</li></ul><p>在 MOS 中，操作系统为用户准备了一系列可以在用户态调用的函数： <code>syscall_*</code> 系列函数，他们每个函数都对应一个可以通过系统调用完成的任务，用户通过调用这些函数，向操作系统传达信息：<strong>我要使用系统调用完成某个功能</strong></p><ul><li>  进入内核态：汇编函数 <code>msyscall</code></li></ul><p>在刚提到的 <code>syscall_*</code> 函数中，存在一个 <code>msyscall</code> 函数，在这个汇编写成的 <code>msyscall</code> 中，才出现了真正的 <code>syscall</code> 汇编指令，也就是在这里正式地进入了内核态，准备使用异常处理程序解决 <code>syscall</code></p><ul><li>  用户态保存：<code>exc_gen_entry</code></li></ul><p>在异常处理程序中，调用 SAVE_ALL 保存当前现场为内核栈中的 trapframe ，并将当前使用栈转换为内核栈。</p><ul><li>  接收请求并分类：<code>handle_sys</code></li></ul><p>通过异常处理程序判断为系统调用后，转入 handler 这个函数创建了一个size = TFSIZE + 8 大小的栈帧，8byte 为了保存参数 *tf（函数开始后会写回 a0 寄存器）</p><ul><li>  参数预处理调用处理函数：<code>do_syscall</code></li></ul><p>在这个函数中，我们通过分析用户传入的信息（<code>syscall_*</code> 的类型和用户现场）来响应系统调用。 分析主要凭借 tf-&gt;regs[29] 获取用户 trapframe 状态，通过sp访问内核栈获取参数等</p><ul><li>  响应完毕，返回用户态：<code>ret_from_exception</code></li></ul><p>在从 <code>do_syscall</code> 跳出并执行完对应处理函数，并返回至 <code>handle_sys</code> 后，最后会和其他异常一样，执行 <code>ret_from_exception</code>，还原现场，返回用户态，整个系统调用的过程结束   至此，整个执行流程可以总结为这张图片： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304231627668.png" alt="image-20230423162717568"></p><h2 id="发起系统调用-syscall"><a href="#发起系统调用-syscall" class="headerlink" title="发起系统调用 - syscall_*"></a>发起系统调用 - syscall_*</h2><p>上面提到，可由用户调用、距离内核态最近的函数就是这一系列 <code>syscall_*</code> 函数了。它们作为用户可调用的函数，位于 <code>user/lib/syscall_lib.c</code> 文件中，现在来看看它们的具体内容：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为节省空间仅保留了部分函数，反正差不多里面所有函数都长这样()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_putchar</span><span class="params">(<span class="type">int</span> ch)</span> &#123;</span><br><span class="line">    msyscall(SYS_putchar, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">syscall_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_getenvid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_mem_map</span><span class="params">(u_int srcid, <span class="type">void</span> *srcva, u_int dstid, <span class="type">void</span> *dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_mem_map, srcid, srcva, dstid, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它们都只调用了<strong>不同参数</strong>的 <code>msyscall</code> 函数，然后早早跑路（x）。这里还需要注意，<code>syscall_putchar</code>、<code>syscall_yield</code>、<code>syscall_panic</code> 这几个函数没有以”return“的方式调用 <code>msyscall</code> ，因为他们不是 <code>void</code> 的，就是 <code>noreturn</code> 的，憋憋 可以发现每个不同的函数，第一个参数一定不同，并且都代表了这个函数。也就是说， <code>msyscall</code> 通过接收这系列函数传入的第一个参数，决定最后响应的内核函数是谁，而后续的参数充当信息，用于辅助处理。  </p><h2 id="转入内核态-msyscall-Exercise-4-1"><a href="#转入内核态-msyscall-Exercise-4-1" class="headerlink" title="转入内核态 - msyscall - Exercise 4.1"></a>转入内核态 - msyscall - Exercise 4.1</h2><p>这个在用户态执行的最后一个函数（但用户编程过程中实际上不用），位于 <code>user/lib/syscall_wrap.S</code> 中，这个函数很简单：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;asm/asm.h&gt;</span><br><span class="line"></span><br><span class="line">LEAF(msyscall)</span><br><span class="line">    // Just use &#x27;syscall&#x27; instruction and return.</span><br><span class="line"></span><br><span class="line">    /* Exercise 4.1: Your code here. */</span><br><span class="line">    syscall</span><br><span class="line">    jr ra</span><br><span class="line">END(msyscall)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个函数实际上充当了用户态、内核态的转接口：执行 <code>syscall</code> 进入内核态，从调用返回后执行 <code>jr ra</code> ，十分简洁，分工明确 我们可能注意到了不同的 <code>msyscall</code> 调用可能有不同的参数数量，他们都被保存在堆栈中为函数创造的 stack frame 空间中，与 sp 相邻。 下一步，内核就会接收到由硬件产生的 8 号异常，通过处在 <code>kern/entry.S</code> 的异常分发程序 <code>exc_gen_entry</code> 跳转到 handler 函数： <code>do_syscall</code>  </p><h2 id="分发系统调用-do-syscall"><a href="#分发系统调用-do-syscall" class="headerlink" title="分发系统调用 - do_syscall"></a>分发系统调用 - do_syscall</h2><p>首先需要注意，在跳转至 <code>do_syscall</code> 前，我们在异常分发程序中向内核栈（SAVE_ALL）压入了用户态 trapframe 的信息。随后又通过 move 指令把 a0 寄存器复制成了 trapframe 的地址（SAVE_ALL 中 move sp 的值） 所以 <code>do_syscall</code> 在调用时就会自动地带有一个参数，它就是存放在 a0 寄存器中的用户态 <code>trackframe</code> <strong>指针</strong>（为什么是指针？因为传入的 sp 的值实际上指向了存放 tf 的地址）  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];    <span class="comment">// sysno 是 msyscall 的第一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (sysno &lt; <span class="number">0</span>  sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 移动 EPC，使得syscall返回后执行下一条指令 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/* Step 2: 通过 sysno 获得使用的处理函数 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">    func = syscall_table[sysno];</span><br><span class="line">    <span class="comment">/* Step 3: 获取前三个参数 $a1, $a2, $a3. */</span></span><br><span class="line">    u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">    u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">    u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 获取后两个参数 [$sp + 16 bytes], [$sp + 20 bytes] */</span></span><br><span class="line">    u_int arg4, arg5;</span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">    arg4 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>));</span><br><span class="line">    arg5 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>));</span><br><span class="line">    <span class="comment">/* Step 5: 调用处理函数，返回值保存在用户态的 v0 中 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h3><ul><li>  这里 sysno 取自 a0 寄存器，那前面说的 tf 地址保存在 a0 寄存器又是什么呢，不会互相覆盖吗？</li><li>  首先结论很明显，不会。这里的两个 a0 指的不是同样的东西</li></ul><p>首先我们需要明确一点：当进程运行在用户态时，使用的是用户栈，栈指针也指向用户栈；每当进程<strong>通过异常</strong>从用户态切换到内核态时，handler 会执行汇编函数 <code>SAVE_ALL</code>。 它的具体作用是把用户态的所有寄存器都保存到一个 trapframe 中，同时这个 tf 会被放置在内核栈中，同时还会切换当前使用的栈空间为<strong>内核栈</strong>。并且<strong>切换时内核栈总是空的</strong>。内核栈此时就保存了进程在进入内核态前的相关信息。重回到用户态时，再通过 ret_from_exception 中的 RESTORE_SOME 将内核栈中保存的信息恢复，再切回用户栈。 因为内核栈在切换后总是空的，每次又只会传入一个 trapframe ，所以这个 trapframe 实际上每次都占用的是 KSTACKTOP 向下的一个 sizeof(trapframe) 大小的空间 所以会出现这样的空间图：</p><ul><li>  stackframe：调用函数时创建，保存函数的参数、临时变量与相关跳转指针</li><li>  trapframe：陷入内核时使用 <code>SAVE_ALL</code> 创建，保存用户态寄存器</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012029029.png" alt="image-20230501202927787"> 新的内核栈 sp 指向 trapframe，旧的用户栈 sp 指向 arg0</p><ul><li>  使用当前（内核栈）的 sp，能访问到 trapframe 的信息；使用 tf 中 sp （用户栈）的信息，能访问到最近的 stackframe 的信息</li></ul><p>回到我们的 sysno，它是 <code>msyscall</code> 的第一个参数（<strong>用户态</strong>函数），也就是在分发异常调用 SAVE_ALL 时保存的 a0 寄存器，来源是用户态，所以要从用户态的 tf 里取 a0 寄存器（tf-&gt;regs[4]）；而参数 *tf 是保存在了调用 <code>do_syscall</code> 时的内核态 a0 中，并不干扰</p><ul><li>  后面的 arg4 类似，同样来源于用户态，但由于寄存器内没有保存，所以不能直接从 tf 里取得，需要通过用户栈指针回到 stackframe 中获取(tf-&gt;regs[29] + 16)</li></ul><h3 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 - stack frame"></a>栈帧 - stack frame</h3><p>这里是实际在网站里的教程里有讲过了，当时没有仔细理解，感觉还是再说说吧。 昨天有同学问我说为啥NESTED(handler_sys, TFSIZE + 8, 0)提示编译器共有 TFSIZE + 8 字节的栈帧，但是 ra 却只移动了 8Byte。然后我就发现，我确实没理解栈帧。。 存疑：栈帧在C语言函数中自动创建，汇编函数中需要手动创建 以下内容根据 R3000 手册筛选，但不能保证正确性，为了讨论，这里就只涉及到非叶函数，也就是一般函数的栈情况</p><ul><li>  栈帧 stackframe 创建于刚刚进入函数时：编译器会令 sp 指针向下移动一定空间，并使得这段空间成为该函数栈帧（大小由编译器通过函数变量、子函数参数、临时变量等指标确定；需要<strong>注意双字对齐</strong>，所以在没对齐时需要补充空白的单字（称作pad））</li><li>  随即，编译器调用 sw 指令，把 a0 - a3 寄存器中存放的本函数前四个参数填充到紧邻本栈帧的<strong>上方的空间</strong>里，不够四个就有几个补几个</li><li>  栈内高地址存放函数的临时变量等，低地址预留本函数可能调用的<strong>子函数的参数</strong>的空间，这部分空间在进入子函数时又会成为子函数第二步填充参数的地方</li></ul><p>那回来说这个 handler_sys，它通过NESTED宏中的.frame向编译器声明自己需要 TFSIZE+8 字节的栈帧，但是自己却只移动了 8 字节的 sp。 我感觉是因为 TFSIZE 实际上是上面调用 SAVE_ALL 时移动的一个 TFSIZE，这里为了避免覆盖掉就把它看成了栈的一部分（<strong>小孩子瞎猜的</strong>）。真正有用的是那8个字节：4字节的arg1和4字节的pad，而arg1又是在进入子函数do_syscall内，才从 a0 寄存器中填充的</p><h2 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h2><p>了解完系统调用的流程后，下一步就是填写具体用于处理系统调用的函数了，可能会把能写的都写一下，<strong>建议是跳着看</strong>。  </p><h3 id="获取进程块-envid2env-Exercise-4-3"><a href="#获取进程块-envid2env-Exercise-4-3" class="headerlink" title="获取进程块 - envid2env -Exercise 4.3"></a>获取进程块 - envid2env -Exercise 4.3</h3><p>首先是 envid2env 这个函数，它用来获取id对应的进程控制块。虽然它不是系统调用的一部分，但在进行交互、系统调用时，经常使用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 赋值，当 envid == 0 时返回当前进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *penv = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE  e-&gt;env_id != envid) &#123;  <span class="comment">// double check: invaild env_id</span></span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 当 checkperm != 1 时，要求查询的 env 必须是当前运行进程块**本身或父亲**</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; (e-&gt;env_id != curenv-&gt;env_id &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)) &#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;E_BAD_ENV: %x, %x, %x\n&quot;</span>, e-&gt;env_id, curenv-&gt;env_id, e-&gt;env_parent_id);</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 向 *penv 中赋值 */</span></span><br><span class="line">    *penv = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数本身没什么问题，但要注意 <code>envid == 0</code> 时必须提前退出函数，否则会一直运行到最后，返回 envs 内的第一个进程控制块</p><ul><li>  当 checkperm == 0 时，不需处理进程块与当前进程之间的关系，反之则需要确保调用本函数的进程是被调用者的<strong>直接父亲或本身</strong>，否则返回错误。值得一提的是，除了在进行 ipc 通讯的过程外，所有 syscall 函数都需要令 checkperm != 0（传信息不用限定在父子进程中）</li></ul><p> </p><h3 id="强制进行进程切换-sys-yield-Exercise-4-7"><a href="#强制进行进程切换-sys-yield-Exercise-4-7" class="headerlink" title="强制进行进程切换 - sys_yield - Exercise 4.7"></a>强制进行进程切换 - sys_yield - Exercise 4.7</h3><p>具体而言就是调用一次 <code>schedule</code> 函数，使得运行的进程交出 CPU 时间片，记得 yield 别传 0（）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// Hint: Just use &#x27;schedule&#x27; with &#x27;yield&#x27; set.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.7: Your code here. */</span></span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意这里函数 <code>noreturn</code> ，也就是说会直接开始运行下一个进程块  </p><h3 id="指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4"><a href="#指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4" class="headerlink" title="指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4"></a>指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4</h3><ul><li>函数作用：为指定进程的 va 申请一个物理页面并形成映射<ul><li>  类似于跨进程的 page_insert</li></ul></li><li>操作：<ul><li>  确认 va 和 env 的合法性，如有错误则直接返回错误值</li><li>  申请一个物理页，调用 page_insert 生成映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 envid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Hint: **Always** validate the permission in syscalls! except for in function sys_ipc_try_send */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;env, <span class="number">1</span>)) &#123;<span class="comment">// test 4-2: !envid2env() or 0 != envid2env())</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 申请物理页 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (3/3) */</span></span><br><span class="line">    try(page_alloc(&amp;pp));</span><br><span class="line">    <span class="comment">/* Step 4: 将 va 映射入指定进程 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这不就是一个 page_insert 吗，仔细一看确实。但是用户态的 page_insert 无法<strong>帮</strong>其他进程申请一个映射，因为根本看不到其他进程的进程块，所以原则上需要看得见所有东西的内核态来帮忙  </p><h3 id="在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5"><a href="#在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5" class="headerlink" title="在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5"></a>在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5</h3><ul><li>  函数作用：说白了就是把 src 进程 va 所在的物理页，在 dst 进程中找了指定位置形成了映射（insert）</li><li>操作：<ul><li>  检验传入的两个 va 合法性</li><li>  获取 srcid 和 dstid 的进程控制块</li><li>  page_lookup 获得 srcva 在 srcid 中映射的<strong>物理页</strong></li><li>  page_insert 让物理页在 dstid 中也形成一个映射</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="comment">//printk(&quot;mem_map:va is %x\n&quot;, srcva);</span></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (1/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(srcva)  is_illegal_va(dstva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;invaild va: %x or %x\n&quot;, srcva, dstva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 srcid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (2/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcid, &amp;srcenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;srcenv, 1)\n&quot;, srcid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 获取 dstid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (3/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(dstid, &amp;dstenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;dstenv, 1)\n&quot;, dstid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 找到 srcid + srcva 指向的物理页 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (4/4) */</span></span><br><span class="line">    <span class="keyword">if</span> ((pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 最终在 dst 中形成映射 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="解除指定进程的映射-sys-mem-unmap-Exercise-4-6"><a href="#解除指定进程的映射-sys-mem-unmap-Exercise-4-6" class="headerlink" title="解除指定进程的映射 - sys_mem_unmap - Exercise 4.6"></a>解除指定进程的映射 - sys_mem_unmap - Exercise 4.6</h3><ul><li>  函数作用：上一行就是.jpg</li><li>操作：<ul><li>  检验 va 有效性</li><li>  获取 envid 的进程块</li><li>  直接调用 page_remove 进行映射的删除</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取对应的进程控制块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 解除 env 中 va 的映射 */</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较好写，但是 MOS 也没调用过，之后可能会有用处吧  </p><h3 id="为当前进程创建一个子进程-sys-exofork-Exercise-4-9"><a href="#为当前进程创建一个子进程-sys-exofork-Exercise-4-9" class="headerlink" title="为当前进程创建一个子进程 - sys_exofork - Exercise 4.9"></a>为当前进程创建一个子进程 - sys_exofork - Exercise 4.9</h3><p> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 使用 env_alloc 申请新进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把当前进程存入的 trapframe 复制给子进程 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// e-&gt;env_tf = curenv-&gt;env_tf;</span></span><br><span class="line">    <span class="comment">/* Step 3: 把子进程的 v0 寄存器置0，即函数返回值为0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 设置子进程状态，继承优先级  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="设置进程块-status-sys-set-env-status"><a href="#设置进程块-status-sys-set-env-status" class="headerlink" title="设置进程块 status - sys_set_env_status"></a>设置进程块 status - sys_set_env_status</h3><p>见 fork 部分  </p><h3 id="设置-trapframe-sys-set-trapframe"><a href="#设置-trapframe-sys-set-trapframe" class="headerlink" title="设置 trapframe - sys_set_trapframe"></a>设置 trapframe - sys_set_trapframe</h3><p>见 fork 部分  </p><h3 id="ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8"><a href="#ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8" class="headerlink" title="ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8"></a>ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8</h3><ul><li>  函数作用：主动将当前进程<strong>阻塞</strong>，等待 send 信息</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 非 0 va 意味着传输页面，此时需检测 va 是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;<span class="comment">// test 4-3: English &quot;either or&quot;</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 标记：允许接收数据 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (1/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 3: 设置接收的指定va */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (2/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    <span class="comment">/* Step 4: 移出调度队列，进入阻塞态 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (3/8) */</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line">    <span class="comment">/* Step 5: schedule(1) 令当前进程开摆，设置返回值为0 */</span></span><br><span class="line">    ((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里最后一块：<code>((struct Trapframe *)KSTACKTOP - 1)</code> 指的就是 <code>do_syscall</code> 那之前创建的用户态 Trapframe，这里把用户态的 v0 寄存器值设为了0，用来代表用户态<strong>最初</strong>调用的 <code>syscall_ipc_recv</code> 的返回值为 0</li></ul><h3 id="ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8"><a href="#ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8" class="headerlink" title="ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8"></a>ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8</h3><ul><li>  函数作用：和 recv 配套使用，向<strong>已准备好</strong>的进程发送信息</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检测 va 有效性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (4/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;srcva is bad! %x\n&quot;, srcva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取进程块，无需令 perm = 1，非父子进程也可传输信息 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (5/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;envid is bad! %x\n&quot;, envid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 检测目标进程是否处于可接受状态(env_ipc_recving = 1) */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (6/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 设置目标进程字段 */</span></span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">    e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 恢复目标进程状态为可运行 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (7/8) */</span></span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    <span class="comment">/* Only link page while srcva != 0, to save running time */</span></span><br><span class="line">    <span class="comment">/* Step 6: va != 0 则传输页面 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">        <span class="comment">// printk(&quot;4.8 is sys_mem_map(%x, %x, %x, %x, %x));\n&quot;, curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm);</span></span><br><span class="line">        <span class="comment">// try(sys_mem_map(curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm));</span></span><br><span class="line">        <span class="comment">/* Test 4-5: do not use sys_mem_map because it call function envid2env with perm == 1; */</span></span><br><span class="line">        <span class="comment">// because two communicating env may not have parent relatioinship</span></span><br><span class="line">        p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="ipc-进程通信-ipc-c"><a href="#ipc-进程通信-ipc-c" class="headerlink" title="ipc 进程通信 - ipc.c"></a>ipc 进程通信 - ipc.c</h1><p>为了在进程间进行数据的传输，我们在 MOS 操作系统中设置了两种传输方式：传输单个 int，共享内存；并且两种方式都集成在了同一个系统调用，也即 <code>sys_ipc_send</code> 和 <code>sys_ipc_recv</code> 两个函数完成，并且两个函数执行时需要先 recv，声明自己已准备好，再调用 send，进行信息的发送。 但是，只设置好了系统调用函数还不足以让我们完成进程间的通信，因为系统需要对发送过程是否成功进行检测，若目标进程未准备好还需要等待，也有许多诸如此类的情况。所以为了方便使用，MOS 在用户态中封装了两个完整的函数用于进行信息传递的全流程，它们位于 <code>user/lib/ipc.c</code> 中，当有通信需求时，直接调用它们就能直观地完成进程通信。 <code>ipc.c</code> 文件开头就有一句这样的注释：<code>User-level IPC library routines</code>，也正好说明了下面两个函数在用户态服务</p><h2 id="用户态发送函数-ipc-send"><a href="#用户态发送函数-ipc-send" class="headerlink" title="用户态发送函数 - ipc_send"></a>用户态发送函数 - ipc_send</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use syscall_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 持续查询是否能进行传输 */</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_send(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 如果只因为对方未就绪，自身也停止这个 while 导致的忙等待，交出 CPU */</span></span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 如果 r != 0，说明退出 while 循环的原因是 -E_INVAL，说明出现错误 */</span></span><br><span class="line">    user_assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  这里使用的 <code>syscall_yield</code> 非常巧妙：如果对方进程未就绪，那在这个时间片中也不可能转换为就绪状态（本时间片一直是本进程运行），那为了避免当前时间片忙等，索性直接归还 CPU，等下一次调度到自己之后再查</li></ul><p> </p><h2 id="用户态接收函数-ipc-recv"><a href="#用户态接收函数-ipc-recv" class="headerlink" title="用户态接收函数 - ipc_recv"></a>用户态接收函数 - ipc_recv</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use env to discover the value and who sent it.</span></span><br><span class="line">u_int <span class="title function_">ipc_recv</span><span class="params">(u_int *whom, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 直接进系统调用，因为 recv 是先执行的，不用等 */</span></span><br><span class="line">    <span class="comment">/* 需要注意进程在下一条语句中调用了 schedule，传输完毕后才跳出 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_ipc_recv(dstva);</span><br><span class="line">    <span class="comment">/* Step 2: 检查返回值，错误值则 panic */</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;syscall_ipc_recv err: %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 返回发送者的 env_id */</span></span><br><span class="line">    <span class="keyword">if</span> (whom) &#123;</span><br><span class="line">        *whom = env-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 返回映射页权限位 */</span></span><br><span class="line">    <span class="keyword">if</span> (perm) &#123;</span><br><span class="line">        *perm = env-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 返回传输的单个 int */</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  相比之下，recv 函数内赋值语句较多，因为需要接收一些信息，系统调用函数倒比较简单，单纯调用一次 syscall_ipc_recv 就完事了</li></ul><p> </p><h1 id="用户进程的创建-fork-c"><a href="#用户进程的创建-fork-c" class="headerlink" title="用户进程的创建 - fork.c"></a>用户进程的创建 - fork.c</h1><p>用户进程调用 <code>fork</code> 函数时，将会创建一个<strong>和当前一模一样</strong>的新进程：父进程进行一次函数调用，父、子进程都产生一个返回值。父进程返回值为子进程的 <code>env_id</code>，子进程返回值是0，通过返回值不同来标定谁是子进程。 为了实现 <code>fork</code> 函数，我们主要需要补充<code>user/lib/fork.c</code> 中的函数。 实现 <code>fork</code> 的主要流程如下，我们接下来会按顺序介绍（感谢指导书的图.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011703551.png" alt="image-20230501170305441">  </p><h2 id="写时复制-COW-与页写入异常"><a href="#写时复制-COW-与页写入异常" class="headerlink" title="写时复制 COW 与页写入异常"></a>写时复制 COW 与页写入异常</h2><p>在通过后文提到的 <code>fork</code> 函数创建进程时，父子进程间会暂时共享内存空间，但实际上在<strong>写入</strong>这两个进程空间时，它们应该互不干扰。那一种直观的做法就是把父进程的<strong>所占用的物理页面</strong>全都复制一遍插入进子进程中。然而这么做会造成很大的内存开销，同时那些本身不可写的页面还需要白复制一遍。 所以我们引入了一种写时复制机制 <strong>COW</strong>，用来解决进程创建后的内存共享问题。COW 的解决思路：当父子进程需要修改可写页面内容（<code>PTE_COW = 1</code>）时产生一种异常，它只新复制出该页的内容以供修改，没用到的页面仍旧保持原状。 考虑到给 <code>PTE_D = 0</code> 的页面写入时会产生 TLB_MOD 异常，我们就顺便把 COW 需要的页面标记为 <code>PTE_D = 0, PTE_COW = 1</code>，也进入 TLB_MOD，并在其中中判断是真正的错误写入，还是 COW 触发。<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012033983.png" alt="image-20230501203319024">    </p><h2 id="申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9"><a href="#申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9" class="headerlink" title="申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9"></a>申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9</h2><ul><li>  函数作用：为子进程申请一个进程块，并把父进程的内容拷贝</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 通过 env_alloc 申请进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把 KSTACKTOP 下一个 tf 内容拷贝给子进程，tf 内放的是父进程调用 fork 前的用户态 TrapFrame */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Step 3: 子进程 v0 寄存器(env_tf.regs[2]) 设为 0，说明返回值为 0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 进程块初始化  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id; <span class="comment">// 这里返回实际上是父进程的返回值，返回子进程 env_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  为了避免 <code>syscall_exofork</code> 的栈帧在后续写时复制机制建立好<strong>之前</strong>被错误地更改，导致返回地址被覆盖，我们把 <code>syscall_exofork</code> 设置为了内联函数，不再创建栈帧，保护了进程地址跳转的正确性。</li></ul><h3 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd: 23.5.4"></a>Upd: 23.5.4</h3><ul><li>  在父进程执行这个函数的过程中，会把子进程的 v0 寄存器设置为 0；随后父进程从系统调用中返回并恢复现场，<code>syscall_exofork</code> 的返回值为子进程 env_id，而子进程<strong>并没有执行这个函数</strong>，只是在被调度时才首次开始运行，恢复进程控制块中存放的 trapFrame，其中的 EPC 也令进程从 fork 函数中的 <code>syscall_exofork</code> 结束后运行，这时存放于 v0 寄存器的返回值是 0，<strong>看起来好像子进程执行了</strong>这个函数并返回了 0。这就是 <code>syscall_exofork</code> 实现两个不同返回值的过程。</li></ul><p> </p><h2 id="写时保护函数-duppage-Exercise-4-10"><a href="#写时保护函数-duppage-Exercise-4-10" class="headerlink" title="写时保护函数 - duppage - Exercise 4.10"></a>写时保护函数 - duppage - Exercise 4.10</h2><ul><li>  这个函数功能比较单一，但考虑的情况比较多</li><li>  函数功能：将符合要求的页面 <code>PTE_D</code> 置0，<code>PTE_COW</code> 置1</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   若含有 PTE_LIBRARY 则说明该页面是共享页面，不做处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only the father env can call this function, &#x27;envid&#x27; in args is the child&#x27;s envid */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int addr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vpt is the 自映射页表 in env&#x27;s virtual memory */</span></span><br><span class="line">    <span class="comment">/* Step 1: 获得当前页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (1/2) */</span></span><br><span class="line">    perm = (vpt)[vpn];</span><br><span class="line">    addr = vpn * BY2PG;</span><br><span class="line">    <span class="comment">/* Step 2: 若页面可写，同时非共享，则标记为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: 先在子进程中映射、后更新父进程的权限位，原因见下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (((perm &amp; PTE_D)  (perm &amp; PTE_COW)) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;<span class="comment">// need to change perm and remap</span></span><br><span class="line">        perm = (perm &amp; ~(PTE_D))  PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 1!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, syscall_getenvid(), (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 2!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 3!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  先给子进程映射的原因可以看<a href="https://www.cnblogs.com/CindyZhou/p/12858468.html">这里</a></li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011737320.png" alt="image-20230501173715236"></p><blockquote><p>如果先给父进程加PTE_COW，然后修改了该页，该页将进行写时复制，父进程指向新的页，而新页没有被加上PTE_COW。此时再map子进程，子进程该页加上PTE_COW位而父进程没有。在随后程序运行中，若父进程进行修改，由于缺失PTE_COW，导致无法进行写时复制，因此子进程的运行出现错误（子进程该页本来不该被改，但却由于父进程被改而一起改了）。</p></blockquote><p> </p><h2 id="设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12"><a href="#设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12" class="headerlink" title="设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12"></a>设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12</h2><p>在 “写时复制 COW 与页写入异常” 一节中，我们已经知道，MOS 处理<strong>写时复制</strong>的时间是在进入 TLB_Mod 异常之后的，现在我们需要先设置 TLB_Mod 的处理函数。注意这里的处理函数可以来自<strong>用户态</strong>。 这样，在后续触发写时复制机制时，就能直接从用户给出的函数开始执行，处理异常了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取目标进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (1/2) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 2: 给函数入口字段赋值 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (2/2) */</span></span><br><span class="line">    env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  这里的 func 指的实际是异常处理函数的入口地址，当触发异常时，<code>do_tlb_mod</code> 会将 EPC 设置为 func 的值，同时退出异常，借此执行 Mod 异常的处理。</li></ul><h2 id="TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11"><a href="#TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11" class="headerlink" title="TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11"></a>TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11</h2><ul><li>  当系统发生 TLB_Mod 异常后，首先进入这里的 handler，设置好跳转后再 <code>ret_from_exception</code> 回到用户态，执行真正响应异常的用户态函数，最后再从该函数中返回受害指令</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   This is the TLB Mod exception handler in kernel.</span></span><br><span class="line"><span class="comment"> *   Our kernel allows user programs to handle TLB Mod exception in user mode,</span></span><br><span class="line"><span class="comment"> * so we copy its context &#x27;tf&#x27; into UXSTACK and modify the EPC to the registered</span></span><br><span class="line"><span class="comment"> * user exception entry.</span></span><br><span class="line"><span class="comment"> *   The user entry should handle this TLB Mod exception and restore the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 置位用户异常栈指针，并将当前异常 TrapFrame 复制到用户异常栈中 */</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">    *(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 存在用户的异常处理函数，手动设置处理函数的参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];           <span class="comment">// a0 = 用户异常栈地址</span></span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);  <span class="comment">// 移动异常栈指针，为函数调用保存参数留出空间</span></span><br><span class="line">        <span class="comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to</span></span><br><span class="line">        <span class="comment">// &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span></span><br><span class="line">        <span class="comment">/* Exercise 4.11: Your code here. */</span></span><br><span class="line">        tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p> </p><h3 id="用户异常栈"><a href="#用户异常栈" class="headerlink" title="用户异常栈"></a>用户异常栈</h3><ul><li>  前面在栈帧一小节中已经提到了用户栈、内核栈和他们的作用，这里还要提到一个新的栈帧：用户异常栈（<code>va = UXSTACKTOP</code>），它充当在用户态中处理异常所用到的函数的栈，这里就是页写入异常处理函数的栈</li><li>  用户异常栈和内核栈功能类似，都是在发生异常时开始使用，同时都从对应栈的 TOP 开始记录，看起来用户异常栈应该也允许异常重入。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果 regs[29] 在用户异常栈中，应该就不需要再次赋值了</span></span><br></pre></td></tr></table></figure><ul><li>  这里的 Step2 为什么要做这样一系列操作呢？因为这个C语言函数结束后，会通过汇编语言的 <code>ret_from_exception</code> 直接返回 EPC。因为没有显式的函数调用，所以编译器并不会为后续跳转到的处理函数创建栈帧，这里我们需要手动创建<strong>用户异常栈</strong>中的函数栈帧，供异常处理函数使用</li></ul><p> </p><h2 id="TLB-Mod-的实际处理-cow-entry-Exercise-4-13"><a href="#TLB-Mod-的实际处理-cow-entry-Exercise-4-13" class="headerlink" title="TLB_Mod 的实际处理 - cow_entry - Exercise 4.13"></a>TLB_Mod 的实际处理 - cow_entry - Exercise 4.13</h2><p>没错，这个函数就是刚才提到的用户态异常处理函数，执行 <code>ret_from_exception</code> 后会从这里继续执行。最终在这里完成写时复制页面的复制，并返回用户态继续执行受害指令。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the faulting page to a private writable copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;va&#x27; 为受害的虚拟地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">    u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取受害页面的标志位，判断是否为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27; doesn&#x27;t have</span></span><br><span class="line"><span class="comment">     * &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (1/6) */</span></span><br><span class="line">    u_int envid = syscall_getenvid();</span><br><span class="line">    perm = ((Pte *)(vpt))[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;?&quot;</span>);   <span class="comment">// 不是写时复制，意味着就是访问错了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 写时复制，设置新页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (2/6) */</span></span><br><span class="line">    perm = (perm &amp; ~(PTE_COW))  PTE_D;</span><br><span class="line">    <span class="comment">/* Step 3: 在 UCOW 空间申请一个临时页面，并建立映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (3/6) */</span></span><br><span class="line">    syscall_mem_alloc(envid, (<span class="type">void</span> *) UCOW, perm);</span><br><span class="line">    <span class="comment">/* Step 4: 把 va 那个页面内容复制过去 */</span></span><br><span class="line">    <span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (4/6) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) UCOW, (<span class="type">void</span> *) ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line">    <span class="comment">/* Step 5: 用 Step2 的 perm 新建了一个 va 的新映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (5/6) */</span></span><br><span class="line">    syscall_mem_map(envid, (<span class="type">void</span> *) UCOW, envid, (<span class="type">void</span> *) va, perm);</span><br><span class="line">    <span class="comment">/* Step 6: 解除 UCOW 的占用 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (6/6) */</span></span><br><span class="line">    syscall_mem_unmap(envid, (<span class="type">void</span> *) UCOW);</span><br><span class="line">    <span class="comment">// Step 7: 恢复栈帧，彻底退出异常 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">    user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>cow_entry</code> 的实际作用就是建立了一个<strong>受害页面在页表中的新映射</strong>。这个映射只有权限位不同，当再次写入受害 va 所在的页面时，会得到正确的 perm。</li><li>  旧：UCOW 空，va 会触发写时复制（申请物理页面，复制va-&gt; UCOW） 过程中：UCOW va内容，va会触发写时复制 结束：UCOW 空，va不会触发写时复制，指向UCOW 申请得到的那个物理页面</li></ul><p> </p><h2 id="子进程控制块设置-sys-env-set-status-Exercise-4-14"><a href="#子进程控制块设置-sys-env-set-status-Exercise-4-14" class="headerlink" title="子进程控制块设置 - sys_env_set_status - Exercise 4.14"></a>子进程控制块设置 - sys_env_set_status - Exercise 4.14</h2><ul><li>  启动新进程的最后一步：执行完所有的设置后，最后通过这个函数将子进程插入待调度队列，正式启动子进程</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;status&#x27; is valid. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (2/3) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 4: Update &#x27;env_sched_list&#x27; if the &#x27;env_status&#x27; of &#x27;env&#x27; is being changed. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (3/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status == ENV_RUNNABLE) &#123;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: Set the &#x27;env_status&#x27; of &#x27;env&#x27;. */</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Upd-23-5-5"><a href="#Upd-23-5-5" class="headerlink" title="Upd: 23.5.5"></a>Upd: 23.5.5</h3><p>需要在 Step4 中额外留意 <code>status</code> 的变化，如果变为 RUNNABLE 则需要加入至调度队列，如果 NOT_RUNNABLE 则需要<strong>移出</strong>，因为在 Lab3 的 <code>schedule</code> 函数中，我们已经要求所有变化进程状态的函数需要负责维护 <code>env_sched_list</code>，在这里就需要将 NOT_RUNNABLE 的函数移除。感谢芬海哥哥捏，指出了这里的错误 以上，就是创建一个子进程所需要的全部步骤，那么 fork 函数，实际上就是这些函数的结合  </p><h2 id="子进程的创建-fork-Exercise-4-15"><a href="#子进程的创建-fork-Exercise-4-15" class="headerlink" title="子进程的创建 - fork - Exercise 4.15"></a>子进程的创建 - fork - Exercise 4.15</h2><p> </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    u_int child;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line">    <span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix it to the</span></span><br><span class="line">    <span class="comment">// correct value.</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line">    <span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">for</span> (i = UTEMP &gt;&gt; <span class="number">12</span>; i * BY2PG &lt; USTACKTOP; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((vpd[i / <span class="number">1024</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;</span><br><span class="line">            duppage(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">     *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment">     *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (2/2) */</span></span><br><span class="line">    syscall_set_tlb_mod_entry(child, cow_entry);</span><br><span class="line">    syscall_set_env_status(child, ENV_RUNNABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在这里唯一需要考虑的点就是 Step3 中 for 循环的起止条件、if 的判断条件</li><li>  i 在这里表示的是<strong>用户态可用虚拟内存的页号</strong>： <code>UTEMP &gt;&gt; 12</code> ，是正式可以被用户态使用的第一个页面，而 <code>USTACKTOP &gt;&gt; 12</code> 则是最后一个</li><li>  if 的判断条件则是：i 对应的虚拟页面是否能在页表中查到有效的映射，如果有，说明它需要考虑是否需要标记 <code>PTE_COW</code>。</li></ul><p> </p><h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>Lab4 到这里可算是结束了，这个 Lab 给人最直观的感受就是码量的上升与内核态/用户态函数的协同更复杂了。这篇文章唠唠叨叨说了这么多，也是想尝试从更深一层去了解 MOS 运作的机理，而不是简单的完成几个填空，知晓表象就弃若敝履罢了。文章实际上没有想做什么分享，算是自我总结吧，因为自己都不知道对不对（笑 还剩两个 Lab，希望能把习惯保持下去  </p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>一些没用上的函数，贴一下</p><h2 id="syscall-all-c"><a href="#syscall-all-c" class="headerlink" title="syscall_all.c"></a>syscall_all.c</h2><h3 id="打印字符至控制台-sys-putchar"><a href="#打印字符至控制台-sys-putchar" class="headerlink" title="打印字符至控制台 - sys_putchar"></a>打印字符至控制台 - sys_putchar</h3><p>直接调用了 <code>printcharc</code> 函数，和 <code>printk</code> 效果类似吧</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_putchar</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    printcharc((<span class="type">char</span>)c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="打印用户空间的定长字符串-sys-print-cons"><a href="#打印用户空间的定长字符串-sys-print-cons" class="headerlink" title="打印用户空间的定长字符串 - sys_print_cons"></a>打印用户空间的定长字符串 - sys_print_cons</h3><p>先检查了地址是否位于用户区域，然后检查了长度是不是正的，最后循环调用了 <code>printcharc</code> 函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_print_cons</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s, u_int num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (((u_int)s + num) &gt; UTOP  ((u_int)s) &gt;= UTOP  (s &gt; s + num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        printcharc(((<span class="type">char</span> *)s)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="获得运行中进程块的-id-sys-getenvid"><a href="#获得运行中进程块的-id-sys-getenvid" class="headerlink" title="获得运行中进程块的 id - sys_getenvid"></a>获得运行中进程块的 id - sys_getenvid</h3><p>就一句话，但是好像还没有在 MOS 中使用过</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="销毁进程-sys-env-destroy"><a href="#销毁进程-sys-env-destroy" class="headerlink" title="销毁进程 - sys_env_destroy"></a>销毁进程 - sys_env_destroy</h3><p>只有直系进程才能进行销毁（自己也行）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">    env_destroy(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h3 id="读入字符-sys-cgetc"><a href="#读入字符-sys-cgetc" class="headerlink" title="读入字符 - sys_cgetc"></a>读入字符 - sys_cgetc</h3><p>直接调用了函数 <code>scancharc</code> ，此时会让系统处于忙等状态，直至接收到字符返回</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-1-Exam</title>
      <link href="/p/17374.html"/>
      <url>/p/17374.html</url>
      
        <content type="html"><![CDATA[<p>中途脑梗了好几次，差点寄了，不过好在这次把题留下来了（</p><h1 id="Exam-进程组-ipc-通信"><a href="#Exam-进程组-ipc-通信" class="headerlink" title="Exam - 进程组 ipc 通信"></a>Exam - 进程组 ipc 通信</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><blockquote><p>在 Linux 中，进程理论上所拥有的权限与执行它的用户的权限相同。进程运行时能够访问哪些资源或文件，不取决于进程文件的属主属组，而是取决于<strong>运行该命令的用户身份的 uid/gid</strong>，以该身份获取各种系统资源。</p></blockquote><p>所以我们需要完成同一个进程组ID的不同进程的通信。具体而言，需要做到：</p><ol><li> 在 Env 结构体中添加 <code>u_int env_gid</code> 字段代表进程所在的进程组，初始值为 0。</li><li> 实现一个修改 <code>gid</code> 字段的<strong>用户态函数</strong>：<code>void set_gid(u_int gid);</code></li><li> 实现一个<strong>仅能</strong>向同组块发送消息的<strong>用户态函数</strong>：<code>int ipc_group_send(u_int whom, u_int val, const void *srcva, u_int perm);</code></li><li> 实现 2、3 两点中对应的<strong>系统调用函数</strong>和调用接口</li></ol><p>教程组已经把两个用户态函数实现了，我们只需要考虑系统调用函数 <code>syscall_set_gid</code> 和 <code>syscall_ipc_try_group</code> 即可</p><h3 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h3><ol><li>在内核中为每个进程维护<strong>进程组ID</strong>，并保证每个进程<strong>创建时的的组ID为0</strong>。</li><li>在 <code>user/include/lib.h</code> 中：<ul><li>  添加以下两个用户函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure><ul><li>  添加以下两个系统调用函数的声明：</li></ul> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syscall_set_gid</span><span class="params">(u_int gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span>;</span><br></pre></td></tr></table></figure></li><li>在 <code>include/error.h</code> 中，增加以下新错误码 <code>E_IPC_NOT_GROUP</code> ，表示组间通信时通信双方进程的组ID不匹配。 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> E_IPC_NOT_GROUP 14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>两个用户态函数的<strong>实现已经给出（请参看实验提供代码部分），你需要将其复制到 <code>user/lib/ipc.c</code> *_，具体代码的解释在*_提示</strong>部分给出。</li><li>在 <code>include/syscall.h</code> 中：定义两个新的系统调用号。请注意新增系统调用号的位置，应当位于 <code>MAX_SYSNO</code> 之前。</li><li>在 <code>user/lib/syscall_lib.c</code> 中：实现上述两个系统调用函数，发起系统调用。</li><li>在 <code>kern/syscall_all.c</code> 中：添加两个系统调用在内核中的实现函数。请保证两个函数的定义位于系统调用函数表 <code>void *syscall_table[MAX_SYSNO]</code> 之前。</li><li>在 <code>kern/syscall_all.c</code> 中的 <code>void *syscall_table[MAX_SYSNO]</code> 系统调用函数表中，为你定义的系统调用号添加对应的内核函数指针。</li><li>编写 <code>syscall_ipc_try_group_send</code> 系统调用<strong>在内核中的实现函数</strong>时，判断 <code>-E_IPC_NOT_RECV</code> 错误的<strong>优先级</strong>高于 <code>-E_IPC_NOT_GROUP</code></li></ol><h2 id="实验提供代码"><a href="#实验提供代码" class="headerlink" title="实验提供代码"></a>实验提供代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy to user/lib/ipc.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_gid</span><span class="params">(u_int gid)</span> &#123;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_set_gid 系统调用</span></span><br><span class="line">    syscall_set_gid(gid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ipc_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">// 你需要实现此 syscall_ipc_try_group_send 系统调用</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_group_send(whom, val, srcva, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 接受方进程尚未准备好接受消息，进程切换，后续继续轮询尝试发送请求</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_RECV) syscall_yield();</span><br><span class="line">        <span class="comment">// 接收方进程准备好接收消息，但非同组通信，消息发送失败，停止轮询，返回错误码 -E_IPC_NOT_GROUP</span></span><br><span class="line">        <span class="keyword">if</span> (r == -E_IPC_NOT_GROUP) <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数返回0，告知用户成功发送消息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一种可行的做法"><a href="#一种可行的做法" class="headerlink" title="一种可行的做法"></a>一种可行的做法</h2><p>课上写了半天总是说函数名找不到，仔细一看写了一半的 <code>group_send</code>，写了一半的 <code>send_group</code>，难绷</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_group_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva,</span></span><br><span class="line"><span class="params">                           u_int perm)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> != envid2env(whom, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;env_gid != curenv-&gt;env_gid) &#123; <span class="comment">// 唯一与 ipc_send 不同的地方就在这了</span></span><br><span class="line">    <span class="keyword">return</span> -E_IPC_NOT_GROUP;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  e-&gt;env_ipc_value = val;</span><br><span class="line">  e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">  e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">  e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">    p = page_lookup(curenv-&gt;env_pgdir, (u_int)srcva, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">      <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sys_set_gid</span><span class="params">(u_int gid)</span> &#123; <span class="comment">// 简单赋值</span></span><br><span class="line">  curenv-&gt;env_gid = gid;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>按照题目给的思路顺下来其实很容易就能写完，顺便也可以用这个题回顾一下系统调用：怎样添加一个新的、可用的系统调用？</p><ul><li>  首先从内核态出发，编写一个能够完成功能的函数，看一下它都需要什么参数 - <code>kern/syscall_all.c</code></li><li>  然后在 <code>void *syscall_table[MAX_SYSNO]</code> 把函数添加进去，使得 <code>do_syscall</code> 函数能跳到这个新函数里：这需要随便写一个字符串当成<strong>系统调用号</strong>，无所谓了 - <code>kern/syscall_all.c</code></li><li>  找到刚才那个系统调用号的枚举类，把定义加上 - <code>include/syscall.h</code></li><li>  <code>do_syscall</code> 不需要变化，然后再上一层是 <code>msyscall</code>，它需要一个 <code>syscall_</code> 开头的函数进行调用。到这里我们就完成了内核态中所需要做的所有改动</li><li>  回到用户态，编写一个用户态的 <code>syscall_new</code> 函数调用 <code>msyscall</code>，同时需要注意参数的第一个参数需要是刚才加进去的调用号 - <code>users/lib/syscall_lib.c</code></li><li>  最后编写顶层的用户态函数，其中调用 <code>syscall_new</code> 函数，用户态工作也就完成了 - <code>users/某个文件</code></li><li>  最最后别忘了<strong>加上函数声明</strong>：内核态不需要，用户态加在 <code>users/include/lib.h</code> 即可</li></ul><h1 id="Extra-家族-ipc-广播"><a href="#Extra-家族-ipc-广播" class="headerlink" title="Extra - 家族 ipc 广播"></a>Extra - 家族 ipc 广播</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>课下我们在 MOS 系统中实现了进程间通信。</p><p>现在你需要仿照 <code>ipc_send</code> 函数在 <code>user/lib/ipc.c</code> 中实现 <code>ipc_broadcast</code> 函数，使得调用 <code>ipc_broadcast</code> 可以使当前进程向其后代进程（也即当前广播进程的子进程、子进程的子进程、子进程的子进程的子进程…以此类推）发起广播消息，当后代进程进入 recv 后进行发送。</p><h3 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h3><p><strong><code>ipc_broadcast</code></strong></p><p>需要在 <code>user/lib/ipc.c</code> 新增：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> * srcva, u_int perm)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>  <code>val</code> ：进程广播传递的具体数值, 与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>srcva</code> ：进程广播发送页的对应用户虚地址，与 <code>ipc_send</code> 函数中的定义相同。</li><li>  <code>perm</code> : 传递的页面的权限位设置，与 <code>ipc_send</code> 函数中的定义相同。</li></ul><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>  你可以实现 <code>syscall_ipc_try_broadcast</code> 系统调用，使其行为类似于 <code>syscall_ipc_try_send</code>，但尝试发送给当前进程的所有后代进程。</li><li>  你也可以尝试在用户空间利用 <code>envs</code> 实现相关行为。</li><li>  发送广播消息时，你可以先等待所有后代进程进入接受状态，再统一进行实际传输，也可以依次等待每个后代进程，一旦其处于接受状态，当即对其进行实际传输。</li></ul><p>也就是说可以在用户态使用这些已有的调用函数完成目标，也可以像 Exam 中添加一种新的系统调用处理这种请求。</p><p>如果注意到原来提供的 <code>ipc_send</code> 函数能使用 bfs 操作进程块数组，那实际上难度就会降低很多。无所谓，我没看出来</p><h2 id="两种可行的做法"><a href="#两种可行的做法" class="headerlink" title="两种可行的做法"></a>两种可行的做法</h2><h3 id="新建系统调用-sys-ipc-broadcast"><a href="#新建系统调用-sys-ipc-broadcast" class="headerlink" title="新建系统调用 - sys_ipc_broadcast"></a>新建系统调用 - <code>sys_ipc_broadcast</code></h3><p>类似在刚才 Exam 中提到的思路，加一个新的系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_broadcast</span><span class="params">(u_int val, <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">  u_int childs[<span class="number">20</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    childs[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// printk(&quot;childs ready!\n&quot;);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va((u_int)srcva)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step1: 找到直系的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NENV; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (envs[i].env_parent_id == curenv-&gt;env_id) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (childs[j] == <span class="number">0</span>) &#123;</span><br><span class="line">          childs[j] = envs[i].env_id;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step2: 通过 bfs 找到所有子进程的子进程 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; NENV; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (envs[j].env_parent_id == childs[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">20</span>; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == envs[j].env_id) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (childs[k] == <span class="number">0</span>) &#123;</span><br><span class="line">            childs[k] = envs[j].env_id;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step3: 对所有待发送的进程进行发送 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; childs[i] != <span class="number">0</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// printk(&quot;%d: %x\n&quot;, i, childs[i]);</span></span><br><span class="line">      sys_ipc_try_send(childs[i], val, srcva, perm);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用户态通过已有函数处理"><a href="#用户态通过已有函数处理" class="headerlink" title="用户态通过已有函数处理"></a>用户态通过已有函数处理</h3><p>因为代码不是我的，所以我就不贴了，说一说思路吧</p><p>首先和第一种做法一样，需要用循环和队列 bfs 出所有满足条件的进程 <code>env_id</code>，最后实际上可以直接用 <code>ipc_send</code> 解决，太快了。</p><h2 id="一点废话"><a href="#一点废话" class="headerlink" title="一点废话"></a>一点废话</h2><p>其实一开始读这个题我理解成调用 <code>env_alloc</code> 函数来创建进程了，然后就在 Env 里面加了一个数组字段保存自己的孩子，同时在 <code>env_alloc</code> 里通过 <code>env_parent_id</code> 更新<strong>所有</strong>祖宗进程的字段，最后在系统调用进行 send 的时候直接查一下自己的字段就能跑了</p><p>结果这个题它创建进程最后用的是宏 <code>ENV_CREATE_PRIORITY</code>，也就是调用了 <code>env_create</code> 函数。甚至 <code>parent_id</code> 是下面这么加进去的！看起来两个函数好像没啥差别，但是 <code>env_create</code> 函数只能产生 <code>parent_id = 0</code> 的新进程，我这一套直接寄了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa1</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa2</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa3</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">ppa4</span> =</span> ENV_CREATE_PRIORITY(test_ppa, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">ppa2-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa3-&gt;env_parent_id = ppa1-&gt;env_id;</span><br><span class="line">ppa4-&gt;env_parent_id = ppa3-&gt;env_id;</span><br></pre></td></tr></table></figure><p>幸亏看了一眼测试代码，要不寄大发了。不过反正写完这一版才发现写的不对，实际上已经寄了。</p><p>不然我觉得我那个做法将能算得上是绝杀（可能吧）</p><p>总之 lab4 这样就算结束一半了，之后再看吧。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Exam</title>
      <link href="/p/20326.html"/>
      <url>/p/20326.html</url>
      
        <content type="html"><![CDATA[<p>这次比较尴尬，做完了忘记保存题目了，结果复盘的时候全程想不起来题目写的是啥</p><h1 id="Exam"><a href="#Exam" class="headerlink" title="Exam"></a>Exam</h1><h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>我们提出了一种基于多个用户而平均分配的时间片轮转调度算法。对于每个进程来说，它的拥有者（用户，用 0 \sim 4 的数字表示）用一个新增字段 <code>u_int env_user</code>表示。我们要改进的这个调度算法，每次都会运行<strong>已经使用过的时间片最少的</strong>用户的进程（相同时<strong>取 id 小者</strong>），进程按在<code>env_sched_list</code> 中的顺序取出，每次运行该用户的第一个进程。</p><p>为了记录每个用户已经使用的时间片，我们设置了一个全局数组 <code>static int user_time[]</code>，当每次进程时间片耗尽时，对数组进行更新（对应用户加 pri即可）。例如对于如下的三个用户和三个进程，应该有这样的调度顺序（没保存所以只能上手绘图力！）</p><p>假装有图.jpg</p><p>请你按照这样的提示修改 <code>schedule</code> 函数，使其能满足刚才解释的按用户使用分配的时间片轮转算法。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (需要更换 e 的条件) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e 不为 <span class="literal">NULL</span> &amp;&amp; e 处在 ENV_RUNNABLE 状态) &#123;</span><br><span class="line">      移动 e 进程块</span><br><span class="line">      修改 user_time 数组（加对应的 env_pri 即可）</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (无调度进程块) &#123;</span><br><span class="line">      panic</span><br><span class="line">    &#125;</span><br><span class="line">遍历调度列表，查询列表中有哪些用户的进程块</span><br><span class="line"></span><br><span class="line">遍历每个有进程块的用户，哪个用户用过的时间片最少（user_time 最小）</span><br><span class="line"></span><br><span class="line">遍历调度列表，取出第一个该用户的进程块，e = env，count = env_pri</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  count--</span><br><span class="line">  env_run</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  教程组给出的伪代码大致如上，可惜这次没有把题目记下来，只能靠记忆来了</li><li>  给的解释实际上已经足够清晰了，只需要按着步骤走就行。</li></ul><p>要注意<strong>额外声明变量时要考虑初始化</strong>的问题，有同学没初始化导致数组内的值反复横跳，根本没法debug（</p><h2 id="一种可行的解答"><a href="#一种可行的解答" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>贴一下我的做法，比较水，仅供参考</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> user_time[<span class="number">5</span>];</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> able[<span class="number">5</span>];   <span class="comment">// 额外声明了一个数组，当列表中存在该用户进程块时就置 1 ，否则保持 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">// 数组初始化</span></span><br><span class="line">    able[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">      TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">      <span class="comment">// 记得 + env_pri，有笨比上来直接丢了这一句，根本调度不起来</span></span><br><span class="line">      user_time[e-&gt;env_user] += e-&gt;env_pri;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">      panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">    count = e-&gt;env_pri;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">en</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用了 TAILQ_FOREACH 宏进行循环包装，循环查询有哪个用户在队列里，更新 able 数组</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (able[en-&gt;env_user] == <span class="number">0</span>) &#123;</span><br><span class="line">        able[en-&gt;env_user] = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环查看哪个用户使用的时间片最少（user_time 最小）</span></span><br><span class="line">    <span class="type">int</span> user = <span class="number">-1</span>;</span><br><span class="line">    u_int times = <span class="number">111111111</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (user_time[j] &lt; times &amp;&amp; able[j] == <span class="number">1</span>) &#123;</span><br><span class="line">        user = j;</span><br><span class="line">        times = user_time[j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再循环调度链表，取出第一个目标用户的进程块，准备调度</span></span><br><span class="line">    TAILQ_FOREACH(en, &amp;env_sched_list, env_sched_link) &#123;</span><br><span class="line">      <span class="keyword">if</span> (en-&gt;env_user == user) &#123;</span><br><span class="line">        e = en;               <span class="comment">// 更换调度块</span></span><br><span class="line">        count = e-&gt;env_pri;   <span class="comment">// 重置时间片 count</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count--;</span><br><span class="line">  env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><h2 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h2><p>在 Lab3/4 中，我们已经处理了若干种异常，但在 CO 学习中经常出现的一种异常我们还没有处理，就是<strong>数值溢出</strong>（Ov）。在 R3000 中，硬件已经把溢出设置为 <strong>12 号异常</strong>，也就是说，只要设置对应的 <strong>handle 函数</strong>、<strong>异常向量</strong>与<strong>异常处理函数</strong>，我们就能顺利响应这个异常了。 Extra 的任务，就是响应 addi、add、sub 这三类指令可能产生的<strong>溢出异常</strong>。</p><p>这三类溢出的处理规则如下：</p><ul><li>  <code>add</code>：将指令修改为 <code>addu</code>，直接返回原 EPC</li><li>  <code>sub</code>：将指令修改为 <code>subu</code>，直接返回原 EPC</li><li>  <code>addi</code>：令 RF[rt]=RF[rs]/2+imm/2 ，返回至 EPC + 4 继续执行</li></ul><p>下面还有很多提示，能想起来的就直接放下一部分了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>  首先需要明确我们需要做的有三件事：</li><li>  注册 handle 函数</li><li>  更新异常向量组，使其支持跳转至 Ov 的异常处理函数</li><li>  编写异常处理函数逻辑</li></ul><p>前两步很简单，只要仿照对应文件中其他异常的处理方式来就可以了</p><h3 id="注册-handle-函数"><a href="#注册-handle-函数" class="headerlink" title="注册 handle 函数"></a>注册 handle 函数</h3><ul><li>  在 <code>kern/genex.S</code> 中，增加处理 Ov 的 <code>handle_ov</code> ，可以命名其异常处理函数名为 <code>do_ov</code></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BUILD_HANDLER ov do_ov</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更新异常向量组"><a href="#更新异常向量组" class="headerlink" title="更新异常向量组"></a>更新异常向量组</h3><ul><li>  开始没看见直接写了溢出是12号异常，我直接当场下载 See Mips Run Linux 开始查（）</li><li>  在 <code>kern/traps.c</code> 中，更新异常向量：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line">    [<span class="number">12</span>] = handle_ov,        <span class="comment">// 支持 handle_ov 以处理 ov</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="异常处理函数-do-ov"><a href="#异常处理函数-do-ov" class="headerlink" title="异常处理函数 do_ov"></a>异常处理函数 <code>do_ov</code></h3><ul><li>  这个函数的核心就是<strong>分析 EPC</strong> 这条指令的内容并加以修改。</li></ul><p>但由于一些我忘了的原因（有笨比），我们不能在内核态中直接通过用户态的虚拟地址获得地址上的值，所以如何访存就又成了一个问题。</p><p>题目提示：可以从 EPC 的 va 出发，找到它所对应的 pa，再将 pa 转换为 kseg0 区域的 va ，这样就能不通过页表之类的操作直接访问到了。所以大致的处理思路如下：</p><p>EPC(va)\to pa\to va(kseg0)\to *va(code)</p><p>许多同学在第一步转化物理地址时使用了宏 <code>va2pa</code> ，但是这玩意它只能找到 pa 所在页框的<strong>基地址</strong>，<strong>页内偏移它没有！</strong>然后好多人就绷了（）</p><p>还好我根本没想起来有这么个宏，还好我机智地使用了 <code>page_lookup</code> 老老实实地从<strong>页控制块</strong>出发找物理地址，这样就很轻松地记住了要加偏移，要不然直接用了 <code>page2pa(p)</code>，看过去就显然没有页内偏移（）</p><p>然后就很轻松地得到了目标指令。</p><ul><li>  随后要分析指令类型进行异常处理</li></ul><p><code>add</code> 和 <code>sub</code> 两个指令修改太简单了，直接给指令值+1就能用了，在 <code>addi</code> 中要稍微多想一点。</p><p><code>addi</code> 需要更新寄存器的值，同时也需要更新 EPC，这时就要从传入的用户栈中修改信息。修改过程中需要注意从指令里取出寄存器号之后要<strong>移动到最低位</strong>才能使用，有人 <code>addi</code> 了半天 0 号寄存器，才发现原来寄存器号还在高位呆着（）</p><p>最最后，调用一下 <code>printk</code>，异常统计变量自增，结束力！</p><h2 id="一种可行的解答-1"><a href="#一种可行的解答-1" class="headerlink" title="一种可行的解答"></a>一种可行的解答</h2><p>直接上代码了，依然是一坨不可名状的东西</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_ov</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">  <span class="comment">// printk(&quot;Got an ov\n&quot;);</span></span><br><span class="line">  u_int badva = tf-&gt;cp0_epc;</span><br><span class="line">  Pde *pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">  Pte **ppte = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page_lookup(pgdir, badva, ppte);</span><br><span class="line">  <span class="comment">// pgdir_walk(pgdir, badva, 0, &amp;p);</span></span><br><span class="line">  u_int badpa = page2pa(p) + (badva &amp; <span class="number">0xfff</span>);</span><br><span class="line">  u_int *badk0va = <span class="number">0x80000000</span>  badpa;</span><br><span class="line">  u_int code = *badk0va;</span><br><span class="line">  <span class="comment">// printk(&quot;got code %x\n&quot;, code);</span></span><br><span class="line">  <span class="keyword">if</span> (code &amp; <span class="number">0x20000000</span>) &#123; <span class="comment">// addi</span></span><br><span class="line">    u_int s = (code &amp; <span class="number">0x3e00000</span>) &gt;&gt; <span class="number">21</span>;</span><br><span class="line">    u_int t = (code &amp; <span class="number">0x1f0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    u_int svalue = tf-&gt;regs[s];</span><br><span class="line">    u_int imm = code &amp; <span class="number">0xffff</span>;</span><br><span class="line">    tf-&gt;regs[t] = svalue / <span class="number">2</span> + imm / <span class="number">2</span>;</span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// printk(&quot;inform:%x %d %d %x %x\n&quot;, code, s, t, svalue, tf-&gt;regs[t]);</span></span><br><span class="line">    printk(<span class="string">&quot;addi ov handled\n&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((code &amp; <span class="number">0x1f</span>) == <span class="number">0</span>) &#123; <span class="comment">// add</span></span><br><span class="line">    printk(<span class="string">&quot;add ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// sub</span></span><br><span class="line">    printk(<span class="string">&quot;sub ov handled\n&quot;</span>);</span><br><span class="line">    *badk0va = code + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  curenv-&gt;env_ov_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="debug-思路"><a href="#debug-思路" class="headerlink" title="debug 思路"></a>debug 思路</h2><p>在第一次写完之后，测试很华丽地给我返回了错误值：<code>$v0 = 0xffffffff</code>（-1），这是测试程序提示处理有误的返回值。想要de出来bug在哪出现的，自然需要回到那个返回错误值的地方看一眼。所以我就在函数里打了几个 <code>printk</code>，现在还在注释里（）。 同时把三个会 <code>return -1</code> 的地方修改成了返回<strong>不同的值</strong>，然后看看到底是哪里寄了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* tests/lab3_ov/test_ov.c */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> src1, src2, dst;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 add, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 + src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果异常处理结果不正确进程将运行结束并返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 sub, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 - src2)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>; <span class="comment">// change the return value to figure the error place</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 测试 addi, code here</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (dst != (src1 / <span class="number">2</span> + <span class="number">10</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-3</span>; <span class="comment">// change too</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一看，哈哈 <code>return -3</code> ，<code>addi</code> 我来辣（×）</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab4-Report</title>
      <link href="/p/60484.html"/>
      <url>/p/60484.html</url>
      
        <content type="html"><![CDATA[<p> </p><h1 id="BUAA-OS-2023-Lab4-Report"><a href="#BUAA-OS-2023-Lab4-Report" class="headerlink" title="BUAA-OS-2023-Lab4-Report"></a>BUAA-OS-2023-Lab4-Report</h1><h1 id="Thinking-4-1"><a href="#Thinking-4-1" class="headerlink" title="Thinking 4.1"></a>Thinking 4.1</h1><ul><li>  思考并回答下面的问题：</li><li>  内核在保存现场的时候是如何避免破坏通用寄存器的？</li><li>  系统陷入内核调用后可以直接从当时的$a0-$a3 参数寄存器中得到用户调用msyscall留下的信息吗？</li><li>  我们是怎么做到让sys 开头的函数“认为”我们提供了和用户调用msyscall 时同样的参数的？</li><li>  内核处理系统调用的过程对Trapframe 做了哪些更改？这种修改对应的用户态的变化是什么？</li></ul><ol><li> 在系统发生异常时跳入异常分发程序时，会先调用 <code>SAVE_ALL</code> 宏定义，把所有寄存器（用户态现场）保存在内核栈 KSTACKTOP 下。最后将 sp寄存器指向保存的这个栈帧。这样既能保护用户态时通用寄存器的值不被改变，同样也能在内核态中便捷地调用每个寄存器的值</li><li> 可以直接调用。系统调用 <code>msyscall</code> 时只通过 <code>SAVE_ALL</code>将寄存器的值复制到了内核栈中，但对寄存器中的值没有做任何处理，仍然保持着用户态进入时的状态。所以这时参数寄存器内数值仍然可用。</li><li> 在 <code>do_syscall</code> 函数中，我们通过系统调用向量 <code>syscall_table</code> 选择系统调用函数后，在函数内调用了 <code>func(arg1, arg2, arg3, arg4, arg5);</code> ，此处的 <code>arg</code>都来源于用户态中保存的参数寄存器和栈帧内。所以相当于调用了相同参数的函数。</li><li>系统调用过程中：<ul><li>  <code>tf-&gt;regs[2] = func(arg1, arg2, arg3, arg4, arg5);</code> 更改了 v0 寄存器以保存系统调用执行后的返回值；</li><li>  <code>tf-&gt;cp0_epc += 4;</code> 更改了 cp0_epc 寄存器以使得返回用户态的执行语句变为执行系统调用的后一条指令</li></ul></li></ol><h1 id="Thinking-4-2"><a href="#Thinking-4-2" class="headerlink" title="Thinking 4.2"></a>Thinking 4.2</h1><ul><li>  思考 envid2env 函数: 为什么 envid2env 中需要判断 e-&gt;env_id != envid 的情况？如果没有这步判断会发生什么情况？</li></ul><p>在产生 <code>env_id</code> 的函数 <code>mkenvid</code> 中，id 的低10位会保留为该 env 块在 envs 中的序号，高位是一个按序增大的数。当再次申请一个曾经被调度过的 env 块时，<strong>两次获取的 <code>env_id</code> 低10位相同，高位不同</strong>。 我们在 <code>envid2env</code> 中直接用 <code>e = &amp;envs[ENVX(envid)];</code> 选取了 env 块，实际上此时只能保证取出的块与 id 的低10位一定相同，没有对10位以上进行检验。为了避免出现高位不同而无效的 <code>env_id</code> ，我们需要再判断一次 <code>e-&gt;env_id != envid</code> 。 如果没有这步判断，可能会导致<strong>之前申请这个 env 产生的</strong> <code>env_id</code> 再次获取到这个 env 块。（然而实际上旧 id 已经失效了）</p><h1 id="Thinking-4-3"><a href="#Thinking-4-3" class="headerlink" title="Thinking 4.3"></a>Thinking 4.3</h1><ul><li>  思考下面的问题，并对这个问题谈谈你的理解：请回顾 kern/env.c 文件中 mkenvid() 函数的实现，该函数不会返回0，请结合系统调用和 IPC 部分的实现与 envid2env() 函数的行为进行解释</li></ul><p>首先在 <code>envid2env</code> 函数中，为了进程能够便利地获得自身进程的 <code>env</code> ，我们规定了当输入 ID = 0 时，会返回当前进程的控制块。如果 <code>mkenvid</code> 函数产生了一个 ID = 0 的进程块，那么这个功能将无法判断当前是在查询 <code>ID = 0</code> 的进程块，还是在查询当前进程的进程块了 在 <code>sys_ipc_send</code> 中更新接收者信息时也会发生这样的状况，若发送者 <code>env_id</code> 为 0，那么接收者将混淆发送者，有可能会是自己发给自己的（）</p><h1 id="Thinking-4-4"><a href="#Thinking-4-4" class="headerlink" title="Thinking 4.4"></a>Thinking 4.4</h1><ul><li>  关于fork 函数的两个返回值，下面说法正确的是： A、fork 在父进程中被调用两次，产生两个返回值 B、fork 在两个进程中分别被调用一次，产生两个不同的返回值 C、fork 只在父进程中被调用了一次，在两个进程中各产生一个返回值 D、fork 只在子进程中被调用了一次，在两个进程中各产生一个返回</li></ul><p>选 C 。 <code>fork</code> 函数在父进程想要创建子进程时被执行，在执行过程中创建了一个新的进程。同时子进程会返回 0 ，父进程将会返回子进程的 id，方便父进程进行规划。</p><h1 id="Thinking-4-5"><a href="#Thinking-4-5" class="headerlink" title="Thinking 4.5"></a>Thinking 4.5</h1><ul><li>  我们并不应该对所有的用户空间页都使用duppage 进行映射。那么究竟哪些用户空间页应该映射，哪些不应该呢？请结合kern/env.c 中env_init 函数进行的页面映射、include/mmu.h 里的内存布局图以及本章的后续描述进行思考</li></ul><p><code>UTEXT</code> 之下的无效内存、<code>USTACKTOP</code> 之上的空白区与用户异常栈都不需要进行页面映射。在进入 <code>duppage</code> 函数内，只读页面与共享同写页面都不需要进行映射。除此之外，用户区的其他页面都需要进行映射。</p><h1 id="Thinking-4-6"><a href="#Thinking-4-6" class="headerlink" title="Thinking 4.6"></a>Thinking 4.6</h1><ul><li>  在遍历地址空间存取页表项时你需要使用到vpd 和vpt 这两个指针，请参考user/include/lib.h 中的相关定义，思考并回答这几个问题：</li><li>  vpt 和vpd 的作用是什么？怎样使用它们？</li><li>  从实现的角度谈一下为什么进程能够通过这种方式来存取自身的页表？</li><li>  它们是如何体现自映射设计的？</li><li>  进程能够通过这种方式来修改自己的页表项吗？</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vpt ((volatile Pte *)UVPT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vpd ((volatile Pde *)(UVPT + (PDX(UVPT) &lt;&lt; PGSHIFT)))</span></span><br></pre></td></tr></table></figure><p>  <code>vpt</code> 指向了用户进程自身的<strong>用户页表基址</strong>； <code>vpd</code> 指向了用户进程的<strong>用户页目录基址</strong>。<code>vpd</code> 可以视作用户的 <code>cur_pgdir</code>，<code>vpt</code>则可以看作 <code>cur_pgdir[0]</code> 这是两个系统定义的便于读取用户态页表的宏，它们指向了位于 kuseg 中的页表虚拟地址。程序允许访问 kuseg 中的虚拟地址，从过 vpt 和 vpd ，用户就能获取自身的页表。 UVPT 本身就是用户页表的基地址，vpt 自然是页表基址。<code>(PDX(UVPT) &lt;&lt; PGSHIFT))</code> 指向了用户页表所在的页目录项，这里的取法来自页表的自映射。 进程页表在这种情况下应当只允许读取，不允许这样修改，否则可能会出现错误的访问。</p><h1 id="Thinking-4-7"><a href="#Thinking-4-7" class="headerlink" title="Thinking 4.7"></a>Thinking 4.7</h1><ul><li>在 <code>do_tlb_mod</code> 函数中，你可能注意到了一个向异常处理栈复制 Trapframe 运行现场的过程，请思考并回答这几个问题：<ul><li>  这里实现了一个支持类似于“<strong>异常重入</strong>”的机制，而在什么时候会出现这种“异常重 入”？</li><li>  内核为什么需要将异常的现场 Trapframe 复制到用户空间？</li></ul></li></ul><p>当处理 <code>tlb_mod</code> 时，可能会发生<strong>用户异常处理函数出错</strong>导致的异常，这时需要重入处理；同时由于没有关闭中断，所以若再次发生外部中断（时钟中断），也会触发异常的重入 如果在这里不保存 Trapframe 的话，do_tlb_mod 函数会跳转至用户设置的异常处理函数 <code>env_user_tlb_mod_entry</code> 中，但当该函数执行结束后，将无法恢复 EPC，所以需要先保存用户现场再返回  </p><h1 id="Thinking-4-8"><a href="#Thinking-4-8" class="headerlink" title="Thinking 4.8"></a>Thinking 4.8</h1><ul><li>  在用户态处理页写入异常，相比于在内核态处理有什么优势？</li></ul><p>在用户态处理，相较于内核态处理最明显的区别就在于其省去了跳转进入内核态的繁琐操作，为频繁的跳转省去了大量时间。 其次在用户态处理，给用户自定义页写入异常处理函数的入口，使得操作系统的处理更多样性、更灵活。  </p><h1 id="Thinking-4-9"><a href="#Thinking-4-9" class="headerlink" title="Thinking 4.9"></a>Thinking 4.9</h1><p>请思考并回答以下几个问题：</p><ul><li>  为什么需要将 <code>syscall_set_tlb_mod_entry</code> 的调用放置在 <code>syscall_exofork</code> 之前？</li><li>  如果放置在写时复制保护机制完成之后会有怎样的效果？</li></ul><h2 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd:23.5.4"></a>Upd:23.5.4</h2><p>前两年的这个题好像放的是缺页中断的处理函数？我们这里变成了设置页写入异常的处理函数。如果在 syscall_exofork 中，写入了某个曾经被标记为 TLB_COW 的页面，此时的 tlb_Mod 将无法处理。虽然我觉得这种情况应该不会发生？确实不太明白 其实我觉得如果我们的 syscall_exofork 不是一个内联函数的话，这里就有点意义了，可以防止 syscall_exofork 的栈帧被父进程覆盖，导致子进程无法返回（但是做法也不对，应该把duppage也移动过来，实际上更寄） 如果放在写时复制机制完成后设置，一旦在这两步操作中出现了进程的 TLB_Mod，进程就会因为无法处理异常而 panic 对于第二问，如果先执行完写时复制机制，这时的所有原本可写 &amp; 非共享的用户页都成为写时复制页，这就导致了 USTACKTOP 这一页也变成了写时复制页，在此之后的任意一个会创建栈帧的函数都不能执行了，因为这样会写入用户栈，并进入 TLB_Mod，此时又会因为没有设置 handler 导致 panic 可能是因为，如果先fork的话，还需要给子进程设置一下cow_entry；但如果先给父进程设置entry的话，生成子进程的exofork过程中调用了env_alloc，会自动复制父进程的cow_entry，就省去了额外在子进程中设置entry的步骤，写时复制机制可以直接运行（大概） 因为在 fork 函数中调用的 duppage 函数中也会发生页写入异常。如果不设置 mod_entry 就先进行 fork，会导致无法响应页写入异常。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在 Lab4 中，我们学习了：</p><ul><li>  系统调用 <code>syscall</code> 的流程</li><li>  进程间通信机制：ipc</li><li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li><li>  写时复制 <strong>COW</strong> 与页写入异常</li></ul><p>主要实现了用户进程的创建，完善了不同进程间内存空间的处理机制。完成进程创建，尤其是进程内存的使用后， Lab5 中，基于进程的文件系统才能更好实现。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab3</title>
      <link href="/p/45960.html"/>
      <url>/p/45960.html</url>
      
        <content type="html"><![CDATA[<h1 id="Lab3-进程与异常"><a href="#Lab3-进程与异常" class="headerlink" title="Lab3 - 进程与异常"></a>Lab3 - 进程与异常</h1><p>Lab3 中主要涉及到以下内容：</p><ul><li>  进程的创建</li><li>  时钟中断与内核态</li><li>  进程调度与进程切换</li><li>  <strong>数据进程控制块</strong> <code>Env</code></li></ul><h1 id="进程控制块与初始化"><a href="#进程控制块与初始化" class="headerlink" title="进程控制块与初始化"></a>进程控制块与初始化</h1><ul><li>  由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。</li><li>  进程是一个活动中的实体，拥有自己的虚拟地址空间。</li><li>  程序是非活动的实体，<strong>执行中</strong>的程序就是<strong>进程</strong></li></ul><h2 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 - PCB"></a>进程控制块 - PCB</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// 保存上下文环境，定义于 trap.h 中</span></span><br><span class="line">    LIST_ENTRY(Env) env_link;<span class="comment">// 构建空闲进程链表 env_free_link</span></span><br><span class="line">    u_int env_id;<span class="comment">// 进程标识符</span></span><br><span class="line">    u_int env_parent_id;<span class="comment">// 父进程的进程 id</span></span><br><span class="line">    u_int env_status;<span class="comment">// 进程块状态位</span></span><br><span class="line">    Pde *env_pgdir;<span class="comment">// 进程页目录的虚拟地址</span></span><br><span class="line">    TAILQ_ENTRY(Env) env_sched_link;<span class="comment">// 构造调度队列 env_sched_list</span></span><br><span class="line">    u_int env_pri;<span class="comment">// 进程优先级，与后续时间片调度进程相关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>env_status</code>：<ul><li>  <code>ENV_FREE</code>：进程控制块处于空闲链表中，值为0</li><li>  <code>ENV_NOT_RUNNABLE</code>：<strong>阻塞态</strong>，可转变为就绪状态，值为1</li><li>  <code>ENV_RUNNABLE</code>：就绪、执行状态（等待调度/运行中），值为2</li></ul></li><li>  在 MOS 中，进程控制块的<strong>物理地址</strong>已经被分配好了（<code>envs</code>数组）</li></ul><p>这里的初始化使用了__attribute__函数，做完再看 其中的结构体 <code>TrapFrame</code> 在 Lab4 中作用比较大，但在 Lab3 中没有必要过于关注，结构就不再过多介绍了 Env 块中存在两个链表（<code>env_free_list</code>和<code>env_sched_list</code>），<code>TAILQ</code> 结构在 Lab2 的 Probe 中已经提过了，该结构为双向的有尾列表，支持在头尾进行元素增删操作。</p><h2 id="跨页地址映射-map-segment-Exercise-3-2"><a href="#跨页地址映射-map-segment-Exercise-3-2" class="headerlink" title="跨页地址映射 - map_segment - Exercise 3.2"></a>跨页地址映射 - <code>map_segment</code> - Exercise 3.2</h2><ul><li>  函数作用如下：物理地址映射到指定进程的虚拟地址中（更大的 <code>page_insert</code>）</li><li>将物理地址 pa <strong>按页映射</strong>到指定进程页表中（va）<ul><li>  映射大小 size 必须是<strong>页面大小的整数倍</strong></li></ul></li><li>  设置用到的页表项权限位为 perm</li></ul><p>这个函数在上面的 <code>env_init()</code>中使用过，其将内核中 pages 与 envs 所在的物理地址映射到内核页表中，我们可以根据下面这个实例补充代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), </span><br><span class="line">BY2PG), PTE_G);</span><br></pre></td></tr></table></figure><p>代码中注释已经给好方向，使用<code>page_insert()</code>，将 <code>[va, va+size)</code> 所涉及到的每个页面都映射到 pa 开始的页面中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 将 pa 地址内容映射到指定页目录中的虚拟地址 va</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">map_segment</span><span class="params">(Pde *pgdir, u_int asid, u_long pa, u_long va,</span></span><br><span class="line"><span class="params">                        u_int size, u_int perm)</span> &#123;</span><br><span class="line">  <span class="comment">/* 预先确保地址对齐 */</span></span><br><span class="line">  assert(pa % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(va % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(size % BY2PG == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 循环对应的每一页形成映射 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123; </span><br><span class="line">    <span class="comment">/*  使用 pa2page 获取物理地址 pa 对应的页控制块</span></span><br><span class="line"><span class="comment">     * va + i 表示每个虚拟页的基地址，pa + i 表示页框基地址</span></span><br><span class="line"><span class="comment">     * 使用 page_insert 形成新映射，**权限**设置为 perm</span></span><br><span class="line"><span class="comment">     * Exercise 3.2: Your code here. */</span></span><br><span class="line">    page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程块队列初始化-env-init-Exercise-3-1"><a href="#进程块队列初始化-env-init-Exercise-3-1" class="headerlink" title="进程块队列初始化 - env_init - Exercise 3.1"></a>进程块队列初始化 - <code>env_init</code> - Exercise 3.1</h2><ul><li>  函数功能：初始化 envs 链表</li><li>  完成 <strong>Env 控制块</strong>的空闲队列、调度队列的<strong>初始化功能</strong></li><li>  空闲队列需要<strong>倒序插入</strong>，用来优先分配小序号的进程控制块 Env</li><li>  临时存放 内核结构 ‘pages’ 与 ‘envs’ ，为后续映射做准备（详见 Exercise 3.3）</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">/* Step 1: 初始化 `env_free_list` 与 `env_sched_list` 两个调度队列 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (1/2) */</span></span><br><span class="line">  LIST_INIT(&amp;env_free_list);</span><br><span class="line">  TAILQ_INIT(&amp;env_sched_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 将所有进程控制块插入空闲队列中，注意需要 **倒序** 插入 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (2/2) */</span></span><br><span class="line">  <span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;env_free_list, &amp;envs[i], env_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将内核结构 &#x27;pages&#x27; 与 &#x27;envs&#x27; 映射到每个用户空间的虚拟地址（UPAGES </span></span><br><span class="line"><span class="comment">   * 和 UENVS）中，并要求只读，这里先暂时把两个内容存在一个临时页目录 &#x27;base_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   * 中，并建立映射，直至 `env_setup_vm&#x27; 中再将其拷贝进用户页目录 &#x27;env_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  panic_on(page_alloc(&amp;p));</span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">  base_pgdir = (Pde *)page2kva(p);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES,</span><br><span class="line">              ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG), PTE_G);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS,</span><br><span class="line">              ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG), PTE_G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码实现较简单，注意要区分 Env 结构体中存在的链表，env_free_list 链表需要使用 env_link 连接，使用LIST类宏操作；而 env_sched_list 需要使用 env_sched_link 连接，使用 TAILQ 类宏操作</p><h2 id="env-id-与进程表示"><a href="#env-id-与进程表示" class="headerlink" title="env_id 与进程表示"></a>env_id 与进程表示</h2><p>在进程管理块 Env 中，有三个与 <code>id</code> 相关的字段，它们从不同的方式代表进程</p><ul><li>  <code>env_id</code> ：（进程标识符，unique environment identifier）MOS 操作系统中使用 <code>env_id</code> <strong>唯一地</strong>表示不同进程，在创建进程时被 <code>mkenvid</code> 函数赋值</li><li><code>env_asid</code> ：（地址空间标识符，Address-Space IDentifier）ASID也可以<strong>唯一地</strong>标记进程，同时为进程提供相应的<strong>地址保护</strong><ul><li>  在 MOS 实验系统中使用 &lt;VirtualPageNumber, ASID&gt; 作为索引在 TLB 中查询映射</li><li>  在 MOS 中，使用了<strong>位图法</strong>管理了64个 ASID ，具体位于 asid_alloc 函数中</li></ul></li><li>  <code>env_parentid</code> ：（env_id of this env’s parent）顾名思义是创建本进程的父进程的 <code>env_id</code></li></ul><p>对于<code>id</code>与<code>asid</code>：<code>id</code>指的是控制块和线程自己的属性；<code>asid</code>则在 TLB 、地址管理上用的比较多 <code>env_id</code> 的值从同文件中的 <code>mkenvid()</code> 函数中得来，asid由同文件中的 <code>asid_alloc()</code> 得到</p><h2 id="Linux-中的-ASID-分代机制-（有空再补）"><a href="#Linux-中的-ASID-分代机制-（有空再补）" class="headerlink" title="Linux 中的 ASID 分代机制 （有空再补）"></a>Linux 中的 ASID 分代机制 （有空再补）</h2><p>   </p><h1 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h1><p>程序想要成为进程，必须要把对应的的 ELF 文件（此处为<strong>可执行文件</strong>）中所有需要加载的 <strong>程序段(Segment)</strong> 分配进虚拟内存空间中。但在 lab3 中我们还不能直接操作磁盘中的文件，所以 ELF 文件被转化为C数组的形式，再通过编译到内核完成加载 这里可以使用部分函数操作 ELF 文件，加载整个文件进入内存、获取其文件头、加载 segment 至内存</p><h2 id="ELF-文件函数"><a href="#ELF-文件函数" class="headerlink" title="ELF 文件函数"></a>ELF 文件函数</h2><ul><li>  <code>load_icode()</code>：加载可执行文件至指定进程内存（调用的最外层函数）</li><li>  <code>elf_from()</code>：解析 ELF 文件头，获取段位置</li><li>  <code>elf_load_seg()</code>：加载 ELF 程序段</li><li><code>load_icode_mapper()</code>：分配一页物理页，在 env 块对应的页表中建立映射<ul><li>  可能需要复制 src 处的数据到该物理页面中</li></ul></li></ul><h2 id="加载-ELF-文件-load-icode-Exercise-3-6"><a href="#加载-ELF-文件-load-icode-Exercise-3-6" class="headerlink" title="加载 ELF 文件 - load_icode - Exercise 3.6"></a>加载 ELF 文件 - <code>load_icode</code> - Exercise 3.6</h2><ul><li>  函数作用：调用相关函数，将 ELF 文件加载进指定进程中</li><li>  解析 ELF 头获取段信息</li><li>  使用 <code>elf_load_seg</code> 加载每个程序段</li><li>  初始化 EPC 指向程序入口点地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: 解析 ELF 头 */</span></span><br><span class="line">  <span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size);</span><br><span class="line">  <span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 循环加载每个程序段</span></span><br><span class="line"><span class="comment">   * 循环：使用 ELF_FOREACH_PHDR_OFF</span></span><br><span class="line"><span class="comment">   * 加载：使用 elf_load_seg</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">size_t</span> ph_off;</span><br><span class="line">  ELF_FOREACH_PHDR_OFF(ph_off, ehdr) &#123;</span><br><span class="line">    Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">      <span class="comment">// &#x27;load_icode_mapper&#x27; 指定了用户的加载方式</span></span><br><span class="line">      panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将进程起始地址 EPC 指向 ELF 入口 e_entry ，执行程序入口点指令 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.6: Your code here. */</span></span><br><span class="line">  e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">  <span class="comment">/* env_tf.cp0_epc 字段指示了进程运行时PC 应指向的位置,说明其为连续的虚拟地址中</span></span><br><span class="line"><span class="comment">     的某一个值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ELF_FOREACH_PHDR_OFF</code>：在上述的顶层函数中，调用了一个宏，其展开后对 ELF 程序段进行循环：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_FOREACH_PHDR_OFF(ph_off, ehdr)        \</span></span><br><span class="line"><span class="meta">(ph_off) = (ehdr)-&gt;e_phoff;                   \</span></span><br><span class="line"><span class="meta">for (int _ph_idx = 0; _ph_idx <span class="string">&lt; (ehdr)-&gt;</span>e_phnum; ++_ph_idx, (ph_off) += (ehdr)-&gt;e_phentsize)</span></span><br></pre></td></tr></table></figure><h2 id="elf-load-seg"><a href="#elf-load-seg" class="headerlink" title="elf_load_seg"></a><code>elf_load_seg</code></h2><ul><li>  函数作用：把 ELF 程序段加载到 <code>data</code> 处； MOS 中在 <code>load_icode</code> 内配合 <code>load_icode_mapper</code> 调用，也就是<strong>把程序段加载到进程内存里</strong></li><li>  按页划分，分别映射每一页至 data 中</li><li>  回调函数 <code>map_page</code> 决定映射的方式</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 加载 ELF 文件的段至 data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   bin != NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 if success. Otherwise return &lt; 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">u_long va = ph-&gt;p_vaddr;</span><br><span class="line"><span class="type">size_t</span> bin_size = ph-&gt;p_filesz;<span class="comment">// 文件大小</span></span><br><span class="line"><span class="type">size_t</span> sgsize = ph-&gt;p_memsz;<span class="comment">// 内存大小，需要补齐这一段差值</span></span><br><span class="line">u_int perm = PTE_V;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">perm = PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;              <span class="comment">// 起始地址未页对齐，映射第一页</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: 映射 p_filesz 至指定区中 */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 补全空白页至 p_memsz */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">i += BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页映射回调函数-load-icode-mapper-Exercise-3-5"><a href="#页映射回调函数-load-icode-mapper-Exercise-3-5" class="headerlink" title="页映射回调函数 - load_icode_mapper - Exercise 3.5"></a>页映射回调函数 - <code>load_icode_mapper</code> - Exercise 3.5</h2><ul><li>  函数作用：作为 <code>load_icode</code> 中使用的回调函数，它决定了页映射的方式</li><li>  申请一个物理页 <code>page_alloc</code></li><li>  复制一下src内容（注意不要复制多/少了） <code>memcpy</code></li><li>  把这个复制好的物理页映射到目标 env 里 <code>page_insert</code></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 把 src 处数据映射到进程 data 的va 处，更新 perm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;offset + len&#x27; &lt;= &#x27;BY2PG&#x27;.</span></span><br><span class="line"><span class="comment"> * 换句话说就是复制过去后也只在**同一个**虚拟页里面，不会跨页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个装内容的物理页 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 2: 复制 src 内容 */</span></span><br><span class="line">  <span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) (page2kva(p) + offset), src, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 把物理页插进 env 进程页表，创建映射，完成复制 */</span></span><br><span class="line">  <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> </p><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>创建进程的过程主要由 <code>env_alloc</code> 函数实现，其步骤大致如下：</p><ul><li>  申请一个空闲的进程控制块</li><li>  初始化这个空白的控制块</li><li>  初始化进程<strong>页目录</strong></li><li>  从 env_free_list 中取出该控制块</li></ul><p><strong>用户栈</strong>是在使用过程中动态分配的</p><h2 id="进程页目录初始化-env-setup-vm-Exercise-3-3"><a href="#进程页目录初始化-env-setup-vm-Exercise-3-3" class="headerlink" title="进程页目录初始化 - env_setup_vm - Exercise 3.3"></a>进程页目录初始化 - <code>env_setup_vm</code> - Exercise 3.3</h2><ul><li>  函数作用：初始化进程页目录（共享只读段映射和自映射）</li><li>  <strong>形成进程页表</strong>，初始化新进程的虚拟地址空间</li><li>  把 UTOP 至 UVPT 两段地址间的内核页表 base_pgdir 拷贝到进程页表中，借此暴露这段由<strong>所有进程共享</strong>的只读空间（ Exercise 3.1完成了 base_pgdir 的建立与映射）</li></ul><p>关于共享只读的空间，指导书这样解释：</p><blockquote><p>在MOS 操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这是MOS 特有的设计。在Lab4 和Lab6 中将用到此机制。而这里我们要暴露是<strong>UTOP 往上到UVPT 之间所有进程共享的只读空间</strong>，也就是把这部分内存对应的内核页表base_pgdir 拷贝到进程页表中。从UVPT 往上到ULIM 之间则是进程自己的页表。</p></blockquote><p>拷贝的这一段空间，具体来说存放的是 envs 和 pages 两个经常使用的结构体，使其共享只读确实能够减少大量对内核空间的访问；不然用户进程申请个物理页都要进内核看 pages 了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 初始化进程的**用户内存（虚拟地址）空间**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 1: 使用 page_alloc 申请一页物理页框存放进程页目录 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  try(page_alloc(&amp;p));</span><br><span class="line">  <span class="comment">/* Exercise 3.3: Your code here. */</span></span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line">  e-&gt;env_pgdir = (Pde *) page2kva(p);</span><br><span class="line">  <span class="comment">/* Step 2: 将 &#x27;base_pgdir&#x27; 页目录内容拷贝至 &#x27;e-&gt;env_pgdir&#x27; 中 */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">         <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 设置页表自映射：令对应的页目录项指向页目录物理基地址 */</span></span><br><span class="line">  e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir)  PTE_V;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  使用 memcpy 时虽然只进行了页目录的拷贝，但两个页目录此时指向了相同的二级页表（物理页），之后再寻址就一样了</li><li>  页表自映射细节在 Thinking 3.1 中，可以回 Report 看一眼</li></ul><h2 id="申请并初始化进程块-env-alloc-Exercise-3-4"><a href="#申请并初始化进程块-env-alloc-Exercise-3-4" class="headerlink" title="申请并初始化进程块 - env_alloc - Exercise 3.4"></a>申请并初始化进程块 - <code>env_alloc</code> - Exercise 3.4</h2><ul><li>  函数作用如下：</li><li>  从空闲控制块链表中申请一个<strong>进程控制块</strong>（类似于 <code>page_alloc</code> 申请页）</li><li>  使用 <code>env_setup_vm</code> 函数和赋值语句对控制块进行初始化</li><li>  把申请好的控制块从链表中摘除并返回</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   申请并初始化进程块，存放在 &#x27;*new&#x27; 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   无父进程时 parent_id = 0</span></span><br><span class="line"><span class="comment"> *   需要初始化 envs（使用 env_init 函数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 on success</span></span><br><span class="line"><span class="comment"> *   return &lt; 0 on error：无空闲进程、ASID 或 &#x27;env_setup_vm&#x27; 失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   可能需要初始化下列字段:</span></span><br><span class="line"><span class="comment"> *     &#x27;env_id&#x27;, &#x27;env_asid&#x27;, &#x27;env_parent_id&#x27;, &#x27;env_tf.regs[29]&#x27;,</span></span><br><span class="line"><span class="comment"> * &#x27;env_tf.cp0_status&#x27;, &#x27;env_user_tlb_mod_entry&#x27;, &#x27;env_runs&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请空闲块，存放在 e 里 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (1/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e = LIST_FIRST(&amp;env_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: 使用 &#x27;env_setup_vm&#x27; 初始化用户空间 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (2/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (env_setup_vm(e)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 3: 初始化字段：</span></span><br><span class="line"><span class="comment">   *   &#x27;env_user_tlb_mod_entry&#x27; (lab4), &#x27;env_runs&#x27; (lab6), &#x27;env_id&#x27; (lab3),</span></span><br><span class="line"><span class="comment">   * &#x27;env_asid&#x27; (lab3), &#x27;env_parent_id&#x27; (lab3)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Hint:</span></span><br><span class="line"><span class="comment">   *   asid: asid_alloc</span></span><br><span class="line"><span class="comment">   *   envid: mkenvid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  e-&gt;env_user_tlb_mod_entry = <span class="number">0</span>; <span class="comment">// for lab4</span></span><br><span class="line">  e-&gt;env_runs = <span class="number">0</span>;               <span class="comment">// for lab6</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (3/4) */</span></span><br><span class="line">  e-&gt;env_id = mkenvid(e);</span><br><span class="line">  <span class="keyword">if</span> (asid_alloc(&amp;(e-&gt;env_asid)) == -E_NO_FREE_ENV) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;env_parent_id = parent_id;</span><br><span class="line">  <span class="comment">/* Step 4: 初始化 CP0 寄存器与栈顶寄存器 sp */</span></span><br><span class="line">  <span class="comment">// Timer interrupt (STATUS_IM4) will be enabled.</span></span><br><span class="line">  e-&gt;env_tf.cp0_status = STATUS_IM4  STATUS_KUp  STATUS_IEp;</span><br><span class="line">  <span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">  e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 5: 移出控制块并赋值 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (4/4) */</span></span><br><span class="line">  LIST_REMOVE(e, env_link);</span><br><span class="line">  *new = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化两个 ID 时，使用了两个不需要填空的函数，体现了操作系统生成不重复的 ID 的方式和位图法保存 ASID 的应用，这边也来看一下吧：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算一个 ASID 并存入参数指针内</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">asid_alloc</span><span class="params">(u_int *asid)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NASID; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> index = i &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> inner = i &amp; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> ((asid_bitmap[index] &amp; (<span class="number">1</span> &lt;&lt; inner)) == <span class="number">0</span>) &#123;</span><br><span class="line">      asid_bitmap[index] = <span class="number">1</span> &lt;&lt; inner;</span><br><span class="line">      *asid = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据当前 env ，计算其 env_id</span></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV))  (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在设置<strong>寄存器初始化</strong>时，我们使用了两个赋值语句，这两句关键语句需要解释一下：</p><ul><li><code>e-&gt;env_tf.cp0_status = STATUS_IM4 STATUS_KUp STATUS_IEp</code><ul><li>  初始化 CP0 的 SR 寄存器， IM4 代表允许响应4号中断、 KUp 代表处于用户态、 IEp 代表允许中断，这里实际上是初始化了<strong>中断响应机制</strong>所需的寄存器条件</li></ul></li><li><code>e-&gt;env_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **)</code><ul><li>  在 USTACKTOP 下存放的实际上就是用户栈，还记得倒置的 mips 栈吗，这里就是栈顶</li></ul></li></ul><p>对于 SR 寄存器，更具体的解释如下： 指导书P66  </p><h2 id="创建内核进程-env-create-Exercise-3-7"><a href="#创建内核进程-env-create-Exercise-3-7" class="headerlink" title="创建内核进程 - env_create -Exercise 3.7"></a>创建内核进程 - <code>env_create</code> -Exercise 3.7</h2><ul><li>  函数作用：创建一个内核进程，并加载 ELF 文件</li><li>  申请没有父进程的进程控制块</li><li>  初始化 priority 和 ENV_RUNNABLE</li><li>  加载 ELF 文件并插入调度队列</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  使用 &#x27;binary&#x27; 与 &#x27;priority&#x27; 字段创建一个进程</span></span><br><span class="line"><span class="comment"> *  在进程调度开始之前创建**内核**进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> Env *<span class="title function_">env_create</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个进程控制块，因为没有父进程所以 parent_id = 0,  &#x27;env_alloc&#x27; */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (1/3) */</span></span><br><span class="line">  env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Step 2: 标记 &#x27;priority&#x27; 并设置为 ENV_RUNNABLE，表示可以运行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (2/3) */</span></span><br><span class="line">  e-&gt;env_pri = (u_int) priority;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  <span class="comment">/* Step 3: 加载 ELF 文件，并插入 &#x27;env_sched_list&#x27; 头，表示允许调度 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (3/3) */</span></span><br><span class="line">  load_icode(e, binary, size);</span><br><span class="line">  TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>ENV_CREATE_PRIORITY</code>：MOS 创建内核<strong>示例</strong>进程时使用的宏，定义在 <code>include/env.h</code> 中</li></ul><p>这里用到的 <code>##x##</code> 可以理解成变量替换后的字符串拼接</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// priority = y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE_PRIORITY(x, y)                                             \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, y);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// priority = 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE(x)                                                         \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, 1);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 创建进程，binary字段来自名为 binary_user_bare_loop_start 的外部数组，定义在 user/bare/loop.b.c 中</span></span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p> </p><h2 id="再探-mmu-h"><a href="#再探-mmu-h" class="headerlink" title="再探 mmu.h"></a>再探 <code>mmu.h</code></h2><p>至此，一个新的<strong>内核进程</strong>创建过程就结束了，在 Lab4 中还会用部分函数创建<strong>用户进程</strong>。回顾一下。在申请进程之前，我们先初始化了进程控制块链表(<code>env_init</code>)，在申请过程中初始化了它的内存空间、页表(<code>env_setup_vm</code>)与进程控制块字段，最后返回(<code>env_alloc</code>)。 借助 Lab2 已有的布局和进程建立的过程，我们可以大致构建起一个不断完善的内存体系，这时候 <code>include/mmu.h</code> 内的内存布局图就可以再拿出来用了。不过实际上，仍有一些字段我们没有使用，这些字段在 Lab4 中会再加以利用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Part 2.  Our conventions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> o 4G -----------&gt;  +----------------------------+------------0x100000000</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg2</span></span><br><span class="line"><span class="comment"> o  KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span></span><br><span class="line"><span class="comment"> o                            Devices             kseg1</span></span><br><span class="line"><span class="comment"> o  KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span></span><br><span class="line"><span class="comment"> o                        Invalid Memory           /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+-----------Physical Memory Max</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg0</span></span><br><span class="line"><span class="comment"> o  KSTACKTOP-----&gt; +----------------------------+-----------0x8040 0000---end</span></span><br><span class="line"><span class="comment"> o                         Kernel Stack              KSTKSIZE            /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+----------                </span></span><br><span class="line"><span class="comment"> o                         Kernel Text                                  PDMAP</span></span><br><span class="line"><span class="comment"> o  KERNBASE -----&gt; +----------------------------+-----------0x8001 0000    </span></span><br><span class="line"><span class="comment"> o                        Exception Entry          \/                    \/</span></span><br><span class="line"><span class="comment"> o  ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span></span><br><span class="line"><span class="comment"> o                           User VPT                PDMAP                /\</span></span><br><span class="line"><span class="comment"> o  UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span></span><br><span class="line"><span class="comment"> o                             pages                 PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    </span></span><br><span class="line"><span class="comment"> o                             envs                  PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UTOP,UENVS ---&gt; +----------------------------+------------0x7f40 0000    </span></span><br><span class="line"><span class="comment"> o  UXSTACKTOP -/        user exception stack        BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f f000    </span></span><br><span class="line"><span class="comment"> o                                                   BY2PG                 </span></span><br><span class="line"><span class="comment"> o  USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    </span></span><br><span class="line"><span class="comment"> o                       normal user stack           BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f d000    </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                         kuseg</span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> o   UTEXT   -----&gt; +----------------------------+------------0x0040 0000    </span></span><br><span class="line"><span class="comment"> o                        reserved for COW           BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UCOW    -----&gt; +----------------------------+------------0x003f f000    </span></span><br><span class="line"><span class="comment"> o                     reversed for temporary        BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UTEMP   -----&gt; +----------------------------+------------0x003f e000    </span></span><br><span class="line"><span class="comment"> o                         invalid memory                                 \/</span></span><br><span class="line"><span class="comment"> a 0 ------------&gt;  +----------------------------+ ----------------------------</span></span><br><span class="line"><span class="comment"> o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> </p><ul><li>  UPAGES 和 UENVS 处于用户可见区内，包含内核的页面控制块和进程控制块，每个进程拷贝成了相同的内容</li></ul><h2 id="执行进程-env-run-Exercise-3-8"><a href="#执行进程-env-run-Exercise-3-8" class="headerlink" title="执行进程 - env_run - Exercise 3.8"></a>执行进程 - <code>env_run</code> - Exercise 3.8</h2><ul><li>  函数作用：切换并运行指定进程</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 切换当前运行进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   使用 &#x27;env_pop_tf&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  assert(e-&gt;env_status == ENV_RUNNABLE);</span><br><span class="line">  pre_env_run(e); <span class="comment">// WARNING: DO NOT MODIFY THIS LINE!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 保存当前运行栈 */</span></span><br><span class="line">  <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">    curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 变更全局变量 curenv */</span></span><br><span class="line">  curenv = e;</span><br><span class="line">  curenv-&gt;env_runs++; <span class="comment">// lab6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 更改当前运行进程的页目录 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (1/2) */</span></span><br><span class="line">  cur_pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 4: 使用 &#x27;env_pop_tf&#x27; 更新寄存器，并返回用户态 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (2/2) */</span></span><br><span class="line">  env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  返回用户态，实际上是个精妙的过程，只不过我们的填空不需要完成这部分，但实在是值得研究研究</li></ul><h2 id="env-pop-tf"><a href="#env-pop-tf" class="headerlink" title="env_pop_tf"></a><code>env_pop_tf</code></h2><ul><li>  修改 CP0 寄存器和 sp 寄存器，为跳回用户态提供数据</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(env_pop_tf)</span><br><span class="line">.set reorder</span><br><span class="line">.set at</span><br><span class="line">sll     a1, a1, 6</span><br><span class="line">mtc0    a1, CP0_ENTRYHI    # 把 ENTRYHI 中保存 ASID 的部分改为 curenv-&gt;env_asid</span><br><span class="line">move    sp, a0             # 把栈指针变更为 &amp;curenv-&gt;env_tf</span><br><span class="line">j       ret_from_exception # 离开异常处理程序，返回用户态</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure><h2 id="ret-from-exception"><a href="#ret-from-exception" class="headerlink" title="ret_from_exception"></a><code>ret_from_exception</code></h2><ul><li>  刚才在 <code>env_pop_tf</code> 的最后一句中，我们跳转到了这个汇编函数，它的作用是离开异常处理程序，回到用户态，虽然当前调用不算是异常处理，但是想要完成的作用都一样：<strong>恢复用户态现场，返回用户态执行</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">RESTORE_SOME         # 从 sp（视作 tf）中恢复除了 sp 以外的大部分寄存器</span><br><span class="line">lw      k0, TF_EPC(sp)   # 从 tf 中取出 EPC </span><br><span class="line">lw      sp, TF_REG29(sp) # 从 env_tf 中取得用户栈指针，赋值给 sp ，即切换到用户栈</span><br><span class="line">.set noreorder</span><br><span class="line">jr      k0               # 跳转至用户态 EPC ，离开异常处理程序</span><br><span class="line">rfe                      # 调用 rfe，使 SR 寄存器中的二重栈出栈一层</span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure><ul><li>  这里的 EPC 在初始化进程块时就被赋值成了 <strong>ELF 程序入口点</strong>，也就是说会直接 jr 到加载的 ELF 程序开始</li><li>  其中最关键的是 lw sp这一句，把用户栈指针从 tf 中取出，恢复了用户栈</li><li>  最后使用的 rfe 指令也刚好把 <code>env_alloc</code> 时初始化的二重栈用上了。每个进程都需要由此启动，所以确实<strong>都需要执行一次 rfe 指令</strong></li><li>  md，太妙了</li></ul><p> </p><h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>P7 的痛苦回忆又回来了.jpg</p><blockquote><p>我们实验里认为中断是异常的一种，并且是仅有的一种<strong>异步异常</strong>。</p></blockquote><h2 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h2><ul><li>  设置 <strong>EPC</strong> 指向返回地址</li><li>  设置 SR 寄存器，强制 CPU 进入内核态</li><li>  设置 Cause 寄存器记录异常原因</li><li>  跳转到异常处理程序入口，执行处理</li></ul><p> </p><h2 id="异常分发程序-exc-gen-entry-Exercise-3-9"><a href="#异常分发程序-exc-gen-entry-Exercise-3-9" class="headerlink" title="异常分发程序 - exc_gen_entry - Exercise 3.9"></a>异常分发程序 - <code>exc_gen_entry</code> - Exercise 3.9</h2><ul><li>  异常分发程序：根据发生的异常跳转到异常处理程序</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">SAVE_ALL                      # 将当前寄存器形成 TrapFrame 保存在内核栈 KSTACKTOP 内</span><br><span class="line">/* Exercise 3.9: Your code here. */</span><br><span class="line">mfc0 t0, CP0_CAUSE</span><br><span class="line">andi t0, 0x7c                 # 获取 Cause 寄存器中的 ExcCode</span><br><span class="line">lw t0, exception_handlers(t0) # 通过 handler 获取分发的处理函数入口</span><br><span class="line">jr t0                         # 跳转到对应的异常处理入口，响应异常</span><br></pre></td></tr></table></figure><ul><li>  <code>lw t0, exception_handlers(t0)</code> 指令明明是个访存指令，如何做到获取处理函数地址的呢？</li></ul><p>实际上这是由于 <code>exception_handlers</code> 这个异常向量组以数组的形式保存在内存中。只需要将 t0 寄存器作为下标，我们就能直接访问了这个数组的对应内容（这个内容存放的就是处理函数的地址） 为了程序能找到这个分发程序和处理 TLB Miss 的程序，我们在 <code>kernal.lds</code> 中放置了它们所在的字段：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.tlb_miss_entry : &#123;</span><br><span class="line">*(.text.tlb_miss_entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">= 0x80000080;</span><br><span class="line">.exc_gen_entry : &#123;</span><br><span class="line">*(.text.exc_gen_entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（虽然处理 TLB 的函数会直接跳到主异常分发程序，没啥用（</p><h2 id="异常向量组-exception-handlers"><a href="#异常向量组-exception-handlers" class="headerlink" title="异常向量组 - exception_handlers"></a>异常向量组 - <code>exception_handlers</code></h2><ul><li>  异常分发程序通过 <code>exception_handlers</code> 数组定位中断处理程序，而定义在 <code>kern/traps.c</code> 中的 <code>exception_handlers</code> 就称作<strong>异常向量组</strong>。</li></ul><p>这部分指导书的逻辑很明确，就直接借用了：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_tlb</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_sys</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_mod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_reserved</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义在哪个文件可以参考 Report 内容，在思考题中出现过</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读 2 号异常的处理函数为handle_tlb，表示TLB load 异常 3 号异常的处理函数为handle_tlb，表示TLB store 异常 8 号异常的处理函数为handle_sys，表示系统调用，用户进程通过执行syscall 指令陷 入内核</p></blockquote><p>通过访问对应的异常下标，就能在异常分发程序中进入对应的处理函数（目前中断还不行），最后调用 <code>ret_from_exception</code> 返回用户态</p><h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><ul><li>  中断处理的流程</li><li>  进入异常分发程序，判断为中断</li><li>  进入<strong>中断处理程序</strong> <code>handle_int</code>，判断中断种类，再进行分发</li><li>  处理中断结束后，进入 <code>ret_from_exception</code> 返回用户态</li></ul><p>目前我们的 MOS 只能处理一种<strong>时钟中断</strong>，所以中断处理就只有一种选择（）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2              # 获取可以处理的时钟中断</span><br><span class="line">andi    t1, t0, STATUS_IM4  # 中断号 4 号：时钟中断</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0               # 将时钟响应位置0</span><br><span class="line">j       schedule            # 执行 schedule(0)</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><h2 id="时钟中断-kclock-init-Exercise-3-11"><a href="#时钟中断-kclock-init-Exercise-3-11" class="headerlink" title="时钟中断 - kclock_init - Exercise 3.11"></a>时钟中断 - <code>kclock_init</code> - Exercise 3.11</h2><p>MOS 系统产生定时的时钟中断，并根据这些中断分配每个进程运行的时间片（限制进程一次性运行的时间长度）</p><ul><li>  初始化并启用时钟中断</li></ul><p><code>kern/kclock.S</code> 中的 <code>kclock_init</code> 函数完成了时钟中断的初始化，该函数向 <code>KSEG1 DEV_RTC_ADDRESS DEV_RTC_HZ</code> 位置写入200，其中 <code>KSEG1 DEV_RTC_ADDRESS</code> 是模拟器（GXemul）映射<strong>实时钟</strong>的位置。偏移量为 <code>DEV_RTC_HZ</code> 表示设置实时钟中断的频率，200 表示1 秒钟中断200 次。 随后再调用 <code>kern/env_asm.S</code> 中的 <code>enable_irq</code> 函数开启中断。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(kclock_init)</span><br><span class="line">li      t0, 200 // the timer interrupt frequency in Hz</span><br><span class="line"></span><br><span class="line">/* Write &#x27;t0&#x27; into the timer (RTC) frequency register.</span><br><span class="line"> *</span><br><span class="line"> * Hint:</span><br><span class="line"> *   To access device through mmio, a physical address must be converted to a</span><br><span class="line"> *   kseg1 address.</span><br><span class="line"> * #define DEV_RTC_HZ 0x0100</span><br><span class="line"> * #define DEV_RTC_ADDRESS 0x15000000</span><br><span class="line"> *  #define KSEG1 0xA0000000U</span><br><span class="line"> */</span><br><span class="line">/* Exercise 3.11: Your code here. */</span><br><span class="line">sw t0 , (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_HZ)</span><br><span class="line">jr      ra</span><br><span class="line">END(kclock_init)</span><br></pre></td></tr></table></figure><p><code>enable_irq</code> 函数在 Report 里也有，文章太长就不写力</p><ul><li>  时钟中断的处理</li><li><ol><li> 中断产生，进入异常分发程序</li><li> 判断为中断，进入中断处理程序</li><li> 判断为时钟中断，执行处理函数</li><li> 执行 <code>schedule(0)</code>，进行进程调度</li></ol></li></ul><h2 id="进程调度-schedule-Exercise-3-12"><a href="#进程调度-schedule-Exercise-3-12" class="headerlink" title="进程调度 - schedule - Exercise 3.12"></a>进程调度 - <code>schedule</code> - Exercise 3.12</h2><ul><li>  函数功能：根据参数 <code>yield</code> 和当前进程状态进行进程调度</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment"> *   1. 使用 static 变量 count 记录剩余时间片</span></span><br><span class="line"><span class="comment"> *   2. 不需要在 &#x27;noreturn&#x27; 函数中使用 return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always decrease the &#x27;count&#x27; by 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span></span><br><span class="line"><span class="comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span></span><br><span class="line"><span class="comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span></span><br><span class="line"><span class="comment"> * if that list is empty**.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 3.12: Your code here. */</span></span><br><span class="line"><span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  在 <code>schedule</code> 函数中，我们没有使用 <code>return</code>，而直接进入了新一轮的 <code>env_run</code>，保存当前已运行的部分内容，开始新的进程。</li><li>  这也说明了为什么只有 <code>timer_irq</code> 没有调用 <code>ret_from_exceprion</code> 函数，因为<strong>不用回到原本执行进程</strong>的用户态了</li></ul><p>  Lab3 大体到这里就结束了，要写的要看的也太多了，有点逆天。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab3-Report</title>
      <link href="/p/2565.html"/>
      <url>/p/2565.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab3-Report"><a href="#BUAA-OS-2023-Lab3-Report" class="headerlink" title="BUAA-OS-2023-Lab3-Report"></a>BUAA-OS-2023-Lab3-Report</h1><h1 id="Thinking-3-1"><a href="#Thinking-3-1" class="headerlink" title="Thinking 3.1"></a>Thinking 3.1</h1><ul><li>  Thinking 3.1 请结合MOS 中的页目录自映射应用解释代码中 <code>e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) PTE_V</code> 的含义</li></ul><p>根据自映射机制可知， <code>e-&gt;env_pgdir[PDX(UVPT)]</code> 指的是进程块 <code>e</code> 的<strong>指向用户页表</strong>的页目录项，又根据页表映射的要求，这一项的内容应该是用户页表的物理地址，即<code>PADDR(e-&gt;env_pgdir)</code> ，再为其置有效位为1，初始化用户页表</p><h1 id="Thinking-3-2"><a href="#Thinking-3-2" class="headerlink" title="Thinking 3.2"></a>Thinking 3.2</h1><ul><li><p>  <code>elf_load_seg()</code> 以函数指针的形式，接受外部自定义的回调函数 <code>map_page</code> 。请你找到与之相关的 <code>data</code> 这一参数在此处的来源，并思考它的作用。没有这个参数可不可以？为什么？</p></li><li><p>  <code>elf_load_seg()</code> 函数定义位于 <code>lib/elfloader.c</code> 中；使用仅有一处，位于 <code>kern/env.c</code> 的 <code>load_icode()</code> 函数中</p></li></ul><p>首先这里的回调函数是定义在 <code>kern/env.c</code> 的 <code>load_icode_mapper()</code> 函数，作用是把一段虚拟地址的内容<strong>加载</strong>到<strong>某个进程管理块对应进程</strong>的虚拟内存中（通过申请物理页面并建立页表映射）。这两个函数中的 <code>data</code> 参数相同，其来源是待加载的进程管理块指针，它用来告知 <code>load_icode_mapper()</code> 函数加载到哪个进程。所以<strong>不可以</strong>没有这个参数，如果没有这个参数，将无法确定加载到哪个进程的虚拟内存中。</p><p>在 <code>elf_load_seg()</code> 中使用回调函数，可以令用户自定义加载段中各个待加载页面的方式</p><h1 id="Thinking-3-3"><a href="#Thinking-3-3" class="headerlink" title="Thinking 3.3"></a>Thinking 3.3</h1><ul><li>  结合 <code>elf_load_seg()</code> 的参数和实现，考虑该函数需要处理哪些页面加载的情况</li></ul><p>考虑情况如下：</p><ul><li>  段起始地址未页面对齐</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  复制段大小不足一个页面</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))</span><br><span class="line"><span class="comment">// MIN(bin_size, BY2PG - offset) 选择了待复制段与页面偏移后</span></span><br><span class="line"><span class="comment">// 剩余空间中更小的值进行复制，避免复制不必要的内容</span></span><br></pre></td></tr></table></figure><ul><li>  为 <code>.bss</code> 段预留空间：文件大小与程序大小不同需要补充空页面</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  i += BY2PG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-4"><a href="#Thinking-3-4" class="headerlink" title="Thinking 3.4"></a>Thinking 3.4</h1><blockquote><p>这里的 <code>env_tf.cp0_epc</code> 字段指示了进程恢复运行时 PC 应恢复到的位置。我们要运行的进程的代码段预先被载入到了内存中，且程序入口为 <code>e_entry</code>，当我们运行进程时，CPU 将自动从 PC 所指的位置开始执行二进制码。</p></blockquote><ul><li>  思考上面这一段话，并根据自己在 Lab2 中的理解，回答：你认为这里的 <code>env_tf.cp0_epc</code> 存储的是物理地址还是虚拟地址?</li></ul><p>显然， PC 值应该在程序运行过程中<strong>保持连续</strong>，而程序运行时的物理地址应该是<strong>经过页表映射后</strong>不连续的，虚拟地址可以则保证其连续性。所以这里的 <code>env_tf.cp0_epc</code> 应该保存的是<strong>虚拟地址</strong></p><h1 id="Thinking-3-5"><a href="#Thinking-3-5" class="headerlink" title="Thinking 3.5"></a>Thinking 3.5</h1><blockquote><p>在<strong>异常向量组</strong>中，通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为 <code>handle_int</code> ，表示<strong>中断</strong>，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为 <code>handle_mod</code> ，表示<strong>存储异常</strong>，进行存储操作时该页被标记为只读 2 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB load</strong> 异常 3 号异常的处理函数为 <code>handle_tlb</code> ，表示 <strong>TLB store</strong> 异常 8 号异常的处理函数为 <code>handle_sys</code> ，表示<strong>系统调用</strong>，用户进程通过执行 <code>syscall</code> 指令陷 入内核</p></blockquote><ul><li>  试找出上述 5 个异常处理函数的<strong>具体实现位置</strong>。</li></ul><p>在 <code>kern/genex.S</code> 文件中，我们可以先找到其上声明的 <code>handle_int</code> 函数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)# handle_int 实现</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2</span><br><span class="line">andi    t1, t0, STATUS_IM4</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0</span><br><span class="line">j       schedule</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure><p>其余的四个函数通过同文件的宏 <code>BUILD_HANDLER exception handler</code> 定义在其后：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.macro BUILD_HANDLER exception handler</span><br><span class="line">NESTED(handle_\exception, TF_SIZE + 8, zero)</span><br><span class="line">move    a0, sp</span><br><span class="line">addiu   sp, sp, -8</span><br><span class="line">jal     \handler</span><br><span class="line">addiu   sp, sp, 8</span><br><span class="line">j       ret_from_exception</span><br><span class="line">END(handle_\exception)</span><br><span class="line">.endm</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER tlb do_tlb_refill# do_tlb_refill 实现于 kern/tlbex.c</span><br><span class="line"></span><br><span class="line">#if !defined(LAB)  LAB &gt;= 4</span><br><span class="line">BUILD_HANDLER mod do_tlb_mod# do_tlb_mod 实现于 kern/tlbex.c</span><br><span class="line">BUILD_HANDLER sys do_syscall# do_syscall 实现于 kern/syscall_all.c</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">BUILD_HANDLER reserved do_reserved# do_reserved 实现于 kern/traps.c</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-6"><a href="#Thinking-3-6" class="headerlink" title="Thinking 3.6"></a>Thinking 3.6</h1><ul><li>  阅读 init.c、kclock.S、env_asm.S 和 genex.S 这几个文件，并尝试说出 <code>enable_irq</code> 和 <code>timer_irq</code> 中每行汇编代码的作用</li></ul><h2 id="enable-irq"><a href="#enable-irq" class="headerlink" title="enable_irq"></a><code>enable_irq</code></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(enable_irq)</span><br><span class="line">li      t0, (STATUS_CU0  STATUS_IM4  STATUS_IEc)    # 允许用户态使用 CP0 寄存器 + 允许4号中断响应 + </span><br><span class="line">                                                    # 开启当前状态CPU中断</span><br><span class="line">mtc0    t0, CP0_STATUS                              # 将 CPU 状态保存在 CP0 的 STATUS 寄存器</span><br><span class="line">jr      ra                                          # 返回调用者函数</span><br><span class="line">END(enable_irq)</span><br></pre></td></tr></table></figure><h2 id="timer-irq"><a href="#timer-irq" class="headerlink" title="timer_irq"></a><code>timer_irq</code></h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">                                                    # 将 GXemul 时钟响应位置 0</span><br><span class="line">li      a0, 0                                       # 令 schedule 参数 yield = 0</span><br><span class="line">j       schedule                                    # 进入 schedule 函数进行进程块队列调度</span><br></pre></td></tr></table></figure><h1 id="Thinking-3-7"><a href="#Thinking-3-7" class="headerlink" title="Thinking 3.7"></a>Thinking 3.7</h1><ul><li>  阅读相关代码，思考操作系统是怎么根据时钟中断切换进程的</li></ul><p>首先，我们在kern/kclock.S 中的kclock_init 函数完成了时钟中断的初始化，并在 genex.S 中的 enable_irq 中设置允许响应该中断</p><p>当时钟计时归零（时间片耗尽），产生时钟中断，进入<strong>异常处理程序</strong>，并跳转到 handle_int 处理中断。</p><p>当前我们的系统只能处理 <code>timer_irq</code> 一种时钟中断，所以直接进入 <code>timer_irq</code> 函数，恢复时钟，并执行 <code>schedule(0);</code></p><p>在 <code>schedule()</code> 中，我们根据当前进程块状态进行进程块队列调度，实现进程切换或进程的舍弃，至此完成时钟中断响应</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT2-Summary</title>
      <link href="/p/32036.html"/>
      <url>/p/32036.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>纸上得来终觉浅，多线程要多测试</p></blockquote><ul><li><strong>博客撰写基本要求：</strong><ul><li>总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li><li>总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的<ul><li>结合线程协同的架构模式（如流水线架构），分析和总结自己<ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul></li></ul></li><li>分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li><li>心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul></li></ul><p><strong>注意：</strong>在编写完博客并发布在CSDN之后，请在选择要作为作业提交的博客，点击提交。</p><h1 id="架构思路总结"><a href="#架构思路总结" class="headerlink" title="架构思路总结"></a>架构思路总结</h1><p>本单元作业，我采取了一种专精调度器的路线，调度器知晓程序内几乎所有类、线程的数据，并根据这些数据进行全局的调度，其包括：</p><ul><li>  为指定请求分派特定的电梯</li><li>  唤醒、终止<strong>特定的</strong>电梯线程</li><li>  指定电梯运行的掉头楼层（抵达该楼层就进行转向）</li><li>  拆解不可直达请求为局部最优路线并分配电梯</li></ul><p>实现这样一个看起来全能全知的调度器就意味着它需要掌握大量数据，否则很难做出合理的调度。所以设计模式上我采取了一种”一家独大“的<strong>黑板模式</strong>：电梯类与生产者类持续进行数据的实时更新，调度器则根据这些实时数据做出判断。</p><p>为了减少死锁的发生，我限制了所有信息的流动方向：仅允许调度器这块黑板被外界访问，调度器只能向黑板上写数据，不能主动申请获取外界信息。<strong>单方向的信息传递</strong>保证死锁不会在这样的架构中产生。同时我并没有将调度器类转变为线程，而是以数据字段与众多处理方法组成，不同的数据更改会使用调度器类的不同方法，从而进行下一步的调度。</p><h2 id="同步块的设置与锁的选择"><a href="#同步块的设置与锁的选择" class="headerlink" title="同步块的设置与锁的选择"></a>同步块的设置与锁的选择</h2><ul><li>  总结分析三次作业中同步块的设置和锁的选择，并分析锁与同步块中处理语句之间的关系</li></ul><p>在三次作业中，我均使用了互斥锁 <code>synchronized</code> 进行代码同步块的保护。原有想重构为效率更高的 <code>ReentrantLock</code> 或可释放指定线程便于高效调度的 <code>LockSupport</code> 或更高端的读写锁 <code>ReentrantReadWriteLock</code> ，但是最后都因为原来架构压得有点死而放弃（</p><p>在本轮作业迭代中，我在生产者类、调度器类与电梯类中都出现了锁，但这些锁<strong>全部指向调度器类</strong>，并且只设置了一个调度器。也就是说，无论发生怎样的线程交互，都只能申请访问一个锁，所以根本不可能出现死锁状况，大家都在等着调度器那一把锁而已。</p><p>为了保证线程安全，我将调度器内的所有方法都使用了 <code>synchronized</code> 关键字进行包装，但其他的类除了电梯类 <code>wait()</code> 调度器锁时需要同步外，均未出现同步方法/同步块。</p><h3 id="各个类获取锁的目的"><a href="#各个类获取锁的目的" class="headerlink" title="各个类获取锁的目的"></a>各个类获取锁的目的</h3><ul><li>生产者类：<ul><li>  向调度器中的请求队列中添加新的请求（乘客请求）</li><li>  更新调度器类中的电梯集合（ADD、MAINTAIN）</li></ul></li><li>电梯类：<ul><li>  向调度器中<strong>写入</strong>当前自身状态（楼层、方向、运行与否等）</li><li>  从调度器中<strong>读取</strong>自身的下一步状态（运动方向/状态、MAINTAIN等）</li><li>  更新调度器中的请求队列（MAINTAIN、换乘下客）</li></ul></li></ul><h2 id="调度器设计与线程交互"><a href="#调度器设计与线程交互" class="headerlink" title="调度器设计与线程交互"></a>调度器设计与线程交互</h2><ul><li>  总结分析三次作业中的调度器设计，并分析调度器如何与程序中的线程进行交互；总结分析三次作业中的调度策略，并分析自己的调度策略是如何适应时间、电量等多个性能指标的</li></ul><h3 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h3><p>本单元采用黑板模式进行设计。各个类都将信息交互集中于黑板之上，生产者写入请求，调度器调度请求，电梯获取自身预定的运动细节。由此，黑板便成了整个程序最大的、也是唯一的<strong>共享数据类</strong>。</p><p>三次作业中，调度器都建立在提到的共享数据类 “黑板” 之上。通过生产者和电梯的数据更新，调度器能够掌握全部线程的几乎全部信息，并根据信息设计调度策略。</p><h3 id="线程交互与信息传递"><a href="#线程交互与信息传递" class="headerlink" title="线程交互与信息传递"></a>线程交互与信息传递</h3><p>由于有且仅有一个共享数据类——黑板，所以程序内的信息流动都与这个数据类相关。</p><p>在设计本单元架构时，我考虑的第一个问题实际上是<strong>死锁</strong>，不知道同学们有没有因为程序死锁而难以推进的时候。为了解决这种困扰，我直接简单粗暴的将所有<strong>信息访问</strong>的方向固定为单向：生产者、电梯只能更新调度器内数据，或读取调度器产生的信息，正如在前面锁的部分提到的一样。这样做线程交互的难度能有所降低。</p><p>其实当时还并不理解这样做的原理是什么，直到第八周理论课上，我才发现自己采取的架构和老师谈到的黑板模式十分相近。具体的信息流动如下：</p><p>假装有图.jpg</p><p>但实际上，随着工程代码量与类的增多，黑板上记录的东西会越来越复杂，想来看黑板的人也会越来越多，这样必然会导致多线程交互效率下降，同时也会导致黑板与离着黑板最近的调度器类复杂度升高。</p><h3 id="调度策略与性能指标"><a href="#调度策略与性能指标" class="headerlink" title="调度策略与性能指标"></a>调度策略与性能指标</h3><p>在单元初就被告知今年的性能指标增加了一个用电量的限制。旨在加重调度器在程序设计中的地位，弱化所有电梯饿虎扑食的自由竞争的使用。这更加坚定了我要写一个全局调度器的决心，主要是不觉得写调度器优质规划是一件很酷的事情吗（并不）</p><p>再加上原本的传统性能指标：运行时间和等待时间。多数情况下，电梯移动更少的楼层能消耗更少的时间，所以我希望电梯能少跑一层就少跑一层（省电）；乘客能早接一下就早接一下（省时间）。</p><p>由此确定了基本的思路为：</p><blockquote><p>能近就近，能省就省</p><p>（乘客选用距离最近的电梯，电梯运行中考虑移动最少的楼层数）</p></blockquote><p>决定采用调度器全局调度的方式后，实际上后续迭代的请求分配策略几乎没有发生改变：</p><ul><li>准备工作：电梯在移动/休息过程中将自身状态实时写到黑板上</li><li>调度启动：生产者向黑板写入请求，告知调度器开始规划</li><li>规划思路：为请求分配等待最短时间就能搭上的电梯<ul><li>  遍历所有电梯，能否装下这个乘客（过程中会不会超载），若超载则被筛除</li><li>  根据 请求楼层/运动方向、电梯楼层/运动方向、电梯掉头时预计抵达的楼层，计算当前电梯接收请求所用的时间</li><li>  将请求分配给所需时间最短者（保证局部最优），并更新电梯掉头预计抵达的楼层（请求终点站与原本预计抵达楼层间的比较），以便电梯掌握运动路线，同时便利下次分配</li></ul></li></ul><p>这种做法，实际上和往年学长们的影子电梯/模拟做法类似，只不过这种做法精确度不如纯模拟，但是实现难度要比复制一遍电梯内容并全局模拟的难度还是要低不少的。这里唯一需要比模拟做法多考虑的点就是<strong>电梯超载</strong>：</p><p>试考虑以下场景：电梯停靠于1层，首先为其分配6个5-11层的请求令电梯满载，在电梯运行到2层时再输入一个3-11层的请求，显然电梯此刻为空，同时显然把7个请求全部分给这台电梯，会超载，或剩下一个请求等这台电梯回来接他。</p><p>假装有图.jpg</p><p>这样做的效果显然不如第一次就把请求分配给另一台电梯，那么如何表示<strong>当前有空间</strong>的电梯，在<strong>未来某一刻</strong>会满载呢？我使用了两个数组代表上行/下行过程中电梯在某个楼层时的人数，然后根据分配的请求进行动态变化，如果某一层达到capacity说明电梯在该层会出现满员状态。具体细节就不展开说了，有了思路后实现还是很轻松的。</p><p>在第三次作业中，加入了<strong>强制换乘</strong>请求，我的处理方式是将所有可联通（换乘）的电梯当作图中的两个连接的节点，然后从请求起始楼层所有可达的电梯出发，求到终止楼层所有可达电梯的<strong>多源对多源可达路径</strong>（全部可达路径，做法可参考<a href="https://blog.csdn.net/spnooyseed/article/details/106957325">这一篇文章</a>）。再按照换乘次数递增的方式排序路线并拆分每一个请求的第一次<strong>换乘段</strong>，查看能否分配。</p><p>总体来说性能还是蛮不错了，至少有人上来错仨点还能拿84+（</p><h2 id="架构分析与协作图"><a href="#架构分析与协作图" class="headerlink" title="架构分析与协作图"></a>架构分析与协作图</h2><p>结合线程协同的架构模式（如流水线架构），分析和总结自己</p><ul><li>  三次作业架构设计的逐步变化和未来扩展能力画UML类图</li><li>  画UML协作图(sequence diagram)来展示线程之间的协作关系（别忘记主线程）</li><li>  识别出三次作业稳定的内容和易变的内容，并加以分析</li></ul><h3 id="UML-类图"><a href="#UML-类图" class="headerlink" title="UML 类图"></a>UML 类图</h3><ul><li>  类图中不包含<code>[]</code>标记的是第一次第一次的架构，方括号内数字代表这个字段/方法在第几次作业中加入</li></ul><p>通过三次迭代作业的类图可以发现，迭代过程中并没有增添过多的类，处理方式大多为增添函数以满足请求。</p><p>在拓展方面上，可以考虑迭代前两年作业中出现过的横向电梯，为此可能需要做出以下调整：</p><ul><li>  改良电梯间的图结构，使其能支持更复杂的换乘需求</li><li>  增添新的横向电梯类，优化电梯信息类以兼容两类电梯</li></ul><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752603.jpg" alt="ClassUML3.jpg"></p><h3 id="UML-协作图"><a href="#UML-协作图" class="headerlink" title="UML 协作图"></a>UML 协作图</h3><p>UML 协作图如下，本架构中，调度器 Manager 并不属于运行中的线程，只不过因为方法与交互太多，导致它看起来好像在持续运行一样（）</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304131752093.jpg" alt="ProcessUML"></p><h2 id="代码中稳定-易变的内容"><a href="#代码中稳定-易变的内容" class="headerlink" title="代码中稳定/易变的内容"></a>代码中稳定/易变的内容</h2><ul><li>稳定内容：<ul><li>  电梯运行逻辑：在三次作业中，电梯都采用了 检查方向 - 移动 - 上下客 - 检查方向 的循环进行电梯的移动，同时电梯 MAINTAIN 逻辑也只在添加时进行了编写，后续没有改动</li><li>  电梯上下客逻辑：电梯检测每个请求是否标记为自身携带，如果是则进入电梯；检查自身队列，如果目的地是当前楼层则释放；这部分逻辑也没有发生过改变</li><li>  计算最优电梯逻辑：针对每一个请求，每台电梯都会计算接收请求所用时间长短，并分配电梯，这个逻辑也大致没有变化，只在第二次作业中<strong>将时间由固定值改为电梯属性</strong></li></ul></li><li>易变内容：<ul><li>请求读入逻辑：在第一次作业中请求只有 <code>PersonRequest</code> 一种，只需要考虑读取乘客请求并更新队列即可；在第二次作业中，增加了 <code>ADD</code> 、 <code>MAINTAIN</code> 请求，需要分类并处理增删电梯逻辑与对应的方法；在第三次作业中， <code>ADD</code> 电梯的逻辑更加复杂，需要额外考虑电梯的可达楼层。每次作业迭代都发生了改变。</li><li>线程终止逻辑：与请求输入相关的终止逻辑变更也较大。第一次作业中只要输入停止，就一定意味着线程可以处理完当前请求后结束；第二次作业中，必须考虑 <code>MAINTAIN</code> 电梯仍然会在输入结束后释放乘客，而这部分乘客需要回填请求队列，这就产生了新的请求；第三次作业中回填的情况也发生在不可直达请求的换乘过程中：换乘请求下车后仍需要回填请求序列。</li><li>第三次作业中的请求拆分逻辑：虽然这部分逻辑只在最后一次作业出现，但是我尝试过各种不同的方法，感觉也有必要做一些总结：<ul><li>  “<strong>电梯井</strong>”逻辑：按照 电梯ID + 楼层号 的方式创建节点，同时创建一个只连接<strong>可停靠在该层</strong>电梯的<strong>换乘大厅</strong>， dfs 找出所有可行路线，并排序最少换乘路线；但这个做法时间复杂度过高，处理单个请求都可能 CTLE ，无奈不得不放弃</li><li>  电梯邻接链表：同学分享的思路，将每一层构建一个节点，各层能停的电梯划分在楼层后，再根据所有能上的电梯继续寻找下一个能上的电梯，直至能够抵达最终目的楼层，回溯路径</li><li>  多源 - 多源 dfs：最后采用的方法，之前在前面写过了就不水了</li></ul></li></ul></li></ul><h2 id="bug-记录与多线程-bug-修复"><a href="#bug-记录与多线程-bug-修复" class="headerlink" title="bug 记录与多线程 bug 修复"></a>bug 记录与多线程 bug 修复</h2><ul><li>  分析自己程序出现过的bug以及自己面对多线程程序的debug方法</li></ul><h3 id="bug记录"><a href="#bug记录" class="headerlink" title="bug记录"></a>bug记录</h3><p>在第一单元互测中，大家的常用攻击方式都是短时间大量投喂1 - 11之类的请求卡 RTLE。本地测试没出现过被卡的情况，但在互测中还真被刀了。在助教的帮助下我意识到可能的原因是生产者 - 电梯之间处理 <code>notifyAll()</code> 的速度差异。</p><p>在我的架构中，对于一个读入的请求会计算其搭乘的电梯 ID ，同时根据 ID 去唤醒指定的电梯，具体来说就是在黑板的一块<strong>公共空间</strong>写下电梯号，每个电梯按顺序查看是不是自己，再决定会不会醒来。但如果生产者的运转速度过快，有可能导致 A 乘客的 ID 还没有被所有电梯看完， B 乘客的 ID 就覆盖了旧 ID ，有可能A的电梯就醒不过来了。但当时采用了一种不合适的修改思路：使用 <code>sleep()</code> 降低生产者速度。</p><p>因为这次修改不够充分，类似的问题出现在第三次作业中，最后的bug修复我把公共的空间改为了每个电梯只查看自己的一小块私有黑板，这样不会频繁更改，才是最好的办法。</p><h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h3><blockquote><p>一定要多 <code>println()</code> .jpg</p></blockquote><p>打印共享数据类的各个所需状态都是debug的一种选择。其中我认为最好用的是根据可能出错的电梯ID和乘客ID，直接输出当时电梯内外的所有状态，大体为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (elevator.getId() == specialEid &amp;&amp; request.getId() == specialRid) &#123;</span><br><span class="line">    System.println(<span class="string">&quot;message you want to see&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的 specialId 都是具体的数字</span></span><br></pre></td></tr></table></figure><p>其次就是多做<strong>场景复原</strong>，回溯错误发生前的一段时间，看一看错误电梯的行为。通过配合前面的特定print效果还是挺不错的，因为既不会打印出满屏输出，同时也能看到一些关键的信息。</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ul><li>  心得体会。从线程安全和层次化设计两个方面来梳理自己在本单元三次作业中获得的心得体会</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>这单元的作业中，很多同学都出现了<strong>死锁</strong>的状况，原因大部分是复杂的<strong>线程间信息交互</strong>。而且都是在持有锁的同步块内索取其他对象的锁，确实容易出错（）规范信息交互方式、合理使用同步块和锁，注意单个函数逻辑，我认为是处理交互的重中之重。</p><p>再比如有佬采用了每个请求的每秒都生成一个线程，我觉得这是对自己架构设计的磨练与宝贵经验；虽然我距离这样把线程用活的程度还有很远，但我觉得这样架构中的信息交互与安全性实在值得我们学习。</p><p>其次是保证读写操作不会被其他操作干扰，实际上这个还比较好处理，需要注意<strong>一次</strong>读写操作的范围，对于单个对象来说可能是一个 <code>return</code> ，一个赋值；而对于容器来说，一次读写就应该对应着一次遍历了，在遍历途中实际上都不应该允许容器被改变。</p><h2 id="层次化设计"><a href="#层次化设计" class="headerlink" title="层次化设计"></a>层次化设计</h2><p>在考虑线程之间的协作时，为了避免线程本身拥有太多信息导致交互臃肿，我选择了一个单独的电梯信息类对单个电梯所拥有的一系列属性进行包装，并且把这个信息类放在黑板中。电梯线程类本身不具有太多信息，查询、更新状态都需要去黑板查看，这样保证了线程交互的简便性。</p><p>其余的层次化主要体现在调度器类这个黑板上，黑板拥有不同的字段，这些字段是对应的下一级的类，它们分别代表着黑板上的不同种类信息。总的来说层次化设计在本次作业架构中不是很明显。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>oo最让人难熬的电梯月到这里就算告一段落了，我认为这个单元学到的线程协作知识很有价值，不仅在学习过程中了解到了更多的设计模式，同时也知晓了线程/进程的概念、线程间信息传递的安全问题，是十分宝贵的经验。还有两个单元，不要懈怠就好了。</p><p>能看到最后的我觉得大概率是助教giegie吧，在这我想对每一位助教说声谢谢，在电梯月的摸爬滚打少了你们的帮助真的会寸步难行。接下来两个单元也要救救我哦（逃</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-Probe-Lab2</title>
      <link href="/p/29513.html"/>
      <url>/p/29513.html</url>
      
        <content type="html"><![CDATA[<h2 id="实验细节"><a href="#实验细节" class="headerlink" title="实验细节"></a>实验细节</h2><p>在进行实验前，建议通读<code>mmu.h</code>和<code>pmap.h</code>文件，了解一些宏定义，对后续工作很有帮助</p><p>名称</p><p>参数</p><p>作用</p><p>PADDR</p><p>内核<strong>虚拟地址</strong>kva</p><p>将内核虚拟地址kva转成对应的物理地址</p><p>KADDR</p><p><strong>物理地址</strong>pa</p><p>将物理地址pa转化为内核虚拟地址</p><p>page2pa</p><p>页信息结构<strong>struct Page</strong></p><p>通过空闲页结构得到这一页起始位置的物理地址</p><p>pa2page</p><p><strong>物理地址</strong>pa</p><p>通过物理地址pa获取这一页对应的页结构体struct Page</p><p>page2kva</p><p>页信息结构<strong>struct PageInfo</strong></p><p>通过空闲页结构得到这一页起始位置的虚拟地址</p><p>PDX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la对应的页目录项索引</p><p>PTX</p><p><strong>线性地址</strong>la</p><p>获得该线性地址la在二级页表中对应的页表项索引</p><p>PTE_ADDR(pte)</p><p>页表项或页目录项的<strong>值</strong></p><p>获得对应的页表/地址基址(低12位为0，并均为<strong>物理地址</strong>)</p><h3 id="内核启动后的内存分配-2-1"><a href="#内核启动后的内存分配-2-1" class="headerlink" title="内核启动后的内存分配 - 2.1"></a>内核启动后的内存分配 - 2.1</h3><ul><li>我们的操作系统内核启动后需要执行下列三个函数完成内存分配机制的建立<ul><li>  <code>mips_detect_memory()</code>：探测硬件可用内存，初始化内存基本变量</li><li>  <code>mips_vm_init()</code>：建立用于管理内存的数据结构</li><li>  <code>page_init()</code>：初始化结构<code>Page</code>与空闲链表<code>page_free_list</code></li></ul></li></ul><h4 id="mips-detect-memory-Exercise-2-1"><a href="#mips-detect-memory-Exercise-2-1" class="headerlink" title="mips_detect_memory() - Exercise 2.1"></a><code>mips_detect_memory()</code> - Exercise 2.1</h4><ul><li>本函数的作用是探测硬件可用内存，并初始化两个变量：<ul><li>  <code>memsize</code>：物理内存对应的字节数（实验中从外设中读取）</li><li>  <code>npage</code>：物理内存对应的页数</li></ul></li></ul><h5 id="Exercise-2-1"><a href="#Exercise-2-1" class="headerlink" title="Exercise 2.1"></a>Exercise 2.1</h5><ul><li>  请参考代码注释，补全<code>mips_detect_memory</code>函数。 在实验中，从外设中获取了硬件可用内存大小<code>memsize</code>，请你用内存大小<code>memsize</code>完成总物理页数<code>npage</code>的初始化</li></ul><p>相对简单的一题，<code>memsize</code>已知，只需要除以每页的大小即可（<code>BY2PG = 4096</code>定义在<code>mmu.h</code>中）</p><p>在这里要留意一下<code>npage</code>这个变量，后面的练习中会用到几次</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mips_detect_memory</span><span class="params">()</span> &#123;</span><br><span class="line">    memsize = *(<span class="keyword">volatile</span> u_int *)(KSEG1  DEV_MP_ADDRESS  DEV_MP_MEMORY);</span><br><span class="line">    <span class="comment">/* Exercise 2.1 Your code here. */</span></span><br><span class="line">    npage = memsize / BY2PG;</span><br><span class="line">    </span><br><span class="line">    printk(<span class="string">&quot;Memory size: %lu KiB, number of pages: %lu\n&quot;</span>, memsize / <span class="number">1024</span>, npage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mips-vm-init"><a href="#mips-vm-init" class="headerlink" title="mips_vm_init()"></a><code>mips_vm_init()</code></h4><ul><li>  本函数通过一次性调用<code>alloc()</code>函数完成对内存管理结构（<strong>页控制块</strong>）所在空间的初步分配，实现的关键在<code>alloc()</code>中。这个函数只在系统初始化、尚未生成页式管理机制时才会被调用。</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在建立页式存储机制前，使用alloc函数进行内存空间的分配</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">alloc</span><span class="params">(u_int n, u_int align, <span class="type">int</span> clear)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> end[];</span><br><span class="line">    <span class="comment">/* Initialize &#x27;freemem&#x27; if this is the first time. */</span></span><br><span class="line">    <span class="keyword">if</span> (freemem == <span class="number">0</span>) &#123;</span><br><span class="line">        freemem = (u_long)end;<span class="comment">/* 明确 freemem 指向虚拟地址 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    freemem = ROUND(freemem, align);<span class="comment">/* 按大小向上取整，保证此时freemem表示</span></span><br><span class="line"><span class="comment">     * 空闲空间的起始地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloced_mem = freemem;<span class="comment">/* freemem 以下空间均被分配 */</span></span><br><span class="line">    freemem = freemem + n;<span class="comment">/* 分配出 n 个字节大小的空间 */</span></span><br><span class="line">    <span class="keyword">if</span> (PADDR(freemem) &gt;= memsize) &#123;<span class="comment">/* 物理地址越界，无足够空闲空间 */</span></span><br><span class="line">        panic(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (clear) &#123;<span class="comment">/* clear 是分配内存清零的标志位 */</span></span><br><span class="line">        <span class="built_in">memset</span>((<span class="type">void</span> *)alloced_mem, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) alloced_mem;<span class="comment">/* 返回被分配空间的起始**虚拟**地址 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mips_vm_init</span><span class="params">()</span> &#123;</span><br><span class="line">    pages = (<span class="keyword">struct</span> Page *)alloc(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 分配了一块大小为 (npage * 页表项) 字节的空间并清空，用于存放所有的页表项</span></span><br><span class="line"><span class="comment">     * 起始地址为 pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  <code>freemem</code>：在这里我们通过使用虚拟内存的<code>kseg0</code>段来操作内存，但实际上它可以直接映射到指定的物理地址（去掉最高位），不需要额外的映射逻辑</li><li>  <code>extern char end[]</code>：在lab1中分配段加载地址用到的<code>kernel.lds</code>已经声明过，可以直接使用表示地址</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80400000;// 相当于物理内存的0x400000</span><br><span class="line">end = . ;</span><br></pre></td></tr></table></figure><h3 id="物理内存管理-2-2-2-5"><a href="#物理内存管理-2-2-2-5" class="headerlink" title="物理内存管理 - 2.2 ~ 2.5"></a>物理内存管理 - 2.2 ~ 2.5</h3><ul><li>  MOS系统使用页式内存管理物理内存，使用链表管理页表，重要代码位于<code>kern/pmap.c</code>中</li></ul><h4 id="链表宏-Exercise-2-2"><a href="#链表宏-Exercise-2-2" class="headerlink" title="链表宏 - Exercise 2.2"></a>链表宏 - Exercise 2.2</h4><p>更具体的链表宏其实在Thinking部分已经提到了，这里不再过多展开。</p><p>在这里出现的链表形式与常见的双向链表有些不同，每一个链表项含有一个<code>field* le_next</code>，还有一个<code>field** le_prev</code>，其中的<code>le_next</code>很好理解，就正常指向下一个链表项，但是这个<code>le_prev</code>则是指向<strong>上一个</strong>链表项的<code>le_next</code>域：更直观地来说就是这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">first-&gt;field.le_next = second</span><br><span class="line">second-&gt;field.le_prev = &amp;(first-&gt;field.le_next)</span><br><span class="line"><span class="comment">// **类型 = 给*类型取地址</span></span><br><span class="line">*(second-&gt;field.le_prev) = first-&gt;field.le_next = second</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.2已经可以完成了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field)\</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (((elm)-&gt;field.le_next = (listelm)-&gt;field.le_next) != NULL)          \</span></span><br><span class="line"><span class="meta">        (listelm)-&gt;field.le_next-&gt;field.le_prev =                           \</span></span><br><span class="line"><span class="meta">            &amp;((elm)-&gt;field.le_next);                                        \</span></span><br><span class="line"><span class="meta">    (listelm)-&gt;field.le_next = (elm);                                       \</span></span><br><span class="line"><span class="meta">    (elm)-&gt;field.le_prev = &amp;(listelm)-&gt;field.le_next;                       \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br></pre></td></tr></table></figure><p>再有一个注意点就是，各个宏定义传入参数时要求的是什么类型：</p><p><code>head</code>参数就要求传入的是链表头的指针<code>&amp;</code>（本实验中指<code>Page_List *</code>）</p><p><code>elm</code>参数要传入链表项的指针<code>&amp;</code>（本实验中指<code>Page *</code>）</p><p><code>field</code>参数则传入的是链表项的指针（本实验中指的是<code>pp_link</code>）</p><blockquote><p>接下来的三个练习（2.3-2.5）针对的是在建立页式内存管理后中/后所需要用到的一些函数，这些函数的正确与否直接决定了分页管理能否正常运行（虽然<code>init</code>那里错了也会寄就是了，哈哈比如我）</p></blockquote><h4 id="page-init-Exercise-2-3"><a href="#page-init-Exercise-2-3" class="headerlink" title="page_init() - Exercise 2.3"></a><code>page_init()</code> - Exercise 2.3</h4><ul><li>  <code>page_init()</code>函数用于初始化空闲链表<code>page_free_list</code></li></ul><p>任务要求为完成函数：</p><ol><li> 使用链表初始化宏<code>LIST_INIT</code>。</li><li> 将<code>freemem</code>按照<code>BY2PG</code>进行对齐（使用<code>ROUND</code>宏为<code>freemem</code>赋值）。</li><li> 将<code>freemem</code>以下页面对应的页控制块中的<code>pp_ref</code>标为1。</li><li> 将其它页面对应的页控制块中的<code>pp_ref</code>标为0 并使用<code>LIST_INSERT_HEAD</code>将其插入空闲链表。</li></ol><p>还可以这样把任务具体化：</p><ol><li>对<code>free_page_list</code>初始化，使用<code>LIST_INIT()</code>宏</li><li>将<code>freemem</code>按<code>BY2PG</code>对齐，使用<code>ROUND()</code>宏</li><li>从划分的页表项指针<code>pages</code>开始，按照地址由低到高遍历：<ol><li> <code>virtual address &lt; freemem</code>：令<code>pp_ref = 1</code></li><li> <code>else</code>：令<code>pp_ref = 0</code>、使用<code>LIST_INSERT_HEAD()</code>宏插入<code>free_page_list</code>中</li></ol></li></ol><p>将任务具体化后，发现实际上前两步的实现相对简单，使用了头文件定义好的宏，或是复现之前出现过的操作，就不多展开了。重点在最后一步的遍历<code>Page *pages</code>上：</p><p>首先，循环可以使用<code>pages++</code>方法（<code>+</code>运算符重载），同样也可以使用<code>pages[i], i++</code>的做法，这样都能表示单次大小为<code>page</code>的地址位移</p><p>其次，直观地想要实现<code>virtual address &lt; freemem</code>的比较，需要获取到每一页的虚拟地址，实际上<code>pmap.h</code>提供了<code>page2kva</code>这个返回虚拟地址的宏</p><p>当然在这里也可以换个思路，不去转换<code>PPN</code>和<code>pages</code>，而把<code>freemem</code>这个虚拟地址转化为页表项相关的值，也就是找到<code>freemem</code>对应的<code>PPN</code>号：<code>PPN(KADDR(freemem))</code>，然后进行循环边界的判断即可</p><p>具体实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Initialize page_free_list. */</span></span><br><span class="line">  <span class="comment">/* Hint: Use macro `LIST_INIT` defined in include/queue.h. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (1/4) */</span></span><br><span class="line">  LIST_INIT(&amp;page_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: Align `freemem` up to multiple of BY2PG. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (2/4) */</span></span><br><span class="line">  freemem = ROUND(freemem, BY2PG);</span><br><span class="line">  <span class="comment">/* Step 3: Mark all memory below `freemem` as used (set `pp_ref` to 1) */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (3/4) */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> pages;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> freePPN = PPN(PADDR(freemem));</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freePPN; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 4: Mark the other memory as free. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.3: Your code here. (4/4) */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; npage; i++) &#123;</span><br><span class="line">    pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;page_free_list, (pages + i), pp_link);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-alloc-Exercise-2-4"><a href="#page-alloc-Exercise-2-4" class="headerlink" title="page_alloc - Exercise 2.4"></a><code>page_alloc</code> - Exercise 2.4</h4><ul><li>  如果能顺利完成并理解前面练习的话，这个也理应算是个水题了（</li></ul><p>任务要求为完成<code>page_alloc()</code>函数，这个函数取代了最初的<code>alloc()</code>函数，成为页式内存管理中申请内存时调用的函数</p><ol><li> 如果空闲链表没有可用页了，返回异常返回值。</li><li> 如果空闲链表有可用的页，取出第一页；初始化后，将该页对应的<strong>页控制块的地址</strong>放到调用者指定的地方。</li><li> 可能需要使用链表宏<code>LIST_EMPTY</code>或函数<code>page2kva</code></li><li> 实际上Use <code>LIST_FIRST</code> and <code>LIST_REMOVE</code>也在函数前面的注释里当作HINT了（</li><li> 顺带提一嘴，异常返回值也在那个注释写了，叫<code>-E_NO_MEM</code></li></ol><p>这个也就做一下空链表判断返回值，再取出<strong>第一页</strong>并清空即可，<strong>不要忘记清空的区域大小是多少</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_alloc</span><span class="params">(<span class="keyword">struct</span> Page **new)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: Get a page from free memory. If fails, return the error code.*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;page_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">  &#125;</span><br><span class="line">  pp = LIST_FIRST(&amp;page_free_list);</span><br><span class="line">  LIST_REMOVE(pp, pp_link);</span><br><span class="line">  <span class="comment">/* Step 2: Initialize this page with zero.</span></span><br><span class="line"><span class="comment">   * Hint: use `memset`. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.4: Your code here. (2/2) */</span></span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *)page2kva(pp), <span class="number">0</span>, BY2PG);</span><br><span class="line">  *new = pp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-decref"><a href="#page-decref" class="headerlink" title="page_decref()"></a><code>page_decref()</code></h4><ul><li>  函数作用是通过页控制块改变页框的引用次数，若出现空闲页则调用回收函数<code>page_free()</code>回收内存</li></ul><h4 id="page-free-Exercise-2-5"><a href="#page-free-Exercise-2-5" class="headerlink" title="page_free() - Exercise 2.5"></a><code>page_free()</code> - Exercise 2.5</h4><ul><li>  非常好水题，多来点（</li><li>  任务要求为完成<code>page_free()</code>函数，该函数回收空闲页面（判定方式为<code>pp_ref == 0</code>），插入<code>page_free_list</code>中</li><li>  提示：使用链表宏<code>LIST_INSERT_HEAD</code>，将页结构体插入空闲页结构体链表</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_free</span><span class="params">(<span class="keyword">struct</span> Page *pp)</span> &#123;</span><br><span class="line">  assert(pp-&gt;pp_ref == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Just insert it into &#x27;page_free_list&#x27;. */</span></span><br><span class="line">  <span class="comment">/* Exercise 2.5: Your code here. */</span></span><br><span class="line">  LIST_INSERT_HEAD(&amp;page_free_list, pp, pp_link);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Exercise 2.1-2.5顺利结束，<strong>物理内存管理</strong>模块练习完成</p><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><p>在开始后续练习前，我们先了解一下实验环境中的虚拟地址分配：</p><h4 id="虚拟内存结构"><a href="#虚拟内存结构" class="headerlink" title="虚拟内存结构"></a>虚拟内存结构</h4><ul><li>32位虚拟内存：<code>PDX(va)PTX(va)offset (10 + 10 + 12)</code></li><li>页表项结构：<ul><li>  一级页表项<code>Pde = u_long = 物理页号权限位</code></li><li>  二级页表项<code>Pte = u_long = 物理页号权限位</code></li><li>  权限位与<code>EntryLo</code>寄存器的标志位排布一致：<code>NDVG0[7:0]</code>，具体内容我们放到后面的<code>TLB</code>部分再详细说</li></ul></li><li>二级页表系统的作用：<strong>虚拟地址\to物理地址</strong></li><li>一/二级页表偏移量（<code>PDX(va)/PTX(va)</code>）：从一/二级页表基地址出发，移动n个单位到达</li><li>一级页表<strong>项</strong>包含的<strong>页号</strong>是其对应的二级页表<strong>页</strong>的<strong>物理页号</strong></li></ul><blockquote><p>访问虚拟地址时，先通过一级页表基地址和一级页表项的偏移量，找到对应的一级页表项，得到对应的二级页表的物理页号，再根据二级页表项的偏移量找到所需的二级页表项，进而得到该虚拟地址对应的物理页号</p></blockquote><ul><li>  这个过程中需要将二级页表的物理页转换为物理地址，再转换为虚拟地址返回：<code>pgdir -&gt; PTE_ADDR(pgdir) -&gt; KADDR(PTE_ADDR(pgdir))</code>，<code>Pde* pgdir</code>是偏移后得到的一级页表项</li></ul><h4 id="一些小tips"><a href="#一些小tips" class="headerlink" title="一些小tips"></a>一些小tips</h4><ul><li><code>kseg0/kseg1</code>使用<code>PADDR/KADDR</code>进行物理/虚拟地址的转换，而<code>kuseg</code>使用<code>TLB</code>（实际上是页表项）进行转换</li><li>在创建页表时，可以使用<code>KADDR</code>进行转换（处于内核态 存疑 通过<code>kseg0</code>读取）</li><li><code>memset</code>等函数操控的都是虚拟内存，不能直接访问物理内存</li><li><strong>页表项与页控制块</strong><ul><li>  页控制块是内存管理最开始初始化的<code>pages</code>变量，它管理物理页面的属性（前驱后继、引用次数等）</li><li>  页表项是虚拟页管理中最小的映射单元，它管理虚拟页面映射相关的属性（有效与否等）</li><li>  页控制块\to页表项的高位值：<code>*pte = page2pa(pp)</code></li><li>  页表项\to页控制块：<code>pp = pa2page(*pte)</code></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/mmu.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2PG 4096<span class="comment">// 定义了页面字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDMAP (4 * 1024 * 1024)<span class="comment">// 定义了一个一级页表页能管理的字节数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGSHIFT 12<span class="comment">// 移动获得二级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDSHIFT 22<span class="comment">// 移动获得一级页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PDX(va) ((((u_long)(va)) &gt;&gt; 22) &amp; 0x03ff)<span class="comment">// 获取31-22位，一级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTX(va) ((((u_long)(va)) &gt;&gt; 12) &amp; 0x03ff)<span class="comment">// 获取21-12位，二级页表偏移量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ADDR(pte) ((u_long)(pte) &amp; ~0xfff)<span class="comment">// 获得对应的页表基址或者物理地址基址(低12位为0)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的物理页号</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VPN(va) ((u_long)(va) &gt;&gt; 12)<span class="comment">// 地址对应的虚拟页号</span></span></span><br></pre></td></tr></table></figure><h4 id="pgdir-walk-Exercise-2-6"><a href="#pgdir-walk-Exercise-2-6" class="headerlink" title="pgdir_walk() - Exercise 2.6"></a><code>pgdir_walk()</code> - Exercise 2.6</h4><ul><li>该函数的作用是：给定一个虚拟地址，在给定的页目录中查找这个虚拟地址对应的物理地址<ul><li>  如存在：返回页表项所在的<strong>虚拟</strong>地址</li><li>  如不存在：连对应页表项都不存在（PDX指向的<strong>页目录项</strong>为<strong>空或无效</strong>），则根据传入的参数进行创建二级页表，或返回空指针。</li></ul></li><li>注意，这里可能会在页目录表项无效且<code>create</code> 为真的情况，需要使用<code>page_alloc</code> 创建一个二级页表页，并应维护申请得到的物理页的<code>pp_ref</code> 字段</li></ul><p>（查物理地址）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pgdir_walk</span><span class="params">(Pde *pgdir, u_long va, <span class="type">int</span> create, Pte **ppte)</span> &#123;</span><br><span class="line">  Pde *pgdir_entryp;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (1/3) */</span></span><br><span class="line">  pgdir_entryp = pgdir + PDX(va);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (2/3) */</span></span><br><span class="line">  <span class="keyword">if</span> ((*pgdir_entryp &amp; PTE_V) == <span class="number">0</span>) &#123; <span class="comment">// not existent</span></span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">      <span class="keyword">if</span> (-E_NO_MEM == page_alloc(&amp;pp)) &#123;<span class="comment">// fail to collect a page to Page *pp</span></span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">      &#125;</span><br><span class="line">      pp-&gt;pp_ref++;</span><br><span class="line">      *pgdir_entryp = page2pa(pp)  PTE_V  PTE_D;<span class="comment">// set Physical address of pp to it, and init 页表项</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *ppte = <span class="literal">NULL</span>;<span class="comment">// no need to create a page</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Exercise 2.6: Your code here. (3/3) */</span></span><br><span class="line">  <span class="comment">// Pte *pte_location = (Pte *)(*pgdir_entryp &gt;&gt; 12 &lt;&lt; 12) + PTX(va);</span></span><br><span class="line">  <span class="comment">// physical</span></span><br><span class="line">  Pte *pte_location = (Pte *)(KADDR(PTE_ADDR(*pgdir_entryp))) +</span><br><span class="line">                      PTX(va); <span class="comment">// get pte virtual address</span></span><br><span class="line">  *ppte = (pte_location);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>(*pgdir_entryp &amp; PTE_V)</code>是为了获取把目标一级页表项的有效位（使用位运算）</p><p><code>(KADDR(PTE_ADDR(*pgdir_entryp)))</code>获取目标一级页表项的虚拟地址，后面的加法表示二级页表偏移量，获得的是二级页表项地址</p><h4 id="page-insert-Exercise-2-7"><a href="#page-insert-Exercise-2-7" class="headerlink" title="page_insert() - Exercise 2.7"></a><code>page_insert()</code> - Exercise 2.7</h4><ul><li>  该函数的作用是将一级页表基地址<code>pgdir</code>中虚拟地址<code>va</code>所在<strong>虚拟页面</strong>指向页控制块<code>pp</code>对应的<strong>物理页面</strong>，并将页表项权限为设置为<code>perm</code>。</li></ul><p>（改变页表指的页面）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">page_insert</span><span class="params">(Pde *pgdir, u_int asid, <span class="keyword">struct</span> Page *pp, u_long va,u_int perm)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Get corresponding page table entry. */</span></span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (pte &amp;&amp; (*pte &amp; PTE_V)) &#123;<span class="comment">// 页表项有效</span></span><br><span class="line">        <span class="keyword">if</span> (pa2page(*pte) != pp) &#123;<span class="comment">// 指向的物理页不同，删除页表项</span></span><br><span class="line">            page_remove(pgdir, asid, va);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tlb_invalidate(asid, va);<span class="comment">// 物理页相同，删除过时的 tlb 映射</span></span><br><span class="line">            *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 更新为 pp 所在物理页并置有效位</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Flush TLB with &#x27;tlb_invalidate&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (1/3) */</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 va 所在的 tlb 表项</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Re-get or create the page table entry. */</span></span><br><span class="line">    <span class="comment">/* If failed to create, return the error. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (2/3) */</span></span><br><span class="line">    <span class="type">int</span> temp = pgdir_walk(pgdir, va, <span class="number">1</span>, &amp;pte);</span><br><span class="line">    <span class="keyword">if</span> (-E_NO_MEM == temp) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Insert the page to the page table entry with &#x27;perm  PTE_V&#x27; and</span></span><br><span class="line"><span class="comment">     * increase its &#x27;pp_ref&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 2.7: Your code here. (3/3) */</span></span><br><span class="line">    *pte = page2pa(pp)  perm  PTE_V;<span class="comment">// 同上，更新为 pp 所在物理页并置有效位</span></span><br><span class="line">    pp-&gt;pp_ref++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  <code>pa2page(*pte)</code>：取得二级页表项具体值，并取高位（物理页号）转换为<code>page</code>类指针，这里就是取得虚拟地址指的物理页的<strong>page</strong>结构体</li><li>  <code>page2pa(pp)permPTE_V</code>：pp对应的物理地址基址（物理页号，低位为0），并增添<code>perm</code>与有效位</li></ul><h4 id="page-lookup"><a href="#page-lookup" class="headerlink" title="page_lookup()"></a><code>page_lookup()</code></h4><ul><li>  该函数的作用是返回虚拟地址<code>va</code>映射物理页的页控制块<code>Page</code>，并将<code>ppte</code>指向的空间设为<strong>二级页表项</strong>地址</li></ul><p>（查va对应的Page和Pte）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Page *<span class="title function_">page_lookup</span><span class="params">(Pde *pgdir, u_long va, Pte **ppte)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    Pte *pte;</span><br><span class="line">    </span><br><span class="line">    pgdir_walk(pgdir, va, <span class="number">0</span>, &amp;pte);<span class="comment">// 获取 va 对应的二级页表项</span></span><br><span class="line">    <span class="keyword">if</span> (!(pte &amp;&amp; (*pte &amp; PTE_V))) &#123;<span class="comment">// 页表项无效，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pp = pa2page(*pte);<span class="comment">// 由 *pte 取出对应物理页块</span></span><br><span class="line">    <span class="keyword">if</span> (ppte) &#123;</span><br><span class="line">        *ppte = pte;<span class="comment">// 写入二级页表项地址</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pp;<span class="comment">// 返回页控制块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="page-remove"><a href="#page-remove" class="headerlink" title="page_remove()"></a><code>page_remove()</code></h4><ul><li>  删除虚拟地址<code>va</code>在指定程序中所对应的<strong>物理页面</strong>映射</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">page_remove</span><span class="params">(Pde *pgdir, u_int asid, u_long va)</span> &#123;</span><br><span class="line">    Pte *pte;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    pp = pgdir(pgdir, va, &amp;pte);<span class="comment">// 查找对应的页控制块</span></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 没有映射，返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    page_decref(pp);<span class="comment">// 减少物理页引用次数</span></span><br><span class="line">    *pte = <span class="number">0</span>;<span class="comment">// 清楚原有页表映射</span></span><br><span class="line">    tlb_invalidate(asid, va);<span class="comment">// 无效化 tlb 中的页表映射</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="虚拟内存与-TLB"><a href="#虚拟内存与-TLB" class="headerlink" title="虚拟内存与 TLB"></a>虚拟内存与 TLB</h3><h4 id="CP0-寄存器-EntryHi、EntryLo、Index"><a href="#CP0-寄存器-EntryHi、EntryLo、Index" class="headerlink" title="CP0 寄存器 - EntryHi、EntryLo、Index"></a>CP0 寄存器 - EntryHi、EntryLo、Index</h4><ul><li>  CP0 寄存器 EntryHi 与 EntryLo 分别对应到 TLB 的 Key 与 Data ，是 TLB 映射信息的来源</li><li>  ASID 与<strong>虚拟页号</strong>位于 EntryHi 中</li><li>  有效位、可写位等标记位与<strong>物理页号</strong>在 EntryLo 中</li><li>  <code>Index</code>寄存器中存放访问的 TLB 的标号</li><li>  TLB 相当于一小段常用的<strong>直接映射页表</strong>，使用虚拟页号 + ASID 直接得到物理页号及相关信息</li></ul><p>软件通过使用 CP0 寄存器和下面的汇编指令，把两个寄存器中分别存放的页号形成映射，存入 TLB 内部</p><h4 id="TLB-相关汇编指令"><a href="#TLB-相关汇编指令" class="headerlink" title="TLB 相关汇编指令"></a>TLB 相关汇编指令</h4><p><code>tlbr</code>：将<code>Index</code>的值作为索引，将当前索引指向的 TLB 表项<strong>读出</strong>至 CP0 寄存器</p><p><code>tibwi</code>：将 CP0 寄存器的值回写入 TLB 索引的表项内</p><p><code>tlbwr</code>：<strong>randomly</strong> 写入 TLB 表项内</p><p><code>tlbp</code>：根据 EntryHi 查询 TLB 内的表项，并将查找到的索引存入 Index 内（若不存在则将 Index 最高位置为1）</p><h4 id="TLB-维护与更新"><a href="#TLB-维护与更新" class="headerlink" title="TLB 维护与更新"></a>TLB 维护与更新</h4><ol><li> 更新页表中虚拟地址对应的页表项的同时，将 TLB 中对应的<strong>旧表项无效化</strong></li><li> 在下一次访问该虚拟地址时触发 <strong>TLB 重填异常</strong>，对 TLB 进行重填</li></ol><h4 id="tlb-invalidate-Exercise-2-8"><a href="#tlb-invalidate-Exercise-2-8" class="headerlink" title="tlb_invalidate() - Exercise 2.8"></a><code>tlb_invalidate()</code> - Exercise 2.8</h4><p>填空上毫无难度，汇编函数相关过程需要进行一些思考，详细可以参考 Thinking 2.5内容</p><h4 id="do-tlb-refill-Exercise-2-9-2-10"><a href="#do-tlb-refill-Exercise-2-9-2-10" class="headerlink" title="do_tlb_refill() - Exercise 2.9 ~ 2.10"></a><code>do_tlb_refill()</code> - Exercise 2.9 ~ 2.10</h4><p>2.10类似于2.8，填空无难度，2.9的<code>do_tlb_refill</code>函数机制如下：</p><ol><li> 进入函数，取出<code>TLB</code>缺失的<strong>虚拟地址</strong>（<code>BADVADDR</code>）和当前进程的<code>asid</code>（<code>EntryHi[11:6]</code>）</li><li> 调用C语言函数 Exercise 2.10 的<code>_do_tlb_refill()</code>（<code>jal _do_tlb_refill</code>），获取虚拟地址对应的<strong>页表项</strong>（<code>Pte *</code>）</li><li> 填空指令<code>tlbwr</code>随机地把保存在<code>EntryHi</code>和<code>EntryLo</code>中的信息写入一条<code>TLB</code>中</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Pte _do_tlb_refill(u_long va, u_int asid) &#123;</span><br><span class="line">  Pte *pte;</span><br><span class="line">  <span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment">   *  Invoke &#x27;page_lookup&#x27; repeatedly in a loop to find the page table entry</span></span><br><span class="line"><span class="comment">   * &#x27;pte&#x27; associated with the virtual address &#x27;va&#x27; in the current address space</span></span><br><span class="line"><span class="comment">   * &#x27;cur_pgdir&#x27;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  **While** &#x27;page_lookup&#x27; returns &#x27;NULL&#x27;, indicating that the &#x27;pte&#x27; could</span></span><br><span class="line"><span class="comment">   * not be found, allocate a new page using &#x27;passive_alloc&#x27; until &#x27;page_lookup&#x27;</span></span><br><span class="line"><span class="comment">   * succeeds.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Exercise 2.9: Your code here. */</span></span><br><span class="line">  <span class="comment">// Page *pp = page_lookup(cur_pgdir, va, &amp;pte);</span></span><br><span class="line">  <span class="keyword">while</span> (page_lookup(cur_pgdir, va, &amp;pte) == <span class="literal">NULL</span>) &#123;<span class="comment">// 查询 va 的页表项和物理页</span></span><br><span class="line">    passive_alloc(va, cur_pgdir, asid);<span class="comment">// 调用被动分配函数分配物理页</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *pte;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">passive_alloc</span><span class="params">(u_int va, Pde *pgdir, u_int asid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &lt; UTEMP) &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG) = 4 * 1024 * 1024 - 2 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;address too low&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= USTACKTOP &amp;&amp; va &lt; USTACKTOP + BY2PG) &#123;</span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG) = 0x80000000 - 5 * 4 * 1024 * 1024</span></span><br><span class="line">        panic(<span class="string">&quot;invalid memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UENVS &amp;&amp; va &lt; UPAGES) &#123;</span><br><span class="line">        panic(<span class="string">&quot;envs zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= UPAGES &amp;&amp; va &lt; UVPT) &#123;</span><br><span class="line">        panic(<span class="string">&quot;pages zone&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (va &gt;= ULIM) &#123;</span><br><span class="line">        panic(<span class="string">&quot;kernel address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    panic_on(page_alloc(&amp;p));</span><br><span class="line">    panic_on(page_insert(pgdir, asid, p, PTE_ADDR(va), PTE_D));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERNBASE 0x80010000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KSTACKTOP (ULIM + PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ULIM 0x80000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVPT (ULIM - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPAGES (UVPT - PDMAP)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UENVS (UPAGES - PDMAP)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTOP UENVS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UXSTACKTOP UTOP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USTACKTOP (UTOP - 2 * BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEXT PDMAP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UCOW (UTEXT - BY2PG)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTEMP (UCOW - BY2PG)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="SLIST宏代码"><a href="#SLIST宏代码" class="headerlink" title="SLIST宏代码"></a><code>SLIST</code>宏代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List definitions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">#defineSLIST_HEAD(name, type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">slh_first</span>;</span><span class="comment">/* first element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_HEAD_INITIALIZER(head)\</span><br><span class="line">&#123; <span class="literal">NULL</span> &#125;</span><br><span class="line"></span><br><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">#defineSLIST_INIT(head) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = <span class="literal">NULL</span>;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (slistelm)-&gt;field.sle_next;\</span><br><span class="line">(slistelm)-&gt;field.sle_next = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(elm)-&gt;field.sle_next = (head)-&gt;slh_first;\</span><br><span class="line">(head)-&gt;slh_first = (elm);\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line">(head)-&gt;slh_first = (head)-&gt;slh_first-&gt;field.sle_next;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="keyword">if</span> ((head)-&gt;slh_first == (elm)) &#123;\</span><br><span class="line">SLIST_REMOVE_HEAD((head), field);\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">else</span> &#123;\</span><br><span class="line"><span class="keyword">struct</span> type *curelm = (head)-&gt;slh_first;\</span><br><span class="line"><span class="keyword">while</span>(curelm-&gt;field.sle_next != (elm))\</span><br><span class="line">curelm = curelm-&gt;field.sle_next;\</span><br><span class="line">curelm-&gt;field.sle_next =\</span><br><span class="line">    curelm-&gt;field.sle_next-&gt;field.sle_next;\</span><br><span class="line">&#125;\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="comment">/*CONSTCOND*/</span><span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">#defineSLIST_FOREACH(var, head, field)\</span><br><span class="line"><span class="keyword">for</span>((var) = (head)-&gt;slh_first; (var); (var) = (var)-&gt;field.sle_next)</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Singly-linked List access methods.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_EMPTY(head)((head)-&gt;slh_first == <span class="literal">NULL</span>)</span><br><span class="line">#defineSLIST_FIRST(head)((head)-&gt;slh_first)</span><br><span class="line">#defineSLIST_NEXT(elm, field)((elm)-&gt;field.sle_next)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
          <category> MOS Probe </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab2-Report</title>
      <link href="/p/50884.html"/>
      <url>/p/50884.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab2-Report"><a href="#BUAA-OS-2023-Lab2-Report" class="headerlink" title="BUAA-OS-2023-Lab2-Report"></a>BUAA-OS-2023-Lab2-Report</h1><h1 id="Thinking-2-1"><a href="#Thinking-2-1" class="headerlink" title="Thinking 2.1"></a>Thinking 2.1</h1><blockquote><p>虚拟地址在系统中的使用</p></blockquote><p>根据指导书说明：</p><blockquote><p>而在实际程序中，访存、跳转等<strong>指令</strong>以及用于取指的<strong>PC寄存器</strong>中的访存地址都是<strong>虚拟地址</strong>。 我们编写的C程序中也经常通过对指针解引用来进行访存，其中<strong>指针的值</strong>也会被视为<strong>虚拟地址</strong>，经过编译后生成相应的访存指令。</p></blockquote><p>故在编写的C程序中指针存储的地址和汇编程序中<code>lw</code>和<code>sw</code>使用的值都是<strong>虚拟地址</strong>。</p><h1 id="Thinking-2-2"><a href="#Thinking-2-2" class="headerlink" title="Thinking 2.2"></a>Thinking 2.2</h1><blockquote><p>链表宏与对应的链表结构</p></blockquote><ul><li>  从可重用性的角度，阐述用宏来实现链表的好处。</li></ul><p>使用宏进行链表实现，一方面能够规范系统内所有链表的存在形式，达成结构上的统一，易于编码与链表维护； 链表宏中大部分传入的参数并不是链表项整体，而是不包含链表具体存放信息的一个<strong>结构体</strong>，这个结构体只负责管理链表指针。 我们利用宏对这个结构体进行处理，一方面统一链表操作，不限制可以使用链表的结构类型；另一方面能够降低链表指针与链表内容间不必要的耦合性，维护数据安全；使用预设结构还能保证链表结构的正确性。 查阅资料后得知，除了重用性角度外，使用宏定义还意味着放置在<code>queue.h</code>内的所有宏都是完整的，不需要编译为<strong>库文件</strong></p><ul><li>  分析<strong>单向链表</strong>、<strong>循环链表</strong>和实验中使用的<strong>双向链表</strong>在插入与删除操作上的性能差异。</li></ul><blockquote><p>头文件<code>queue.h</code>为C语言中的链表提供了更加标准规范的编程接口。如今的版本多为伯克利加州大学1994年8月的8.5版本。 每种结构都支持基本的操作：</p><ol><li> 在链表头插入节点</li><li> 在任意的节点后插入节点</li><li> 移除链表头后的节点</li><li> 前向迭代遍历链表</li></ol></blockquote><p>我们打开对应的文件<code>/usr/include/sys/queue.h</code>，可以发现其中不仅仅包含了我们使用的双向链表<code>LIST</code>、待分析的单向链表<code>SLIST</code>和循环链表<code>CIRCLEQ</code>，还有两个有尾链表结构<code>TAILQ</code>和<code>SIMPLEQ</code>（双向有尾/单向有尾），这5个数据结构共同构成了<code>LINUX</code>的链表宏定义（为节省空间，下文只拿出所需的定义进行解释，其他定义便不再详述<strong>，完整定义会贴在全文最后</strong>）</p><ol><li> 单向链表<code>SLIST</code>：</li></ol><p>单向链表（<code>Singly-linked List</code>）在结构上较为简单，链表项只包含一个指向下一个元素的指针 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260156076.png" alt="单向链表">  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#defineSLIST_ENTRY(type)\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span> *<span class="title">sle_next</span>;</span><span class="comment">/* next element */</span>\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入操作：<ul><li>  链表中插入（已知前驱元素指针）需要修改被插入项<code>slistelm</code>和自身<code>elm</code>的指针，即需要两条指令；</li><li>  插入第一个元素需要修改自身<code>elm</code>的指针指向原有的第一项，同时还需要修改<strong>链表头项</strong>的<code>slh_first</code>指向自身，也需要两条指令</li></ul></li><li>删除操作：<ul><li>  链表中删除（无前驱元素指针）需要判断是否前驱元素为链表第一个元素，是则归入第二类，不是则需要从头部开始遍历得到前驱元素，并修改前驱指针指向自身的后继元素，需要2n+2条指令</li><li>  删除第一个元素只需要修改链表头指向的链表项即可，即一条指令</li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#defineSLIST_INSERT_AFTER(slistelm, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_INSERT_HEAD(head, elm, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行2条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE_HEAD(head, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1条语句</span></span><br><span class="line">    </span><br><span class="line">#defineSLIST_REMOVE(head, elm, type, field) <span class="keyword">do</span> &#123;\</span><br><span class="line"><span class="comment">// 执行1或2n+2条语句</span></span><br></pre></td></tr></table></figure><ol start="2"><li> 循环链表<code>CIRCLEQ</code>：</li></ol><p><code>LINUX</code>宏定义下的循环链表只存在双向循环链表<code>CIRCLEQ</code>一种，它是<code>Circular queue</code>的简写 <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303260200417.png" alt="循环链表"> 由于循环链表有头有尾，故链表头项包含两个指针：<code>cqe_first</code>和<code>cqe_last</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_HEAD(name, type)                                            \</span></span><br><span class="line"><span class="meta">struct name &#123;                                                               \</span></span><br><span class="line"><span class="meta">    struct type *cqh_first;     <span class="comment">/* first element */</span>                         \</span></span><br><span class="line"><span class="meta">    struct type *cqh_last;      <span class="comment">/* last element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时每个链表项与双向无尾链表<code>LIST</code>结构稍有不同，它有两个指向链表项的指针:<code>cqe_next</code>和<code>cqe_prev</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_ENTRY(type)                                                 \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *cqe_next;      <span class="comment">/* next element */</span>                          \</span></span><br><span class="line"><span class="meta">    struct type *cqe_prev;      <span class="comment">/* previous element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>由于可以提供双向+头尾指针，所以循环链表可以有多种插入方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do &#123;                \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do &#123;               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_HEAD(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_INSERT_TAIL(head, elm, field) do &#123;                          \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CIRCLEQ_REMOVE(head, elm, field) do &#123;                               \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句，但需要进行额外的两次if分支判断</span></span></span><br></pre></td></tr></table></figure><p>在进行插入操作时，需要考虑到是否仅含一个元素的情况，这时需要对链表头项进行修改，与其他情况稍有不同（以INSERT_HEAD为例）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((head)-&gt;cqh_last == (<span class="type">void</span> *)(head))                              \</span><br><span class="line">        (head)-&gt;cqh_last = (elm);                                           \</span><br><span class="line">    <span class="keyword">else</span>                                                                    \</span><br><span class="line">        (head)-&gt;cqh_first-&gt;field.cqe_prev = (elm);                          \</span><br><span class="line">    (head)-&gt;cqh_first = (elm);  </span><br></pre></td></tr></table></figure><ol start="3"><li> 双向链表<code>LIST</code>：</li></ol><p>然后就是我们在实验中使用到的双向链表<code>LIST</code>，它与其他内置链表宏的最大区别就是链表项：<code>LIST</code>含有一个指针和一个<strong>二重指针</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(type)                                                    \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct type *le_next;   <span class="comment">/* next element */</span>                              \</span></span><br><span class="line"><span class="meta">    struct type **le_prev;  <span class="comment">/* address of previous next element */</span>          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>也因为其能够进行双向操作，插入的方法也有多种</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_AFTER(listelm, elm, field) do &#123;                         \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_BEFORE(listelm, elm, field) do &#123;                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_INSERT_HEAD(head, elm, field) do &#123;                             \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行4条语句</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_REMOVE(elm, field) do &#123;                                        \</span></span><br><span class="line"><span class="meta"><span class="comment">// 执行2条语句</span></span></span><br></pre></td></tr></table></figure><p>这里需要注意执行向后插入的<code>INSERT_AFTER</code>和<code>INSERT_HEAD</code>都需要判断是否为最后一个元素，决定是否需要调整后继元素的<code>le_prev</code>指针 分析后可以看出，</p><ul><li>  单项链表<code>SLIST</code>执行插入的效率最高，但是删除时需要进行遍历操作以防止后续链表元素丢失，性能较差；</li><li>  循环链表<code>CIRCLEQ</code>执行插入的效率稍低于单项链表，删除效率要高于单向链表，但需要进行分支判断，也为常数级</li><li>  双向链表<code>LIST</code>插入效率与循环链表类似，删除效率略高于循环链表</li></ul><h1 id="Thinking-2-3"><a href="#Thinking-2-3" class="headerlink" title="Thinking 2.3"></a>Thinking 2.3</h1><p>查看<code>pmap.h</code>得知<code>Page_list</code>结构调用了<code>LIST_HEAD()</code>宏定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIST_HEAD(Page_list, Page);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_HEAD(Page_list, Page)                                               \</span></span><br><span class="line"><span class="meta">struct Page_list &#123;                                                             \</span></span><br><span class="line"><span class="meta">struct Page *lh_first; <span class="comment">/* first element */</span>                          \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>同时还定义了<code>Page</code>结构体和<code>Page_LIST_entry_t</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">Page_LIST_entry_t pp_link; <span class="comment">/* free list link */</span></span><br><span class="line">u_short pp_ref;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LIST_ENTRY</span><span class="params">(Page)</span> Page_LIST_entry_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换后结构如下</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_ENTRY(Page)                                                                   \</span></span><br><span class="line"><span class="meta">struct &#123;                                                                               \</span></span><br><span class="line"><span class="meta">struct Page *le_next;  <span class="comment">/* next element */</span>                                          \</span></span><br><span class="line"><span class="meta">struct Page **le_prev; <span class="comment">/* address of previous next element */</span>                      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>于是可以得出完整结构：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">// Page_LIST_entry_t</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">le_next</span>;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> **<span class="title">le_prev</span>;</span></span><br><span class="line">        &#125; pp_link;</span><br><span class="line">        </span><br><span class="line">        u_short pp_ref;</span><br><span class="line">    &#125;* lh_first</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>故选择C选项  </p><h1 id="Thinking-2-4"><a href="#Thinking-2-4" class="headerlink" title="Thinking 2.4"></a>Thinking 2.4</h1><ul><li>  请阅读上面有关R3000-TLB 的描述，从虚拟内存的实现角度，阐述ASID 的必要性。</li></ul><blockquote><p>ASID，Address Space IDentifier 用于区分不同的地址空间，同一虚拟地址通常在不同的地址空间中映射到不同的物理地址。</p></blockquote><p>也就是说，ASID用来标记当前虚拟地址所归属的程序号，如果访问的是其他程序的虚拟地址，通常会指向一个错误的物理地址。因此需要确保访问的请求来自特定的程序，于是采用了ASID作为保险，确定虚拟地址请求的来源。</p><ul><li>  请阅读《IDT R30xx Family Software Reference Manual》的Chapter 6，结合ASID段的位数，说明R3000 中可容纳不同的地址空间的最大数量。</li></ul><p>ASID段占用的数据位为[11, 6]，共6位，则意味着R3000中可容纳不同的地址空间的最大数量为64。</p><h1 id="Thinking-2-5"><a href="#Thinking-2-5" class="headerlink" title="Thinking 2.5"></a>Thinking 2.5</h1><ul><li>  tlb_invalidate 和tlb_out 的调用关系？</li></ul><p>打开<code>kern/pmap.c</code>文件并找到<code>tlb_invalidate</code>函数定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tlb_invalidate</span><span class="params">(u_int asid, u_long va)</span> &#123;</span><br><span class="line">    tlb_out(PTR_ADDR(va)  (asid &lt;&lt; <span class="number">6</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>易知C语言函数<code>tlb_invalidate</code>调用了汇编函数<code>tlb_out</code></p><ul><li>  请用一句话概括tlb_invalidate 的作用。</li></ul><p>删除在序号为<code>ASID</code>的程序规划的虚拟空间中，虚拟地址<code>va</code>所在页在<code>TLB</code>中的页表项</p><ul><li>  逐行解释tlb_out 中的汇编代码。</li></ul><p><code>tlb_out</code>代码如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(tlb_out)</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mfc0 t0, CP0_ENTRYHI# 从CP0_ENTRYHI寄存器取值至$t0</span><br><span class="line">mtc0 a0, CP0_ENTRYHI# 将$a0的值存入CP0_ENTRYHI中</span><br><span class="line">nop</span><br><span class="line">tlbp# 查找 TLB 表项，将索引存入 Index 寄存器</span><br><span class="line">nop</span><br><span class="line">mfc0 t1, CP0_INDEX# 将索引取值至$t1寄存器</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line">bltz t1, NO_SUCH_ENTRY# 索引空，准备退出</span><br><span class="line">.set noreorder# 禁止代码优化</span><br><span class="line">mtc0 zero, CP0_ENTRYHI# 清空ENTRYHI和ENTRYLO</span><br><span class="line">mtc0 zero, CP0_ENTRYLO0</span><br><span class="line">nop</span><br><span class="line">tlbwi# 清空 Index 对应的 TLB 项</span><br><span class="line">.set reorder# 优化代码</span><br><span class="line"></span><br><span class="line">NO_SUCH_ENTRY:</span><br><span class="line">mtc0 t0, CP0_ENTRYHI# 把ENTRYHI的值回存</span><br><span class="line">j ra</span><br><span class="line">END(tlb_out)# 结束 tlb_out 函数</span><br></pre></td></tr></table></figure><p> </p><h1 id="Thinking-2-6"><a href="#Thinking-2-6" class="headerlink" title="Thinking 2.6"></a>Thinking 2.6</h1><ul><li>  简单了解并叙述X86 体系结构中的内存管理机制，比较X86 和MIPS 在内存管理上的区别。</li></ul><p>在x86架构中内存被分为三种形式，分别是<strong>逻辑地址</strong>（Logical Address），<strong>线性地址</strong>（Linear Address）和<strong>物理地址</strong>（Physical Address）。其中分段可以将逻辑地址转换为线性地址，而分页可以将线性地址转换为物理地址。 并且x86允许存在不分页的情况，但不允许程序不分段 <strong>MIPS 与 X86 的 TLB 差别</strong> 其在于对 TLB 不命中时的处理上： MIPS 会触发TLB Refill 异常，内核的 tlb_refill_handler 会以 pgd_current 为当前进程的 PGD 基址，索引获得转换失败的虚址对应的 PTE，并将其填入 TLB，完了CPU 把刚刚转换失败的虚地址再走一下 TLB 就OK了。 而 X86 在 TLB 不命中时，是由硬件 MMU 以 CR3 为当前进程的 PGD 基址，索引获得 PFN 后，直接输出 PA。同时 MMU 会填充 TLB 以加快下次转换的速度。 </p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Exam</title>
      <link href="/p/44391.html"/>
      <url>/p/44391.html</url>
      
        <content type="html"><![CDATA[<h1 id="lab1-Exam"><a href="#lab1-Exam" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h1><blockquote><p>课下一时爽，课上<code>debug</code>火葬场</p></blockquote><h2 id="课下出锅力！"><a href="#课下出锅力！" class="headerlink" title="课下出锅力！"></a>课下出锅力！</h2><p>问题出在<code>%ld/%d</code>时负数的判定上（也就是判定<code>neg_flag</code>上）:我的判定方法是，<code>if (num &lt; 0)</code>则<code>neg_flag = 1; num = -num;</code>，这样对<code>ld</code>来说还说得过去，但是对于<code>int</code>类型就出问题了，<code>long</code>类型的<code>num</code>变量装了一个<code>int</code>的值，然后取相反数的时候却按着<code>long</code>类型跑的，然后补码尊贵的符号位就登场搞事情了（寄），还好课上一个多小时修出来了，要不然计组<code>P7</code>历史重演力！</p><h2 id="lab1-Exam-1"><a href="#lab1-Exam-1" class="headerlink" title="lab1-Exam"></a>lab1-Exam</h2><blockquote><p>题目要求：修改我们课下编写的<code>vprintfmt</code>函数，使其能够支持新格式符（<code>format specifiers</code>） range ：<code>R</code>，同时要求格式符<code>R</code>也能使用与其他格式符同等的副格式符：即<code>&lt;flag&gt;</code>、<code>&lt;width&gt;</code>、<code>&lt;length&gt;</code>三个副格式符。 格式符<code>Range</code>的作用为：使用函数中接下来的两个<strong>整数参数</strong><code>a, b</code>，输出<code>(&lt;a&gt;,&lt;b&gt;)</code>字符串。这两个参数共用一组副格式符，受到的修饰相同。</p></blockquote><ul><li>  样例：对于下面的函数<code>range_1_check</code>，应该有其之后的输出：</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">range_1_check</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    printk(<span class="string">&quot;%s%R%s&quot;</span>, <span class="string">&quot;This is a testcase: &quot;</span>, <span class="number">2023</span>, <span class="number">2023</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;the range is %R, size = %d\n&quot;</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//This is a testcase: (2023,2023)</span></span><br><span class="line"><span class="comment">//the range is (1,9), size = 8</span></span><br></pre></td></tr></table></figure><ul><li>  解题流程：仔细看下来其实就是要在<code>vprintfmt()</code>函数里增加一种格式符的判断：<code>case &#39;R&#39;:</code>，作用是输出三个字符和两个整数（<code>%c%d%c%d%c</code>，当然这个<code>%d</code>是可能有副格式符的）；只需要判断一下输出的整数是<code>int</code>还是<code>long</code>就解决了，（然后课下出锅寄了一个多小时）</li><li>  BUG与坑点：课下对了就是对了，剩下的都可以抄<code>%c</code>和<code>%d</code>那里的</li></ul><h2 id="lab1-Extra"><a href="#lab1-Extra" class="headerlink" title="lab1-Extra"></a>lab1-Extra</h2><blockquote><p>题目要求：实现一个类似<code>fprintf</code>的函数<code>int sprintf(char *buf, const char *fmt, ...);</code>，将<code>fmt</code>字符串格式化输出到<code>buf</code>所在的内存空间中，且返回值应是<code>buf</code>中存放字符串的长度。 <strong>提示</strong>：可以调用<code>vprintfmt</code>函数进行协助输出</p></blockquote><ul><li>  样例：就不写了，可以拿个<code>fprintf</code>逝逝，效果一样的</li><li>这个考题完美回答了对于<code>vprintfmt</code>函数中不起作用的<code>void *data</code>形参和看起来有点复杂的函数形参<code>fmt_callback_t out</code>的问题：<ul><li>  函数中的<code>data</code>可以承载输出的目的地指针，在<code>printk</code>中我们输出至控制台，所以<code>data</code>的取值并不重要（最终以调用了<code>printcharc</code>函数作为具体输出）；但在这里实现的<code>sprintf</code>函数含有一个<strong>目的地</strong><code>buf</code>，所以我们需要把<code>buf</code>传入，负责接收所有需要输出的字符（写入<code>buf</code>指向的内存）</li><li>  函数中的<code>out</code>被称为回调函数参数，不过这个概念在这里并不重要，我们在解完题之后再来回顾。</li></ul></li><li>解题流程：实现思路与<code>printk</code>类似，顶层和中间层的调用都相同，不同的是最底层的输出方式：<ul><li>  <code>printk</code>使用<code>printcharc</code>写入控制台</li><li>  <code>sprintf</code>需要写入<code>buf</code>指向的内存</li><li>  （这是不是刚说过一遍）所以顶层函数照抄，我们重点实现这个替代原有<code>outputk</code>的新函数<code>outputbuf</code>（忘了啥是<code>outputk</code>的快回去看<code>lab1</code>讲解那篇文！）</li></ul></li><li>  <code>outputbuf</code>的实现：<code>void outputbuf(void *data, const char *buf, size_t len);</code></li></ul><p>如果能把<code>vprintfmt</code>整明白也挺容易看的，本函数应输出的字符串序列已经被安放在<code>buf</code>内，需要输出的长度为<code>len</code>，目的地为<code>data</code>；需要做的就是一个循环把字符搬运过去（记得末尾加一个<code>\0</code>） 这里的<code>\0</code>不需要考虑是否会导致下次再调用时没法接上，先取一下当前<code>data</code>的<code>strlen</code>，再从下一位（实际上是上一次写进去的<code>\0</code>）开始继续拼就可以了，最后又会是一个<code>\0</code>结束 附一种可能可行的实现方法：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *temp = (<span class="type">char</span> *)data + <span class="built_in">strlen</span>(data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        *temp = buf[i];</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    *temp = <span class="string">&#x27;\0;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我课上的实现方法严格意义上不符合要求，因为传入的参数形式不同，但是给了警告也能照样跑（</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">outputbuf</span><span class="params">(<span class="type">void</span> **data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    **(<span class="type">char</span> **)data = buf[i];</span><br><span class="line">    (*data) = (*data) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    **(<span class="type">char</span> **)data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主要不同体现在没有充当临时变量的char *temp，全程都是void **data取一层值后*data这个char *的自由移动，效果类似，不使用strlen也许效率会高一点？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于outputbuf传参不同，所以这里给vprintfmt传参也需要发生改变，所以说这样的做法不太合适，相当于改变了函数结构</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *buf, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">  <span class="type">char</span> *place = buf;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line">  vprintfmt(outputbuf, &amp;buf, fmt, ap);</span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)(buf - place - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>好了，课上的部分大概就是这些了，现在我们回来谈谈这个回调函数<code>fmt_callback_t</code>到底是个买</p><blockquote><p>回调函数，是一个通过<strong>函数指针</strong>调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，并且被传参的函数<strong>使用了这个函数指针</strong>，我们就认为这是一个回调函数。 回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另一方（被传参函数）调用的，用于对某事件或条件进行响应。</p></blockquote><p>说白了，回调函数就是一个只能被他人调用的函数，而回调函数参数就是某个函数中已经<strong>固定好返回值、自身形参</strong>的参数（类型是函数指针） 那我们还拿<code>vprintfmt</code>举例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里<code>fmt_callback_t out</code>，就是一个回调参数，实际类型是一个函数指针，接收者<code>vprintfmt</code>在自身内部对<code>out</code>函数进行调用，用于处理某些事件（这个例子中就是输出处理好的字符串），这样的处理虽然看起来有些繁琐，但是实际上给了<code>vprintfmt</code>函数非常强的<strong>可拓展性</strong>，输出函数的接口化，意味着它可以通过传入不同的输出函数，完成更复杂情况下、更多种类的输出任务（就比如<code>lab1-extra</code>这个输出到内存）。 如果只考虑输出控制台，实际上完全可以不传入<code>out</code>参数，直接使用<code>printcharc</code>函数完成任务。但强拓展性可不是一个简简单单的<code>printcharc</code>能受的住的（） 顺便提一嘴最好让同一个回调参数对应的函数类型都一致，否则可不一定能保证功能正确（反正编译器会先给你个难看的警告.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303202324203.png" alt="image-20230320232412341"> 实际上，在C语言库中还有很多这样的<strong>回调函数</strong>，其中我们用的相当多的一个就是<code>qsort</code>中的第四个参数：<code>cmp</code>。每次我们调用<code>qsort</code>，都需要事先写好<code>cmp</code>函数，并且传入<code>qsort</code>中，让其按照我们程序员事先设定好的规则进行排序。 写到这里我也才注意到，当时程设 + DS绕的一圈一圈的<code>cmp</code>参数格式，实际上正是C库的高拓展性所在：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* e1, <span class="type">const</span> <span class="type">void</span>* e2)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先为了符合回调函数要求，无论编写怎样的<code>cmp</code>函数都要保证参数类型一致；而为了能够处理更多种类的数据（甚至结构体），形参被设置成了<code>const void*</code>，这样不管比较的是什么结构，传入形参后强制类型转换把引用解开就可以进一步处理了。所以虽然程序员用起来有点绕，但对C库来说，这样写绝对是件好事。 在编程过程中使用回调机制，可以更好地分离代码，使得应用层和驱动层尽可能分离，降低总代码的耦合性。 受教了。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OO-UNIT1-Summary</title>
      <link href="/p/36144.html"/>
      <url>/p/36144.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>UNIT1-递归下降 因为想把作业比较完整地记录下来，而不仅仅是提交一份作业、交差完事，所以会写的相对多一点（ 可能刚敲完报告的同学 or 已经看了 n 份报告的助教看这篇答辩会觉得很臃肿，但这就不关我事了（？） <strong>博客作业要求部分</strong> 包含在 <strong>作业完成情况</strong> 标题下</p></blockquote><h1 id="作业内容及完成情况"><a href="#作业内容及完成情况" class="headerlink" title="作业内容及完成情况"></a>作业内容及完成情况</h1><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><blockquote><p>指导书总结搬运，回顾用</p></blockquote><h3 id="三次作业任务描述"><a href="#三次作业任务描述" class="headerlink" title="三次作业任务描述"></a>三次作业任务描述</h3><ul><li>  第一次作业任务：读入一个包含加、减、乘、乘方以及括号（其中括号的深度<strong>至多为 1 层</strong>）的<strong>多变量</strong>表达式，输出<strong>恒等变形展开所有括号后</strong>的表达式。 在本次作业中，<strong>展开所有括号</strong>的定义是：对原输入表达式E做<strong>恒等变形</strong>，得到新表达式E，且E中不含有字符 <code>(</code> 和 <code>)</code> 。</li><li>  第二次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。 本次作业起，不再限制表达式内的括号层数</li><li>  第三次作业任务：读入<strong>一系列自定义函数的定义</strong>以及一个包含幂函数、三角函数、自定义函数调用、求导算子的<strong>表达式</strong>，输出<strong>恒等变形展开所有括号后</strong>的表达式。</li></ul><h3 id="设定的形式化表述"><a href="#设定的形式化表述" class="headerlink" title="设定的形式化表述"></a>设定的形式化表述</h3><blockquote><p>本节按不同作业中课程组的条目标定进行整合； 其中，条目前标定**[2]<strong>的是第二次作业的新增项目，</strong>[3]**同理</p></blockquote><ul><li>  表达式 → 空白项 [加减 空白项] 项 空白项 表达式 加减 空白项 项 空白项</li><li>  项 → [加减 空白项] 因子 项 空白项 ‘*‘ 空白项 因子</li><li>  因子 → 变量因子 常数因子 表达式因子｜[3]求导因子</li><li>  变量因子 → 幂函数 **[2]**三角函数 <strong>[2]<strong>自定义函数</strong>调用</strong></li><li>  常数因子 → 带符号的整数</li><li>  表达式因子 → ‘(‘ 表达式 ‘)’ [空白项 指数]</li><li>  幂函数 → 自变量 [空白项 指数]</li><li>  自变量 → ‘x’ ‘y’ ‘z’</li><li>**[2]**三角函数 → ‘sin’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数] ‘cos’ 空白项 ‘(‘ 空白项 因子 空白项 ‘)’ [空白项 指数]<ul><li>  <strong>请注意输出三角函数时需要满足的形式化表述：内部元素为因子</strong></li></ul></li><li>指数 → ‘**‘ 空白项 [‘+’] 允许前导零的整数<ul><li>  <strong>指数一定不是负数，且输入的指数不得超过8</strong></li></ul></li><li>  带符号的整数 → [加减] 允许前导零的整数</li><li>  允许前导零的整数 → (‘0’’1’’2’…’9’){‘0’’1’’2’…’9’}</li><li>  空白项 → {空白字符}</li><li>  空白字符 → （空格） <code>\t</code></li><li>  加减 → ‘+’ ‘-‘</li><li><strong>[2]<strong>自定义函数</strong>定义</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项 [‘,’ 空白项 自变量 空白项]] ‘)’ 空白项 ‘=’ 空白项 函数表达式<ul><li>  <strong>规定自定义函数在表达式输入前进行输入，需要预先输入自定义函数数量，且0\le num\le3</strong></li></ul></li><li>  <strong>[2]<strong>自定义函数</strong>调用</strong> →→ 自定义函数名 空白项 ‘(‘ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项 [‘,’ 空白项 因子 空白项]] ‘)’</li><li>  **[2]**自定义函数名 →→ ‘f’ ‘g’ ‘h’</li><li>**[2]**函数表达式 →→ 表达式<ul><li>  <strong>第三次作业函数表达式中可以调用其他自定义函数，但保证不会出现递归调用的情况；同时调用自变量为常数的自身也不被允许)</strong></li></ul></li><li>  **[3]**求导因子 →→ 求导算子 空白项 ‘(‘ 空白项 表达式 空白项 ‘)’</li><li>  **[3]**求导算子 →→ ‘dx’ ｜’dy’ ｜’dz’</li></ul><h2 id="作业完成情况"><a href="#作业完成情况" class="headerlink" title="作业完成情况"></a>作业完成情况</h2><blockquote><p>虽然笨人很喜欢写东西，但耐不住笨人就是<strong>菜</strong>，三次作业全有bug（寄）</p></blockquote><h3 id="第一次作业"><a href="#第一次作业" class="headerlink" title="第一次作业"></a>第一次作业</h3><h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p>简单分析过题面之后，可以分析出一个初步的构造顺序： 表达式项因子表达式\to项\to因子 再进行进一步分析后，可以发现题目中最基础的<strong>单元</strong>就是一个形如a*x^b*y^c*z^d形式的<strong>单项式</strong>，而无论是题干中出现的任何一种构成成分，都由<strong>一个或多个</strong>这样的单项式构成：</p><ul><li>  常数因子\to带符号整数：b=c=d=0</li><li>  变量因子\to幂函数：a\ne0\ \&amp;\&amp;\ bcd中仅存在一个值\ne0</li><li>  表达式：<strong>若干</strong>单项式相加</li><li>  <strong>因子</strong>：<strong>若干</strong>单项式相加</li><li>  <strong>项</strong>：<strong>若干</strong>单项式相加 前三个条目的安排相对直观，<strong>那为什么因子也需要用若干单项式相加来表示呢？</strong>原因在于这里没有写下的一条构成路线：</li></ul><p>因子表达式因子表达式</p><p>也就是说，表达式的组成也可以成为因子的一种，也容易理解： (2x+y+1)按照形式化表述显然属于因子，然而很明显其无法用<strong>一个单项式</strong>表示 而对于<strong>项</strong>，则由组合规则同理可知，不再赘述 于是第一次设计采用了：</p><ul><li>数据结构：统一的<code>HashSet&amp;lt;Values&amp;gt; values</code>字段存储对应条目的值，每一个<code>Values</code>都表达一个单项式；<ul><li>  使用<code>HashSet</code>这种不能便利取值的容器是第二次的罪魁祸首</li></ul></li><li>  计算方法：<code>HashSet.add()</code>方法表示相加，创建一个两重遍历容器的方法表示相乘</li><li>  类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192152189.png" alt="name"></li></ul><h4 id="实现过程-难点"><a href="#实现过程-难点" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h4><ul><li>  词法分析器<code>Lexer</code>：构建思路来自单元训练栏目，根据当前字符判断元素种类，再决定<code>Paser</code>的解析逻辑，考虑各种可能出现的字符才能避免解析时出现<code>Runtime Error</code>（换句话说，一般<code>RE</code>的话就是解析错了，或者是爆递归栈、爆堆等，结构不是很怪的话比较少见）</li><li>  <strong>符号与减法</strong>：直到很靠后的时候才想出去解析<strong>可能出现</strong>负号位置（共三个）的解决方案：先查询一下是不是负号，然后给一个标记位，控制到最后返回的表达式/项/因子的系数正负</li><li>  乘法实现：开始直接把两项<code>add</code>到一个容器了，后来才意识到需要<strong>按照分配律</strong>一项一项的加指数再<code>add</code></li><li>指数与 **0：n次方就把前面的元素乘个n次<ul><li>  特判0**0=1（三角函数特判，易锅）</li></ul></li><li>  化简-合并同类项：每次<code>add</code>时，遍历所有容器内已有元素，如指数完全一致则进行系数运算并放弃<code>add</code>操作；否则直接<code>add</code></li><li>  输出：为<code>Values</code>类配置了<code>ttoString()</code>方法，不重写原有的<code>toString</code>方法（出过锅），输出最终表达式中所有<code>Values</code>的<code>ttoString()</code>字符串</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192156742.jpg" alt="img"></li></ul><h4 id="debug与测试"><a href="#debug与测试" class="headerlink" title="debug与测试"></a>debug与测试</h4><ul><li>  强测得分/互测失分/互测得分：100/1(1bug)/0.75(1bug)</li><li>互测锅是后导空白字符，会一直解析直到<code>OutofIndex</code>报<code>RE</code>，挑战最短hack数据之：<code>x&amp;lt;space&amp;gt;</code><ul><li>  解决方案是预处理所有空白字符，忍痛在递归下降里用<strong>字符串处理</strong>，写了<code>replaceAll</code></li></ul></li><li>  互测刀到的是如果有形如factor*a，且a.length\ge2时，会只乘以贴近乘号的值</li><li>性能方面：x*x要比x**2短一个字符，x-1要比-1+x短一个字符，处理好这个优化点就能强测100了（确信<ul><li>  不要随便对输出用正则：</li><li>  消去1*x的无用系数，导致21*x\to 2x</li><li>  替换长的x**2为等价描述，导致x**21\to x*x1</li></ul></li></ul><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><h4 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h4><p><strong>TLE，遂重构。</strong> 很遗憾，对于上一次的遍历查询值的操作来说，2s的CPU时间很明显不够祸祸的，所以只能换成<code>Map</code>类型便于查询 <code>Map</code>类型就要考虑采用什么作为<code>key/value</code>进行匹配，我采用了<code>&amp;lt;String, Values&amp;gt;</code>的键值对进行适配，为每一个项创建一个独特的字符串，且<strong>能够合并</strong>的项需要保证字符串相同（合并同类项时使用） 于是增添了一个新的<code>hashString()</code>方法，为每个<code>Values</code>创建字符串（生成<code>key</code>），这样其中的键值对都是<code>&amp;lt;Values.hashString(), Values&amp;gt;</code>形式的了；具体而言需要输出除了系数外的所有信息（xyz指数，<strong>三角函数</strong>的种类、指数、内部表达式、数量）。这也是这次重构中<strong>我遇到的的主要难点</strong> 其次是三角函数引入对<code>Values</code>类造成的改变，为了保证项中仅含单个三角函数时也能进行合并，故也采用类似<code>Values</code>的结构构建，键值对类型相同，此处的<code>String</code>则指三角内<code>expr</code>的<code>hashStringInValues()</code>（必须保证系数也一并输出，否则sin(x)和sin(2*x)将能合并） 最终结构为</p><h4 id="实现过程-难点-1"><a href="#实现过程-难点-1" class="headerlink" title="实现过程/难点"></a>实现过程/难点</h4><ul><li>  <code>hashString()</code>方法：由于采用字符串比较，所以需要严格保证<strong>能够合并的项需要保证字符串相同</strong>这一要求，否则无法合并。那么就需要避免出现2*cos(x-1)和-3*cos(-1+x)不能合并的惨案。最简单有效的办法就是保证<code>expr</code>有序，这也是为什么最后架构采用了<code>TreeMap&lt;String, Values&gt;</code>（其实这里同时做了诱导公式，保证三角内<code>expr</code>第一项恒为正，避免了上述无法合并的情况）</li><li>  三角函数化简 - 特殊值：对于特殊值，也就是cos(0)=1、sin(0)=0；务必注意(sin(0))**0=1，不过我是在创建三角函数时就进行了其中<code>expr</code>特判，如果<code>expr.values = 0</code>就会返回0/1，而不是<code>sincos</code>，转化计算的优先度要高于乘方</li><li>  三角函数化简 - 诱导公式：已在<code>hashString()</code>方法中进行了解释</li><li>  三角函数化简 - 二倍角：对于二倍角优化比较复杂，简化下只处理了指数为1的sin二倍角和指数为2的cos二倍角/平方和</li><li>自定义函数与调用：创建类<code>ArtiFunc</code>用于存储函数相关数据，在自定义函数<strong>调用时解析</strong>对应函数名、因子，同时使用字符串替换原公式形参后直接进行完整公式的解析，并返回<code>TreeMap &lt;String, Values&gt;</code><ul><li>  在调用时才进行解析的做法可以有效避免被<strong>根本不调用</strong>的超高cost自定义函数刀掉</li></ul></li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192158265.jpg" alt="img"></li></ul><h4 id="debug与测试-1"><a href="#debug与测试-1" class="headerlink" title="debug与测试"></a>debug与测试</h4><ul><li>bug点：<ul><li>  自定义函数实参因子替换后，需要给因子加一层括号，否则可能会出现sin(f(x))\to sin(x*y)这样不符合形式表达的bug</li><li>  三角函数优化太容易出锅了，尤其是引入了新的机制<code>hashString()</code>，即使二倍角优化更改的是三角函数中某一个<code>expr</code>的值，但最后需要把整个<code>Values</code>的<code>hashString()</code>再存一遍（更新），经常在运算忘记更新导致合并出锅，反向优化甚至错误输出</li><li>  在优化过程中需要不断把合并掉的三角函数从容器中取出、运算、装入，这个过程需对元素进行深克隆，出锅后细化了<code>Calculator</code>类，支持了各种元素的深克隆方法（尽可能同名以减轻记忆压力）</li><li>  输出时，三角函数套括号的层数判断出了问题，具体为编写的<code>hasOneFactor()</code>判断不严谨，没有考虑到a*sin(a^{‘})的情况，仍然会输出一层括号，导致格式不合法</li></ul></li><li>  强测得分/互测失分/互测得分：88.7/1(1bug)/4.75(4bug)</li><li>  强测（20测试点）2×0分，4×性能非满分</li><li>  互测则全是优化的问题，bug修复就注释了四行优化函数摆了烂，下来还是好好修了修；</li><li>  刀到的是自己写了随机数据的测评姬，同时<code>SymPy</code>房里所有人的输出，谁不一样就拎出来批（×），bug还算比较多的</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181203783.png" alt="《你在强测中得到了 88.7702 分。》"></li></ul><p>《你在强测中得到了 88.7702 分。》 <strong>架构设计</strong> 第三次作业的实现在上一次作业的合理基础上反而更加简单，只需要实现求导功能和自定义函数相互调用两点即可 求导方法函数增添在原有的计算类<code>Caluculator</code>中，接受<code>TreeMap&lt;String, Values&gt;</code>，对每个单项的<code>Values</code>求导后返回一个盛放导数的新容器 自定义函数由于支持了声明时嵌套，所以为了使用简洁，改成了在声明时<strong>预解析</strong>的方式处理，但这样虽然方便处理函数，但没法解决第二次作业提到的高cost互测数据，有<code>TLE/MLE</code>风险 类与方法： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192214859.png" alt="name"> <strong>实现过程/难点</strong></p><ul><li>求导功能：修改<code>Lexer</code>支持解析求导文法，并在<code>Calculator</code>类中创建求导方法，返回输入<code>TreeMap&lt;String, Values&gt;</code>的导数；<ul><li>  为便于实现，我将求导功能分类，分别实现基础项a、a*x^b、sincos(expr)和可递归项的求导(sincos(expr))**e、sincos(expr1)*sincos(expr2)、x^b*sincos(expr1)[*sincos(expr)]?</li></ul></li><li>  自定义函数：只需提前解析自定义函数内容即可，注意替换调用时的因子对应</li><li>  复杂度图： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303192215413.jpg" alt="img"></li></ul><p><strong>debug与测试</strong></p><ul><li>bug点：<ul><li>  递归部分的求导函数，复杂的判断条件以及繁琐的操作（取出、运算、更新、放回等）使得方法复杂度远超其他方法，回想起来，编写的时候实际上也很头疼，出错其实也不出意外</li><li>  三角函数因子内含有自定义函数调用，这种组合可能会出现仅用一层括号就包住一个表达式的情况，然后在解析过程中就会因为文法问题出锅；解决方案是在输出自定义函数调用结果时也用一层括号包起来，表达式\to表达式因子，使其符合三角函数形式化表述</li></ul></li><li>  强测得分/互测失分/互测得分：85.7/3(2bug)/1(1bug)</li><li>  强测（15测试点）2×0分，1×性能非满分</li><li>  小提示：<strong>别卷优化</strong> <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303181202787.png" alt="image-20230318120226762"></li></ul><p>《你在强测中得到了 85.72 分。》</p><h2 id="作业总结"><a href="#作业总结" class="headerlink" title="作业总结"></a><strong>作业总结</strong></h2><p>首先要感谢上学期的先导课，有先导课做Java语言的基础极大地便利了我对基础语法的理解与运用，尤其是在第一次作业上，没有犹豫太多就选择了相对能够满足当前要求的架构（虽然后续需要重构，但完成了当时任务的要求）。其次，本单元作业通过构造一系列类间关系进行表达式的解析，使用了部分接口、继承、重写等Java语言特性。再其次，这次作业为<strong>递归下降</strong>的原理做了引入和解释，对之后的编译原理也许有一定助力作用</p><h3 id="设计模式思考"><a href="#设计模式思考" class="headerlink" title="设计模式思考"></a>设计模式思考</h3><p>在第一次作业中因为实现的功能比较简单，就没有涉及到深/浅克隆的处理；但是随着计算功能复杂化、容器深度变深（<code>Values</code>内又存放了<code>Map</code>类），深克隆逐渐重要了起来。虽然应该写序列化深克隆方法，但是当时完全忘记了<code>clone</code>方法能重写（），然后又造了轮子 功能类（计算类）与数据类（表达式组件类）要进行明确划分，避免一个类同时运行多种复杂函数。从第二次作业重构起，创建了一个单独的运算类<code>Calculator</code>，用于执行乘法、乘方功能，并在第三次作业中把求导功能也一并集成，反思这个设定应该为每一种运算创建一个类，避免<code>Calculator</code>类过于复杂。同时写的东西实际上没有写成<strong>静态方法</strong>（知识储备不足），导致每次计算都要<code>new</code>一个对象，虽然没有字段但也对运行时间、空间有一定的影响。</p><h3 id="代码复杂度分析"><a href="#代码复杂度分析" class="headerlink" title="代码复杂度分析"></a>代码复杂度分析</h3><p>肉眼可见的，复杂度飘红的方法都是功能复杂的方法，如[1]中的<code>toString</code>、<code>pow</code>方法；[2]中的<code>doubleSin</code>、<code>mergeInduction</code>方法、[3]中的<code>qiuDao</code>方法。同时，出锅的实际上也正是这几个方法，几乎无一幸免。 所以在编写代码的过程中要尤其注意行数多、判断循环条件复杂、功能复杂的方法，尽量将其功能<strong>分散</strong>、模块化，或者说可以方法多，别让方法难，否则单个复杂方法debug过于折磨，而多设方法、接口处还能进行调试检测，方便缩小错误范围。</p><h3 id="互测总结"><a href="#互测总结" class="headerlink" title="互测总结"></a>互测总结</h3><p>各次作业中强测出现的bug已在各自的<strong>debug与测试</strong>栏目中进行分析。对于互测部分，<code>hack</code>他人代码主要依靠自己随机递归思路生成数据+借助<code>SymPy</code>库实现的校对测评姬。</p><ul><li>  纯多项式使用<code>expand</code>进行比对、含三角函数则输出式相减与0比较，如遇合并项则选择人工核对（这里其实可以代入变量值进行比对，不过没写.jpg） 只能说自己写的逻辑确实不容易<code>hack</code>到自己，第一次作业的测评姬甚至<strong>不支持生成</strong>末尾空格，所以根本测不出来自己的bug；</li></ul><p>前期的数据空有一番大体量，但是覆盖度并不好，总有组合测试不到；后面改良版本则更多侧重0、±1等<strong>边界</strong>小数据是否会出现错误。 对于三角函数合并、求导，以及求导后再进行的合并化简，我设计了一个占比不同的导数内表达式生成机制，能够较充分地覆盖各类情况进行测试（能出现含<strong>0</strong>层三角函数的项，同时也按照等比的概率考虑到了多重三角函数嵌套的可能性和概率的合理性） 对于导数，应该生成：</p><ul><li>  5\% a</li><li>  5\% a*x^b</li><li>  10\% a*x^b*y^c</li><li>  15\% a*sincos(expr)</li><li>  15\% a*x^b*sincos(expr)</li><li>  25\% a*sincos(expr1)*sincos(expr2)</li><li>  25\% a*x^b*y^c*sincos(expr1)*sincos(expr2)\ expr1 =? expr2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Object Oriented </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab1-Report</title>
      <link href="/p/54148.html"/>
      <url>/p/54148.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab1-Report"><a href="#BUAA-OS-2023-Lab1-Report" class="headerlink" title="BUAA-OS-2023-Lab1-Report"></a>BUAA-OS-2023-Lab1-Report</h1><h1 id="Thinking-1-1"><a href="#Thinking-1-1" class="headerlink" title="Thinking 1.1"></a>Thinking 1.1</h1><p>不使用交叉编译，使用<code>gcc -c</code>对文件进行编译，对编译而尚未链接的文件进行反汇编可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc -c hello.c </span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;main&gt;:</span><br><span class="line">   0:   f3 0f 1e fa             endbr64 </span><br><span class="line">   4:   55                      push   %rbp</span><br><span class="line">   5:   48 89 e5                mov    %rsp,%rbp</span><br><span class="line">   8:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        <span class="comment"># f &lt;main+0xf&gt;</span></span><br><span class="line">   f:   48 89 c7                mov    %rax,%rdi</span><br><span class="line">  12:   e8 00 00 00 00          call   17 &lt;main+0x17&gt;</span><br><span class="line">  17:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">  1c:   5d                      pop    %rbp</span><br><span class="line">  1d:   c3                      ret    </span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>不使用交叉编译，对编译出的可执行文件直接进行<code>objdump -DS</code>指令，可以得到以下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ gcc hello.c -o hello2</span><br><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump -DS hello2</span><br><span class="line"></span><br><span class="line">hello2：     文件格式 elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .interp:</span><br><span class="line"></span><br><span class="line">0000000000000318 &lt;.interp&gt;:</span><br><span class="line"> 318:   2f                      (bad)  </span><br><span class="line"> 319:   6c                      insb   (%dx),%es:(%rdi)</span><br><span class="line"> 31a:   69 62 36 34 2f 6c 64    imul   <span class="variable">$0x646c2f34</span>,0x36(%rdx),%esp</span><br><span class="line"> 321:   2d 6c 69 6e 75          sub    <span class="variable">$0x756e696c</span>,%eax</span><br><span class="line"> 326:   78 2d                   js     355 &lt;__abi_tag-0x37&gt;</span><br><span class="line"> 328:   78 38                   js     362 &lt;__abi_tag-0x2a&gt;</span><br><span class="line"> 32a:   36 2d 36 34 2e 73       ss sub <span class="variable">$0x732e3436</span>,%eax</span><br><span class="line"> 330:   6f                      outsl  %ds:(%rsi),(%dx)</span><br><span class="line"> 331:   2e 32 00                cs xor (%rax),%al</span><br><span class="line"></span><br><span class="line">Disassembly of section .note.gnu.property:</span><br><span class="line"></span><br><span class="line">0000000000000338 &lt;.note.gnu.property&gt;:</span><br><span class="line"> 338:   04 00                   add    <span class="variable">$0x0</span>,%al</span><br><span class="line"> 33a:   00 00                   add    %al,(%rax)</span><br><span class="line"> 33c:   20 00                   and    %al,(%rax)</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure><p>如使用交叉编译<code>mips-linux-gnu-gcc hello.c</code>进行编译链接，并直接使用<code>objdump -DS</code>进行反汇编，则会返回如下代码：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ objdump a.out -DS</span><br><span class="line"></span><br><span class="line">a.out：     文件格式 elf32-big</span><br><span class="line"></span><br><span class="line">objdump: can<span class="string">&#x27;t disassemble for architecture UNKNOWN!</span></span><br></pre></td></tr></table></figure><p>出现如上错误是因为，需要使用交叉编译链所对应的反汇编工具才能解析，在我们的实验环境下就是<code>mips-linux-gnu-objdump</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git@21371068:~/21371068/tools/readelf (lab1)$ mips-linux-gnu-objdump -DS hello.o</span><br><span class="line"></span><br><span class="line">hello.o：     文件格式 elf32-tradbigmips</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line">   0:   27bdffe0        addiu   sp,sp,-32</span><br><span class="line">   4:   afbf001c        sw      ra,28(sp)</span><br><span class="line">   8:   afbe0018        sw      s8,24(sp)</span><br><span class="line">   c:   03a0f025        move    s8,sp</span><br><span class="line">  10:   3c1c0000        lui     gp,0x0</span><br><span class="line">  14:   279c0000        addiu   gp,gp,0</span><br><span class="line">  18:   afbc0010        sw      gp,16(sp)</span><br><span class="line">  1c:   3c020000        lui     v0,0x0</span><br><span class="line">  20:   24440000        addiu   a0,v0,0</span><br><span class="line">  24:   8f820000        lw      v0,0(gp)</span><br><span class="line">  28:   0040c825        move    t9,v0</span><br><span class="line">  2c:   0320f809        jalr    t9</span><br><span class="line">  30:   00000000        nop</span><br><span class="line">  34:   8fdc0010        lw      gp,16(s8)</span><br><span class="line">  38:   00001025        move    v0,zero</span><br><span class="line">  3c:   03c0e825        move    sp,s8</span><br><span class="line">  40:   8fbf001c        lw      ra,28(sp)</span><br><span class="line">  44:   8fbe0018        lw      s8,24(sp)</span><br><span class="line">  48:   27bd0020        addiu   sp,sp,32</span><br><span class="line">  4c:   03e00008        jr      ra</span><br><span class="line">  50:   00000000        nop</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="objdump参数意义"><a href="#objdump参数意义" class="headerlink" title="objdump参数意义"></a><code>objdump</code>参数意义</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-D  反汇编文件中的所有section(节)</span><br><span class="line">-S  输出时按照C语言与汇编代码相对应的格式输出</span><br></pre></td></tr></table></figure><h1 id="Thinking-1-2"><a href="#Thinking-1-2" class="headerlink" title="Thinking 1.2"></a>Thinking 1.2</h1><p>使用我们编写的<code>readelf</code>程序对内核文件检查后得到的视图如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122303933.png" alt="image-20230312230359908"></p><p>使用<code>Linux</code>系统内自带的<code>readelf</code>指令对<code>readelf</code>文件和<code>hello</code>文件进行分析（使用<code>readelf -h readelf/hello</code>指令）可以发现两个文件的类型不同：<code>hello</code>是<code>ELF32</code>类型，而<code>readelf</code>是<code>ELF64</code>类型</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122307115.png" alt="image-20230312230745084"></p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303122308042.png" alt="image-20230312230826009"></p><p>这说明我们的<code>hello</code>文件是32位的格式，而<code>readelf</code>则是64位的。我们打开<code>readelf.c</code>文件，发现其中的的数据类型前缀都是<code>ELF32</code>，也正是说明了这个程序负责分析32位的<code>ELF</code>文件。所以它不能分析身为64位格式程序的自己。</p><p>进入同目录下的<code>Makefile</code>文件查看，发现了两个文件在编译方式上的不同：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303130009343.png" alt="image-20230313000915321"></p><p>查阅相关资料后得知参数<code>-m32</code>：编译出来的是32位程序，既可以在32位操作系统运行，又可以在64位操作系统运行。这也恰好印证了<code>readelf</code>指令对于这两个文件的类型判定。</p><h2 id="补充：大小端转换"><a href="#补充：大小端转换" class="headerlink" title="补充：大小端转换"></a>补充：大小端转换</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//小端-&gt;大端：</span></span><br><span class="line">UINT <span class="title function_">EndianConvertLToB</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p&lt;&lt;<span class="number">24</span>)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">16</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">8</span>)+(UINT)*(p+<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//大端-&gt;小端</span></span><br><span class="line">UINT <span class="title function_">EndianConvertBToL</span><span class="params">(UINT InputNum)</span> &#123;</span><br><span class="line">    UCHAR *p = (UCHAR*)&amp;InputNum;</span><br><span class="line">    <span class="keyword">return</span>(((UINT)*p)+((UINT)*(p+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>)+</span><br><span class="line">               ((UINT)*(p+<span class="number">2</span>)&lt;&lt;<span class="number">16</span>)+(UINT)*(p+<span class="number">3</span>)&lt;&lt;<span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Thinking-1-3"><a href="#Thinking-1-3" class="headerlink" title="Thinking 1.3"></a>Thinking 1.3</h1><p>在我们的实验中，系统启动被简化成了把内核加载到指定内存位置。</p><p>MIPS系统启动时首先接管的是<code>bootloader</code>，随后<code>Linker Script</code>把各个节映射到对应的段上，内核文件也在这时被加载到合适的地址空间中。</p><p>在<code>Exercise 1.2</code>中，我们补全了<code>kernel.lds</code>文件，把<code>.text</code>、<code>.data</code>、<code>.bss</code>三个段映射到了合理空间</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Exercise 1.2 Your code here. */</span><br><span class="line"></span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = .;</span><br></pre></td></tr></table></figure><p>经过<code>Linker Script</code>文件的引导，内核代码就会被加载到<code>0x80010000</code>这段地址。再通过<code>ENTRY(_start)</code>的入口规定，如此便保证了我们能够跳转到内核入口</p><h1 id="Exercise-1-1"><a href="#Exercise-1-1" class="headerlink" title="Exercise 1.1"></a>Exercise 1.1</h1><h2 id="C语言指针"><a href="#C语言指针" class="headerlink" title="C语言指针"></a>C语言指针</h2><p>在<code>Exercise 1.1</code>中，我们需要使用指针对ELF头进行寻址后取值，那么这时使用指针取得合适的地址就是重点了</p><blockquote><p>C语言对指针的加法运算符进行了重载</p></blockquote><p>如果使用了<code>+</code>对地址进行运算，地址的位移量会自动根据加号前的数据结构调整。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Struct st * p = (Struct st*)p + a</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体为：地址会向后移动<code>a*sizeof(Struct st)</code>字节</p><p>在我们的实验中需要在ELF头中寻找到节头表的入口，需要的行为是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line"><span class="comment">//binary、ehdr为ELF头地址；e_shoff为节头表入口偏移</span></span><br></pre></td></tr></table></figure><p>但是有的同学写成了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table = (Elf32_Shdr *)(ehdr + ehdr-&gt;e_shoff);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原本的<code>binary</code>类型为<code>const void *</code>，它的加法运算符向后移动的单位为1字节；而已经转型为<code>Elf32_Ehdr</code>的<code>ehdr</code>重载后则会向后移动一个<code>Elf32_Ehdr</code>大小的地址空间。于是虽然两个指针指向了同一个地址，<code>+</code>后的值也相同，但是运算后得到的结果却截然不同</p><h2 id="readelf-c文件的补全"><a href="#readelf-c文件的补全" class="headerlink" title="readelf.c文件的补全"></a><code>readelf.c</code>文件的补全</h2><p>实验目的为输出ELF文件的节头地址信息。</p><p>首先需要明确，我们需要的节头地址信息保存在节头表中每个项目的特定字段中（<code>Elf32_Shdr -&gt; sh_addr</code>）。并且这个<code>sh_addr</code>指向ELF文件中的每个节头所在地址。那么就需要我们从ELF表头访问到节头表，并对每一项遍历即可。</p><blockquote><p><strong>遍历每一个节头</strong>的方法是：先读取节头的大小，随后以指向第一个节头的指针（即节头表第一项的地址）为基地址，不断累加得到每个节头的地址。</p></blockquote><p>具体实现为根据<code>Elf32_Edhr -&gt; e_shoff</code>寻找到节头表入口地址、根据<code>Elf32_Edhr -&gt; e_shnum</code>获取节头表中所含有项的个数，并根据<code>Elf32_Edhr -&gt; e_shentsize</code>获取节头表长度，便于位移</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">void</span> *sh_table;</span><br><span class="line">Elf32_Half sh_entry_count;</span><br><span class="line">Elf32_Half sh_entry_size;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (1/2) */</span></span><br><span class="line">sh_table = (Elf32_Shdr *)(binary + ehdr-&gt;e_shoff);</span><br><span class="line">sh_entry_count = ehdr-&gt;e_shnum;</span><br><span class="line">sh_entry_size = ehdr-&gt;e_shentsize;</span><br><span class="line"><span class="comment">// For each section header, output its index and the section address.</span></span><br><span class="line"><span class="comment">// The index should start from 0.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sh_entry_count; i++) &#123;</span><br><span class="line"><span class="type">const</span> Elf32_Shdr *shdr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> addr;</span><br><span class="line"><span class="comment">/* Exercise 1.1: Your code here. (2/2) */</span></span><br><span class="line">shdr = sh_table + i * sh_entry_size;</span><br><span class="line">addr = (<span class="type">unsigned</span> <span class="type">int</span>)(shdr-&gt;sh_addr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d:0x%x\n&quot;</span>, i, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Exercise-1-2"><a href="#Exercise-1-2" class="headerlink" title="Exercise 1.2"></a>Exercise 1.2</h1><h2 id="Linker-Script"><a href="#Linker-Script" class="headerlink" title="Linker Script"></a><code>Linker Script</code></h2><blockquote><p><code>Linker Script</code>中记录了各个节应该如何映射到段，以及各个段应该被加载到的位置。</p></blockquote><p>在<code>Exercise 1.2</code>中，我们就要利用<code>Linker Script</code>，对内核文件的各节进行内存指派，找到对应节的地址。段是由节所结合组成的，因为节的位置改变了，所以段的地址也会相应地发生移动，具体实现如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">/* fill in the correct address of the key sections: text, data, bss. */</span><br><span class="line">/* Exercise 1.2: Your code here. */</span><br><span class="line">. = 0x80010000;</span><br><span class="line">.text : &#123; *(.text) &#125;</span><br><span class="line">.data : &#123; *(.data) &#125;</span><br><span class="line">.bss : &#123; *(.bss) &#125;</span><br><span class="line">bss_end = .;</span><br><span class="line">. = 0x80400000;</span><br><span class="line">end = . ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的<code>.</code>号用作<strong>定位计数器</strong>，通过设置<code>.</code>的地址，声明接下来的节会被按序安放在该地址后。（在<code>SECTIONS</code>中，默认初始的地址为0地址，所以需要先修改地址然后再安排节文件）</p><p>后面的代码如<code>.bss:&#123;*(.bss)&#125;</code>，表示将所有输入文件中的<code>.bss</code>节（右边<br>的<code>.bss</code>）都放到输出的<code>.bss</code>节（左边的<code>.bss</code>）中。</p><p>观察<code>kernel.lds</code>的其他代码，还能发现这个文件规定了程序的入口地址。我们的实验程序通过<code>ENTRY(_start)</code>设置<code>_start</code>函数作为入口地址开始运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Set the ENTRY point of the program to _start.</span><br><span class="line"> */</span><br><span class="line">ENTRY(_start)</span><br></pre></td></tr></table></figure><p>而<code>_start</code>函数被安放在<code>/init/start.S</code>文件中</p><h1 id="Exercise-1-3"><a href="#Exercise-1-3" class="headerlink" title="Exercise 1.3"></a>Exercise 1.3</h1><h2 id="start函数的设置"><a href="#start函数的设置" class="headerlink" title="_start函数的设置"></a><code>_start</code>函数的设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">EXPORT(_start)</span><br><span class="line">.set at</span><br><span class="line">.set reorder</span><br><span class="line">/* disable interrupts */</span><br><span class="line">mtc0    zero, CP0_STATUS</span><br><span class="line">/* hint: you can reference the memory layout in include/mmu.h */</span><br><span class="line">/* set up the kernel stack */</span><br><span class="line">/* Exercise 1.3: Your code here. (1/2) */</span><br><span class="line">li sp, 0x80400000</span><br><span class="line">/* jump to mips_init */</span><br><span class="line">/* Exercise 1.3: Your code here. (2/2) */</span><br><span class="line">jal mips_init</span><br></pre></td></tr></table></figure><p>在<code>mmu.h</code>文件中我们可以查询到系统内核各部分内存分配情况，这里就能找到栈顶地址为<code>0x80400000</code></p><p>设置结束后汇编程序完成，就可以跳转入C语言的函数入口<code>mips_init</code>了</p><blockquote><p>我们使用<code>jal</code>、<code>j</code>指令进行函数的跳转。在不同文件链接时，链接器回对目标文件中的符号（包括函数名）进行重定位，修改跳向这些函数的地址，实现跨文件的函数调用</p></blockquote><h2 id="printk函数的实现"><a href="#printk函数的实现" class="headerlink" title="printk函数的实现"></a><code>printk</code>函数的实现</h2><p><code>printk</code>函数实现功能，底层上依靠的是<code>console.c</code>文件中<code>printcharc</code>函数对控制台进行字符的输出；</p><p>向上一层，<code>print.c</code>中的<code>vprintfmt</code>函数则通过<strong>格式化字符</strong>的形式对<code>console.c</code>中的函数进行合理调用，实现输出；</p><p>再向上一层，就是<code>printk.c</code>这个文件，它接收输出参数，并把<strong>变长参数表</strong>和传递给<code>vprintfmt</code>函数，最终实现字符的输出。</p><h3 id="变长参数表"><a href="#变长参数表" class="headerlink" title="变长参数表"></a>变长参数表</h3><blockquote><p><code>stdarg.h</code>头文件对变长参数表定义了一系列宏变量与变量类型：</p></blockquote><ul><li>  <code>va_list</code>：变长参数表对应的变量类型</li><li>  <code>va_start(va_list ap, lastarg)</code>：初始化变长参数表</li><li>  <code>va_arg(ca_list ap, 类型)</code>：去除变长参数表的下一个参数</li><li>  <code>va_end(va_list ap)</code>：结束变长参数表的使用</li></ul><p>声明方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">va_list ap;<span class="comment">// 声明变长参数表</span></span><br><span class="line">va_start(ap, lastarg);<span class="comment">// 初始化参数表</span></span><br><span class="line"><span class="type">int</span> var = va_arg(ap, <span class="type">int</span>);<span class="comment">// 取出一个int类型的变量</span></span><br><span class="line">...</span><br><span class="line">va_end(ap);<span class="comment">// 结束当前的变长参数表</span></span><br></pre></td></tr></table></figure><p>回到我们的<code>printk</code>函数：<code>printk</code>本身接受了外部传入的不定长参数，创建了一个变长参数表，传入了<code>vprintfmt</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// printcharc</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printcharc</span><span class="params">(<span class="type">char</span> ch)</span> &#123;</span><br><span class="line">        *((<span class="keyword">volatile</span> <span class="type">char</span> *)(KSEG1 + DEV_CONS_ADDRESS + DEV_CONS_PUTGETCHAR)) = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outputk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">outputk</span><span class="params">(<span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line"><span class="comment">// buf：输出的字符串指针；len：输出的字符长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                printcharc(buf[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vprintfmt</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vprintfmt</span><span class="params">(<span class="type">fmt_callback_t</span> out, <span class="type">void</span> *data, <span class="type">const</span> <span class="type">char</span> *fmt, va_list ap)</span> &#123; ... &#125;</span><br><span class="line"><span class="comment">// 此处传入的out，实际上是outputk的函数指针，内部实际上在调用outputk函数进行输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// printk</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printk</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line"><span class="comment">// fmt：传递的主字符串指针</span></span><br><span class="line">        va_list ap;</span><br><span class="line">        va_start(ap, fmt);</span><br><span class="line">        vprintfmt(outputk, <span class="literal">NULL</span>, fmt, ap);</span><br><span class="line">        va_end(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自顶向下地：</span></span><br><span class="line"><span class="comment">// printk函数创建变长参数表，调用vprintfmt</span></span><br><span class="line"><span class="comment">// vprintfmt格式化参数表，调用outputk；</span></span><br><span class="line"><span class="comment">// outputk接收数据直接调用printcharc，实现功能</span></span><br></pre></td></tr></table></figure><p>具体实现不再说明</p><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><ol><li> 第一次完成<code>lab1</code>内容时还不能理解内核为什么能正常工作、函数为何能正常运行，只是按照指导书的说明进行补充而已。而恰是这个不理解，成了实验过程中的最大难题。只有完成内容后，再重新回过头来审视每一步，才能知道每一步的具体功效，明白实验过程中“那里”为什么要“那么做”。经常性的回顾对实验过程理解很有必要。</li><li> 完成实验过程中并没有查看除了需要填写代码文件以外的文件，然而，各个函数的实现过程与相关信息其实都藏在课程组为我们写好的其他文件中，读过一遍其他函数的定义、调用与功能，才让实验过程中填写的代码有理可据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 3</title>
      <link href="/p/6747.html"/>
      <url>/p/6747.html</url>
      
        <content type="html"><![CDATA[<p>“Marva Collins comes along and reframes the question. And her question becomes ‘how can we cultivate the seed of greatness in our students.” (0:04:52)</p><p>If a student has depression or other mental illness, we can’t just tell him that depression is wrong, you can’t do that. This method of correcting errors from the negative side cannot always be used. Instead, like the teacher, tell him what is right and what is beautiful and shining in life. In this way, students can understand the beauty of themselves and the world from a positive perspective, and can really help them out of difficulties.</p><p>“Happiness does not just come spontaneously when we negate unhappiness.” (0:25:34)</p><p>This sentence is very reasonable. From my perspective, life is like a ruler with scale. It is not enough to just go back to the origin from the negative half. To get real happiness, we must make changes and move forward to the positive side. These methods of change are what we really need in life. I think it is also very useful  to call on universities to teach these courses to discover the shining points of people, which was just like the author said.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 4</title>
      <link href="/p/55322.html"/>
      <url>/p/55322.html</url>
      
        <content type="html"><![CDATA[<p>“The problem is not lower these high expectations—that doesn’t matter. The problem is right versus wrong expectations. Not high or low, that won’t make a difference to our level of wellbeing. It is if we have right vs. wrong expectations.   </p><p>Hoping for changes created by one or two things happen in life probably cannot make us happier. The right expectation is to believe in change from within. Sometimes there is a huge barrier between the actual gain from one thing and our mental expectation. It’s the wrong expectation that make our mood upside down. However, the changes made by yourself when you absorbing the environment could help you last the sense of fulfilling. And it’s a critical way to bring happy from the outer life.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Record()</title>
      <link href="/p/233.html"/>
      <url>/p/233.html</url>
      
        <content type="html"><![CDATA[<p>23/03/09<br>网站正式启动，不过还只能通过IP访问。挂载了Sakurairo主题，也试着把两篇文章从公众号里搬了过来。不得不说wordpress这个写作后台还是不太适应</p><p>23/03/10 update<br>上军理课的时候接到邮件说，域名模板审批下来了，我直接放下手里的java开始搞解析。现在终于可以通过<a href="http://cookedbear.top/">cookedbear.top</a>访问啦！配置好之后也把站点里的分类随便写了写</p><p>23/03/11 update<br>今天申请了免费的SSL证书，现在访问支持https了，Chrome终于不再提示我“不安全”力！<br>之后可能会改改CDN给图片加个速之类的。还有个问题就是，首页这个图只要还在浏览器可见范围内，就会疯狂掉帧（</p><p>23/03/15 update<br>甲了，暂缓相关更新<br>同时发现评论的时区也得调一下</p><p>23/03/17 update<br>好点了，爬回来改网站，改了评论的时区了（大概），同时优化了一下缓存机制<br>红烧天堂真好玩（bushi</p><p>23/03/20 update<br>甲流那劲差不多过去了，还是有点咳嗽等等症状，问题不大了，等过十天半个月的冯如杯过去，就可以大张旗鼓回来写文了<br>lab1上机发现课下大锅，幸亏de出来了（）</p><p>23/03/26 update<br>学习暂告一段落，回来把主题改成了Sakura，至少现在自己电脑跑起来不会卡顿了。调了一下图床，给Gravatar改了一个代理，顺便在页首加了一个最后一次更新时间的显示。但是发布时间还是会显示8小时前，头大.jpg</p><p>23/04/14 update<br>发布时间和更新时间现在都能正常显示了， TOC 换了一个更好用的插件，基本上算成型了吧，有时间加一个分类页</p><p>23/04/16 update<br>前天加的灯箱插件寄了，点开一次灯箱之后图片就丢了，属实是逆天，回头再禁用掉吧。</p><p>23/05/05 update<br>在考虑需不需要转成 hexo 建站，wordpress 的写作风格有点难受，后台和主题也不太好管理。hexo 体验了一下，感觉特点就是轻量化，如果不加入新功能的话，静态站点应该是够用了。择日再议。</p><p>23/05/13 update<br>说到做到，直接迁移到 hexo 上了，之后慢慢来重新做一下配置吧。感觉比 wordpress 现有的主题灵活性要强不少，而且好歹有灯箱了（</p><p>现在问题就是：之前买了的服务器怎么整（）</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Response Paper for Positive Psychology Lecture 5</title>
      <link href="/p/6363.html"/>
      <url>/p/6363.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Just take some notes down. I didn’t follow the video all the time.</p></blockquote><p>The video first stated the question about the importance of happiness. Not only happiness can make us feel good, it can also contribute to our life, relationships, and other people.</p><p>Barbara Fredrickson says is that positive emotion has a revolutionary reason, beyond making us feel good.(0:26:35) Enjoying the happiness is quite excellent experience. When I was suffering from some bad messages, trying to find some joy, and happiness can pull me out of there for a while indeed. It’s useful to help us overcome the negative emotions(just work as positive side).</p><p>Positive emotions broad and build, which can lead to more positive emotions. Then the positive emotions continue to broad and build. So they function as a virtuous cycle, which is completely contrast to the situation negative emotions do. Hopefully, if we are, unfortunately, trapped in the cycle created by the bad emotions, just think about the happiness things, which can help us get out of the narrow and constrict to the broad and build.</p><p>Being put into a positive mood is a win-win situation, for who experiences it and who give. Feeling positive can surely give us more motivation and energy to work further.</p><hr><p>The NO.1 causes of unhappiness is “equating to selfishness and immorality”, because people feel guilty for their own happiness. I think it’s quite suitable for me. When I gain something brilliant every time, I would think about the people around me. Is it <strong>fair</strong> for them? Can I take the joy just for myself? However the lecture told me that gain happiness for your self is a contribution indirect to other people’s happiness.</p><blockquote><p>Be the change you want to see in the world.</p></blockquote><p>People do what you do, more than what you say. The professor showed us that by a little experiment: ask students to put your hand on their cheek, while put his own hand on the chin. Amusingly, many students put their hands on their chin, including me. Cause I didn’t hear the actual word “chin” (lol). So quite right, the professor then add that, the optimal way spreading happiness is to work on your own happiness. Looking at your happiness, the people around you would surely influenced by your actions, cuz you are leading examples.</p><h2 id="Beliefs-as-Self-fulfilling-Prophecies"><a href="#Beliefs-as-Self-fulfilling-Prophecies" class="headerlink" title="Beliefs as Self-fulfilling Prophecies"></a>Beliefs as Self-fulfilling Prophecies</h2><p>Beliefs are self-fulfilling prophecies. Some time, subconsciousness stops us from moving forward. The barriers are not made by physical, medical, but mental.</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Reading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elevate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>延绵不绝的纯粹爱恋——观《相逢于明月映照的彼方》</title>
      <link href="/p/29212.html"/>
      <url>/p/29212.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2697字</p><p>预计阅读时间：7分钟</p></blockquote><p>各位好，这次带来的是关于上次提到的补坑作品<strong>《相逢于明月映照的彼方》</strong>（偷懒下面就叫月彼了）的一些想法，作为tone work’s的第四作，游戏的整体内容配得上终极纯爱战士tone的一贯作风了（雨音线糖度拉满）；个人线路也各有千秋，但灯华线的表现实在让人……不好接受。在此处不做展开，来看下文罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-1.png"></p><h2 id="Part-1-tone-work’s"><a href="#Part-1-tone-work’s" class="headerlink" title="Part 1 tone work’s"></a><strong>Part 1 tone work’s</strong></h2><p>先来介绍一下tone work’s（tone社）吧 到现在为止tone社总共有4部作品：《初恋1/1》、《星织梦未来》、《银色遥远》还有这次提到的月彼。个人感觉tone的原画、音乐和系统演出基本无可挑剔，半清新画风的background图也称得上是壁纸级别了，不过你社真的缺一个把剧本写好的写手哇。总的来说，已经完成的后三部作品都属于高质量作，均可放心食用（1/1我没玩过就尴尬了）。话说回来，每次打开tone社的游戏，听到欢迎界面的7个单音（欢迎音）都感觉很安心，就和即将要玩的作品一样。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-2.png"></p><p>tone社社标</p><p>好闲话少说进入下一部分（</p><h2 id="Part-2-剧情介绍"><a href="#Part-2-剧情介绍" class="headerlink" title="Part 2 剧情介绍"></a><strong>Part 2 剧情介绍</strong></h2><p>如果，未来与过去被手机连接</p><p>你有什么后悔的事情选择重来？</p><p>高二那年的暑假</p><p>她们比谁都反复无常，比谁都不可捉摸</p><p>而且比谁，都楚楚动人。</p><p>第一次的恋爱。酸甜的回忆。</p><p>依依不舍，那是夏季的日子。</p><p>25岁的夏天</p><p>突然发现自己变成了上班族。</p><p>一边仰望天空，一边回想起梦一般的日子。</p><p>就像怀旧一般，把学生时代没用过的</p><p>智能手机启动了。启动短信应用程序后，</p><p>给自己发送短信。</p><p>后悔了吧</p><p>致过去的自己，无法传达的想法。</p><p>然而，智能手机振动了。</p><p>突如其来的事情</p><p>那是过去自己发来的邮件……</p><p>——来自萌娘百科相关页面</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-3.png"></p><p>游戏海报</p><p>不同于前几作的单纯学园纯爱作品，这次tone社加入了超自然因素（啊对就是你灯华手里拿着的恩底弥翁）以及数量众多的个人线，海报里出现的女主角都是有个人线的（右侧三位是在after篇社畜生活后开放的路线），所以游戏的体量也不小（但好像比银遥体积小不少欸）。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-4.png"></p><p>左起：新谷灯华、日紫喜うぐいす、佐仓雨音、<br>仓桥圣衣良、岬栞菜、松宫雾子、月ヶ洞きらり</p><p>作为社畜后选择的三人组路线和圣衣良线并没有对手机有过多的涉及，和核心故事的关联也不密切，这里就不再着笔叙述了（绝对不是因为二刷的时候没玩然后已经忘了内容了）关于游戏的配乐我就不多说什么了直接上图吧（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-5.png"></p><p>喵？</p><p>游戏的系统制作也很精良，动态效果等等都十分顺滑，顺带一提，第一次看到过场动画都这么艺术的我实在是叹为观止  </p><h2 id="Part-3-人物线浅析"><a href="#Part-3-人物线浅析" class="headerlink" title="Part 3 人物线浅析"></a><strong>Part 3 人物线浅析</strong></h2><h3 id="Rein-Side"><a href="#Rein-Side" class="headerlink" title="Rein Side"></a><strong>Rein Side</strong></h3><p>先看雨音线吧，作为官方认定的亲女儿，雨音在游戏发售的不久就增加了个人FanDisk（Sweet Summer Rainbow），全程发糖，糖度过高（大喜），在游戏本体的表现也算不错，虽然没有FD里的心态变化那么丰满自然，但是本体好好地承担了推进核心剧情的任务，没有把游戏玩成谜语真是太好了（</p><p>无论是恩底弥翁的本意，还是Rainbow与Kanata这样文字的小小解密；是雨音与父母短暂地相见，抑或是接受现状后的继续前行，都把游戏想传达出的点给到了。虽然说部分玩家评论雨音这个角色媚宅元素浓，但我在这一点保留一个中立态度，正因为是游戏，所以保有一些幻想的观点我认为无可厚非；削减糖度柔化人设让剧情故事更加平衡这种想法我更是表示欢迎。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-6.png"></p><p>但无论如何，感动永远是雨音线中不可或缺的重要组成部分，过多的不再言及，请诸位自行品味罢，如果想要深入了解雨音这个人设定位的话，强烈建议再补一下FD，失去了高度集中主线的约束，雨音的心理成长算是成为了其中聚焦的重点，嘛，反正不玩也不会怎样就是了。   </p><h3 id="U-guisu-Side"><a href="#U-guisu-Side" class="headerlink" title="_U_guisu Side"></a>_U_guisu Side</h3><p>学姐线走的是一种扑面而来的文艺风，始终是一首不浓不烈的爱情诗，没有一种喧宾夺主的色彩，通线的时候就很舒服，我也很喜欢学姐线的主题曲《月之钟》</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-7.png"></p><p>（每当钟声响起的时候/我想起的 是二人如诗般的过往）<br>哇我真的爱死这句</p><p>两人第一次在湖心岛许下诺言时确实心旷神怡。虽然这部作品刻画的学姐形象不很戳我，但是这种青涩、文艺、甚至可以称作优雅的恋爱经历却是令我向往的。本篇写下的是学姐虽然患病不久于人世但仍旧选择与奏汰共度剩余的时光。</p><p>但after篇接续的却是学姐的绝症可以治疗，但学姐已经因为自己患病离去的消息，意识到这一点的奏汰充满了痛苦与自我厌恶，但多亏恩底弥翁给了他重新选择的机会——让学姐前往国外医治疾病，重写这段历史，也因此他不得不对过去的自己出违心的主意，为的就是让莺学姐远离自己出国医治，而自己独自承受着内心的愧疚和来自过去的自己的埋怨。所幸在故事的最后满月之时，修正过的历史同步，两人重新在月之钟下约定诺言，故事驶向终章。 </p><h3 id="Duca-Side"><a href="#Duca-Side" class="headerlink" title="Duca Side"></a>Duca Side</h3><p>灯华在海报里这C位可不是白占的，本篇的表现确实不错，留下的观感很好，第一次推的时候还留了一个挺好的印象，结果进了after篇就开始拉大胯，剧本直接放弃了在成年后的时间线中推动剧情，索性让成年奏汰借助手机跨越时空起了一个远程军师的作用，但归根到底还是高中那点事，更类似于一种if线的展开，而且剧情衔接上总感觉莫名其妙，说不出的怪异点，怎么看怎么不舒服。如果只看本篇，甚至灯华的消失我都可以当成结局，但是这after的下饭操作我是真不太懂。</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>游戏的缺点不多但也明显，有一部分对手机必要的解释被放置在了雨音线里，如果没有先通雨音线的话在其他路线中感觉起来会有些牵强，以及灯华线这莫名其妙的塞粪感emmm ，其他方面都可圈可点，仍值得一试。  </p><p>其中特别要说的就是tone社特有的分段式恋爱了，不同于窗社等同样注重校园恋爱的会社，tone更倾向于抓住“生活”，没有用一句话勾勒几年，也不会对一个节点过度过度地抒写，这样的优点就让tone社作品地节奏很舒服，并没有赶着人往前走的急迫感，也能切实地感受到情感的变化、剧情的推进等。</p><p>但相对而言，这类“陪伴”型作品的剧本通常要长上不少，有时生活琐事都会成为游玩时的一大感触，可以说，有着这类特征的作品更像是散文诗篇，不进行浓墨重彩的挥洒，而是把情感放在平时不断地氤氲。个人认为这类用文本量换节奏的交换算是值得的，也正是如此，tone社的作品才会有这种悠长的回味，有更深的共感和感动罢。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-8.png"></p><blockquote><p>长久的陪伴，</p><p>才是这世上最深情的告白  </p></blockquote><p>谢谢谢谢你看到这里，因为咱小订阅号嘛看的人也不多，资源就送给关注我的大家啦 后台回复<strong>月彼</strong>或者<strong>相逢于明月映照的彼方</strong>就可以取本体和FD的链接了顺带一提里面攻略都做（翻译）好了，不给个赞鼓励鼓励？（逃）</p><p>再次感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天你学数分了吗？（1）</title>
      <link href="/p/18451.html"/>
      <url>/p/18451.html</url>
      
        <content type="html"><![CDATA[<p>近日来数分课程学习了数项级数（11章）和函数项级数（12章），倍感学习之苦（逃），所以就花了些功夫整理了下基础的笔记和定理之类的，当作个备忘录，也拿出来和大家分享分享，和同志们一起进步。其实11章算是为12章做下铺垫把，其中的重难点并不多，大部分是延续上学期末尾讲述的无穷积分部分，两者有相似之处。而12章的函数项级数相当于给数项级数多加了一个自由变化的未知量，虽然前面的题目也出现过类似的情况，不过当时是把它当作恒定不变的参数，而这里则成了探讨的一大重点。<br>类似的，12.4的幂函数内容也是对前面内容的一个拓延，把泰勒展开的完全形式搬了出来，让整个体系更加的完整。（也给我整不会了）</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/5.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/6.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/7.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/8.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/9.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/10.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/1.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/2.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/3.jpg"></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/4.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Fundamental </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> Fundamental </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>于悲剧之下抗争，于星光之下颂歌——浅谈《水葬银货的Istria》</title>
      <link href="/p/60862.html"/>
      <url>/p/60862.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共4099字</p><p>预计阅读时间：17分钟</p></blockquote><p><strong>『抛弃某人获得的未来，在我眼里已经失去了幸福的色彩』</strong></p><p>朋友们你们好啊，这是第二篇杂谈，今日也请多多指教。 </p><p>请注意：本文谈及的游戏包含少部分心理崩坏、监禁、血腥、欺诈等悲剧色彩的消极内容，同时也用那些不幸来衬托了真实与美好，在写作时我也尽量减少消极方面的涉及，如果您在我分享完杂谈过后对它还有兴趣的话，请来文末寻找回复词去体验，之后的分享估计也会提供相应资源吧（不咕的话）。</p><h2 id="Part-0-序言"><a href="#Part-0-序言" class="headerlink" title="Part 0 序言"></a><strong>Part 0 序言</strong></h2><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-9.png"></p><p>今天我们来谈谈发生在ルクル笔下架空世界的故事吧——那是一个关于眼泪、牺牲与恶意的故事、一部裹挟着英雄星光与向恶意反抗的<strong>正剧——《水葬银货的Istria》</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-10.png"></p><p>起初见到这部作品的时候，我并没有意识到它的杀伤力（哎你看回想里总共20个Hcg你告诉我这怎么输，怎么输啊哈哈哈哈哈），然后Episode1还没结束我就放弃了那个愚蠢的想法，至少没法笑着推进剩余的剧情了。 </p><p>为什么？ </p><p>因为这个故事的起源本就是一场悲剧，孕育自悲剧的故事自然难有完美的结局啊kora（无emo意，这里代指游戏）。</p><h2 id="Part-1-相关信息"><a href="#Part-1-相关信息" class="headerlink" title="Part 1 相关信息"></a><strong>Part 1 相关信息</strong></h2><p><strong>日文名称</strong>：水葬銀貨のイストリア</p><p><strong>品牌</strong>：ウグイスカグラ</p><p><strong>剧本</strong>： ルクル</p><p><strong>又名</strong>：水葬银货、水葬银币的Istoria </p><h3 id="游戏简介"><a href="#游戏简介" class="headerlink" title="游戏简介"></a>游戏简介</h3><p>水上都城 · アメマドイ。<br>这座建于海上的人工岛是秀丽多姿的花锦之地。<br>住在此处的我们——身负着种种烦恼。礼仪端正、心地善良的青梅竹马、煤谷小夜。<br>异想天开的妹妹、茅崎 夕桜。<br>憧憬英雄的后辈、小不動ゆるぎ。<br>卡在小巷里的垃圾箱之中的、汐入玖々里。<br>还有本人、茅崎英士。<br>一连串的阴谋、事件在等待着心灵受创的我们。<br>时而赌上部室来玩神经衰落（卡牌游戏）。<br>又或与被抛弃的少女一起玩抽鬼牌。<br>在倾心于夜空中绽放的礼花时、又不禁想要填补残缺的空洞。<br>以自己的做法、为成事而努力拼搏。<br>这样的我、若能帮到谁的话——<br>「——向你约定、幸福的结局」<br>愿所有人都能露出笑容。<br>在这遗失了泪水的都市里、我们的成长物语拉开了帷幕——</p><p>（以上内容摘自网站2dfan<strong>）</strong> </p><h3 id="人物出场表"><a href="#人物出场表" class="headerlink" title="人物出场表"></a>人物出场表</h3><p>茅崎英士：男主，背负着事实的真相和许多重担，想要保护身边的一切。</p><p>汐入玖玖里：英士在垃圾桶中捡到的少女。</p><p>煤谷小夜：英士的青梅竹马，总是叫英士“哥哥”，有很强的依恋感。</p><p>茅崎夕樱：英士的一抹多，性格古怪离奇。</p><p>小不动摇：后辈学妹，正义感十足。  </p><p>井土谷祈吏：小夜的幼年玩伴、青梅竹马。</p><p>C·A：杀死小夜父亲的凶手（实为茅崎英士）。</p><p>八椚红叶：C·A的主人。</p><p>神峰灯：红叶的手下，C·A的同伙，英士的朋友。</p><p>久末紫子：久末家（最大势力）的现任当家，红叶的对手。</p><p>久末紫乃：紫子的妹妹，第三代人鱼姬。</p><p>茅崎征士：英士、夕樱的父亲，老坏蛋了（</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-11.png"></p><p>茅崎英士</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-12.png"></p><p>汐入玖玖里</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-13.png"></p><p>煤谷小夜</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-14.png"></p><p>茅崎夕樱</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-15.png"></p><p>小不动摇</p><p>主线故事建立在一个架空的<strong>人鱼公主童话</strong>的基础上：很久以前，有一名无私为他人奉献的少女，她的泪水能够治愈一切伤病。她不断地为他人的幸福流泪，村民们也非常感激她，大家过着安定而平和的生活。</p><p>然而某日，少女意识到自己的泪水将折损寿命，于是便不再为村民流泪。贪婪的村民们对此毫不在意，仍然强迫少女为自己流泪，柔弱的少女只能在悲伤中不断消耗着所剩无几的生命，渐渐滋生了怨恨。最终，少女的生命走到尽头，化作泡沫回归大海。</p><p>临终前，她含恨诅咒这些没有血与泪的村民们永远无法流泪，而这竟成为了现实。惊慌失措的村民们为了赎罪，求得这位人鱼公主的原谅，将她生前最喜欢的苹果投入大海。</p><p>然而少女的怨恨并未因此消除，村民们世世代代失去了流泪的能力，无论遭到怎样的痛苦与悲伤，都无法流出一滴眼泪。</p><p><strong>Amemadoi</strong>，就是一座如此诅咒缠身的小岛。人人都向往其上久末医院传说中能够瞬间治疗任何创伤的魔术，可却不知道这辉煌的魔术是用一代代人鱼姬的性命与泪水堆砌而来的。而人鱼公主又难以寻觅，但当一个人心中充斥的只是为他人奉献的情感时，或许会有奇迹发生（？）。巧合的是，故事中的主人公或多或少都与人鱼姬有着不可割舍的联系。</p><p><strong>『鸟笼事件』</strong>，岛上的居民这样称呼它，那个彻底改变两个少女和一个少年命运的悲剧事件：</p><p>茅崎征士绑架了三人并实施了非法监禁，而且还施加了精神上的折磨。茅崎夕樱不再表露真实的情感，煤谷小夜成了没有“哥哥”就活不下去的依恋症患者，而英士不得不背负痛苦与真相前进。 </p><p>过多剧情不再在此讲述，文章已经很拖沓了（）顺带一提一个小点：赌场的Ace公子哥C·A，正是茅崎英士的日语发音的前两个音节（Chigasaki Eishi），背负着这样罪名前行的他，实在是可笑啊。</p><h2 id="Part-2-不足在何"><a href="#Part-2-不足在何" class="headerlink" title="Part 2 不足在何"></a><strong>Part 2 不足在何</strong></h2><p>先来说说差的地方吧：水葬银货中的败笔当为个人线的塑造。说实话，太不走心了：没有铺垫的冲突像是生硬补充出来的；离谱的剧情好像故意为了r18场景和选择个人线而准备，甚至。。。小不动摇这条线甚至还没让人回过味来，就在『我们舍弃了一切，自私地获得幸福』『爱之花，肆意怒放』这样自甘堕落的话语中落幕。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-16.png"></p><p>等会等会，请允许我来个问号❓</p><p>共通章中向往正义的小不动摇怎么最后反而选了最自私的一种ending方式？这不白塑造形象了？亏我还对这个阳光学妹有所好感（） </p><h2 id="Part-3-扑克与选择"><a href="#Part-3-扑克与选择" class="headerlink" title="Part 3 扑克与选择"></a><strong>Part 3 扑克与选择</strong></h2><p>主人公英士自小就用扑克战斗，所以选择肢的外观也像扑克一样，而这内容嘛。。。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-17.png"></p><p>这，这tm是人能想出来的阴间说法？不是说你打算拯救谁，那种成为英雄但整个故事差一点点圆满、只能保护一个人的遗憾；</p><p>而是说你打算抛弃谁，“见死不救”，把加害者的名头安在英士头上，让他永远无法逃离这个痛苦的选择。</p><p>真不愧是极恶啊，把绝望如此肆意播撒，确实符合痛苦这个关键词了。</p><p>而『都不抛弃』，却是直指TrueEnding的一个选择，很简单啊，选择其中的任何一方都代表着妥协，放弃了赢下去的希望。红叶也都会对英士表示“放弃你”的态度。</p><p>都不放弃，虽然意味着结局未知，但这种前路飘渺的感觉才给人以动力。</p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-18.png"></p><p>——在通往成功的赌桌前，最终的选项如上</p><p>是一鼓作气，选择Call（跟注）迎来逆转；还是冷静处事，选择Fold（弃牌）明哲保身呢？</p><p>『无论如何都不能放弃，开阔视野，保持冷静』</p><p>这是宗名教给他的原则，</p><blockquote><p>我不能放弃——所以『都不抛弃』</p><p>保持冷静——所以『Fold』</p></blockquote><p>正是在这种选择过后，英士才能以自己的真面目回应小夜，继续前行。</p><h2 id="Part-4-品鉴"><a href="#Part-4-品鉴" class="headerlink" title="Part 4 品鉴"></a><strong>Part 4 品鉴</strong></h2><p>啊终于来到了我最喜欢的音乐鉴赏环节</p><p>这次的配乐我久违的想打出满分，虽然所有的24首乐曲没有一首铿锵有力能够鼓舞人，但是大部分曲子也能在柔和的曲风中给人以力量。。。令人敬佩呐。</p><p>尤其是OP《アズライトの棺》，悲伤而悠扬的女高音孤独的歌颂着人鱼公主的故事，即使沉入海底，也会有人来将你守护。再配上MV的视觉效果，耀眼流转的微小光束与大体深蓝的背景色相互映衬，可以说是一种微弱的壮观吧。</p><p>而去除人声的Inst Ver更利用弦乐营造了更加深邃的意境，高低声部的糅合流畅而自然，连升近一个八度的副歌把前一秒的悲伤倏地放大，仿佛自己也沉没海底、想要挣扎。</p><p>综上，建议欣赏MV！（<strong>底端阅读原文一键享受！！</strong>）</p><p>啊什么你说CG？啊说实话有部分CG实在是比例崩坏严重，这边不放了，影响观感（） </p><h3 id="有关故事核心的一些想法"><a href="#有关故事核心的一些想法" class="headerlink" title="有关故事核心的一些想法"></a><strong>有关故事核心的一些想法</strong></h3><p>人鱼姬为什么能够流泪？是因为内心深处的悲伤？或是因为难以忍受的苦痛？我想，眼泪在Istria中象征的大概是一种无私，一种甘愿奉献的精神吧。</p><p><strong>玖玖里</strong>虽然遭受了姐姐的折磨，但她在姐姐生命危急时刻依旧想要救她，所以她成为了人鱼姬；</p><p><strong>夕樱</strong>和英士一同遭受了鸟笼事件，她可以为自己的哥哥奉献自己的一切，但相对的，她无法对其他人流泪，因为她并不能对所有人温柔；</p><p><strong>久末紫乃</strong>是故事中难得的、纯粹的善，相信着向阳的正义，即使化为泡沫死去也没有怨言；</p><p><strong>紫子</strong>既接受了紫乃的善意，也经历了久末家、茅崎征士的恶意，她在善与恶的夹缝之中走向了自我，但又难逃其重。</p><p><strong>茅崎英士</strong>的本质是温柔的，这毫无异议，但在鸟笼事件之后这份温柔则被恶意扭曲，成了无法宽容自己的枷锁，也成了他逃避和选择的借口。</p><p>所幸，故事最终迎来结局，他也能安心的放下虚伪的面具，让满是苦楚的温柔氤氲临终的紫子，了却掉她一桩心愿了啊。<br>鸟笼事件的受害者、加害者的家属、小夜的弑父凶手、紫子和红叶的C·A、夕樱和小夜的哥哥、摇的可靠前辈、祈使无法原谅的仇人——</p><p>难以想象吧，这些名号都是那个少年——茅崎英士肩上所背负的，他无法摆脱，更无法逃离；他一次次地被打倒，又一次次狼狈起身；他渴望反击，却又如此弱小。我相信结局的那一刻是他的经历和为他付出过的人鱼公主们的眼泪，真正的给了他勇气吧——那可贵的、抗争到底的勇气。  </p><blockquote><p>『当弱者怀抱正义，便可称之为英雄；当英雄开始抗争，他便开始闪耀光芒。』</p></blockquote><p>抗争作为本作的主旋律，从未停止过高鸣。抗争不是做做样子的口头抗议，而是要勇敢地选择艰辛的道路。仅仅是在抉择面前徘徊后选择放弃的行为是不足以称为抗争的，<strong>真正的抗争是在绝望的深渊中重新挺身，再次踏向失败与悲伤的漩涡。</strong></p><p><img src="http://103.151.216.224/wp-content/uploads/2023/03/image-19.png"></p><p>英士无法放弃，但他选择了<strong>放下</strong>；英士无法成为光鲜的英雄，但他依旧<strong>像英雄一般战斗</strong>；英士身上的身份是那么沉重，但他<strong>决意抗争</strong>，选择了走下去。 面对渺小的希望，他没有放弃，在胜负难料的赌桌上搏来了胜利。 </p><h2 id="Part-5-尾声"><a href="#Part-5-尾声" class="headerlink" title="Part 5 尾声"></a><strong>Part 5 尾声</strong></h2><p>虽然水葬银货TE走到最后一幕令人痛苦，但也处在能够接受的范畴之内，不过最后一幕我还是有所失望。并没有皆大欢喜的完美团圆结局，而是采用了英士与红叶继续周旋下去的留白作为结尾，这种结局也许难以让人——至少不能让我满意。很浅显，万物的团圆固然飘渺，但是在苦难的最后，迎接我们的还是苦难吗，最好不是，我相信这也不是水葬这部作品想要传达给我们的。 </p><p>生活不易，但我们仍要一步步向前走去，尽管我们是弱者，也要心怀正义，去做某人的英雄——即使英雄不过是个自我安慰的梦，我们还是要为某人，为那些为我们牺牲过的人们成为英雄，这便是在绝境中重新奋起的勇气。</p><p> 最后的最后，分享游戏OP的一段歌词吧：  </p><p>蒼く深い海の底から</p><p>从苍蓝幽深的海底</p><p>君を連れ出して　光を求める</p><p>将你救出  追寻着光芒</p><p>もう二度と離れてしまわぬように</p><p>为了不让你再次与我分离</p><p>この手伸ばして　護り続ける</p><p>我将伸出这只手  持续着守护</p><p>暗く冷たい海の底へと</p><p>逐渐沉入昏暗冰冷的海底</p><p>光を求めながら　泡となって消える</p><p>一边追寻着光芒  一边化为泡沫消失</p><p>辛辛苦苦写了这么多，求赞求关注求在看捏–后台发送 水葬银货 资源自提捏（</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那是将我们三色交织在一起的绘卷——聊聊《三色绘恋》</title>
      <link href="/p/13345.html"/>
      <url>/p/13345.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>全文共2797字</p><p>预计阅读时间：12分钟</p></blockquote><h2 id="Part-1-序言"><a href="#Part-1-序言" class="headerlink" title="Part 1 序言"></a><strong>Part 1 序言</strong></h2><p>第一次写杂谈，各种想法肯定不够成熟，还请见谅。<br>第一篇，我们来谈谈国Gal<strong>《三色绘恋》</strong>(Tricolour Lovestory)。游戏发行于STEAM，以其超低的定价、庞大的文字量和CG数、刻画高中生活等等特点保有不错的口碑，前段时间公司也因为续集《三色绘恋S》因为版号问题被罚受玩家同情和支持。啊当然指的是在三色TrueEnd发行之前了。现在的情况确是一言难尽，我们之后再聊。</p><p>其实在推完序章之后就一直有为三色想写些什么的想法了，也许故事结构和剧本有不讨巧的地方，或许结局并不尽如人意，但它可以说是我玩过的最贴近日常生活的一款Galgame了。不同于美好的幻想故事、也不同于日G那活跃的校园生活，朋友、成绩、考试、升学，这些无趣的词充斥了我的高中生活，所以在玩到三色之后，便自然会有一种熟悉感和亲近感，就仿佛“啊，当时好像的确是这样过来的啊”，也会不自主地追忆一些东西吧。  </p><h2 id="Part-2-简介"><a href="#Part-2-简介" class="headerlink" title="Part 2 简介"></a><strong>Part 2 简介</strong></h2><p><strong>（可能没多少严重的剧透）</strong></p><p> 2005年，江城的暖秋。 童年有如被铁笼囚住一般，早已自觉为灰色浸染的男孩，第一次走进名为”艺术班”的教室之中。 </p><p>恰巧在同桌的位置上出现的，宛若冰山，却又似轻风薄雾的朝霞一般，紫水晶色的她…… </p><p>被”他们”焚毁象征着同那女孩回忆的画卷时，在炽热的火光下啜泣的，那一抹橘色的她…… </p><p>两个色彩截然不同的少女，同时伸出双手–相会、再会、交织、着色…… </p><p>是墨小菊十年的坚持为自己青涩的青春谱写的画卷， 还是文芷勾勒出梦中那被黑暗枷锁所束缚的世界。 </p><p>梦初醒已十年。 </p><p>三色，是梦中的绘恋。</p><p>故事发生在2005年的“江城武汉”（游戏开发山百合文化公司地址就在武汉，合理），游戏过程中也或多或少地体现了那个时代的小小标签。</p><p>从故事的第一幕开始算起，整个游戏剧情的时间轴（尾声就不计算在内了）总共覆盖了五个月，说长不长，说短也不算短。从盛夏到初冬、从重新和好到再度出发、从初次相识到决意前行，这三个人，这三抹颜色缓缓纠缠混杂，走向了两种截然不同的结局。</p><p>说邱诚“被灰色浸染”，是因为他的童年并不寻常，家长对他严加管教、大打出手，没有丝毫“自由”，但幸而他遇到了墨小菊，他童年里唯一的、不同于灰白的颜色，她一直温暖着他，帮助着他，默默地在后面支持着他，直到十年后，邱诚近乎毫无意义的“反抗”居然真的为他带来了意想不到的自由。不过换下这摇摇欲坠自由的代价，是他和墨小菊之间的关系。</p><p>在艺术班他遇到了“另一个她”，同为插班生，邱诚总是想要接近她，“保护”她，而文芷也承受不住那连绵不断从城墙外递来的善意，缓缓地降下了心防。“我们，真是一模一样呢”，是啊，都是一个人生活，都想寻求自由，都想回报温柔，他们看起来确实很像啊，不过，只是看起来而已吗。。。</p><h2 id="Part-3-浅析"><a href="#Part-3-浅析" class="headerlink" title="Part 3 浅析"></a><strong>Part 3 浅析</strong></h2><p>可以说，Ep0和Ep1的略显紧张的校园喜剧结束过后，邱诚的灰色便一直笼罩在我的心头，每一句台本下我都害怕会出现意料外的状况，这种微妙的平衡便会被一不留神地打破事实证明，也确实如此。</p><p>邱诚度过了一个扭曲的童年，所以他的很多观点和做法都被一并扭曲了；墨小菊伸出手去温柔地安慰他，所以他面对一切一切都想报以温柔。也正是这种扭曲了的温柔，把他们三人紧紧地束缚在这片灰暗的泥沼，难寻出路。</p><p>面对文芷，他仿佛看到了自己以前难获自由的影子，不断地想去帮助她、保护她，却总是忽视掉些什么，总是无功而返；面对墨小菊，他害怕自己的离开会伤害到她，所以他不断地隐瞒、不断地撒谎，播下一个谎言的种子，为的是阻止另一个谎言的破土而出。</p><p>但他没有想到，这所有的谎言都被墨小菊看在眼里；他更没有想到，这些谎言会在那一刻一齐盛开，把他和他的自以为是，统统绞杀在密不透风的“谎言之林”中。</p><p>“我没有一次怪过你，也没有一次觉得你有错，— —那为什么你就非得向我撒谎不可啊！”</p><p>之后的剧情我便不再多说，玩过的朋友可以回忆一下，没玩过的朋友，强烈建议你入一下，新年促只要5块啊，补库存都血赚的好吧（</p><hr><p>很明显，无论选谁，都是不可弥补的伤害，而且越是考虑到第三个人的心情，就越会把事情搞砸。“越是想完美的解决掉所有事情，越是连一件事情都做不好。”好友迟耀曾这么劝告，我深以为然。</p><p>后半程的游戏中，邱诚一直在做这样的工作，把一切抉择和责任都放在自己身上，两边都不想放手，自顾自地朝着自己心目中的方向前进，还会时不时地找借口安慰自己，可最终呢？只能让自己陷得越来越深，直到自己承受不住肩上的重量，才想要放下，但能和他并肩的人早已被他拖拽地伤痕累累，回天乏术。</p><p>因为我是菊党，所以我把墨小菊放在了最后，而过完文芷线后，我却愣是两天没敢动小菊线（刀麻了）。</p><h3 id="Violet-Side"><a href="#Violet-Side" class="headerlink" title="Violet Side"></a>Violet Side</h3><p>“人们总对触手可及的关怀置若罔闻，却好高骛远地追求海市蜃楼般的美好。”骆衍曾经这么说过。</p><p>也正是如此，相遇两个月的文芷教会了邱诚十年来相濡以沫的墨小菊都没办法教会的东西——爱。</p><p>虽然知道自己的父亲会影响他，但文芷还是没办法放弃邱诚的邀请，就算是在聚光灯下戴着镣铐起舞，就算是逃避过后如梦似幻的三天，也足以让文芷明白了邱诚和他的自由是多么的宝贵：“尝到这样甜头的她，还会愿意回去，回到那个冰冷的家吗？”所以他们没有过分停留，而是舔舐伤口过后一同径直走向了violet的终章。</p><h3 id="Orange-Side"><a href="#Orange-Side" class="headerlink" title="Orange Side"></a>Orange Side</h3><p>“墨小菊姐姐是大家的后盾，文芷姐姐带着大家一起往前走。”迟菓这样劝说文芷。</p><p>起初我不理解为什么在小菊线里依旧有这么多文芷的戏份，直到我再次读到这份剧情，邱诚和墨小菊两个人是不会前进的，只有文芷的加入，才让原本的两色转变为三色，未来更添变数。只有先解决文芷在邱诚心中迟迟纠结的问题，邱诚才能完全地接受墨小菊，不是因为青梅竹马，不是因为其他原因，而是对墨小菊十年的付出的响应，所以邱诚和墨小菊在心意相通后依旧优先解决的是文芷的考试，最终邱诚也狠下心来拒绝了文芷。也正是这些改变了文芷，让她反抗父亲“给我留下”的命令，明白了自己的追求、自己的自由。</p><p>“</p><p>先是试探，再是猜测。——最后庆幸不已，抑或大失所望。</p><p>我们如同植在裂纹的两端。随着地壳的迸裂，慢慢地越离越远。</p><p>尽力向彼此伸出的枝芽，慢慢地也因为不停地碰触，而磨损得圆滑而迟钝。</p><p>”</p><h2 id="Part-4-回想"><a href="#Part-4-回想" class="headerlink" title="Part 4 回想"></a><strong>Part 4 回想</strong></h2><p>所幸，他们走了出来，从灰黑的泥沼中爬出，在千辛万苦确认到的信任中蹒跚向着Orange的终章。</p><p>这故事原本就不是对等的啊，哪会有完美的结局呢？那个说“我没关系的”女孩和那个说“我相信你”的女孩，她们又是怎么想的呢？对我来说，我想做的又是什么呢？回头望向那个等了你十年的女孩子吧，去感受她不离不弃的温柔触碰吧，去回应她十年来的妥协与支持吧，去让她变得幸福吧</p><p>毕竟，那可是黯淡无光的灰色和乐观活力的橙色交织的十年啊。</p>]]></content>
      
      
      <categories>
          
          <category> D_Dimension() </category>
          
          <category> Galgame </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Galgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUAA-OS-2023-Lab0-Report</title>
      <link href="/p/90ed62b0.html"/>
      <url>/p/90ed62b0.html</url>
      
        <content type="html"><![CDATA[<h1 id="BUAA-OS-2023-Lab0-Report"><a href="#BUAA-OS-2023-Lab0-Report" class="headerlink" title="BUAA-OS-2023-Lab0-Report"></a>BUAA-OS-2023-Lab0-Report</h1><blockquote><p>写这一篇的时候还没准备要开博客，所以也就没想就直接截图了</p><p>算了盒了就盒了吧</p></blockquote><h1 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h1><blockquote><ul><li>  <code>git</code>中的<code>status</code>信息提示</li><li>  工作区、暂存区与文件树</li></ul></blockquote><p>首先使用<code>git checkout -b learnGit</code>，在本地创建并检出一个新的分支 然后再根据<code>Thinking</code>中给出的要求对<code>README.txt</code>文件进行一系列操作，并在操作后进行提交</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530699.png" alt="image-20230305153053676"></p><p>然后观察目录中的<code>Untracked.txt</code>、<code>Stage.txt</code>，其区别在于把<code>README.txt</code>移动到了暂存区，git显示的说明不同</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051530519.png" alt="image-20230305152953421"></p><p>提交后再次修改文件，最终的<code>Modified.txt</code>内容如下：</p><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051537728.png" alt="image-20230305153714706"></p><ul><li>  <code>add</code>前，<code>README.txt</code>文件不处于仓库跟踪范围内，在“未跟踪的文件：”分类中；<code>add</code>后被git追踪到修改记录，提示有修改、暂未提交</li></ul><p> </p><h1 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h1><blockquote><ul><li>  常见<code>git</code>指令：<code>add</code>、<code>commit</code></li></ul></blockquote><ul><li>  <code>add the file</code>：使git开始追踪某个文件，即<code>git add filename</code>指令</li><li>  <code>stage the file</code>：把修改过的文件加入暂存区，即<code>git add filename</code>指令</li><li>  <code>commit</code>：提交本次暂存区里保存的内容，回到初始状态，即<code>git commit</code>指令</li></ul><p> </p><h1 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h1><blockquote><ul><li>  使用<code>git rm</code>进行<strong>工作区</strong>文件删除</li><li>  <code>git checkout</code>使得<strong>暂存区</strong>文件回退至工作区</li><li>  使用<code>git checkout &lt;版本&gt; filename</code>进行其他版本的文件拉取</li></ul></blockquote><ol><li> 当本地文件被删除，但还没有提交时，可以使用<code>git checkout print.c</code>指令，把暂存区中的<code>print.c</code>文件拉到工作区</li><li> 执行<code>git rm print.c</code>后，不仅删除了工作区的文件，还把这次删除<code>add</code>到了暂存区，此时工作区和暂存区都不存在需要的文件了，可以使用<code>git restore --staged print.c</code>再把<code>print.c</code>的修改拉回工作区 （如果<code>commit</code>了还可以使用<code>git checkout HEAD^ &lt;filename&gt;</code>从上一个提交版本处把删除前的文件拉回本地）</li><li> 执行<code>git rm --cached &lt;filename&gt;</code>指令，可以只删去暂存区的文件内容，而不对本地的文件进行删除（与不加<code>--cached</code>对比）。可以使用这条指令，把文件从跟踪目录里移出</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051600387.png" alt="image-20230305160023353"></p><blockquote><p>进行实验时的部分操作</p></blockquote><p> </p><h1 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h1><blockquote><ul><li>使用<code>git reset --hard</code>进行git版本回退<ul><li>  可以回退<code>HEAD^^^^</code>或<code>HEAD~4</code>，也可以根据已知的<code>hash</code>值进行任意的跳转</li><li>  <code>--hard</code>会强制把工作目录中未提交的文件数据删除，<strong>并不做保留</strong>，使用前注意暂存区、工作区内容</li></ul></li><li>  <code>git log</code>信息与<code>git reset</code></li></ul></blockquote><ol><li> 先进行三次文件修改与<code>commit</code>操作：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051602484.png" alt="image-20230305160255454"></p><ol start="2"><li> 记录下的<code>git log</code>如下：提交3的hash值为<code>8974e1e6e98f726886103a13cba43fcd4fa08acf</code></li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051604438.png" alt="image-20230305160406404"></p><ol start="3"><li> 版本回退后查看log发现最近一次提交记录消失了：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051606728.png" alt="image-20230305160621703"></p><ol start="4"><li> 使用<code>git reset --hard &lt;hashcode&gt;</code>（hashcode填入提交“1”时的）回到了版本”1”；再把hashcode换成版本”3”的值，会切换回版本”3”</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051609979.png" alt="image-20230305160955957"></p><p> </p><h1 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h1><blockquote><ul><li>  重定向与管道</li></ul></blockquote><ol><li> 操作指令执行后显示如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051615424.png" alt="image-20230305161546400"></p><ol start="2"><li> <code>echo</code>指令向标准输出中输出后续内容，使用<code>&gt;</code>可把输出定向到符号后的文件（重写）；使用<code>&gt;&gt;</code>符号可把输出<strong>追加</strong>到目标文件中</li></ol><p> </p><h1 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h1><blockquote><ul><li>  重定向与文件</li><li>  <code>echo</code>指令与输出转义</li></ul></blockquote><ol><li> <code>command</code>文件使用了<code>echo</code>指令将每一行指令都输出到标准输出，再使用<code>&gt;&gt;</code>把输出重定向到<code>test</code>文件中，文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051639790.png" alt="image-20230305163906756"></p><blockquote><p>使用<code>echo</code>指令输出时需要注意转义字符的使用，如<code>$</code>、<code>&gt;</code>等字符都需要转义，否则会起到错误的效果 转义字符是<code>\</code>，不是<code>$</code>（后者是取值的意思）</p></blockquote><ol start="2"><li> <code>test</code>执行后的<code>result</code>文件内容如下：</li></ol><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202303051638470.png" alt="image-20230305163845452"></p><ol start="3"><li>结果说明：<ol><li> <code>test</code>文件中的所有没有重定向输出的<code>echo</code>语句都是提示性信息，并输出至控制台界面</li><li> 文件创建了三个变量，并分别对其进行赋值（其中变量<code>c</code>的值来自<code>ab</code>两变量的值之和）</li><li> 三个变量的值在有重定向的<code>echo</code>命令下被输出到对应的文件（<code>file1</code>、<code>file2</code>、<code>file3</code>）中，最终结果被连接并借助<code>file4</code>存入<code>result</code>中</li></ol></li><li><code>echo echo Shell Start</code> 与<code>echo `echo Shell Start` </code>效果是否有区别<ol><li> 没有区别，效果都是向控制台输出<code>echo Shell Start</code></li></ol></li><li><code>echo echo $c&gt;file1</code> 与<code>echo`echo $c&gt;file1` </code>效果是否有区别<ol><li> 有区别，前者向<code>file1</code>中写入了<code>echo \$c</code>信息；后者在控制台中输出了<code>echo \$c&gt;file1</code></li></ol></li></ol><p> </p><h1 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h1><ul><li>  在<code>git</code>上，如果只按照最简单的操作去做的话目前还能正常使用，但如果出现版本选择、文件回退等操作就会因为许多指令不易区分而犯难，之后需要把各指令意义进行划分，匹配在图中便于记忆</li><li>  <code>awk</code>指令的使用，正则表达式该如何在<code>awk</code>中使用也是指令实现的一大难点</li></ul><h1 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h1><p>在lab0的课下实验中，我不仅复习了在<code>pre</code>阶段学到的知识：如git、makefile、文本处理、重定向，还对它们的具体实现有了更深的了解。在刚开始的学习过程中，<code>CLI</code>的使用、Linux基础命令、命令行参数的选取都是学习路上的困难，也是后面lab的基础。这些点需要勤练常用才能更好地运用在之后的实验中，便利之后的实验。</p>]]></content>
      
      
      <categories>
          
          <category> Elevate() </category>
          
          <category> Operating System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BUAA </tag>
            
            <tag> Elevate </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>世界，您好！</title>
      <link href="/p/bbc48f3a.html"/>
      <url>/p/bbc48f3a.html</url>
      
        <content type="html"><![CDATA[<div>    <script type="text/javascript" src="../js/outdate.js"></script></div><p>欢迎使用WordPress。这是您的第一篇文章。编辑或删除它，然后开始写作吧！</p>]]></content>
      
      
      <categories>
          
          <category> uncategorized </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
