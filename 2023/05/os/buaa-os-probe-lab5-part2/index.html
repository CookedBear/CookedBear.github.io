<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-Probe-Lab5-Part2 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="当实现完 Part1 中的函数后，磁盘就通过 fsformat 程序成功地生成了。在继续之前，建议大家看一看指导书的这个图，这个文章的顺序大概是：文件系统服务进程→交互区→用户进程  接下来我们正式进入内核，处理后续工作。 块缓存 块缓存指的是借助虚拟内存来实现磁盘块缓存的设计。  在 MOS 系统中，文件管理“系统”，是以一个进程的形式存在的，它通过从磁盘中读写数据，并与其他用户进程交互来实现文">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-Probe-Lab5-Part2">
<meta property="og:url" content="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab5-part2/index.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="当实现完 Part1 中的函数后，磁盘就通过 fsformat 程序成功地生成了。在继续之前，建议大家看一看指导书的这个图，这个文章的顺序大概是：文件系统服务进程→交互区→用户进程  接下来我们正式进入内核，处理后续工作。 块缓存 块缓存指的是借助虚拟内存来实现磁盘块缓存的设计。  在 MOS 系统中，文件管理“系统”，是以一个进程的形式存在的，它通过从磁盘中读写数据，并与其他用户进程交互来实现文">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-05-19T14:27:44.000Z">
<meta property="article:modified_time" content="2023-05-23T11:48:10.175Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab5-part2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-Probe-Lab5-Part2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-23 19:48:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-Probe-Lab5-Part2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-19T14:27:44.000Z" title="发表于 2023-05-19 22:27:44">2023-05-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T11:48:10.175Z" title="更新于 2023-05-23 19:48:10">2023-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MOS-Probe/">MOS Probe</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-Probe-Lab5-Part2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>当实现完 Part1 中的函数后，磁盘就通过 <code>fsformat</code> 程序成功地生成了。在继续之前，建议大家看一看指导书的这个图，这个文章的顺序大概是：文件系统服务进程→交互区→用户进程</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305181232771.png?imageMogr2/format/webp" alt="lab5_total"></p>
<p>接下来我们正式进入内核，处理后续工作。</p>
<h1 id="块缓存"><a href="#块缓存" class="headerlink" title="块缓存"></a>块缓存</h1><ul>
<li><strong>块缓存</strong>指的是借助虚拟内存来实现磁盘块缓存的设计。</li>
</ul>
<p>在 MOS 系统中，文件管理“系统”，是以一个进程的形式存在的，它通过从磁盘中读写数据，并与其他用户进程交互来实现文件的管理，这些被使用到的文件就会先被<strong>缓存</strong>在文件服务进程的进程空间中。类似于批发商从生产商处取货，存储在自己的仓库里，使用时再拿出来给下级的经销商（x）</p>
<p>我们规定，文件管理进程使用大小为 <code>DISKMAX</code> 字节的空间作为磁盘块的缓存区，并且缓存区的存取<strong>单位为磁盘块</strong>。每个磁盘块都应该在内存中有<strong>单独相对应的位置</strong>进行缓存，这样就限制了我们内核支持的最大磁盘大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAP 0x10000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISKMAX 0x40000000</span></span><br></pre></td></tr></table></figure>

<p>为了在磁盘块和内存之间进行交换，我们需要准备一系列辅助和工作函数，而这系列的共 35 个函数都被放置在 <code>fs/fs.c</code> 文件中。（file service？）</p>
<h2 id="fs-c-中的磁盘块操作函数"><a href="#fs-c-中的磁盘块操作函数" class="headerlink" title="fs.c 中的磁盘块操作函数"></a><code>fs.c</code> 中的磁盘块操作函数</h2><p>我们通过简单的函数，一步一步组合执行复杂的功能，有以下函数：</p>
<h3 id="diskaddr-Exercise-5-6"><a href="#diskaddr-Exercise-5-6" class="headerlink" title="diskaddr - Exercise 5.6"></a>diskaddr - Exercise 5.6</h3><p>和上文的块缓存相对应，返回某个特定块在文件管理系统进程内存中<strong>应该被放置到</strong>的虚拟地址，实际上就按照上面提的线性映射就行了，一块一块挨着排</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">diskaddr</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Exercise 5.6: Your code here. */</span></span><br><span class="line">	u_int addr = DISKMAP + blockno * BY2BLK;</span><br><span class="line">	<span class="keyword">if</span> (addr &gt; DISKMAX + DISKMAP) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;illegal blockno_addr!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> (<span class="type">void</span> *) <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">void</span> *) addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="va-is-mapped-amp-block-is-mapped"><a href="#va-is-mapped-amp-block-is-mapped" class="headerlink" title="va_is_mapped &amp; block_is_mapped"></a>va_is_mapped &amp; block_is_mapped</h3><p><code>va_is_mapped</code> 检查文件管理进程中某个虚拟地址是否被使用</p>
<p>通常情况下不会单独使用，一般配合 <code>diskaddr</code> 在 <code>block_is_mapped</code> 中使用</p>
<p><code>block_is_mapped</code> 则检查特定的磁盘块是否使用块缓存装入了内存。其实觉得应该叫 block is mapped <strong>at</strong> 比较合适，因为返回的是映射所在的地址（返回 NULL 说明映射在空气里了）</p>
<p>由于块缓存是<strong>一一对应</strong>的，所以只要查虚拟地址的使用，就能获得独一的磁盘块是否有了缓存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this disk block is mapped in cache.</span></span><br><span class="line"><span class="comment">//  Returns the virtual address of the cache page if mapped, 0 otherwise.</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">block_is_mapped</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);  <span class="comment">// 获取块映射的缓存虚拟地址</span></span><br><span class="line">	<span class="keyword">if</span> (va_is_mapped(va)) &#123;        <span class="comment">// 查一下虚拟地址用没用</span></span><br><span class="line">		<span class="keyword">return</span> va;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_mapped</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (vpd[PDX(va)] &amp; PTE_V) &amp;&amp; (vpt[VPN(va)] &amp; PTE_V);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="map-block-amp-unmap-block"><a href="#map-block-amp-unmap-block" class="headerlink" title="map_block &amp; unmap_block"></a>map_block &amp; unmap_block</h3><p>光检查还不行，也得有形成/解除映射的函数不是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">map_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: 如果已经映射，返回 0 */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (1/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="comment">/* Step 2: 使用系统调用申请一个含 PTE_D 的页面，通过 diskaddr 查询映射的虚拟地址 */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (2/5) */</span></span><br><span class="line">	<span class="keyword">return</span> syscall_mem_alloc(syscall_getenvid(), diskaddr(blockno), PTE_D |PTE_V);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmap_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: 获得指定块的映射地址，没映射就是 NULL */</span></span><br><span class="line">	<span class="type">void</span> *va;</span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (3/5) */</span></span><br><span class="line">	va = block_is_mapped(blockno);</span><br><span class="line">	<span class="keyword">if</span> (va == <span class="number">0</span>) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="comment">/* Step 2: 如果磁盘中块仍使用，缓存还 DIRTY 了，解除映射之前要先写回 */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (4/5) */</span></span><br><span class="line">	<span class="keyword">if</span> (!block_is_free(blockno) &amp;&amp; block_is_dirty(blockno)) &#123;</span><br><span class="line">		write_block(blockno);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Step 3: 通过系统调用解除地址映射 */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.7: Your code here. (5/5) */</span></span><br><span class="line">	syscall_mem_unmap(syscall_getenvid(), va);</span><br><span class="line"></span><br><span class="line">	user_assert(!block_is_mapped(blockno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="write-block-amp-read-block"><a href="#write-block-amp-read-block" class="headerlink" title="write_block &amp; read_block"></a>write_block &amp; read_block</h3><p>形成映射的下一步，就是把数据写到内存之中了</p>
<p>要注意 <code>write_block</code> 是写到磁盘里，<code>read_block</code> 是写到内存里，也就是 write <strong>to</strong> block &amp; read <strong>from</strong> block</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: 检查内存中是否映射，没映射 = 没数据，肯定没法写回 */</span></span><br><span class="line">	<span class="keyword">if</span> (!block_is_mapped(blockno)) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;write unmapped block %08x&quot;</span>, blockno);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step2: 使用 ide_write 把当前缓存块写回 */</span></span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	ide_write(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  **blk != 0 ，则向 *blk 中存入写入后的虚拟地址</span></span><br><span class="line"><span class="comment">//  **isnew != 0，则按照以下规则更新 *isnew：</span></span><br><span class="line"><span class="comment">//  	*isnew = 0: 虚拟地址原本就被写入过</span></span><br><span class="line"><span class="comment">//  	*isnew = 1: 虚拟地址此前没有写入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  (Isnew lets callers like file_get_block clear any memory-only </span></span><br><span class="line"><span class="comment">//  fields from the disk blocks when they come in off disk.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_block</span><span class="params">(u_int blockno, <span class="type">void</span> **blk, u_int *isnew)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: 检查 blockno 的合法性 */</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks) &#123; user_panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line">	<span class="comment">/* Step 2: 检查磁盘中块是否有效，如果磁盘块是 free 的，说明里面没东西 */</span></span><br><span class="line">	<span class="comment">// Hint: 读之前要先读一下 bitmap 是不是倒进内存里了</span></span><br><span class="line">	<span class="comment">//  If the bitmap is NULL, indicate that we haven&#x27;t read bitmap from disk to memory</span></span><br><span class="line">	<span class="comment">//  until now. So, before we check if a block is free using `block_is_free`, we must</span></span><br><span class="line">	<span class="comment">//  ensure that the bitmap blocks are already read from the disk to memory.</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno)) &#123; user_panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno); &#125;</span><br><span class="line">	<span class="comment">/* Step 3: 找到待写入的虚拟地址 */</span></span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	<span class="comment">/* Step 4: 读入内存，更新 *isnew */</span></span><br><span class="line">	<span class="comment">// Hint: 如果已经 mapped 则只更新 isnew，否则先 alloc 页面，再 read</span></span><br><span class="line">	<span class="keyword">if</span> (block_is_mapped(blockno)) &#123; <span class="comment">// 已经 mapped</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">0</span>; &#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;                        <span class="comment">// 未 mapped</span></span><br><span class="line">		<span class="keyword">if</span> (isnew) &#123; *isnew = <span class="number">1</span>; &#125;</span><br><span class="line">		syscall_mem_alloc(<span class="number">0</span>, va, PTE_D);                <span class="comment">// 申请页面</span></span><br><span class="line">		ide_read(<span class="number">0</span>, blockno * SECT2BLK, va, SECT2BLK);  <span class="comment">// 使用 ide_read 读入页面</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* Step 5: 赋值 *blk */</span></span><br><span class="line">	<span class="keyword">if</span> (blk) &#123; *blk = va; &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="block-is-free-amp-free-block"><a href="#block-is-free-amp-free-block" class="headerlink" title="block_is_free &amp; free_block"></a>block_is_free &amp; free_block</h3><p>这两个函数改变的是内存中存放的 <code>bitmap</code> 数组，检查磁盘中是否使用了这个块/操作块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  通过内存中的 bitmap 检查 block 是否在磁盘中有效</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_free</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">    <span class="comment">// blockno 不合法，一定不有效</span></span><br><span class="line">	<span class="keyword">if</span> (super == <span class="number">0</span> || blockno &gt;= super-&gt;s_nblocks) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 查 bitmap，如果指定位为 1，说明有效</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="comment">// 其余情况无效</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark a block as free in the bitmap.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="comment">/* Step 1: 如果 blockno 不合法，不更改 bitmap */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (1/2) */</span></span><br><span class="line">	<span class="comment">// if blockno = 0, the boot sector will have the chance to be overwrited</span></span><br><span class="line">	<span class="keyword">if</span> (blockno == <span class="number">0</span> || blockno &gt; super-&gt;s_nblocks) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="comment">/* Step 2: 通过位运算改变 bitmap 的值，使指定位置为 1. */</span></span><br><span class="line">	<span class="comment">/* Exercise 5.4: Your code here. (2/2) */</span></span><br><span class="line">	bitmap[blockno / <span class="number">32</span>] |= <span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放第 blockno 个磁盘块时，就需要先找到 <code>bitmap</code> 的对应位，bitmap 的类型是 32 位的，也就是说第 blockno 个磁盘块应该位于第 blockno / 32 个数组元素中，再利用位运算把代表 blockno 的那一位置 1 即可。</p>
<h3 id="alloc-block-num-amp-alloc-block"><a href="#alloc-block-num-amp-alloc-block" class="headerlink" title="alloc_block_num &amp; alloc_block"></a>alloc_block_num &amp; alloc_block</h3><p>这两个函数主要负责管理内存中的 <code>bitmap</code>，带 <code>num</code> 的函数负责申请块，不带的则直接完成了申请+映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Search in the bitmap for a free block and allocate it.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if we are out of blocks.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block_num</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> blockno;</span><br><span class="line">	<span class="comment">// walk through this bitmap, find a free one and mark it as used, then sync</span></span><br><span class="line">	<span class="comment">// this block to IDE disk (using `write_block`) from memory.</span></span><br><span class="line">	<span class="keyword">for</span> (blockno = <span class="number">3</span>; blockno &lt; super-&gt;s_nblocks; blockno++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (bitmap[blockno / <span class="number">32</span>] &amp; (<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>))) &#123; <span class="comment">// the block is free</span></span><br><span class="line">			bitmap[blockno / <span class="number">32</span>] &amp;= ~(<span class="number">1</span> &lt;&lt; (blockno % <span class="number">32</span>));</span><br><span class="line">			write_block(blockno / BIT2BLK + <span class="number">2</span>); <span class="comment">// write to disk.</span></span><br><span class="line">			<span class="keyword">return</span> blockno;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// no free blocks.</span></span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Allocate a block -- first find a free block in the bitmap, then map it into memory.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_block</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, bno;</span><br><span class="line">	<span class="comment">// Step 1: find a free block.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = alloc_block_num()) &lt; <span class="number">0</span>) &#123; <span class="comment">// failed.</span></span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	bno = r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: map this block into memory.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = map_block(bno)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		free_block(bno);</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: return block number.</span></span><br><span class="line">	<span class="keyword">return</span> bno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="read-super-amp-read-bitmap"><a href="#read-super-amp-read-bitmap" class="headerlink" title="read_super &amp; read_bitmap"></a>read_super &amp; read_bitmap</h3><p>在这两个函数中，我们完成了文件管理进程的<strong>基础数据准备</strong>：读取了磁盘的超级块（获得基础信息），同时得到了磁盘的位图 <code>bitmap</code>（占用情况）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">read_super</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line">	<span class="comment">/* Step 1: 读取 super 块，blockno = 1 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(<span class="number">1</span>, &amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		user_panic(<span class="string">&quot;cannot read superblock: %e&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line">	super = blk; <span class="comment">// 把 super 块缓存地址所在的指针赋给进程中的变量 super，便于后续使用</span></span><br><span class="line">	<span class="comment">/* Step 2: 检查 MAGIC NUMBER */</span></span><br><span class="line">	<span class="keyword">if</span> (super-&gt;s_magic != FS_MAGIC) &#123; user_panic(<span class="string">&quot;bad file system magic number %x %x&quot;</span>, super-&gt;s_magic, FS_MAGIC); &#125;</span><br><span class="line">	<span class="comment">/* Step 3: 检查磁盘大小，超过块缓存允许的大小就会 panic，对应了 Thinking */</span></span><br><span class="line">	<span class="keyword">if</span> (super-&gt;s_nblocks &gt; DISKMAX / BY2BLK) &#123; user_panic(<span class="string">&quot;file system is too large&quot;</span>); &#125;</span><br><span class="line">	debugf(<span class="string">&quot;superblock is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Read and validate the file system bitmap.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  把磁盘中表示 bitmap 的几个磁盘块全读取到内存中，并设置一个数组指向它们，代表内存中的 bitmap</span></span><br><span class="line"><span class="comment">//  For each block i, user_assert(!block_is_free(i))) to check that they&#x27;re all marked as in use.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">read_bitmap</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	u_int i;</span><br><span class="line">	<span class="type">void</span> *blk = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* Step 1: 计算块数量，并进行  */</span></span><br><span class="line">	u_int nbitmap = super-&gt;s_nblocks / BIT2BLK + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">		read_block(i + <span class="number">2</span>, blk, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bitmap = diskaddr(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 2: 确保特殊块为 in-use 状态 */</span></span><br><span class="line">	<span class="comment">// Hint: use `block_is_free`</span></span><br><span class="line">	user_assert(!block_is_free(<span class="number">0</span>));</span><br><span class="line">	user_assert(!block_is_free(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: 确保 bitmap 对应的块为 in-use 状态 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nbitmap; i++) &#123;</span><br><span class="line">		user_assert(!block_is_free(i + <span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	debugf(<span class="string">&quot;read_bitmap is good\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="va-is-dirty-amp-block-is-dirty"><a href="#va-is-dirty-amp-block-is-dirty" class="headerlink" title="va_is_dirty &amp; block_is_dirty"></a>va_is_dirty &amp; block_is_dirty</h3><p>与上文类似，之不过检查的是对应的 <code>PTE_DIRTY</code> 位，也就是检查块缓存是否发生了更改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Check if this block is dirty. (check corresponding `va`)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">block_is_dirty</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	<span class="keyword">return</span> va_is_mapped(va) &amp;&amp; va_is_dirty(va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">va_is_dirty</span><span class="params">(<span class="type">void</span> *va)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> vpt[VPN(va)] &amp; PTE_DIRTY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dirty-block"><a href="#dirty-block" class="headerlink" title="dirty_block"></a>dirty_block</h3><p>既然能够对块缓存进行写入，那就一定要有一个能产生 <code>PTE_DIRTY</code> 的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Mark this block as dirty (cache page has changed and needs to be written back to disk).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dirty_block</span><span class="params">(u_int blockno)</span> &#123;</span><br><span class="line">	<span class="type">void</span> *va = diskaddr(blockno);</span><br><span class="line">	<span class="keyword">if</span> (!va_is_mapped(va)) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125;</span><br><span class="line">	<span class="keyword">if</span> (va_is_dirty(va)) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">return</span> syscall_mem_map(<span class="number">0</span>, va, <span class="number">0</span>, va, PTE_D | PTE_DIRTY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="fs-init"><a href="#fs-init" class="headerlink" title="fs_init"></a>fs_init</h3><p>这个函数初始化了文件系统.初始化后，<code>super</code> 和 <code>bitmap</code> 都被缓存到了文件管理进程中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Initialize the file system.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//  1. read super block.</span></span><br><span class="line"><span class="comment">//  2. check if the disk can work.</span></span><br><span class="line"><span class="comment">//  3. read bitmap blocks from disk to memory.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	read_super();         <span class="comment">// 缓存 super 块</span></span><br><span class="line">	check_write_block();  <span class="comment">// 一个测试函数</span></span><br><span class="line">	read_bitmap();        <span class="comment">// 缓存 bitmap 所用块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里，与磁盘块相关的函数就结束了。<code>fs.c</code> 中剩余的函数均以文件为读取单位，它们基于我们刚刚分析的读取块的函数而实现，等文件说完再回来看。</p>
<h2 id="struct-File"><a href="#struct-File" class="headerlink" title="struct File"></a>struct File</h2><p>在 MOS 中，描述文件使用文件控制块 File，其定义于 <code>user/include/fs.h</code>，每个控制块的大小为 256 Byte</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="type">char</span> f_name[MAXNAMELEN]; <span class="comment">// filename</span></span><br><span class="line">	<span class="type">uint32_t</span> f_size;	 <span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="type">uint32_t</span> f_type;	 <span class="comment">// file type</span></span><br><span class="line">	<span class="type">uint32_t</span> f_direct[NDIRECT];</span><br><span class="line">	<span class="type">uint32_t</span> f_indirect; <span class="comment">// points to a block contains pointers</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f_dir</span>;</span> <span class="comment">// the pointer to the dir where this file is in, valid only in memory.</span></span><br><span class="line">	<span class="type">char</span> f_pad[BY2FILE - MAXNAMELEN - (<span class="number">3</span> + NDIRECT) * <span class="number">4</span> - <span class="keyword">sizeof</span>(<span class="type">void</span> *)];</span><br><span class="line">&#125; __attribute__((aligned(<span class="number">4</span>), packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BY2FILE 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNAMELEN 128</span></span><br></pre></td></tr></table></figure>

<p>基础的文件结构不再赘述，需要注意文件控制块中包含一个指向目录的控制块指针，可以用来表示位置；同时还使用 <code>f_pad</code> 域将控制块补全至 256 字节，使得一个 Block 能包含整数个文件块。</p>
<p>前面说了那么多，大部分是从<strong>物理单位</strong>（块、扇区）对磁盘进行操作，实际上我们真正要对磁盘操作时，应该从<strong>逻辑单位</strong>（文件）操作。说白了，文件/磁盘块有点类似于页式存储中段/页的概念。在 <code>load_icode</code> 中我们以页为单位进行了读入，实际上还是为了把整个二进制 ELF 全部读入；文件也类似，要读写文件，最终也是以块为单位出发去实现的。</p>
<h1 id="serv-c-文件系统服务进程"><a href="#serv-c-文件系统服务进程" class="headerlink" title="serv.c - 文件系统服务进程"></a><code>serv.c</code> - 文件系统服务进程</h1><p>与指导书介绍顺序不同，我们这里先讲一下文件系统服务进程。</p>
<h2 id="struct-Open"><a href="#struct-Open" class="headerlink" title="struct Open"></a>struct Open</h2><p>在文件服务进程的源代码中，我们找到了一个新数据结构的定义：<code>Open</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Open</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">o_file</span>;</span> <span class="comment">// mapped descriptor for open file</span></span><br><span class="line">	u_int o_fileid;	     <span class="comment">// file id</span></span><br><span class="line">	<span class="type">int</span> o_mode;	         <span class="comment">// open mode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">o_ff</span>;</span> <span class="comment">// va of filefd page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构可以看成是文件服务的<strong>柜台窗口</strong>，文件管理进程想要打开/操作一个文件，必须先获取一个窗口，然后再在窗口上进行操作。其中的 <code>o_ff</code> 字段大小为一页，我个人把他叫做这个<strong>窗口的工作区</strong>，在工作区中存放了当前操作文件的 <code>Filefd</code> ，并且经常要发生赋值和写入（为了更新文件状态）。</p>
<p>同样的，我们设置了一个管理窗口的数组 <code>opentab</code>，可以对其<strong>标识符</strong> <code>o_fileid</code> 进行遍历，从而获取指定窗口。具体存放结构如图：</p>
<p>总而言之，文件系统进程通过 Open 来管理文件的打开与否，但文件信息大多还是需要 File 和 Filefd</p>
<p>插播一个很巧妙的函数：<code>open_alloc</code>，也即申请空闲窗口的函数。</p>
<h3 id="open-alloc"><a href="#open-alloc" class="headerlink" title="open_alloc"></a>open_alloc</h3><p>为什么说它巧，因为它利用了 <code>pp_ref</code> 字段判断窗口当前是否处于使用中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open_alloc</span><span class="params">(<span class="keyword">struct</span> Open **o)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i, r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find an available open-file table entry</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXOPEN; i++) &#123;</span><br><span class="line">		<span class="keyword">switch</span> (pageref(opentab[i].o_ff)) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="keyword">if</span> ((r = syscall_mem_alloc(<span class="number">0</span>, opentab[i].o_ff, PTE_D | PTE_LIBRARY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			opentab[i].o_fileid += MAXOPEN;</span><br><span class="line">			*o = &amp;opentab[i];</span><br><span class="line">			<span class="built_in">memset</span>((<span class="type">void</span> *)opentab[i].o_ff, <span class="number">0</span>, BY2PG);</span><br><span class="line">			<span class="keyword">return</span> (*o)-&gt;o_fileid;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>因为在下面的开启文件的函数中，最后一步是把窗口的工作区<strong>映射并共享</strong>给请求者，这使得 <code>pp_ref</code> 必然 ≥ 2（自身 + 不少于一个请求者）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br></pre></td></tr></table></figure>



<p>当遍历所有窗口的工作区时，一旦发现 <code>pp_ref == 1</code>，则意味着<strong>所有</strong>请求者都主动释放了该页面（文件不再使用后请求者会自行释放，但文件服务进程永远不会主动释放）。也就意味着当前工作区无人使用，就拿来再次分配了。</p>
<h2 id="文件块-amp-磁盘块-amp-块缓存"><a href="#文件块-amp-磁盘块-amp-块缓存" class="headerlink" title="文件块 &amp; 磁盘块 &amp; 块缓存"></a>文件块 &amp; 磁盘块 &amp; 块缓存</h2><p>开始还有点不解，不是说每个磁盘块都要装到固定的块缓存中吗，在 <code>file_map_block</code> 中指定了块号为什么随便 <code>alloc</code> 了一个就用了呢？</p>
<p>前半句确实是正确的，这是<strong>磁盘块缓存</strong>的要求，但是我们这里“指定”的块号是<strong>文件块号</strong>，它代表文件中的第 filebno 块，而在磁盘中具体怎么存放我们并不关心。</p>
<p>更通俗的讲，可以把文件看成虚拟内存，而磁盘看成物理内存：</p>
<ul>
<li>文件块是逻辑上连续的，每个文件都是如此</li>
<li>磁盘块是物理上连续的，同时，它在装入块缓存时又是一一对应的</li>
<li>相邻的文件块可以通过 <code>alloc_block</code> 函数<strong>映射到</strong>不相邻的磁盘块内</li>
</ul>
<p>但和存储管理不同的是，我们这里并没有什么页表去存放映射关系，<strong>保存映射的是文件管理块</strong>。所以 pgdir_walk 查的是页表， file_block_walk 查的是文件块和文件块内部的数据，如图：</p>
<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305161150782.png?imageMogr2/format/webp" alt="mapping_relation" style="zoom: 10%;" />



<h2 id="fs-c-中的文件操作函数"><a href="#fs-c-中的文件操作函数" class="headerlink" title="fs.c 中的文件操作函数"></a><code>fs.c</code> 中的文件操作函数</h2><p>在文件系统服务函数中，我们可以发现它们大多使用了 <code>file_*</code> 类型的函数，他们来自之前剩一点没讲的 <code>fs.c</code>，剩下的部分是以文件为单位进行交互的函数集合。</p>
<p>现在我们就对这些函数做一些分析。</p>
<h2 id="一图流"><a href="#一图流" class="headerlink" title="一图流"></a>一图流</h2><blockquote>
<p>包含了前面的块操作函数</p>
</blockquote>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236155.svg" alt="fs.c"></p>
<h3 id="file-create"><a href="#file-create" class="headerlink" title="file_create"></a>file_create</h3><ul>
<li>创建 <code>path</code> 指向的文件，返回文件控制块</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Create &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *file to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">f</span>;</span></span><br><span class="line">    <span class="comment">/* Step 1: 主要获取 path 包含的目录，顺便查一下文件是否存在 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, &amp;dir, &amp;f, name)) == <span class="number">0</span>) &#123; <span class="keyword">return</span> -E_FILE_EXISTS; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 路径、过程中的路径不存在，返回错误 */</span></span><br><span class="line">	<span class="keyword">if</span> (r != -E_NOT_FOUND || dir == <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 在指定目录下申请一个文件 */</span></span><br><span class="line">	<span class="keyword">if</span> (dir_alloc_file(dir, &amp;f) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 向文件赋名，返回 */</span></span><br><span class="line">	<span class="built_in">strcpy</span>(f-&gt;f_name, name);</span><br><span class="line">	*file = f;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="file-open-amp-walk-path"><a href="#file-open-amp-walk-path" class="headerlink" title="file_open &amp; walk_path"></a>file_open &amp; walk_path</h3><p>直接调用了另一个函数：<code>walk_path</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  从根目录开始，搜索 path 指向的文件，返回路径目录的控制块和文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">walk_path</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pdir, <span class="keyword">struct</span> File **pfile, <span class="type">char</span> *lastelem)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *p;</span><br><span class="line">	<span class="type">char</span> name[MAXNAMELEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">dir</span>, *<span class="title">file</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// start at the root.</span></span><br><span class="line">	path = skip_slash(path);</span><br><span class="line">	file = &amp;super-&gt;s_root;</span><br><span class="line">	dir = <span class="number">0</span>;</span><br><span class="line">	name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123; *pdir = <span class="number">0</span>; &#125;</span><br><span class="line">	*pfile = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the target file by name recursively.</span></span><br><span class="line">	<span class="keyword">while</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		dir = file;</span><br><span class="line">		p = path;</span><br><span class="line">		<span class="keyword">while</span> (*path != <span class="string">&#x27;/&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;\0&#x27;</span>) &#123; path++; &#125;</span><br><span class="line">		<span class="keyword">if</span> (path - p &gt;= MAXNAMELEN) &#123; <span class="keyword">return</span> -E_BAD_PATH; &#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(name, p, path - p);  <span class="comment">// 截断路径并存入 name 数组中</span></span><br><span class="line">		name[path - p] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		path = skip_slash(path);</span><br><span class="line">		<span class="keyword">if</span> (dir-&gt;f_type != FTYPE_DIR) &#123; <span class="keyword">return</span> -E_NOT_FOUND; &#125; <span class="comment">// 检查途径目录的状态</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = dir_lookup(dir, name, &amp;file)) &lt; <span class="number">0</span>) &#123;  <span class="comment">// 若正常，则应递归查找 path</span></span><br><span class="line">			<span class="keyword">if</span> (r == -E_NOT_FOUND &amp;&amp; *path == <span class="string">&#x27;\0&#x27;</span>) &#123;  <span class="comment">// dir_lookup：path 结束且找不到文件</span></span><br><span class="line">				<span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;</span><br><span class="line">				<span class="keyword">if</span> (lastelem) &#123; <span class="built_in">strcpy</span>(lastelem, name); &#125;</span><br><span class="line">				*pfile = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pdir) &#123; *pdir = dir; &#125;  <span class="comment">// 成功递归出 file 的位置</span></span><br><span class="line">	*pfile = file;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Open &quot;path&quot;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  On success set *pfile to point at the file and return 0.</span></span><br><span class="line"><span class="comment">//  On error return &lt; 0.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_open</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> walk_path(path, <span class="number">0</span>, file, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们的查找从根目录开始（<code>super</code>），一直到路径结束前，都采用递归的形式对路径中每个用“/”分开的文件夹进行<strong>搜索</strong>（dir_lookup）</li>
<li>dir_lookup：如果进入异常退出的分支，则意味着 <code>r == -E_NOT_FOUND</code>（目录里没有这个文件） &amp;&amp; <code>*path == &#39;\0&#39;</code>（找到文件所在的最底一层目录了），也就是文件不存在，应当退出。</li>
</ul>
<h3 id="file-get-block-amp-file-map-block-amp-file-block-walk"><a href="#file-get-block-amp-file-map-block-amp-file-block-walk" class="headerlink" title="file_get_block &amp; file_map_block &amp; file_block_walk"></a>file_get_block &amp; file_map_block &amp; file_block_walk</h3><ul>
<li>file_block_walk：类似 pgdir_walk，获取文件 f 的第 filebno 块在磁盘中的磁盘块号；如果在非直接指针区域、没有间接指针块，会创建一个间接块（但是没有申请 filebno 的块）</li>
<li>file_map_block：上一个函数的封装，获取第 filebno 块在磁盘中的块号；如果文件块 → 磁盘块的映射不存在，则会申请磁盘块形成一个映射</li>
<li><strong>file_get_block</strong>：先获取第 filebno 块在磁盘中的块号，再把数据从磁盘中<strong>读到内存中</strong>（read_block）</li>
</ul>
<p>第三个函数是在服务进程中申请某个地址的内容时使用的，用于把指定地址所在的块一并加载，供用户使用。最后实现时需要把直接指针和间接指针块对外包装出<strong>同等的访问方式</strong>，因此需要在内部处理差异。</p>
<p>前两个是比较底层的工具函数，没有在 fs.c 之外的文件内出现，所以没什么印象也没关系的吧（大嘘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Set *blk to point at the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_get_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">void</span> **blk)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">	u_int isnew;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: 找到文件 f 第 filebno 个块在磁盘中对应的磁盘号</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, filebno, &amp;diskbno, <span class="number">1</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: 从磁盘中读该磁盘号的数据到 blk 中</span></span><br><span class="line">	<span class="keyword">if</span> ((r = read_block(diskbno, blk, &amp;isnew)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OVerview:</span></span><br><span class="line"><span class="comment">//  Set *diskbno to the disk block number for the filebno&#x27;th block in file f.</span></span><br><span class="line"><span class="comment">//  If alloc is set and the block does not exist, allocate it.</span></span><br><span class="line"><span class="comment">//  完整的封装</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_map_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, u_int *diskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: 找到指定块的地址，存在 ptr 里</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, alloc)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: 目标块的地址不存在，根据 alloc 决定是否申请</span></span><br><span class="line">	<span class="keyword">if</span> (*ptr == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		*ptr = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: 类似的，给指针赋值</span></span><br><span class="line">	*diskbno = *ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  获取指定文件 f 的指定块在磁盘中的块号，alloc == 1 &amp;&amp; NINDIRECT 时需要申请指针块</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Post-Condition:</span></span><br><span class="line"><span class="comment">//  Return 0 on success, and set *ppdiskbno to the pointer to the target block.</span></span><br><span class="line"><span class="comment">//  Return -E_NOT_FOUND if the function needed to allocate an indirect block, but alloc was 0.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_DISK if there&#x27;s no space on the disk for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_NO_MEM if there&#x27;s not enough memory for an indirect block.</span></span><br><span class="line"><span class="comment">//  Return -E_INVAL if filebno is out of range (&gt;= NINDIRECT).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_block_walk</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno, <span class="type">uint32_t</span> **ppdiskbno, u_int alloc)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line">	<span class="type">uint32_t</span> *blk;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (filebno &lt; NDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 1: 直接指针，则 ptr 直接指向指定的块</span></span><br><span class="line">		ptr = &amp;f-&gt;f_direct[filebno];</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (filebno &lt; NINDIRECT) &#123;</span><br><span class="line">		<span class="comment">// Step 2: 非直接指针，根据 alloc 决定是否需要为文件申请一个指针块</span></span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alloc == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> ((r = alloc_block()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> r;      <span class="comment">// 申请失败，返回</span></span><br><span class="line">			&#125;</span><br><span class="line">			f-&gt;f_indirect = r; <span class="comment">// 申请成功，建立连接</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Step 3: 把指针块映射到文件管理进程的内存中，这时并没有为目标块创建块缓存</span></span><br><span class="line">		<span class="keyword">if</span> ((r = read_block(f-&gt;f_indirect, (<span class="type">void</span> **)&amp;blk, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line">		ptr = blk + filebno;  <span class="comment">// 令 ptr 指向指针块中的第 filebno 项，也就是第 filebno 块</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: 保存 ptr 的值，返回</span></span><br><span class="line">	*ppdiskbno = ptr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush"><a href="#file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush" class="headerlink" title="file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush"></a>file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush</h3><p>函数的作用是设定指定文件的大小，其中还会调用三个底层函数</p>
<ul>
<li>file_truncate：释放文件缩小后占用多余的块</li>
<li>file_clear_block：实际释放块使用的函数</li>
<li>file_flush：同步文件内容至磁盘，此处用于更新被修改文件的目录，也就是同步目录中的所有文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  设定文件的大小</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_set_size</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 若文件变小，则需要释放多余的块 */</span></span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_size &gt; newsize) &#123; file_truncate(f, newsize); &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 更新文件的大小 */</span></span><br><span class="line">	f-&gt;f_size = newsize;</span><br><span class="line">	<span class="comment">/* Step 3: */</span></span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件多余的占用块，同时注意清理间接指针块</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_truncate</span><span class="params">(<span class="keyword">struct</span> File *f, u_int newsize)</span> &#123;</span><br><span class="line">	u_int bno, old_nblocks, new_nblocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 设定缩小前后所占用的块数量 */</span></span><br><span class="line">	old_nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">	new_nblocks = newsize / BY2BLK + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (newsize == <span class="number">0</span>) &#123; new_nblocks = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 释放多余的块缓存；同时如果缩小到不需要使用间接指针块，则释放间接块 */</span></span><br><span class="line">	<span class="keyword">if</span> (new_nblocks &lt;= NDIRECT) &#123;</span><br><span class="line">		<span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">			file_clear_block(f, bno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (f-&gt;f_indirect) &#123;</span><br><span class="line">			free_block(f-&gt;f_indirect);</span><br><span class="line">			f-&gt;f_indirect = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 否则只单纯释放块缓存，保留间接块 */</span></span><br><span class="line">		<span class="keyword">for</span> (bno = new_nblocks; bno &lt; old_nblocks; bno++) &#123;</span><br><span class="line">			file_clear_block(f, bno);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 更新文件大小 */</span></span><br><span class="line">	f-&gt;f_size = newsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_clear_block</span><span class="params">(<span class="keyword">struct</span> File *f, u_int filebno)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="type">uint32_t</span> *ptr;</span><br><span class="line">    <span class="comment">/* Step 1: 找到 filebno 指定的块地址 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_block_walk(f, filebno, &amp;ptr, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 释放指定块的块缓存 */</span></span><br><span class="line">	<span class="keyword">if</span> (*ptr) &#123;</span><br><span class="line">		free_block(*ptr);</span><br><span class="line">		*ptr = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  同步块缓存中的文件内容至磁盘</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_flush</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line">	<span class="comment">// Your code here</span></span><br><span class="line">	u_int nblocks;</span><br><span class="line">	u_int bno;</span><br><span class="line">	u_int diskno;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">	nblocks = f-&gt;f_size / BY2BLK + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 1: 对文件中所有占用的块遍历 */</span></span><br><span class="line">	<span class="keyword">for</span> (bno = <span class="number">0</span>; bno &lt; nblocks; bno++) &#123;</span><br><span class="line">        <span class="comment">/* Step 2: 获取文件中第 bno 块的磁盘块号 diskno */</span></span><br><span class="line">		<span class="keyword">if</span> ((r = file_map_block(f, bno, &amp;diskno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* Step 3: 如果磁盘块在加载到缓存后被更新过，则写回 */</span></span><br><span class="line">		<span class="keyword">if</span> (block_is_dirty(diskno)) &#123;</span><br><span class="line">			write_block(diskno);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="file-close"><a href="#file-close" class="headerlink" title="file_close"></a>file_close</h3><ul>
<li>比较简单，但是断档继续写的时候，我已经快忘了 <code>file_flush</code> 是干嘛的了（悲</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Close a file.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">file_close</span><span class="params">(<span class="keyword">struct</span> File *f)</span> &#123;</span><br><span class="line">	<span class="comment">// 将文件本身 + 目录同步回磁盘块中</span></span><br><span class="line">	file_flush(f);</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_dir) &#123;</span><br><span class="line">		file_flush(f-&gt;f_dir);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="file-dirty"><a href="#file-dirty" class="headerlink" title="file_dirty"></a>file_dirty</h3><ul>
<li>调用了前面的函数 <code>dirty_block</code>，实现了对指定文件的特定地址的 DIRTY 标识。（在写入 <code>offset</code> 后，为了保证能够同步块缓存和磁盘的数据，需要调用这个函数了）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  标记指定文件地 offset 所在的块为 DIRTY </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_dirty</span><span class="params">(<span class="keyword">struct</span> File *f, u_int offset)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int diskbno;</span><br><span class="line">    <span class="comment">// 使用 file_map_block 找到 offset 对应的磁盘块号</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_map_block(f, offset / BY2BLK, &amp;diskbno, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    <span class="comment">// 把指定磁盘块的块缓存置为 DIRTY</span></span><br><span class="line">	<span class="keyword">return</span> dirty_block(diskbno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="file-remove"><a href="#file-remove" class="headerlink" title="file_remove"></a>file_remove</h3><ul>
<li>通过字符串展示的路径先查询到文件控制块，然后使用将自身大小减为 0 的方式解除所有占用的内存块；最后同步至磁盘内</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  清除文件</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_remove</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 1: 找到要 remove 的文件，指针存到 f 内</span></span><br><span class="line">	<span class="keyword">if</span> ((r = walk_path(path, <span class="number">0</span>, &amp;f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 2: 将体积缩小为 0</span></span><br><span class="line">	file_truncate(f, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 3: 清除名称，查询是否文件是否占用时看的就是 f_name[0]</span></span><br><span class="line">	f-&gt;f_name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Step 4: 同步自身内容和目录内容至磁盘内</span></span><br><span class="line">	file_flush(f);</span><br><span class="line">	<span class="keyword">if</span> (f-&gt;f_dir) &#123; file_flush(f-&gt;f_dir); &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="file-sync"><a href="#file-sync" class="headerlink" title="file_sync"></a>file_sync</h3><ul>
<li>啊我整个大的.jpg</li>
</ul>
<p>对于整个块缓存空间来说，同步所有写入过的块</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  Sync the entire file system.  A big hammer.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fs_sync</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; super-&gt;s_nblocks; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (block_is_dirty(i)) &#123;</span><br><span class="line">			write_block(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dir-lookup-Exercise-5-8"><a href="#dir-lookup-Exercise-5-8" class="headerlink" title="dir_lookup - Exercise 5.8"></a>dir_lookup - Exercise 5.8</h3><ul>
<li>遍历目录中的每个文件，查找名称是否相同；同时，遍历的方式是先块后文件，详细可以看代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  查找当前路径下 dir 中字符串 name 指向的文件，返回文件控制块 file</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_lookup</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="type">char</span> *name, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="comment">/* Step 1: 通过占用块计算目录 dir 大小 */</span></span><br><span class="line">	u_int nblock;</span><br><span class="line">	<span class="comment">/* Exercise 5.8: Your code here. (1/3) */</span></span><br><span class="line">	nblock = dir-&gt;f_size / BY2BLK + (dir-&gt;f_size % BY2BLK == <span class="number">0</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">	<span class="comment">/* Step 2: 遍历目录中的每个文件： */</span></span><br><span class="line">    <span class="comment">// 2.1: 遍历每个文件块</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="comment">// 获取目录中的每个磁盘块</span></span><br><span class="line">		<span class="type">void</span> *blk;</span><br><span class="line">		<span class="comment">/* Exercise 5.8: Your code here. (2/3) */</span></span><br><span class="line">		file_get_block(dir, i, &amp;blk);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">files</span> =</span> (<span class="keyword">struct</span> File *)blk;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.2: 遍历块中的每个文件</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">struct</span> File *f = files; f &lt; files + FILE2BLK; ++f) &#123;</span><br><span class="line">			<span class="comment">// 比较文件名，相同则返回</span></span><br><span class="line">			<span class="comment">/* Exercise 5.8: Your code here. (3/3) */</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">strcmp</span>(f-&gt;f_name, name) == <span class="number">0</span>) &#123;</span><br><span class="line">				*file = f;</span><br><span class="line">				f-&gt;f_dir = dir;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 所有文件内均未找到，返回 -E_NOT_FOUND */</span></span><br><span class="line">	<span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="dir-alloc-file"><a href="#dir-alloc-file" class="headerlink" title="dir_alloc_file"></a>dir_alloc_file</h3><ul>
<li>在目录中查找空白文件管理块，并返回这个块。当目录已满时需要自动扩容</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overview:</span></span><br><span class="line"><span class="comment">//  在给定的路径 dir 中申请一个文件空间，返回文件控制块</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dir_alloc_file</span><span class="params">(<span class="keyword">struct</span> File *dir, <span class="keyword">struct</span> File **file)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	u_int nblock, i, j;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">	nblock = dir-&gt;f_size / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 1: 遍历所有目录的磁盘块（按文件控制块大小遍历），尝试发现空白的控制块 */</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nblock; i++) &#123;</span><br><span class="line">		<span class="comment">// read the block.</span></span><br><span class="line">		<span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> r;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		f = blk;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; FILE2BLK; j++) &#123;</span><br><span class="line">            <span class="comment">/* Step 2: 发现空白控制块，直接返回 */</span></span><br><span class="line">			<span class="keyword">if</span> (f[j].f_name[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">				*file = &amp;f[j];</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Step 3: 目录中已有的所有块都占用，通过 file_get_block 尝试申请新磁盘块，并把文件放在新块里 */</span></span><br><span class="line">	dir-&gt;f_size += BY2BLK;</span><br><span class="line">	<span class="keyword">if</span> ((r = file_get_block(dir, i, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> r;</span><br><span class="line">	&#125;</span><br><span class="line">	f = blk;</span><br><span class="line">	*file = &amp;f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数把 <code>file_get_block</code> 这个函数用得很灵活，一是执行其最基本的方法，即实现文件块到磁盘块的映射；同时在 Step 3 中还充当了为文件 <code>alloc_block</code> 的磁盘块申请者（映射肯定也同时生成在文件控制块中了）</p>
<h2 id="serv-c-文件系统进程服务函数"><a href="#serv-c-文件系统进程服务函数" class="headerlink" title="serv.c 文件系统进程服务函数"></a><code>serv.c</code> 文件系统进程服务函数</h2><p>里面函数太多了，偷个懒</p>
<h3 id="一图流-1"><a href="#一图流-1" class="headerlink" title="一图流"></a>一图流</h3><p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305192236561.svg" alt="serv.c"></p>
<h3 id="serve-open"><a href="#serve-open" class="headerlink" title="serve_open"></a>serve_open</h3><p>根据输入，申请一个工作区后打开文件并保存文件信息，完成后直接 ipc_send 返回。</p>
<p>重点体现在后面这个保存信息上了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_open</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_open *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Filefd</span> *<span class="title">ff</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">o</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Find a file id.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123; ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line">	<span class="comment">// Open the file.</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_open(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Save the file pointer.</span></span><br><span class="line">	o-&gt;o_file = f;                       <span class="comment">// file_open 里获取到的文件指针给窗口保管</span></span><br><span class="line">	<span class="comment">// Fill out the Filefd structure</span></span><br><span class="line">	ff = (<span class="keyword">struct</span> Filefd *)o-&gt;o_ff;       <span class="comment">// 把工作区当成 Filefd 准备写入</span></span><br><span class="line">	ff-&gt;f_file = *f;                     <span class="comment">// 工作区存放文件</span></span><br><span class="line">	ff-&gt;f_fileid = o-&gt;o_fileid;          <span class="comment">// 文件的 id 来自于窗口的 id</span></span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;           <span class="comment">// 窗口工作类型由输入决定</span></span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;       <span class="comment">// Filefd 里的工作类型也进行更新</span></span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id; <span class="comment">// 意义不明，待补</span></span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, o-&gt;o_ff, PTE_D | PTE_LIBRARY); <span class="comment">// 把 Filefd 共享给请求进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="serve-map"><a href="#serve-map" class="headerlink" title="serve_map"></a>serve_map</h3><ul>
<li>将目标文件 <code>offset</code> 处的磁盘块的内容映射（分享）给发起请求的用户进程</li>
</ul>
<p>用户进程请求获取文件块内容时，文件管理进程会使用这个函数，它先根据文件块和 <code>offset</code> 获取到实际所在的磁盘块，最后再把在文件管理进程中缓存的信息以共享页面的形式发送给用户进程。</p>
<p>这里也是一个有一个从文件块→磁盘块的映射</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_map</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_map *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	u_int filebno;</span><br><span class="line">	<span class="type">void</span> *blk;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	filebno = rq-&gt;req_offset / BY2BLK;</span><br><span class="line">    <span class="comment">/* Step 2: 获取映射的地址和磁盘块 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_get_block(pOpen-&gt;o_file, filebno, &amp;blk)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* Step 3: 将找到的磁盘块对应的块缓存分享给请求的用户进程 */</span></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, blk, PTE_D | PTE_LIBRARY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="serve-set-size"><a href="#serve-set-size" class="headerlink" title="serve_set_size"></a>serve_set_size</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">serve_set_size</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_set_size *rq)</span> &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Open</span> *<span class="title">pOpen</span>;</span></span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 查询存放当前文件的窗口 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = open_lookup(envid, rq-&gt;req_fileid, &amp;pOpen)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/* Step 2: 利用窗口中存放的文件控制块更改文件大小 */</span></span><br><span class="line">	<span class="keyword">if</span> ((r = file_set_size(pOpen-&gt;o_file, rq-&gt;req_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余的 <code>serve_*</code> 函数实际上也类似，大部分都是对<strong>文件交互函数</strong> <code>file_*</code> 函数的调用，这里函数充当接口，统一化处理信息。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part1/">See Part1 at here</a></p>
<p><a target="_blank" rel="noopener" href="https://cookedbear.top/2023/05/buaa-os-probe-lab5-part3/">See Part3 at here</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab5-part2/">https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab5-part2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/os/buaa-os-probe-lab5-part3/" title="BUAA-OS-Probe-Lab5-Part3"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-Probe-Lab5-Part3</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/os/buaa-os-probe-lab5-part1/" title="BUAA-OS-Probe-Lab5-Part1"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305111956044.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-Probe-Lab5-Part1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/os/buaa-os-challenge-lab6/" title="BUAA-OS-2023-Lab6-Challenge"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-10</div><div class="title">BUAA-OS-2023-Lab6-Challenge</div></div></a></div><div><a href="/2023/03/os/buaa-os-lab1-exam/" title="BUAA-OS-2023-Lab1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171229827.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">BUAA-OS-2023-Lab1-Exam</div></div></a></div><div><a href="/2023/04/os/buaa-os-lab3-exam/" title="BUAA-OS-2023-Lab3-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171231921.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">BUAA-OS-2023-Lab3-Exam</div></div></a></div><div><a href="/2023/04/os/buaa-os-lab4-1-exam/" title="BUAA-OS-2023-Lab4-1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171233017.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="title">BUAA-OS-2023-Lab4-1-Exam</div></div></a></div><div><a href="/2023/05/os/buaa-os-lab5-1-exam/" title="BUAA-OS-2023-Lab5-1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305160043577.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-16</div><div class="title">BUAA-OS-2023-Lab5-1-Exam</div></div></a></div><div><a href="/2023/05/os/buaa-os-lab5-2-exam/" title="BUAA-OS-2023-Lab5-2-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305231505897.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-23</div><div class="title">BUAA-OS-2023-Lab5-2-Exam</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">46</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">块缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#fs-c-%E4%B8%AD%E7%9A%84%E7%A3%81%E7%9B%98%E5%9D%97%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">fs.c 中的磁盘块操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diskaddr-Exercise-5-6"><span class="toc-number">1.1.1.</span> <span class="toc-text">diskaddr - Exercise 5.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#va-is-mapped-amp-block-is-mapped"><span class="toc-number">1.1.2.</span> <span class="toc-text">va_is_mapped &amp; block_is_mapped</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-block-amp-unmap-block"><span class="toc-number">1.1.3.</span> <span class="toc-text">map_block &amp; unmap_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write-block-amp-read-block"><span class="toc-number">1.1.4.</span> <span class="toc-text">write_block &amp; read_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#block-is-free-amp-free-block"><span class="toc-number">1.1.5.</span> <span class="toc-text">block_is_free &amp; free_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-block-num-amp-alloc-block"><span class="toc-number">1.1.6.</span> <span class="toc-text">alloc_block_num &amp; alloc_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-super-amp-read-bitmap"><span class="toc-number">1.1.7.</span> <span class="toc-text">read_super &amp; read_bitmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#va-is-dirty-amp-block-is-dirty"><span class="toc-number">1.1.8.</span> <span class="toc-text">va_is_dirty &amp; block_is_dirty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dirty-block"><span class="toc-number">1.1.9.</span> <span class="toc-text">dirty_block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fs-init"><span class="toc-number">1.1.10.</span> <span class="toc-text">fs_init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-File"><span class="toc-number">1.2.</span> <span class="toc-text">struct File</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#serv-c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">serv.c - 文件系统服务进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-Open"><span class="toc-number">2.1.</span> <span class="toc-text">struct Open</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open-alloc"><span class="toc-number">2.1.1.</span> <span class="toc-text">open_alloc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%9D%97-amp-%E7%A3%81%E7%9B%98%E5%9D%97-amp-%E5%9D%97%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">文件块 &amp; 磁盘块 &amp; 块缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fs-c-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">fs.c 中的文件操作函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%B5%81"><span class="toc-number">2.4.</span> <span class="toc-text">一图流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#file-create"><span class="toc-number">2.4.1.</span> <span class="toc-text">file_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-open-amp-walk-path"><span class="toc-number">2.4.2.</span> <span class="toc-text">file_open &amp; walk_path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-get-block-amp-file-map-block-amp-file-block-walk"><span class="toc-number">2.4.3.</span> <span class="toc-text">file_get_block &amp; file_map_block &amp; file_block_walk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-set-size-amp-file-clear-block-amp-file-truncate-amp-file-flush"><span class="toc-number">2.4.4.</span> <span class="toc-text">file_set_size &amp; file_clear_block &amp; file_truncate &amp; file_flush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-close"><span class="toc-number">2.4.5.</span> <span class="toc-text">file_close</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-dirty"><span class="toc-number">2.4.6.</span> <span class="toc-text">file_dirty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-remove"><span class="toc-number">2.4.7.</span> <span class="toc-text">file_remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#file-sync"><span class="toc-number">2.4.8.</span> <span class="toc-text">file_sync</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dir-lookup-Exercise-5-8"><span class="toc-number">2.4.9.</span> <span class="toc-text">dir_lookup - Exercise 5.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dir-alloc-file"><span class="toc-number">2.4.10.</span> <span class="toc-text">dir_alloc_file</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#serv-c-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">serv.c 文件系统进程服务函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%9B%BE%E6%B5%81-1"><span class="toc-number">2.5.1.</span> <span class="toc-text">一图流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serve-open"><span class="toc-number">2.5.2.</span> <span class="toc-text">serve_open</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serve-map"><span class="toc-number">2.5.3.</span> <span class="toc-text">serve_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#serve-set-size"><span class="toc-number">2.5.4.</span> <span class="toc-text">serve_set_size</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/09/cp/buaa-cp-theory-chapter1/" title="BUAA-CompilePrincipal-Chapter1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-CompilePrincipal-Chapter1"/></a><div class="content"><a class="title" href="/2023/09/cp/buaa-cp-theory-chapter1/" title="BUAA-CompilePrincipal-Chapter1">BUAA-CompilePrincipal-Chapter1</a><time datetime="2023-09-04T08:59:03.000Z" title="发表于 2023-09-04 16:59:03">2023-09-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/learning/vue-component/" title="从负开始的 Vue 学习 (2)"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306122322922.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从负开始的 Vue 学习 (2)"/></a><div class="content"><a class="title" href="/2023/07/learning/vue-component/" title="从负开始的 Vue 学习 (2)">从负开始的 Vue 学习 (2)</a><time datetime="2023-07-15T16:12:05.000Z" title="发表于 2023-07-16 00:12:05">2023-07-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/galgame/cyanotype-daydream/" title="梦、世界与拯救——《白日梦的构想图》有感"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072353014.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="梦、世界与拯救——《白日梦的构想图》有感"/></a><div class="content"><a class="title" href="/2023/07/galgame/cyanotype-daydream/" title="梦、世界与拯救——《白日梦的构想图》有感">梦、世界与拯救——《白日梦的构想图》有感</a><time datetime="2023-07-07T15:54:28.000Z" title="发表于 2023-07-07 23:54:28">2023-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/learning/python-class/" title="BUAA-Python-Note"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306122322922.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-Python-Note"/></a><div class="content"><a class="title" href="/2023/06/learning/python-class/" title="BUAA-Python-Note">BUAA-Python-Note</a><time datetime="2023-06-27T15:22:04.000Z" title="发表于 2023-06-27 23:22:04">2023-06-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>