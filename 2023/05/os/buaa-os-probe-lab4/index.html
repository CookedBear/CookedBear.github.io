<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-Probe-Lab4 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab4 - 系统调用与进程创建Lab4 中主要涉及到以下内容：    系统调用 syscall 的流程   进程间通信机制：ipc   用户进程的创建方式：fork 函数   写时复制 COW 与页写入异常   首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，请善用目录！ 其实最不好理解的部分是在汇编代码">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-Probe-Lab4">
<meta property="og:url" content="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab4/index.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="Lab4 - 系统调用与进程创建Lab4 中主要涉及到以下内容：    系统调用 syscall 的流程   进程间通信机制：ipc   用户进程的创建方式：fork 函数   写时复制 COW 与页写入异常   首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，请善用目录！ 其实最不好理解的部分是在汇编代码">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171224880.png?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-05-01T12:59:07.000Z">
<meta property="article:modified_time" content="2023-05-17T04:25:03.220Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171224880.png?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab4/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-Probe-Lab4',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-17 12:25:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171224880.png?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-Probe-Lab4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-01T12:59:07.000Z" title="发表于 2023-05-01 20:59:07">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-17T04:25:03.220Z" title="更新于 2023-05-17 12:25:03">2023-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MOS-Probe/">MOS Probe</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-Probe-Lab4"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab4-系统调用与进程创建"><a href="#Lab4-系统调用与进程创建" class="headerlink" title="Lab4 - 系统调用与进程创建"></a>Lab4 - 系统调用与进程创建</h1><p>Lab4 中主要涉及到以下内容：</p>
<ul>
<li>  系统调用 <code>syscall</code> 的流程</li>
<li>  进程间通信机制：ipc</li>
<li>  <strong>用户</strong>进程的创建方式：<code>fork</code> 函数</li>
<li>  写时复制 <strong>COW</strong> 与页写入异常</li>
</ul>
<blockquote>
<p>首先需要明确一件事，这篇文里说的大部分和汇编相关的内容估计都不会考，只是用来全面理解每一步的具体作用而已。所以写了一坨好多都是没营养的东西，<strong>请善用目录！</strong> 其实最不好理解的部分是在汇编代码和C代码之间切换的部分，可能一些宏定义、编译器的一些操作就会漏掉很多细节。 所以，时不时用用 <code>make objdump</code> 吧！努力成为 buaa-os 领域大神（？</p>
</blockquote>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>在计算机组成原理实验 P7 与 Lab3 中，我们大致已经能够理清异常的原因、怎样产生与处理的方式了，但在 MOS 之前提到的异常大多不能由用户主动触发（时钟中断、TLB MISS 等），接下来我们就要深入了解一种特殊的、可以<strong>由用户主动发起的异常</strong>：系统调用 <code>syscall</code></p>
<ul>
<li>  异常发生的原因：出现某些不符合操作规范的指令、外部中断、syscall 指令</li>
<li>  产生地点（硬件）：指令流水至（M级）时 CP0 协处理器分析异常，修改 SR、Cause 等寄存器，使得当前 PC 跳转至异常处理程序入口（<code>0x80000000</code>）</li>
<li>  异常处理（软件）：异常处理程序对 CP0 记录的信息进行分析，选择对应的 handler 函数并跳转；对应 handler 处理结束后通过 ret_from_exception 汇编函数返回 EPC，程序继续执行</li>
</ul>
<p>我们想要使用 syscall 指令，为的就是<strong>进入内核态</strong>，让操作系统为用户执行某些任务，这些任务出于安全等考虑，只有内核才能完成，所以在调用 syscall 时，就不可避免地要进行 CPU 状态的切换（标记于 SR 寄存器的 KUc 位中）</p>
<h2 id="系统调用在干啥（）"><a href="#系统调用在干啥（）" class="headerlink" title="系统调用在干啥（）"></a>系统调用在干啥（）</h2><p>在详细了解系统调用前，还有必要再补充一下进程运行时的虚拟空间知识（<strong>可以补充在Lab3中？</strong>） 每个进程，都有相同的虚拟地址划分方式，并按照 mmu.h 文件中所示进行排布。每个进程都具有一张这样的表。同时每个进程的 kseg0、kseg1 段也都存放（或者说映射）着内核相关的数据结构，存在于所有进程的虚拟空间中，相当于被所有进程<strong>只读共享</strong>。所以为了方便使用，它们被整体映射到物理地址的固定区域；对于 kuseg 段，用户的页表和虚拟地址相结合，会指向物理内存中的某些空间，不同进程可能对物理空间进行共享。 执行系统调用，<strong>汇编层面上</strong>就是从 kuseg 段的汇编指令跳转至 kseg0 段，（进入内核态）并执行特定序列（系统调用函数），最后返回用户态 EPC 。<strong>C层面上</strong>就是用户态函数和内核态的系统调用函数之间的调用跳转。</p>
<h2 id="系统调用过程概览"><a href="#系统调用过程概览" class="headerlink" title="系统调用过程概览"></a>系统调用过程概览</h2><p>我觉得 os 学的就是一个全局观，先把需求和路线理清了，细节咱们随后再细说（</p>
<ul>
<li>  用户提出请求：<code>syscall_</code> 函数</li>
</ul>
<p>在 MOS 中，操作系统为用户准备了一系列可以在用户态调用的函数： <code>syscall_*</code> 系列函数，他们每个函数都对应一个可以通过系统调用完成的任务，用户通过调用这些函数，向操作系统传达信息：<strong>我要使用系统调用完成某个功能</strong></p>
<ul>
<li>  进入内核态：汇编函数 <code>msyscall</code></li>
</ul>
<p>在刚提到的 <code>syscall_*</code> 函数中，存在一个 <code>msyscall</code> 函数，在这个汇编写成的 <code>msyscall</code> 中，才出现了真正的 <code>syscall</code> 汇编指令，也就是在这里正式地进入了内核态，准备使用异常处理程序解决 <code>syscall</code></p>
<ul>
<li>  用户态保存：<code>exc_gen_entry</code></li>
</ul>
<p>在异常处理程序中，调用 SAVE_ALL 保存当前现场为内核栈中的 trapframe ，并将当前使用栈转换为内核栈。</p>
<ul>
<li>  接收请求并分类：<code>handle_sys</code></li>
</ul>
<p>通过异常处理程序判断为系统调用后，转入 handler 这个函数创建了一个size = TFSIZE + 8 大小的栈帧，8byte 为了保存参数 *tf（函数开始后会写回 a0 寄存器）</p>
<ul>
<li>  参数预处理调用处理函数：<code>do_syscall</code></li>
</ul>
<p>在这个函数中，我们通过分析用户传入的信息（<code>syscall_*</code> 的类型和用户现场）来响应系统调用。 分析主要凭借 tf-&gt;regs[29] 获取用户 trapframe 状态，通过sp访问内核栈获取参数等</p>
<ul>
<li>  响应完毕，返回用户态：<code>ret_from_exception</code></li>
</ul>
<p>在从 <code>do_syscall</code> 跳出并执行完对应处理函数，并返回至 <code>handle_sys</code> 后，最后会和其他异常一样，执行 <code>ret_from_exception</code>，还原现场，返回用户态，整个系统调用的过程结束   至此，整个执行流程可以总结为这张图片： <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202304231627668.png" alt="image-20230423162717568"></p>
<h2 id="发起系统调用-syscall"><a href="#发起系统调用-syscall" class="headerlink" title="发起系统调用 - syscall_*"></a>发起系统调用 - syscall_*</h2><p>上面提到，可由用户调用、距离内核态最近的函数就是这一系列 <code>syscall_*</code> 函数了。它们作为用户可调用的函数，位于 <code>user/lib/syscall_lib.c</code> 文件中，现在来看看它们的具体内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为节省空间仅保留了部分函数，反正差不多里面所有函数都长这样()</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscall_putchar</span><span class="params">(<span class="type">int</span> ch)</span> &#123;</span><br><span class="line">    msyscall(SYS_putchar, ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int <span class="title function_">syscall_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_getenvid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_mem_map</span><span class="params">(u_int srcid, <span class="type">void</span> *srcva, u_int dstid, <span class="type">void</span> *dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_mem_map, srcid, srcva, dstid, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，它们都只调用了<strong>不同参数</strong>的 <code>msyscall</code> 函数，然后早早跑路（x）。这里还需要注意，<code>syscall_putchar</code>、<code>syscall_yield</code>、<code>syscall_panic</code> 这几个函数没有以”return“的方式调用 <code>msyscall</code> ，因为他们不是 <code>void</code> 的，就是 <code>noreturn</code> 的，憋憋 可以发现每个不同的函数，第一个参数一定不同，并且都代表了这个函数。也就是说， <code>msyscall</code> 通过接收这系列函数传入的第一个参数，决定最后响应的内核函数是谁，而后续的参数充当信息，用于辅助处理。  </p>
<h2 id="转入内核态-msyscall-Exercise-4-1"><a href="#转入内核态-msyscall-Exercise-4-1" class="headerlink" title="转入内核态 - msyscall - Exercise 4.1"></a>转入内核态 - msyscall - Exercise 4.1</h2><p>这个在用户态执行的最后一个函数（但用户编程过程中实际上不用），位于 <code>user/lib/syscall_wrap.S</code> 中，这个函数很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;asm/asm.h&gt;</span><br><span class="line"></span><br><span class="line">LEAF(msyscall)</span><br><span class="line">    // Just use &#x27;syscall&#x27; instruction and return.</span><br><span class="line"></span><br><span class="line">    /* Exercise 4.1: Your code here. */</span><br><span class="line">    syscall</span><br><span class="line">    jr ra</span><br><span class="line">END(msyscall)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个函数实际上充当了用户态、内核态的转接口：执行 <code>syscall</code> 进入内核态，从调用返回后执行 <code>jr ra</code> ，十分简洁，分工明确 我们可能注意到了不同的 <code>msyscall</code> 调用可能有不同的参数数量，他们都被保存在堆栈中为函数创造的 stack frame 空间中，与 sp 相邻。 下一步，内核就会接收到由硬件产生的 8 号异常，通过处在 <code>kern/entry.S</code> 的异常分发程序 <code>exc_gen_entry</code> 跳转到 handler 函数： <code>do_syscall</code>  </p>
<h2 id="分发系统调用-do-syscall"><a href="#分发系统调用-do-syscall" class="headerlink" title="分发系统调用 - do_syscall"></a>分发系统调用 - do_syscall</h2><p>首先需要注意，在跳转至 <code>do_syscall</code> 前，我们在异常分发程序中向内核栈（SAVE_ALL）压入了用户态 trapframe 的信息。随后又通过 move 指令把 a0 寄存器复制成了 trapframe 的地址（SAVE_ALL 中 move sp 的值） 所以 <code>do_syscall</code> 在调用时就会自动地带有一个参数，它就是存放在 a0 寄存器中的用户态 <code>trackframe</code> <strong>指针</strong>（为什么是指针？因为传入的 sp 的值实际上指向了存放 tf 的地址）  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_syscall</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*func)(u_int, u_int, u_int, u_int, u_int);</span><br><span class="line">    <span class="type">int</span> sysno = tf-&gt;regs[<span class="number">4</span>];    <span class="comment">// sysno 是 msyscall 的第一个参数</span></span><br><span class="line">    <span class="keyword">if</span> (sysno &lt; <span class="number">0</span>  sysno &gt;= MAX_SYSNO) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">2</span>] = -E_NO_SYS;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 移动 EPC，使得syscall返回后执行下一条指令 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (1/4) */</span></span><br><span class="line">    tf-&gt;cp0_epc += <span class="number">4</span>;</span><br><span class="line">    <span class="comment">/* Step 2: 通过 sysno 获得使用的处理函数 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (2/4) */</span></span><br><span class="line">    func = syscall_table[sysno];</span><br><span class="line">    <span class="comment">/* Step 3: 获取前三个参数 $a1, $a2, $a3. */</span></span><br><span class="line">    u_int arg1 = tf-&gt;regs[<span class="number">5</span>];</span><br><span class="line">    u_int arg2 = tf-&gt;regs[<span class="number">6</span>];</span><br><span class="line">    u_int arg3 = tf-&gt;regs[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: 获取后两个参数 [$sp + 16 bytes], [$sp + 20 bytes] */</span></span><br><span class="line">    u_int arg4, arg5;</span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (3/4) */</span></span><br><span class="line">    arg4 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">16</span>));</span><br><span class="line">    arg5 = *((u_int *) (tf-&gt;regs[<span class="number">29</span>] + <span class="number">20</span>));</span><br><span class="line">    <span class="comment">/* Step 5: 调用处理函数，返回值保存在用户态的 v0 中 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.2: Your code here. (4/4) */</span></span><br><span class="line">    tf-&gt;regs[<span class="number">2</span>] = func(arg1, arg2, arg3, arg4, arg5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用户栈与内核栈"><a href="#用户栈与内核栈" class="headerlink" title="用户栈与内核栈"></a>用户栈与内核栈</h3><ul>
<li>  这里 sysno 取自 a0 寄存器，那前面说的 tf 地址保存在 a0 寄存器又是什么呢，不会互相覆盖吗？</li>
<li>  首先结论很明显，不会。这里的两个 a0 指的不是同样的东西</li>
</ul>
<p>首先我们需要明确一点：当进程运行在用户态时，使用的是用户栈，栈指针也指向用户栈；每当进程<strong>通过异常</strong>从用户态切换到内核态时，handler 会执行汇编函数 <code>SAVE_ALL</code>。 它的具体作用是把用户态的所有寄存器都保存到一个 trapframe 中，同时这个 tf 会被放置在内核栈中，同时还会切换当前使用的栈空间为<strong>内核栈</strong>。并且<strong>切换时内核栈总是空的</strong>。内核栈此时就保存了进程在进入内核态前的相关信息。重回到用户态时，再通过 ret_from_exception 中的 RESTORE_SOME 将内核栈中保存的信息恢复，再切回用户栈。 因为内核栈在切换后总是空的，每次又只会传入一个 trapframe ，所以这个 trapframe 实际上每次都占用的是 KSTACKTOP 向下的一个 sizeof(trapframe) 大小的空间 所以会出现这样的空间图：</p>
<ul>
<li>  stackframe：调用函数时创建，保存函数的参数、临时变量与相关跳转指针</li>
<li>  trapframe：陷入内核时使用 <code>SAVE_ALL</code> 创建，保存用户态寄存器</li>
</ul>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012029029.png" alt="image-20230501202927787"> 新的内核栈 sp 指向 trapframe，旧的用户栈 sp 指向 arg0</p>
<ul>
<li>  使用当前（内核栈）的 sp，能访问到 trapframe 的信息；使用 tf 中 sp （用户栈）的信息，能访问到最近的 stackframe 的信息</li>
</ul>
<p>回到我们的 sysno，它是 <code>msyscall</code> 的第一个参数（<strong>用户态</strong>函数），也就是在分发异常调用 SAVE_ALL 时保存的 a0 寄存器，来源是用户态，所以要从用户态的 tf 里取 a0 寄存器（tf-&gt;regs[4]）；而参数 *tf 是保存在了调用 <code>do_syscall</code> 时的内核态 a0 中，并不干扰</p>
<ul>
<li>  后面的 arg4 类似，同样来源于用户态，但由于寄存器内没有保存，所以不能直接从 tf 里取得，需要通过用户栈指针回到 stackframe 中获取(tf-&gt;regs[29] + 16)</li>
</ul>
<h3 id="栈帧-stack-frame"><a href="#栈帧-stack-frame" class="headerlink" title="栈帧 - stack frame"></a>栈帧 - stack frame</h3><p>这里是实际在网站里的教程里有讲过了，当时没有仔细理解，感觉还是再说说吧。 昨天有同学问我说为啥NESTED(handler_sys, TFSIZE + 8, 0)提示编译器共有 TFSIZE + 8 字节的栈帧，但是 ra 却只移动了 8Byte。然后我就发现，我确实没理解栈帧。。 存疑：栈帧在C语言函数中自动创建，汇编函数中需要手动创建 以下内容根据 R3000 手册筛选，但不能保证正确性，为了讨论，这里就只涉及到非叶函数，也就是一般函数的栈情况</p>
<ul>
<li>  栈帧 stackframe 创建于刚刚进入函数时：编译器会令 sp 指针向下移动一定空间，并使得这段空间成为该函数栈帧（大小由编译器通过函数变量、子函数参数、临时变量等指标确定；需要<strong>注意双字对齐</strong>，所以在没对齐时需要补充空白的单字（称作pad））</li>
<li>  随即，编译器调用 sw 指令，把 a0 - a3 寄存器中存放的本函数前四个参数填充到紧邻本栈帧的<strong>上方的空间</strong>里，不够四个就有几个补几个</li>
<li>  栈内高地址存放函数的临时变量等，低地址预留本函数可能调用的<strong>子函数的参数</strong>的空间，这部分空间在进入子函数时又会成为子函数第二步填充参数的地方</li>
</ul>
<p>那回来说这个 handler_sys，它通过NESTED宏中的.frame向编译器声明自己需要 TFSIZE+8 字节的栈帧，但是自己却只移动了 8 字节的 sp。 我感觉是因为 TFSIZE 实际上是上面调用 SAVE_ALL 时移动的一个 TFSIZE，这里为了避免覆盖掉就把它看成了栈的一部分（<strong>小孩子瞎猜的</strong>）。真正有用的是那8个字节：4字节的arg1和4字节的pad，而arg1又是在进入子函数do_syscall内，才从 a0 寄存器中填充的</p>
<h2 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h2><p>了解完系统调用的流程后，下一步就是填写具体用于处理系统调用的函数了，可能会把能写的都写一下，<strong>建议是跳着看</strong>。  </p>
<h3 id="获取进程块-envid2env-Exercise-4-3"><a href="#获取进程块-envid2env-Exercise-4-3" class="headerlink" title="获取进程块 - envid2env -Exercise 4.3"></a>获取进程块 - envid2env -Exercise 4.3</h3><p>首先是 envid2env 这个函数，它用来获取id对应的进程控制块。虽然它不是系统调用的一部分，但在进行交互、系统调用时，经常使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">envid2env</span><span class="params">(u_int envid, <span class="keyword">struct</span> Env **penv, <span class="type">int</span> checkperm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 赋值，当 envid == 0 时返回当前进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;</span><br><span class="line">        *penv = curenv;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = &amp;envs[ENVX(envid)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_status == ENV_FREE  e-&gt;env_id != envid) &#123;  <span class="comment">// double check: invaild env_id</span></span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Check when &#x27;checkperm&#x27; is non-zero. */</span></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">    * 当 checkperm != 1 时，要求查询的 env 必须是当前运行进程块**本身或父亲**</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.3: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (checkperm &amp;&amp; (e-&gt;env_id != curenv-&gt;env_id &amp;&amp; e-&gt;env_parent_id != curenv-&gt;env_id)) &#123;</span><br><span class="line">        *penv = <span class="number">0</span>;</span><br><span class="line">        printk(<span class="string">&quot;E_BAD_ENV: %x, %x, %x\n&quot;</span>, e-&gt;env_id, curenv-&gt;env_id, e-&gt;env_parent_id);</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 向 *penv 中赋值 */</span></span><br><span class="line">    *penv = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数本身没什么问题，但要注意 <code>envid == 0</code> 时必须提前退出函数，否则会一直运行到最后，返回 envs 内的第一个进程控制块</p>
<ul>
<li>  当 checkperm == 0 时，不需处理进程块与当前进程之间的关系，反之则需要确保调用本函数的进程是被调用者的<strong>直接父亲或本身</strong>，否则返回错误。值得一提的是，除了在进行 ipc 通讯的过程外，所有 syscall 函数都需要令 checkperm != 0（传信息不用限定在父子进程中）</li>
</ul>
<p> </p>
<h3 id="强制进行进程切换-sys-yield-Exercise-4-7"><a href="#强制进行进程切换-sys-yield-Exercise-4-7" class="headerlink" title="强制进行进程切换 - sys_yield - Exercise 4.7"></a>强制进行进程切换 - sys_yield - Exercise 4.7</h3><p>具体而言就是调用一次 <code>schedule</code> 函数，使得运行的进程交出 CPU 时间片，记得 yield 别传 0（）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) sys_yield(<span class="type">void</span>) &#123;</span><br><span class="line">    <span class="comment">// Hint: Just use &#x27;schedule&#x27; with &#x27;yield&#x27; set.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.7: Your code here. */</span></span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意这里函数 <code>noreturn</code> ，也就是说会直接开始运行下一个进程块  </p>
<h3 id="指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4"><a href="#指定进程建立-va2pa-的映射-sys-mem-alloc-Exercise-4-4" class="headerlink" title="指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4"></a>指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4</h3><ul>
<li>函数作用：为指定进程的 va 申请一个物理页面并形成映射<ul>
<li>  类似于跨进程的 page_insert</li>
</ul>
</li>
<li>操作：<ul>
<li>  确认 va 和 env 的合法性，如有错误则直接返回错误值</li>
<li>  申请一个物理页，调用 page_insert 生成映射</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_alloc</span><span class="params">(u_int envid, u_int va, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 envid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Hint: **Always** validate the permission in syscalls! except for in function sys_ipc_try_send */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;env, <span class="number">1</span>)) &#123;<span class="comment">// test 4-2: !envid2env() or 0 != envid2env())</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 申请物理页 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.4: Your code here. (3/3) */</span></span><br><span class="line">    try(page_alloc(&amp;pp));</span><br><span class="line">    <span class="comment">/* Step 4: 将 va 映射入指定进程 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, pp, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>乍一看这不就是一个 page_insert 吗，仔细一看确实。但是用户态的 page_insert 无法<strong>帮</strong>其他进程申请一个映射，因为根本看不到其他进程的进程块，所以原则上需要看得见所有东西的内核态来帮忙  </p>
<h3 id="在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5"><a href="#在不同进程间形成共同的映射-sys-mem-map-Exercise-4-5" class="headerlink" title="在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5"></a>在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5</h3><ul>
<li>  函数作用：说白了就是把 src 进程 va 所在的物理页，在 dst 进程中找了指定位置形成了映射（insert）</li>
<li>操作：<ul>
<li>  检验传入的两个 va 合法性</li>
<li>  获取 srcid 和 dstid 的进程控制块</li>
<li>  page_lookup 获得 srcva 在 srcid 中映射的<strong>物理页</strong></li>
<li>  page_insert 让物理页在 dstid 中也形成一个映射</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_map</span><span class="params">(u_int srcid, u_int srcva, u_int dstid, u_int dstva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srcenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">dstenv</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">pp</span>;</span></span><br><span class="line">    <span class="comment">//printk(&quot;mem_map:va is %x\n&quot;, srcva);</span></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (1/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(srcva)  is_illegal_va(dstva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;invaild va: %x or %x\n&quot;, srcva, dstva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取 srcid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (2/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(srcid, &amp;srcenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;srcenv, 1)\n&quot;, srcid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 获取 dstid 的进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (3/4) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(dstid, &amp;dstenv, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;bad env2! envid2env(%x, &amp;dstenv, 1)\n&quot;, dstid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 找到 srcid + srcva 指向的物理页 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not mapped. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.5: Your code here. (4/4) */</span></span><br><span class="line">    <span class="keyword">if</span> ((pp = page_lookup(srcenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 最终在 dst 中形成映射 */</span></span><br><span class="line">    <span class="keyword">return</span> page_insert(dstenv-&gt;env_pgdir, dstenv-&gt;env_asid, pp, dstva, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="解除指定进程的映射-sys-mem-unmap-Exercise-4-6"><a href="#解除指定进程的映射-sys-mem-unmap-Exercise-4-6" class="headerlink" title="解除指定进程的映射 - sys_mem_unmap - Exercise 4.6"></a>解除指定进程的映射 - sys_mem_unmap - Exercise 4.6</h3><ul>
<li>  函数作用：上一行就是.jpg</li>
<li>操作：<ul>
<li>  检验 va 有效性</li>
<li>  获取 envid 的进程块</li>
<li>  直接调用 page_remove 进行映射的删除</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_mem_unmap</span><span class="params">(u_int envid, u_int va)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检查 va 合法性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (is_illegal_va(va)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取对应的进程控制块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.6: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (envid2env(envid, &amp;e, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 解除 env 中 va 的映射 */</span></span><br><span class="line">    page_remove(e-&gt;env_pgdir, e-&gt;env_asid, va);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较好写，但是 MOS 也没调用过，之后可能会有用处吧  </p>
<h3 id="为当前进程创建一个子进程-sys-exofork-Exercise-4-9"><a href="#为当前进程创建一个子进程-sys-exofork-Exercise-4-9" class="headerlink" title="为当前进程创建一个子进程 - sys_exofork - Exercise 4.9"></a>为当前进程创建一个子进程 - sys_exofork - Exercise 4.9</h3><p> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 使用 env_alloc 申请新进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把当前进程存入的 trapframe 复制给子进程 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// e-&gt;env_tf = curenv-&gt;env_tf;</span></span><br><span class="line">    <span class="comment">/* Step 3: 把子进程的 v0 寄存器置0，即函数返回值为0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 设置子进程状态，继承优先级  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="设置进程块-status-sys-set-env-status"><a href="#设置进程块-status-sys-set-env-status" class="headerlink" title="设置进程块 status - sys_set_env_status"></a>设置进程块 status - sys_set_env_status</h3><p>见 fork 部分  </p>
<h3 id="设置-trapframe-sys-set-trapframe"><a href="#设置-trapframe-sys-set-trapframe" class="headerlink" title="设置 trapframe - sys_set_trapframe"></a>设置 trapframe - sys_set_trapframe</h3><p>见 fork 部分  </p>
<h3 id="ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8"><a href="#ipc-通信：接收端进程-sys-ipc-recv-Exercise-4-8" class="headerlink" title="ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8"></a>ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8</h3><ul>
<li>  函数作用：主动将当前进程<strong>阻塞</strong>，等待 send 信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_recv</span><span class="params">(u_int dstva)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 非 0 va 意味着传输页面，此时需检测 va 是否合法 */</span></span><br><span class="line">    <span class="keyword">if</span> (dstva != <span class="number">0</span> &amp;&amp; is_illegal_va(dstva)) &#123;<span class="comment">// test 4-3: English &quot;either or&quot;</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 标记：允许接收数据 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (1/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Step 3: 设置接收的指定va */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (2/8) */</span></span><br><span class="line">    curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">    <span class="comment">/* Step 4: 移出调度队列，进入阻塞态 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (3/8) */</span></span><br><span class="line">    curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    TAILQ_REMOVE(&amp;env_sched_list, curenv, env_sched_link);</span><br><span class="line">    <span class="comment">/* Step 5: schedule(1) 令当前进程开摆，设置返回值为0 */</span></span><br><span class="line">    ((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>)-&gt;regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    schedule(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里最后一块：<code>((struct Trapframe *)KSTACKTOP - 1)</code> 指的就是 <code>do_syscall</code> 那之前创建的用户态 Trapframe，这里把用户态的 v0 寄存器值设为了0，用来代表用户态<strong>最初</strong>调用的 <code>syscall_ipc_recv</code> 的返回值为 0</li>
</ul>
<h3 id="ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8"><a href="#ipc-通信：发送端进程-sys-ipc-send-Exercise-4-8" class="headerlink" title="ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8"></a>ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8</h3><ul>
<li>  函数作用：和 recv 配套使用，向<strong>已准备好</strong>的进程发送信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_ipc_try_send</span><span class="params">(u_int envid, u_int value, u_int srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 检测 va 有效性 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (4/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span> &amp;&amp; is_illegal_va(srcva)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;srcva is bad! %x\n&quot;, srcva);</span></span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 获取进程块，无需令 perm = 1，非父子进程也可传输信息 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (5/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> != envid2env(envid, &amp;e, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// printk(&quot;envid is bad! %x\n&quot;, envid);</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 检测目标进程是否处于可接受状态(env_ipc_recving = 1) */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (6/8) */</span></span><br><span class="line">    <span class="keyword">if</span> (e-&gt;env_ipc_recving == <span class="number">0</span>  e-&gt;env_status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 设置目标进程字段 */</span></span><br><span class="line">    e-&gt;env_ipc_value = value;</span><br><span class="line">    e-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">    e-&gt;env_ipc_perm = PTE_V  perm;</span><br><span class="line">    e-&gt;env_ipc_recving = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 5: 恢复目标进程状态为可运行 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.8: Your code here. (7/8) */</span></span><br><span class="line">    e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">    TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">    <span class="comment">/* Only link page while srcva != 0, to save running time */</span></span><br><span class="line">    <span class="comment">/* Step 6: va != 0 则传输页面 */</span></span><br><span class="line">    <span class="comment">/* Return -E_INVAL if &#x27;srcva&#x27; is not zero and not mapped in &#x27;curenv&#x27;. */</span></span><br><span class="line">    <span class="keyword">if</span> (srcva != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Exercise 4.8: Your code here. (8/8) */</span></span><br><span class="line">        <span class="comment">// printk(&quot;4.8 is sys_mem_map(%x, %x, %x, %x, %x));\n&quot;, curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm);</span></span><br><span class="line">        <span class="comment">// try(sys_mem_map(curenv-&gt;env_id, srcva, e-&gt;env_id, e-&gt;env_ipc_dstva, perm));</span></span><br><span class="line">        <span class="comment">/* Test 4-5: do not use sys_mem_map because it call function envid2env with perm == 1; */</span></span><br><span class="line">        <span class="comment">// because two communicating env may not have parent relatioinship</span></span><br><span class="line">        p = page_lookup(curenv-&gt;env_pgdir, srcva, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == p) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            try(page_insert(e-&gt;env_pgdir, e-&gt;env_asid, p, e-&gt;env_ipc_dstva, perm));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h1 id="ipc-进程通信-ipc-c"><a href="#ipc-进程通信-ipc-c" class="headerlink" title="ipc 进程通信 - ipc.c"></a>ipc 进程通信 - ipc.c</h1><p>为了在进程间进行数据的传输，我们在 MOS 操作系统中设置了两种传输方式：传输单个 int，共享内存；并且两种方式都集成在了同一个系统调用，也即 <code>sys_ipc_send</code> 和 <code>sys_ipc_recv</code> 两个函数完成，并且两个函数执行时需要先 recv，声明自己已准备好，再调用 send，进行信息的发送。 但是，只设置好了系统调用函数还不足以让我们完成进程间的通信，因为系统需要对发送过程是否成功进行检测，若目标进程未准备好还需要等待，也有许多诸如此类的情况。所以为了方便使用，MOS 在用户态中封装了两个完整的函数用于进行信息传递的全流程，它们位于 <code>user/lib/ipc.c</code> 中，当有通信需求时，直接调用它们就能直观地完成进程通信。 <code>ipc.c</code> 文件开头就有一句这样的注释：<code>User-level IPC library routines</code>，也正好说明了下面两个函数在用户态服务</p>
<h2 id="用户态发送函数-ipc-send"><a href="#用户态发送函数-ipc-send" class="headerlink" title="用户态发送函数 - ipc_send"></a>用户态发送函数 - ipc_send</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use syscall_yield() to be CPU-friendly.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ipc_send</span><span class="params">(u_int whom, u_int val, <span class="type">const</span> <span class="type">void</span> *srcva, u_int perm)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">/* Step 1: 持续查询是否能进行传输 */</span></span><br><span class="line">    <span class="keyword">while</span> ((r = syscall_ipc_try_send(whom, val, srcva, perm)) == -E_IPC_NOT_RECV) &#123;</span><br><span class="line">    <span class="comment">/* Step 2: 如果只因为对方未就绪，自身也停止这个 while 导致的忙等待，交出 CPU */</span></span><br><span class="line">        syscall_yield();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 如果 r != 0，说明退出 while 循环的原因是 -E_INVAL，说明出现错误 */</span></span><br><span class="line">    user_assert(r == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  这里使用的 <code>syscall_yield</code> 非常巧妙：如果对方进程未就绪，那在这个时间片中也不可能转换为就绪状态（本时间片一直是本进程运行），那为了避免当前时间片忙等，索性直接归还 CPU，等下一次调度到自己之后再查</li>
</ul>
<p> </p>
<h2 id="用户态接收函数-ipc-recv"><a href="#用户态接收函数-ipc-recv" class="headerlink" title="用户态接收函数 - ipc_recv"></a>用户态接收函数 - ipc_recv</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hint: use env to discover the value and who sent it.</span></span><br><span class="line">u_int <span class="title function_">ipc_recv</span><span class="params">(u_int *whom, <span class="type">void</span> *dstva, u_int *perm)</span> &#123;</span><br><span class="line">    <span class="comment">/* Step 1: 直接进系统调用，因为 recv 是先执行的，不用等 */</span></span><br><span class="line">    <span class="comment">/* 需要注意进程在下一条语句中调用了 schedule，传输完毕后才跳出 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_ipc_recv(dstva);</span><br><span class="line">    <span class="comment">/* Step 2: 检查返回值，错误值则 panic */</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;syscall_ipc_recv err: %d&quot;</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: 返回发送者的 env_id */</span></span><br><span class="line">    <span class="keyword">if</span> (whom) &#123;</span><br><span class="line">        *whom = env-&gt;env_ipc_from;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: 返回映射页权限位 */</span></span><br><span class="line">    <span class="keyword">if</span> (perm) &#123;</span><br><span class="line">        *perm = env-&gt;env_ipc_perm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: 返回传输的单个 int */</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  相比之下，recv 函数内赋值语句较多，因为需要接收一些信息，系统调用函数倒比较简单，单纯调用一次 syscall_ipc_recv 就完事了</li>
</ul>
<p> </p>
<h1 id="用户进程的创建-fork-c"><a href="#用户进程的创建-fork-c" class="headerlink" title="用户进程的创建 - fork.c"></a>用户进程的创建 - fork.c</h1><p>用户进程调用 <code>fork</code> 函数时，将会创建一个<strong>和当前一模一样</strong>的新进程：父进程进行一次函数调用，父、子进程都产生一个返回值。父进程返回值为子进程的 <code>env_id</code>，子进程返回值是0，通过返回值不同来标定谁是子进程。 为了实现 <code>fork</code> 函数，我们主要需要补充<code>user/lib/fork.c</code> 中的函数。 实现 <code>fork</code> 的主要流程如下，我们接下来会按顺序介绍（感谢指导书的图.jpg） <img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011703551.png" alt="image-20230501170305441">  </p>
<h2 id="写时复制-COW-与页写入异常"><a href="#写时复制-COW-与页写入异常" class="headerlink" title="写时复制 COW 与页写入异常"></a>写时复制 COW 与页写入异常</h2><p>在通过后文提到的 <code>fork</code> 函数创建进程时，父子进程间会暂时共享内存空间，但实际上在<strong>写入</strong>这两个进程空间时，它们应该互不干扰。那一种直观的做法就是把父进程的<strong>所占用的物理页面</strong>全都复制一遍插入进子进程中。然而这么做会造成很大的内存开销，同时那些本身不可写的页面还需要白复制一遍。 所以我们引入了一种写时复制机制 <strong>COW</strong>，用来解决进程创建后的内存共享问题。COW 的解决思路：当父子进程需要修改可写页面内容（<code>PTE_COW = 1</code>）时产生一种异常，它只新复制出该页的内容以供修改，没用到的页面仍旧保持原状。 考虑到给 <code>PTE_D = 0</code> 的页面写入时会产生 TLB_MOD 异常，我们就顺便把 COW 需要的页面标记为 <code>PTE_D = 0, PTE_COW = 1</code>，也进入 TLB_MOD，并在其中中判断是真正的错误写入，还是 COW 触发。<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305012033983.png" alt="image-20230501203319024">    </p>
<h2 id="申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9"><a href="#申请子进程的进程控制块-sys-exofork-syscall-all-c-Exercise-4-9" class="headerlink" title="申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9"></a>申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9</h2><ul>
<li>  函数作用：为子进程申请一个进程块，并把父进程的内容拷贝</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 通过 env_alloc 申请进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (1/4) */</span></span><br><span class="line">    try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">/* Step 2: 把 KSTACKTOP 下一个 tf 内容拷贝给子进程，tf 内放的是父进程调用 fork 前的用户态 TrapFrame */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (2/4) */</span></span><br><span class="line">    e-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Step 3: 子进程 v0 寄存器(env_tf.regs[2]) 设为 0，说明返回值为 0 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (3/4) */</span></span><br><span class="line">    e-&gt;env_tf.regs[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Step 4: 进程块初始化  */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.9: Your code here. (4/4) */</span></span><br><span class="line">    e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">    e-&gt;env_pri = curenv-&gt;env_pri;</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id; <span class="comment">// 这里返回实际上是父进程的返回值，返回子进程 env_id</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  为了避免 <code>syscall_exofork</code> 的栈帧在后续写时复制机制建立好<strong>之前</strong>被错误地更改，导致返回地址被覆盖，我们把 <code>syscall_exofork</code> 设置为了内联函数，不再创建栈帧，保护了进程地址跳转的正确性。</li>
</ul>
<h3 id="Upd-23-5-4"><a href="#Upd-23-5-4" class="headerlink" title="Upd: 23.5.4"></a>Upd: 23.5.4</h3><ul>
<li>  在父进程执行这个函数的过程中，会把子进程的 v0 寄存器设置为 0；随后父进程从系统调用中返回并恢复现场，<code>syscall_exofork</code> 的返回值为子进程 env_id，而子进程<strong>并没有执行这个函数</strong>，只是在被调度时才首次开始运行，恢复进程控制块中存放的 trapFrame，其中的 EPC 也令进程从 fork 函数中的 <code>syscall_exofork</code> 结束后运行，这时存放于 v0 寄存器的返回值是 0，<strong>看起来好像子进程执行了</strong>这个函数并返回了 0。这就是 <code>syscall_exofork</code> 实现两个不同返回值的过程。</li>
</ul>
<p> </p>
<h2 id="写时保护函数-duppage-Exercise-4-10"><a href="#写时保护函数-duppage-Exercise-4-10" class="headerlink" title="写时保护函数 - duppage - Exercise 4.10"></a>写时保护函数 - duppage - Exercise 4.10</h2><ul>
<li>  这个函数功能比较单一，但考虑的情况比较多</li>
<li>  函数功能：将符合要求的页面 <code>PTE_D</code> 置0，<code>PTE_COW</code> 置1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment"> *   若含有 PTE_LIBRARY 则说明该页面是共享页面，不做处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only the father env can call this function, &#x27;envid&#x27; in args is the child&#x27;s envid */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">duppage</span><span class="params">(u_int envid, u_int vpn)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    u_int addr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* vpt is the 自映射页表 in env&#x27;s virtual memory */</span></span><br><span class="line">    <span class="comment">/* Step 1: 获得当前页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (1/2) */</span></span><br><span class="line">    perm = (vpt)[vpn];</span><br><span class="line">    addr = vpn * BY2PG;</span><br><span class="line">    <span class="comment">/* Step 2: 若页面可写，同时非共享，则标记为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: 先在子进程中映射、后更新父进程的权限位，原因见下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.10: Your code here. (2/2) */</span></span><br><span class="line">    <span class="keyword">if</span> (((perm &amp; PTE_D)  (perm &amp; PTE_COW)) &amp;&amp; !(perm &amp; PTE_LIBRARY)) &#123;<span class="comment">// need to change perm and remap</span></span><br><span class="line">        perm = (perm &amp; ~(PTE_D))  PTE_COW;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 1!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(syscall_getenvid(), (<span class="type">void</span> *) addr, syscall_getenvid(), (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 2!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = syscall_mem_map(<span class="number">0</span>, (<span class="type">void</span> *) addr, envid, (<span class="type">void</span> *) addr, perm)) != <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;duppage mem_map wrong at 3!\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  先给子进程映射的原因可以看<a target="_blank" rel="noopener" href="https://www.cnblogs.com/CindyZhou/p/12858468.html">这里</a></li>
</ul>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305011737320.png" alt="image-20230501173715236"></p>
<blockquote>
<p>如果先给父进程加PTE_COW，然后修改了该页，该页将进行写时复制，父进程指向新的页，而新页没有被加上PTE_COW。此时再map子进程，子进程该页加上PTE_COW位而父进程没有。在随后程序运行中，若父进程进行修改，由于缺失PTE_COW，导致无法进行写时复制，因此子进程的运行出现错误（子进程该页本来不该被改，但却由于父进程被改而一起改了）。</p>
</blockquote>
<p> </p>
<h2 id="设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12"><a href="#设置子进程-TLB-Mod-处理函数-sys-set-tlb-mod-entry-Exercise-4-12" class="headerlink" title="设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12"></a>设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12</h2><p>在 “写时复制 COW 与页写入异常” 一节中，我们已经知道，MOS 处理<strong>写时复制</strong>的时间是在进入 TLB_Mod 异常之后的，现在我们需要先设置 TLB_Mod 的处理函数。注意这里的处理函数可以来自<strong>用户态</strong>。 这样，在后续触发写时复制机制时，就能直接从用户给出的函数开始执行，处理异常了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_tlb_mod_entry</span><span class="params">(u_int envid, u_int func)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取目标进程块 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (1/2) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 2: 给函数入口字段赋值 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.12: Your code here. (2/2) */</span></span><br><span class="line">    env-&gt;env_user_tlb_mod_entry = func;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里的 func 指的实际是异常处理函数的入口地址，当触发异常时，<code>do_tlb_mod</code> 会将 EPC 设置为 func 的值，同时退出异常，借此执行 Mod 异常的处理。</li>
</ul>
<h2 id="TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11"><a href="#TLB-Mod-响应函数-do-tlb-mod-Exercise-4-11" class="headerlink" title="TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11"></a>TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11</h2><ul>
<li>  当系统发生 TLB_Mod 异常后，首先进入这里的 handler，设置好跳转后再 <code>ret_from_exception</code> 回到用户态，执行真正响应异常的用户态函数，最后再从该函数中返回受害指令</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   This is the TLB Mod exception handler in kernel.</span></span><br><span class="line"><span class="comment"> *   Our kernel allows user programs to handle TLB Mod exception in user mode,</span></span><br><span class="line"><span class="comment"> * so we copy its context &#x27;tf&#x27; into UXSTACK and modify the EPC to the registered</span></span><br><span class="line"><span class="comment"> * user exception entry.</span></span><br><span class="line"><span class="comment"> *   The user entry should handle this TLB Mod exception and restore the</span></span><br><span class="line"><span class="comment"> * context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_tlb_mod</span><span class="params">(<span class="keyword">struct</span> Trapframe *tf)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">tmp_tf</span> =</span> *tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 置位用户异常栈指针，并将当前异常 TrapFrame 复制到用户异常栈中 */</span></span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">    &#125;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Trapframe);</span><br><span class="line">    *(<span class="keyword">struct</span> Trapframe *)tf-&gt;regs[<span class="number">29</span>] = tmp_tf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: 存在用户的异常处理函数，手动设置处理函数的参数 */</span></span><br><span class="line">    <span class="keyword">if</span> (curenv-&gt;env_user_tlb_mod_entry) &#123;</span><br><span class="line">        tf-&gt;regs[<span class="number">4</span>] = tf-&gt;regs[<span class="number">29</span>];           <span class="comment">// a0 = 用户异常栈地址</span></span><br><span class="line">        tf-&gt;regs[<span class="number">29</span>] -= <span class="keyword">sizeof</span>(tf-&gt;regs[<span class="number">4</span>]);  <span class="comment">// 移动异常栈指针，为函数调用保存参数留出空间</span></span><br><span class="line">        <span class="comment">// Hint: Set &#x27;cp0_epc&#x27; in the context &#x27;tf&#x27; to</span></span><br><span class="line">        <span class="comment">// &#x27;curenv-&gt;env_user_tlb_mod_entry&#x27;.</span></span><br><span class="line">        <span class="comment">/* Exercise 4.11: Your code here. */</span></span><br><span class="line">        tf-&gt;cp0_epc = curenv-&gt;env_user_tlb_mod_entry;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        panic(<span class="string">&quot;TLB Mod but no user handler registered&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="用户异常栈"><a href="#用户异常栈" class="headerlink" title="用户异常栈"></a>用户异常栈</h3><ul>
<li>  前面在栈帧一小节中已经提到了用户栈、内核栈和他们的作用，这里还要提到一个新的栈帧：用户异常栈（<code>va = UXSTACKTOP</code>），它充当在用户态中处理异常所用到的函数的栈，这里就是页写入异常处理函数的栈</li>
<li>  用户异常栈和内核栈功能类似，都是在发生异常时开始使用，同时都从对应栈的 TOP 开始记录，看起来用户异常栈应该也允许异常重入。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;regs[<span class="number">29</span>] &lt; USTACKTOP  tf-&gt;regs[<span class="number">29</span>] &gt;= UXSTACKTOP) &#123;</span><br><span class="line">    tf-&gt;regs[<span class="number">29</span>] = UXSTACKTOP;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果 regs[29] 在用户异常栈中，应该就不需要再次赋值了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  这里的 Step2 为什么要做这样一系列操作呢？因为这个C语言函数结束后，会通过汇编语言的 <code>ret_from_exception</code> 直接返回 EPC。因为没有显式的函数调用，所以编译器并不会为后续跳转到的处理函数创建栈帧，这里我们需要手动创建<strong>用户异常栈</strong>中的函数栈帧，供异常处理函数使用</li>
</ul>
<p> </p>
<h2 id="TLB-Mod-的实际处理-cow-entry-Exercise-4-13"><a href="#TLB-Mod-的实际处理-cow-entry-Exercise-4-13" class="headerlink" title="TLB_Mod 的实际处理 - cow_entry - Exercise 4.13"></a>TLB_Mod 的实际处理 - cow_entry - Exercise 4.13</h2><p>没错，这个函数就是刚才提到的用户态异常处理函数，执行 <code>ret_from_exception</code> 后会从这里继续执行。最终在这里完成写时复制页面的复制，并返回用户态继续执行受害指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   Map the faulting page to a private writable copy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;va&#x27; 为受害的虚拟地址</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __attribute__((<span class="keyword">noreturn</span>)) cow_entry(<span class="keyword">struct</span> Trapframe *tf) &#123;</span><br><span class="line">    u_int va = tf-&gt;cp0_badvaddr;</span><br><span class="line">    u_int perm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: 获取受害页面的标志位，判断是否为写时复制 */</span></span><br><span class="line">    <span class="comment">/* Hint: Use &#x27;vpt&#x27; and &#x27;VPN&#x27; to find the page table entry. If the &#x27;perm&#x27; doesn&#x27;t have</span></span><br><span class="line"><span class="comment">     * &#x27;PTE_COW&#x27;, launch a &#x27;user_panic&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (1/6) */</span></span><br><span class="line">    u_int envid = syscall_getenvid();</span><br><span class="line">    perm = ((Pte *)(vpt))[VPN(va)] &amp; <span class="number">0xfff</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(perm &amp; PTE_COW)) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;?&quot;</span>);   <span class="comment">// 不是写时复制，意味着就是访问错了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: 写时复制，设置新页面的权限位 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (2/6) */</span></span><br><span class="line">    perm = (perm &amp; ~(PTE_COW))  PTE_D;</span><br><span class="line">    <span class="comment">/* Step 3: 在 UCOW 空间申请一个临时页面，并建立映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (3/6) */</span></span><br><span class="line">    syscall_mem_alloc(envid, (<span class="type">void</span> *) UCOW, perm);</span><br><span class="line">    <span class="comment">/* Step 4: 把 va 那个页面内容复制过去 */</span></span><br><span class="line">    <span class="comment">/* Hint: &#x27;va&#x27; may not be aligned to a page! */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (4/6) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) UCOW, (<span class="type">void</span> *) ROUNDDOWN(va, BY2PG), BY2PG);</span><br><span class="line">    <span class="comment">/* Step 5: 用 Step2 的 perm 新建了一个 va 的新映射 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (5/6) */</span></span><br><span class="line">    syscall_mem_map(envid, (<span class="type">void</span> *) UCOW, envid, (<span class="type">void</span> *) va, perm);</span><br><span class="line">    <span class="comment">/* Step 6: 解除 UCOW 的占用 */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.13: Your code here. (6/6) */</span></span><br><span class="line">    syscall_mem_unmap(envid, (<span class="type">void</span> *) UCOW);</span><br><span class="line">    <span class="comment">// Step 7: 恢复栈帧，彻底退出异常 */</span></span><br><span class="line">    <span class="type">int</span> r = syscall_set_trapframe(<span class="number">0</span>, tf);</span><br><span class="line">    user_panic(<span class="string">&quot;syscall_set_trapframe returned %d&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>cow_entry</code> 的实际作用就是建立了一个<strong>受害页面在页表中的新映射</strong>。这个映射只有权限位不同，当再次写入受害 va 所在的页面时，会得到正确的 perm。</li>
<li>  旧：UCOW 空，va 会触发写时复制（申请物理页面，复制va-&gt; UCOW） 过程中：UCOW va内容，va会触发写时复制 结束：UCOW 空，va不会触发写时复制，指向UCOW 申请得到的那个物理页面</li>
</ul>
<p> </p>
<h2 id="子进程控制块设置-sys-env-set-status-Exercise-4-14"><a href="#子进程控制块设置-sys-env-set-status-Exercise-4-14" class="headerlink" title="子进程控制块设置 - sys_env_set_status - Exercise 4.14"></a>子进程控制块设置 - sys_env_set_status - Exercise 4.14</h2><ul>
<li>  启动新进程的最后一步：执行完所有的设置后，最后通过这个函数将子进程插入待调度队列，正式启动子进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_set_env_status</span><span class="params">(u_int envid, u_int status)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Check if &#x27;status&#x27; is valid. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (1/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status != ENV_RUNNABLE &amp;&amp; status != ENV_NOT_RUNNABLE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Convert the envid to its corresponding &#x27;struct Env *&#x27; using &#x27;envid2env&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (2/3) */</span></span><br><span class="line">    try(envid2env(envid, &amp;env, <span class="number">1</span>));</span><br><span class="line">    <span class="comment">/* Step 4: Update &#x27;env_sched_list&#x27; if the &#x27;env_status&#x27; of &#x27;env&#x27; is being changed. */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.14: Your code here. (3/3) */</span></span><br><span class="line">    <span class="keyword">if</span> (status == ENV_RUNNABLE) &#123;</span><br><span class="line">        TAILQ_INSERT_TAIL(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TAILQ_REMOVE(&amp;env_sched_list, env, env_sched_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 5: Set the &#x27;env_status&#x27; of &#x27;env&#x27;. */</span></span><br><span class="line">    env-&gt;env_status = status;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Upd-23-5-5"><a href="#Upd-23-5-5" class="headerlink" title="Upd: 23.5.5"></a>Upd: 23.5.5</h3><p>需要在 Step4 中额外留意 <code>status</code> 的变化，如果变为 RUNNABLE 则需要加入至调度队列，如果 NOT_RUNNABLE 则需要<strong>移出</strong>，因为在 Lab3 的 <code>schedule</code> 函数中，我们已经要求所有变化进程状态的函数需要负责维护 <code>env_sched_list</code>，在这里就需要将 NOT_RUNNABLE 的函数移除。感谢芬海哥哥捏，指出了这里的错误 以上，就是创建一个子进程所需要的全部步骤，那么 fork 函数，实际上就是这些函数的结合  </p>
<h2 id="子进程的创建-fork-Exercise-4-15"><a href="#子进程的创建-fork-Exercise-4-15" class="headerlink" title="子进程的创建 - fork - Exercise 4.15"></a>子进程的创建 - fork - Exercise 4.15</h2><p> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    u_int child;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Set our TLB Mod user exception entry to &#x27;cow_entry&#x27; if not done yet. */</span></span><br><span class="line">    <span class="keyword">if</span> (env-&gt;env_user_tlb_mod_entry != (u_int)cow_entry) &#123;</span><br><span class="line">        try(syscall_set_tlb_mod_entry(<span class="number">0</span>, cow_entry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Create a child env that&#x27;s not ready to be scheduled. */</span></span><br><span class="line">    <span class="comment">// Hint: &#x27;env&#x27; should always point to the current env itself, so we should fix it to the</span></span><br><span class="line">    <span class="comment">// correct value.</span></span><br><span class="line">    child = syscall_exofork();</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="number">0</span>) &#123;</span><br><span class="line">        env = envs + ENVX(syscall_getenvid());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Map all mapped pages below &#x27;USTACKTOP&#x27; into the child&#x27;s address space. */</span></span><br><span class="line">    <span class="comment">// Hint: You should use &#x27;duppage&#x27;.</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (1/2) */</span></span><br><span class="line">    <span class="keyword">for</span> (i = UTEMP &gt;&gt; <span class="number">12</span>; i * BY2PG &lt; USTACKTOP; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((vpd[i / <span class="number">1024</span>] &amp; PTE_V) &amp;&amp; (vpt[i] &amp; PTE_V)) &#123;</span><br><span class="line">            duppage(child, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Set up the child&#x27;s tlb mod handler and set child&#x27;s &#x27;env_status&#x27; to</span></span><br><span class="line"><span class="comment">     * &#x27;ENV_RUNNABLE&#x27;. */</span></span><br><span class="line">    <span class="comment">/* Hint:</span></span><br><span class="line"><span class="comment">     *   You may use &#x27;syscall_set_tlb_mod_entry&#x27; and &#x27;syscall_set_env_status&#x27;</span></span><br><span class="line"><span class="comment">     *   Child&#x27;s TLB Mod user exception entry should handle COW, so set it to &#x27;cow_entry&#x27;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/* Exercise 4.15: Your code here. (2/2) */</span></span><br><span class="line">    syscall_set_tlb_mod_entry(child, cow_entry);</span><br><span class="line">    syscall_set_env_status(child, ENV_RUNNABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  在这里唯一需要考虑的点就是 Step3 中 for 循环的起止条件、if 的判断条件</li>
<li>  i 在这里表示的是<strong>用户态可用虚拟内存的页号</strong>： <code>UTEMP &gt;&gt; 12</code> ，是正式可以被用户态使用的第一个页面，而 <code>USTACKTOP &gt;&gt; 12</code> 则是最后一个</li>
<li>  if 的判断条件则是：i 对应的虚拟页面是否能在页表中查到有效的映射，如果有，说明它需要考虑是否需要标记 <code>PTE_COW</code>。</li>
</ul>
<p> </p>
<h1 id="一言"><a href="#一言" class="headerlink" title="一言"></a>一言</h1><p>Lab4 到这里可算是结束了，这个 Lab 给人最直观的感受就是码量的上升与内核态/用户态函数的协同更复杂了。这篇文章唠唠叨叨说了这么多，也是想尝试从更深一层去了解 MOS 运作的机理，而不是简单的完成几个填空，知晓表象就弃若敝履罢了。文章实际上没有想做什么分享，算是自我总结吧，因为自己都不知道对不对（笑 还剩两个 Lab，希望能把习惯保持下去  </p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>一些没用上的函数，贴一下</p>
<h2 id="syscall-all-c"><a href="#syscall-all-c" class="headerlink" title="syscall_all.c"></a>syscall_all.c</h2><h3 id="打印字符至控制台-sys-putchar"><a href="#打印字符至控制台-sys-putchar" class="headerlink" title="打印字符至控制台 - sys_putchar"></a>打印字符至控制台 - sys_putchar</h3><p>直接调用了 <code>printcharc</code> 函数，和 <code>printk</code> 效果类似吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sys_putchar</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    printcharc((<span class="type">char</span>)c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="打印用户空间的定长字符串-sys-print-cons"><a href="#打印用户空间的定长字符串-sys-print-cons" class="headerlink" title="打印用户空间的定长字符串 - sys_print_cons"></a>打印用户空间的定长字符串 - sys_print_cons</h3><p>先检查了地址是否位于用户区域，然后检查了长度是不是正的，最后循环调用了 <code>printcharc</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_print_cons</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *s, u_int num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (((u_int)s + num) &gt; UTOP  ((u_int)s) &gt;= UTOP  (s &gt; s + num)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    u_int i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        printcharc(((<span class="type">char</span> *)s)[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="获得运行中进程块的-id-sys-getenvid"><a href="#获得运行中进程块的-id-sys-getenvid" class="headerlink" title="获得运行中进程块的 id - sys_getenvid"></a>获得运行中进程块的 id - sys_getenvid</h3><p>就一句话，但是好像还没有在 MOS 中使用过</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u_int <span class="title function_">sys_getenvid</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> curenv-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="销毁进程-sys-env-destroy"><a href="#销毁进程-sys-env-destroy" class="headerlink" title="销毁进程 - sys_env_destroy"></a>销毁进程 - sys_env_destroy</h3><p>只有直系进程才能进行销毁（自己也行）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_env_destroy</span><span class="params">(u_int envid)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">    try(envid2env(envid, &amp;e, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    printk(<span class="string">&quot;[%08x] destroying %08x\n&quot;</span>, curenv-&gt;env_id, e-&gt;env_id);</span><br><span class="line">    env_destroy(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h3 id="读入字符-sys-cgetc"><a href="#读入字符-sys-cgetc" class="headerlink" title="读入字符 - sys_cgetc"></a>读入字符 - sys_cgetc</h3><p>直接调用了函数 <code>scancharc</code> ，此时会让系统处于忙等状态，直至接收到字符返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_cgetc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = scancharc()) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab4/">https://cookedbear.github.io/2023/05/os/buaa-os-probe-lab4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171224880.png?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/os/buaa-os-lab5-1-exam/" title="BUAA-OS-2023-Lab5-1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305160043577.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-2023-Lab5-1-Exam</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/os/buaa-os-lab4-1-exam/" title="BUAA-OS-2023-Lab4-1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171233017.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-2023-Lab4-1-Exam</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/os/buaa-os-lab1-exam/" title="BUAA-OS-2023-Lab1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171229827.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">BUAA-OS-2023-Lab1-Exam</div></div></a></div><div><a href="/2023/04/os/buaa-os-lab3-exam/" title="BUAA-OS-2023-Lab3-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171231921.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">BUAA-OS-2023-Lab3-Exam</div></div></a></div><div><a href="/2023/06/os/buaa-os-challenge-lab6/" title="BUAA-OS-2023-Lab6-Challenge"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-10</div><div class="title">BUAA-OS-2023-Lab6-Challenge</div></div></a></div><div><a href="/2023/04/os/buaa-os-lab4-1-exam/" title="BUAA-OS-2023-Lab4-1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171233017.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="title">BUAA-OS-2023-Lab4-1-Exam</div></div></a></div><div><a href="/2023/05/os/buaa-os-lab5-2-exam/" title="BUAA-OS-2023-Lab5-2-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305231505897.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-23</div><div class="title">BUAA-OS-2023-Lab5-2-Exam</div></div></a></div><div><a href="/2023/03/os/buaa-os-probe-lab2/" title="BUAA-OS-Probe-Lab2"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171219228.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-31</div><div class="title">BUAA-OS-Probe-Lab2</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">Lab4 - 系统调用与进程创建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%9C%A8%E5%B9%B2%E5%95%A5%EF%BC%88%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">系统调用在干啥（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="toc-number">2.2.</span> <span class="toc-text">系统调用过程概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E8%B5%B7%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-syscall"><span class="toc-number">2.3.</span> <span class="toc-text">发起系统调用 - syscall_*</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81-msyscall-Exercise-4-1"><span class="toc-number">2.4.</span> <span class="toc-text">转入内核态 - msyscall - Exercise 4.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8-do-syscall"><span class="toc-number">2.5.</span> <span class="toc-text">分发系统调用 - do_syscall</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%A0%88%E4%B8%8E%E5%86%85%E6%A0%B8%E6%A0%88"><span class="toc-number">2.5.1.</span> <span class="toc-text">用户栈与内核栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7-stack-frame"><span class="toc-number">2.5.2.</span> <span class="toc-text">栈帧 - stack frame</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">系统调用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E5%9D%97-envid2env-Exercise-4-3"><span class="toc-number">2.6.1.</span> <span class="toc-text">获取进程块 - envid2env -Exercise 4.3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2-sys-yield-Exercise-4-7"><span class="toc-number">2.6.2.</span> <span class="toc-text">强制进行进程切换 - sys_yield - Exercise 4.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E5%BB%BA%E7%AB%8B-va2pa-%E7%9A%84%E6%98%A0%E5%B0%84-sys-mem-alloc-Exercise-4-4"><span class="toc-number">2.6.3.</span> <span class="toc-text">指定进程建立 va2pa 的映射 - sys_mem_alloc - Exercise 4.4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%BD%A2%E6%88%90%E5%85%B1%E5%90%8C%E7%9A%84%E6%98%A0%E5%B0%84-sys-mem-map-Exercise-4-5"><span class="toc-number">2.6.4.</span> <span class="toc-text">在不同进程间形成共同的映射 - sys_mem_map - Exercise 4.5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%99%A4%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%98%A0%E5%B0%84-sys-mem-unmap-Exercise-4-6"><span class="toc-number">2.6.5.</span> <span class="toc-text">解除指定进程的映射 - sys_mem_unmap - Exercise 4.6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%BD%93%E5%89%8D%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AD%90%E8%BF%9B%E7%A8%8B-sys-exofork-Exercise-4-9"><span class="toc-number">2.6.6.</span> <span class="toc-text">为当前进程创建一个子进程 - sys_exofork - Exercise 4.9</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%9B%E7%A8%8B%E5%9D%97-status-sys-set-env-status"><span class="toc-number">2.6.7.</span> <span class="toc-text">设置进程块 status - sys_set_env_status</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-trapframe-sys-set-trapframe"><span class="toc-number">2.6.8.</span> <span class="toc-text">设置 trapframe - sys_set_trapframe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc-%E9%80%9A%E4%BF%A1%EF%BC%9A%E6%8E%A5%E6%94%B6%E7%AB%AF%E8%BF%9B%E7%A8%8B-sys-ipc-recv-Exercise-4-8"><span class="toc-number">2.6.9.</span> <span class="toc-text">ipc 通信：接收端进程 - sys_ipc_recv - Exercise 4.8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ipc-%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%8F%91%E9%80%81%E7%AB%AF%E8%BF%9B%E7%A8%8B-sys-ipc-send-Exercise-4-8"><span class="toc-number">2.6.10.</span> <span class="toc-text">ipc 通信：发送端进程 - sys_ipc_send - Exercise 4.8</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ipc-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-ipc-c"><span class="toc-number">3.</span> <span class="toc-text">ipc 进程通信 - ipc.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%8F%91%E9%80%81%E5%87%BD%E6%95%B0-ipc-send"><span class="toc-number">3.1.</span> <span class="toc-text">用户态发送函数 - ipc_send</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E6%8E%A5%E6%94%B6%E5%87%BD%E6%95%B0-ipc-recv"><span class="toc-number">3.2.</span> <span class="toc-text">用户态接收函数 - ipc_recv</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-fork-c"><span class="toc-number">4.</span> <span class="toc-text">用户进程的创建 - fork.c</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6-COW-%E4%B8%8E%E9%A1%B5%E5%86%99%E5%85%A5%E5%BC%82%E5%B8%B8"><span class="toc-number">4.1.</span> <span class="toc-text">写时复制 COW 与页写入异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-sys-exofork-syscall-all-c-Exercise-4-9"><span class="toc-number">4.2.</span> <span class="toc-text">申请子进程的进程控制块 - sys_exofork - syscall_all.c - Exercise 4.9</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Upd-23-5-4"><span class="toc-number">4.2.1.</span> <span class="toc-text">Upd: 23.5.4</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E6%97%B6%E4%BF%9D%E6%8A%A4%E5%87%BD%E6%95%B0-duppage-Exercise-4-10"><span class="toc-number">4.3.</span> <span class="toc-text">写时保护函数 - duppage - Exercise 4.10</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%90%E8%BF%9B%E7%A8%8B-TLB-Mod-%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0-sys-set-tlb-mod-entry-Exercise-4-12"><span class="toc-number">4.4.</span> <span class="toc-text">设置子进程 TLB_Mod 处理函数 - sys_set_tlb_mod_entry - Exercise 4.12</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLB-Mod-%E5%93%8D%E5%BA%94%E5%87%BD%E6%95%B0-do-tlb-mod-Exercise-4-11"><span class="toc-number">4.5.</span> <span class="toc-text">TLB_Mod 响应函数 - do_tlb_mod - Exercise 4.11</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E5%BC%82%E5%B8%B8%E6%A0%88"><span class="toc-number">4.5.1.</span> <span class="toc-text">用户异常栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TLB-Mod-%E7%9A%84%E5%AE%9E%E9%99%85%E5%A4%84%E7%90%86-cow-entry-Exercise-4-13"><span class="toc-number">4.6.</span> <span class="toc-text">TLB_Mod 的实际处理 - cow_entry - Exercise 4.13</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E8%AE%BE%E7%BD%AE-sys-env-set-status-Exercise-4-14"><span class="toc-number">4.7.</span> <span class="toc-text">子进程控制块设置 - sys_env_set_status - Exercise 4.14</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Upd-23-5-5"><span class="toc-number">4.7.1.</span> <span class="toc-text">Upd: 23.5.5</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-fork-Exercise-4-15"><span class="toc-number">4.8.</span> <span class="toc-text">子进程的创建 - fork - Exercise 4.15</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E8%A8%80"><span class="toc-number">5.</span> <span class="toc-text">一言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">6.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#syscall-all-c"><span class="toc-number">6.1.</span> <span class="toc-text">syscall_all.c</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E8%87%B3%E6%8E%A7%E5%88%B6%E5%8F%B0-sys-putchar"><span class="toc-number">6.1.1.</span> <span class="toc-text">打印字符至控制台 - sys_putchar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84%E5%AE%9A%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2-sys-print-cons"><span class="toc-number">6.1.2.</span> <span class="toc-text">打印用户空间的定长字符串 - sys_print_cons</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E8%BF%90%E8%A1%8C%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%9D%97%E7%9A%84-id-sys-getenvid"><span class="toc-number">6.1.3.</span> <span class="toc-text">获得运行中进程块的 id - sys_getenvid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%80%E6%AF%81%E8%BF%9B%E7%A8%8B-sys-env-destroy"><span class="toc-number">6.1.4.</span> <span class="toc-text">销毁进程 - sys_env_destroy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%85%A5%E5%AD%97%E7%AC%A6-sys-cgetc"><span class="toc-number">6.1.5.</span> <span class="toc-text">读入字符 - sys_cgetc</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/galgame/cyanotype-daydream/" title="梦、世界与拯救——《白日梦的构想图》有感"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202307072353014.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="梦、世界与拯救——《白日梦的构想图》有感"/></a><div class="content"><a class="title" href="/2023/07/galgame/cyanotype-daydream/" title="梦、世界与拯救——《白日梦的构想图》有感">梦、世界与拯救——《白日梦的构想图》有感</a><time datetime="2023-07-07T15:54:28.000Z" title="发表于 2023-07-07 23:54:28">2023-07-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/learning/python_class/" title="BUAA-Python-Note"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306122322922.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-Python-Note"/></a><div class="content"><a class="title" href="/2023/06/learning/python_class/" title="BUAA-Python-Note">BUAA-Python-Note</a><time datetime="2023-06-27T15:22:04.000Z" title="发表于 2023-06-27 23:22:04">2023-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/os/buaa-os-top/" title="BUAA-OS-TOP"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306132108192.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OS-TOP"/></a><div class="content"><a class="title" href="/2023/06/os/buaa-os-top/" title="BUAA-OS-TOP">BUAA-OS-TOP</a><time datetime="2023-06-22T07:50:02.000Z" title="发表于 2023-06-22 15:50:02">2023-06-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/buaa-oo-unit4-summary/" title="BUAA-OO-UNIT4-Summary"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306132108192.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OO-UNIT4-Summary"/></a><div class="content"><a class="title" href="/2023/06/buaa-oo-unit4-summary/" title="BUAA-OO-UNIT4-Summary">BUAA-OO-UNIT4-Summary</a><time datetime="2023-06-13T06:50:01.000Z" title="发表于 2023-06-13 14:50:01">2023-06-13</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>