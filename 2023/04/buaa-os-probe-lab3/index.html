<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-Probe-Lab3 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab3 - 进程与异常Lab3 中主要涉及到以下内容：    进程的创建   时钟中断与内核态   进程调度与进程切换   数据进程控制块 Env  进程控制块与初始化   由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。   进程是一个活动中的实体，拥有自己的虚拟地址空间。   程序是非活动的实体，执行中的程序就是进程  进程控制块 - PCBstruc">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-Probe-Lab3">
<meta property="og:url" content="https://cookedbear.github.io/2023/04/buaa-os-probe-lab3/index.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="Lab3 - 进程与异常Lab3 中主要涉及到以下内容：    进程的创建   时钟中断与内核态   进程调度与进程切换   数据进程控制块 Env  进程控制块与初始化   由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。   进程是一个活动中的实体，拥有自己的虚拟地址空间。   程序是非活动的实体，执行中的程序就是进程  进程控制块 - PCBstruc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171223110.png?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-04-15T16:59:10.000Z">
<meta property="article:modified_time" content="2023-05-17T04:35:46.444Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171223110.png?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/2023/04/buaa-os-probe-lab3/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-Probe-Lab3',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-17 12:35:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171223110.png?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-Probe-Lab3</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-15T16:59:10.000Z" title="发表于 2023-04-16 00:59:10">2023-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-17T04:35:46.444Z" title="更新于 2023-05-17 12:35:46">2023-05-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/MOS-Probe/">MOS Probe</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-Probe-Lab3"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab3-进程与异常"><a href="#Lab3-进程与异常" class="headerlink" title="Lab3 - 进程与异常"></a>Lab3 - 进程与异常</h1><p>Lab3 中主要涉及到以下内容：</p>
<ul>
<li>  进程的创建</li>
<li>  时钟中断与内核态</li>
<li>  进程调度与进程切换</li>
<li>  <strong>数据进程控制块</strong> <code>Env</code></li>
</ul>
<h1 id="进程控制块与初始化"><a href="#进程控制块与初始化" class="headerlink" title="进程控制块与初始化"></a>进程控制块与初始化</h1><ul>
<li>  由于没有在 MOS 操作系统中实现线程，所以进程既是基本的分配单元，也是基本的执行单元。</li>
<li>  进程是一个活动中的实体，拥有自己的虚拟地址空间。</li>
<li>  程序是非活动的实体，<strong>执行中</strong>的程序就是<strong>进程</strong></li>
</ul>
<h2 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 - PCB"></a>进程控制块 - PCB</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// 保存上下文环境，定义于 trap.h 中</span></span><br><span class="line">    LIST_ENTRY(Env) env_link;<span class="comment">// 构建空闲进程链表 env_free_link</span></span><br><span class="line">    u_int env_id;<span class="comment">// 进程标识符</span></span><br><span class="line">    u_int env_parent_id;<span class="comment">// 父进程的进程 id</span></span><br><span class="line">    u_int env_status;<span class="comment">// 进程块状态位</span></span><br><span class="line">    Pde *env_pgdir;<span class="comment">// 进程页目录的虚拟地址</span></span><br><span class="line">    TAILQ_ENTRY(Env) env_sched_link;<span class="comment">// 构造调度队列 env_sched_list</span></span><br><span class="line">    u_int env_pri;<span class="comment">// 进程优先级，与后续时间片调度进程相关</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>env_status</code>：<ul>
<li>  <code>ENV_FREE</code>：进程控制块处于空闲链表中，值为0</li>
<li>  <code>ENV_NOT_RUNNABLE</code>：<strong>阻塞态</strong>，可转变为就绪状态，值为1</li>
<li>  <code>ENV_RUNNABLE</code>：就绪、执行状态（等待调度/运行中），值为2</li>
</ul>
</li>
<li>  在 MOS 中，进程控制块的<strong>物理地址</strong>已经被分配好了（<code>envs</code>数组）</li>
</ul>
<p>这里的初始化使用了__attribute__函数，做完再看 其中的结构体 <code>TrapFrame</code> 在 Lab4 中作用比较大，但在 Lab3 中没有必要过于关注，结构就不再过多介绍了 Env 块中存在两个链表（<code>env_free_list</code>和<code>env_sched_list</code>），<code>TAILQ</code> 结构在 Lab2 的 Probe 中已经提过了，该结构为双向的有尾列表，支持在头尾进行元素增删操作。</p>
<h2 id="跨页地址映射-map-segment-Exercise-3-2"><a href="#跨页地址映射-map-segment-Exercise-3-2" class="headerlink" title="跨页地址映射 - map_segment - Exercise 3.2"></a>跨页地址映射 - <code>map_segment</code> - Exercise 3.2</h2><ul>
<li>  函数作用如下：物理地址映射到指定进程的虚拟地址中（更大的 <code>page_insert</code>）</li>
<li>将物理地址 pa <strong>按页映射</strong>到指定进程页表中（va）<ul>
<li>  映射大小 size 必须是<strong>页面大小的整数倍</strong></li>
</ul>
</li>
<li>  设置用到的页表项权限位为 perm</li>
</ul>
<p>这个函数在上面的 <code>env_init()</code>中使用过，其将内核中 pages 与 envs 所在的物理地址映射到内核页表中，我们可以根据下面这个实例补充代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES, ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), </span><br><span class="line">BY2PG), PTE_G);</span><br></pre></td></tr></table></figure>

<p>代码中注释已经给好方向，使用<code>page_insert()</code>，将 <code>[va, va+size)</code> 所涉及到的每个页面都映射到 pa 开始的页面中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 将 pa 地址内容映射到指定页目录中的虚拟地址 va</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">map_segment</span><span class="params">(Pde *pgdir, u_int asid, u_long pa, u_long va,</span></span><br><span class="line"><span class="params">                        u_int size, u_int perm)</span> &#123;</span><br><span class="line">  <span class="comment">/* 预先确保地址对齐 */</span></span><br><span class="line">  assert(pa % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(va % BY2PG == <span class="number">0</span>);</span><br><span class="line">  assert(size % BY2PG == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 循环对应的每一页形成映射 */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2PG) &#123; </span><br><span class="line">    <span class="comment">/*  使用 pa2page 获取物理地址 pa 对应的页控制块</span></span><br><span class="line"><span class="comment">     * va + i 表示每个虚拟页的基地址，pa + i 表示页框基地址</span></span><br><span class="line"><span class="comment">     * 使用 page_insert 形成新映射，**权限**设置为 perm</span></span><br><span class="line"><span class="comment">     * Exercise 3.2: Your code here. */</span></span><br><span class="line">    page_insert(pgdir, asid, pa2page(pa + i), va + i, perm);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进程块队列初始化-env-init-Exercise-3-1"><a href="#进程块队列初始化-env-init-Exercise-3-1" class="headerlink" title="进程块队列初始化 - env_init - Exercise 3.1"></a>进程块队列初始化 - <code>env_init</code> - Exercise 3.1</h2><ul>
<li>  函数功能：初始化 envs 链表</li>
<li>  完成 <strong>Env 控制块</strong>的空闲队列、调度队列的<strong>初始化功能</strong></li>
<li>  空闲队列需要<strong>倒序插入</strong>，用来优先分配小序号的进程控制块 Env</li>
<li>  临时存放 内核结构 ‘pages’ 与 ‘envs’ ，为后续映射做准备（详见 Exercise 3.3）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">env_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="comment">/* Step 1: 初始化 `env_free_list` 与 `env_sched_list` 两个调度队列 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (1/2) */</span></span><br><span class="line">  LIST_INIT(&amp;env_free_list);</span><br><span class="line">  TAILQ_INIT(&amp;env_sched_list);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 将所有进程控制块插入空闲队列中，注意需要 **倒序** 插入 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.1: Your code here. (2/2) */</span></span><br><span class="line">  <span class="keyword">for</span> (i = NENV - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    LIST_INSERT_HEAD(&amp;env_free_list, &amp;envs[i], env_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将内核结构 &#x27;pages&#x27; 与 &#x27;envs&#x27; 映射到每个用户空间的虚拟地址（UPAGES </span></span><br><span class="line"><span class="comment">   * 和 UENVS）中，并要求只读，这里先暂时把两个内容存在一个临时页目录 &#x27;base_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   * 中，并建立映射，直至 `env_setup_vm&#x27; 中再将其拷贝进用户页目录 &#x27;env_pgdir&#x27;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  panic_on(page_alloc(&amp;p));</span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line"></span><br><span class="line">  base_pgdir = (Pde *)page2kva(p);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(pages), UPAGES,</span><br><span class="line">              ROUND(npage * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Page), BY2PG), PTE_G);</span><br><span class="line">  map_segment(base_pgdir, <span class="number">0</span>, PADDR(envs), UENVS,</span><br><span class="line">              ROUND(NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env), BY2PG), PTE_G);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现较简单，注意要区分 Env 结构体中存在的链表，env_free_list 链表需要使用 env_link 连接，使用LIST类宏操作；而 env_sched_list 需要使用 env_sched_link 连接，使用 TAILQ 类宏操作</p>
<h2 id="env-id-与进程表示"><a href="#env-id-与进程表示" class="headerlink" title="env_id 与进程表示"></a>env_id 与进程表示</h2><p>在进程管理块 Env 中，有三个与 <code>id</code> 相关的字段，它们从不同的方式代表进程</p>
<ul>
<li>  <code>env_id</code> ：（进程标识符，unique environment identifier）MOS 操作系统中使用 <code>env_id</code> <strong>唯一地</strong>表示不同进程，在创建进程时被 <code>mkenvid</code> 函数赋值</li>
<li><code>env_asid</code> ：（地址空间标识符，Address-Space IDentifier）ASID也可以<strong>唯一地</strong>标记进程，同时为进程提供相应的<strong>地址保护</strong><ul>
<li>  在 MOS 实验系统中使用 &lt;VirtualPageNumber, ASID&gt; 作为索引在 TLB 中查询映射</li>
<li>  在 MOS 中，使用了<strong>位图法</strong>管理了64个 ASID ，具体位于 asid_alloc 函数中</li>
</ul>
</li>
<li>  <code>env_parentid</code> ：（env_id of this env’s parent）顾名思义是创建本进程的父进程的 <code>env_id</code></li>
</ul>
<p>对于<code>id</code>与<code>asid</code>：<code>id</code>指的是控制块和线程自己的属性；<code>asid</code>则在 TLB 、地址管理上用的比较多 <code>env_id</code> 的值从同文件中的 <code>mkenvid()</code> 函数中得来，asid由同文件中的 <code>asid_alloc()</code> 得到</p>
<h2 id="Linux-中的-ASID-分代机制-（有空再补）"><a href="#Linux-中的-ASID-分代机制-（有空再补）" class="headerlink" title="Linux 中的 ASID 分代机制 （有空再补）"></a>Linux 中的 ASID 分代机制 （有空再补）</h2><p>   </p>
<h1 id="加载二进制镜像"><a href="#加载二进制镜像" class="headerlink" title="加载二进制镜像"></a>加载二进制镜像</h1><p>程序想要成为进程，必须要把对应的的 ELF 文件（此处为<strong>可执行文件</strong>）中所有需要加载的 <strong>程序段(Segment)</strong> 分配进虚拟内存空间中。但在 lab3 中我们还不能直接操作磁盘中的文件，所以 ELF 文件被转化为C数组的形式，再通过编译到内核完成加载 这里可以使用部分函数操作 ELF 文件，加载整个文件进入内存、获取其文件头、加载 segment 至内存</p>
<h2 id="ELF-文件函数"><a href="#ELF-文件函数" class="headerlink" title="ELF 文件函数"></a>ELF 文件函数</h2><ul>
<li>  <code>load_icode()</code>：加载可执行文件至指定进程内存（调用的最外层函数）</li>
<li>  <code>elf_from()</code>：解析 ELF 文件头，获取段位置</li>
<li>  <code>elf_load_seg()</code>：加载 ELF 程序段</li>
<li><code>load_icode_mapper()</code>：分配一页物理页，在 env 块对应的页表中建立映射<ul>
<li>  可能需要复制 src 处的数据到该物理页面中</li>
</ul>
</li>
</ul>
<h2 id="加载-ELF-文件-load-icode-Exercise-3-6"><a href="#加载-ELF-文件-load-icode-Exercise-3-6" class="headerlink" title="加载 ELF 文件 - load_icode - Exercise 3.6"></a>加载 ELF 文件 - <code>load_icode</code> - Exercise 3.6</h2><ul>
<li>  函数作用：调用相关函数，将 ELF 文件加载进指定进程中</li>
<li>  解析 ELF 头获取段信息</li>
<li>  使用 <code>elf_load_seg</code> 加载每个程序段</li>
<li>  初始化 EPC 指向程序入口点地址</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">  <span class="comment">/* Step 1: 解析 ELF 头 */</span></span><br><span class="line">  <span class="type">const</span> Elf32_Ehdr *ehdr = elf_from(binary, size);</span><br><span class="line">  <span class="keyword">if</span> (!ehdr) &#123;</span><br><span class="line">    panic(<span class="string">&quot;bad elf at %x&quot;</span>, binary);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 循环加载每个程序段</span></span><br><span class="line"><span class="comment">   * 循环：使用 ELF_FOREACH_PHDR_OFF</span></span><br><span class="line"><span class="comment">   * 加载：使用 elf_load_seg</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">size_t</span> ph_off;</span><br><span class="line">  ELF_FOREACH_PHDR_OFF(ph_off, ehdr) &#123;</span><br><span class="line">    Elf32_Phdr *ph = (Elf32_Phdr *)(binary + ph_off);</span><br><span class="line">    <span class="keyword">if</span> (ph-&gt;p_type == PT_LOAD) &#123;</span><br><span class="line">      <span class="comment">// &#x27;load_icode_mapper&#x27; 指定了用户的加载方式</span></span><br><span class="line">      panic_on(elf_load_seg(ph, binary + ph-&gt;p_offset, load_icode_mapper, e));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 将进程起始地址 EPC 指向 ELF 入口 e_entry ，执行程序入口点指令 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.6: Your code here. */</span></span><br><span class="line">  e-&gt;env_tf.cp0_epc = ehdr-&gt;e_entry;</span><br><span class="line">  <span class="comment">/* env_tf.cp0_epc 字段指示了进程运行时PC 应指向的位置,说明其为连续的虚拟地址中</span></span><br><span class="line"><span class="comment">     的某一个值 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>ELF_FOREACH_PHDR_OFF</code>：在上述的顶层函数中，调用了一个宏，其展开后对 ELF 程序段进行循环：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ELF_FOREACH_PHDR_OFF(ph_off, ehdr)        \</span></span><br><span class="line"><span class="meta">(ph_off) = (ehdr)-&gt;e_phoff;                   \</span></span><br><span class="line"><span class="meta">for (int _ph_idx = 0; _ph_idx <span class="string">&lt; (ehdr)-&gt;</span>e_phnum; ++_ph_idx, (ph_off) += (ehdr)-&gt;e_phentsize)</span></span><br></pre></td></tr></table></figure>

<h2 id="elf-load-seg"><a href="#elf-load-seg" class="headerlink" title="elf_load_seg"></a><code>elf_load_seg</code></h2><ul>
<li>  函数作用：把 ELF 程序段加载到 <code>data</code> 处； MOS 中在 <code>load_icode</code> 内配合 <code>load_icode_mapper</code> 调用，也就是<strong>把程序段加载到进程内存里</strong></li>
<li>  按页划分，分别映射每一页至 data 中</li>
<li>  回调函数 <code>map_page</code> 决定映射的方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 加载 ELF 文件的段至 data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   bin != NULL</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   Return 0 if success. Otherwise return &lt; 0.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">elf_load_seg</span><span class="params">(Elf32_Phdr *ph, <span class="type">const</span> <span class="type">void</span> *bin, <span class="type">elf_mapper_t</span> map_page, <span class="type">void</span> *data)</span> &#123;</span><br><span class="line">u_long va = ph-&gt;p_vaddr;</span><br><span class="line"><span class="type">size_t</span> bin_size = ph-&gt;p_filesz;<span class="comment">// 文件大小</span></span><br><span class="line"><span class="type">size_t</span> sgsize = ph-&gt;p_memsz;<span class="comment">// 内存大小，需要补齐这一段差值</span></span><br><span class="line">u_int perm = PTE_V;</span><br><span class="line"><span class="keyword">if</span> (ph-&gt;p_flags &amp; PF_W) &#123;</span><br><span class="line">perm = PTE_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">size_t</span> i;</span><br><span class="line">u_long offset = va - ROUNDDOWN(va, BY2PG);</span><br><span class="line"><span class="keyword">if</span> (offset != <span class="number">0</span>) &#123;              <span class="comment">// 起始地址未页对齐，映射第一页</span></span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va, offset, perm, bin, MIN(bin_size, BY2PG - offset))) !=</span><br><span class="line">    <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 1: 映射 p_filesz 至指定区中 */</span></span><br><span class="line"><span class="keyword">for</span> (i = offset ? MIN(bin_size, BY2PG - offset) : <span class="number">0</span>; i &lt; bin_size; i += BY2PG) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, bin + i, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Step 2: 补全空白页至 p_memsz */</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; sgsize) &#123;</span><br><span class="line"><span class="keyword">if</span> ((r = map_page(data, va + i, <span class="number">0</span>, perm, <span class="literal">NULL</span>, MIN(bin_size - i, BY2PG))) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line">i += BY2PG;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页映射回调函数-load-icode-mapper-Exercise-3-5"><a href="#页映射回调函数-load-icode-mapper-Exercise-3-5" class="headerlink" title="页映射回调函数 - load_icode_mapper - Exercise 3.5"></a>页映射回调函数 - <code>load_icode_mapper</code> - Exercise 3.5</h2><ul>
<li>  函数作用：作为 <code>load_icode</code> 中使用的回调函数，它决定了页映射的方式</li>
<li>  申请一个物理页 <code>page_alloc</code></li>
<li>  复制一下src内容（注意不要复制多/少了） <code>memcpy</code></li>
<li>  把这个复制好的物理页映射到目标 env 里 <code>page_insert</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 把 src 处数据映射到进程 data 的va 处，更新 perm</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> * &#x27;offset + len&#x27; &lt;= &#x27;BY2PG&#x27;.</span></span><br><span class="line"><span class="comment"> * 换句话说就是复制过去后也只在**同一个**虚拟页里面，不会跨页</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">load_icode_mapper</span><span class="params">(<span class="type">void</span> *data, u_long va, <span class="type">size_t</span> offset, u_int perm,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env</span> =</span> (<span class="keyword">struct</span> Env *)data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个装内容的物理页 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.5: Your code here. (1/2) */</span></span><br><span class="line">  <span class="keyword">if</span> ((r = page_alloc(&amp;p)) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 2: 复制 src 内容 */</span></span><br><span class="line">  <span class="comment">// Hint: You may want to use &#x27;memcpy&#x27;.</span></span><br><span class="line">  <span class="keyword">if</span> (src != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* Exercise 3.5: Your code here. (2/2) */</span></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *) (page2kva(p) + offset), src, len);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 把物理页插进 env 进程页表，创建映射，完成复制 */</span></span><br><span class="line">  <span class="keyword">return</span> page_insert(env-&gt;env_pgdir, env-&gt;env_asid, p, va, perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> </p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>创建进程的过程主要由 <code>env_alloc</code> 函数实现，其步骤大致如下：</p>
<ul>
<li>  申请一个空闲的进程控制块</li>
<li>  初始化这个空白的控制块</li>
<li>  初始化进程<strong>页目录</strong></li>
<li>  从 env_free_list 中取出该控制块</li>
</ul>
<p><strong>用户栈</strong>是在使用过程中动态分配的</p>
<h2 id="进程页目录初始化-env-setup-vm-Exercise-3-3"><a href="#进程页目录初始化-env-setup-vm-Exercise-3-3" class="headerlink" title="进程页目录初始化 - env_setup_vm - Exercise 3.3"></a>进程页目录初始化 - <code>env_setup_vm</code> - Exercise 3.3</h2><ul>
<li>  函数作用：初始化进程页目录（共享只读段映射和自映射）</li>
<li>  <strong>形成进程页表</strong>，初始化新进程的虚拟地址空间</li>
<li>  把 UTOP 至 UVPT 两段地址间的内核页表 base_pgdir 拷贝到进程页表中，借此暴露这段由<strong>所有进程共享</strong>的只读空间（ Exercise 3.1完成了 base_pgdir 的建立与映射）</li>
</ul>
<p>关于共享只读的空间，指导书这样解释：</p>
<blockquote>
<p>在MOS 操作系统特意将一些内核的数据暴露到用户空间，使得进程不需要切换到内核态就能访问，这是MOS 特有的设计。在Lab4 和Lab6 中将用到此机制。而这里我们要暴露是<strong>UTOP 往上到UVPT 之间所有进程共享的只读空间</strong>，也就是把这部分内存对应的内核页表base_pgdir 拷贝到进程页表中。从UVPT 往上到ULIM 之间则是进程自己的页表。</p>
</blockquote>
<p>拷贝的这一段空间，具体来说存放的是 envs 和 pages 两个经常使用的结构体，使其共享只读确实能够减少大量对内核空间的访问；不然用户进程申请个物理页都要进内核看 pages 了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 初始化进程的**用户内存（虚拟地址）空间**</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 1: 使用 page_alloc 申请一页物理页框存放进程页目录 */</span></span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span>;</span></span><br><span class="line">  try(page_alloc(&amp;p));</span><br><span class="line">  <span class="comment">/* Exercise 3.3: Your code here. */</span></span><br><span class="line">  p-&gt;pp_ref++;</span><br><span class="line">  e-&gt;env_pgdir = (Pde *) page2kva(p);</span><br><span class="line">  <span class="comment">/* Step 2: 将 &#x27;base_pgdir&#x27; 页目录内容拷贝至 &#x27;e-&gt;env_pgdir&#x27; 中 */</span></span><br><span class="line">  <span class="built_in">memcpy</span>(e-&gt;env_pgdir + PDX(UTOP), base_pgdir + PDX(UTOP),</span><br><span class="line">         <span class="keyword">sizeof</span>(Pde) * (PDX(UVPT) - PDX(UTOP)));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 设置页表自映射：令对应的页目录项指向页目录物理基地址 */</span></span><br><span class="line">  e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir)  PTE_V;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  使用 memcpy 时虽然只进行了页目录的拷贝，但两个页目录此时指向了相同的二级页表（物理页），之后再寻址就一样了</li>
<li>  页表自映射细节在 Thinking 3.1 中，可以回 Report 看一眼</li>
</ul>
<h2 id="申请并初始化进程块-env-alloc-Exercise-3-4"><a href="#申请并初始化进程块-env-alloc-Exercise-3-4" class="headerlink" title="申请并初始化进程块 - env_alloc - Exercise 3.4"></a>申请并初始化进程块 - <code>env_alloc</code> - Exercise 3.4</h2><ul>
<li>  函数作用如下：</li>
<li>  从空闲控制块链表中申请一个<strong>进程控制块</strong>（类似于 <code>page_alloc</code> 申请页）</li>
<li>  使用 <code>env_setup_vm</code> 函数和赋值语句对控制块进行初始化</li>
<li>  把申请好的控制块从链表中摘除并返回</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *   申请并初始化进程块，存放在 &#x27;*new&#x27; 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Pre-Condition:</span></span><br><span class="line"><span class="comment"> *   无父进程时 parent_id = 0</span></span><br><span class="line"><span class="comment"> *   需要初始化 envs（使用 env_init 函数）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Post-Condition:</span></span><br><span class="line"><span class="comment"> *   return 0 on success</span></span><br><span class="line"><span class="comment"> *   return &lt; 0 on error：无空闲进程、ASID 或 &#x27;env_setup_vm&#x27; 失败</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   可能需要初始化下列字段:</span></span><br><span class="line"><span class="comment"> *     &#x27;env_id&#x27;, &#x27;env_asid&#x27;, &#x27;env_parent_id&#x27;, &#x27;env_tf.regs[29]&#x27;,</span></span><br><span class="line"><span class="comment"> * &#x27;env_tf.cp0_status&#x27;, &#x27;env_user_tlb_mod_entry&#x27;, &#x27;env_runs&#x27;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">env_alloc</span><span class="params">(<span class="keyword">struct</span> Env **new, u_int parent_id)</span> &#123;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 申请空闲块，存放在 e 里 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (1/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (LIST_EMPTY(&amp;env_free_list)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e = LIST_FIRST(&amp;env_free_list);</span><br><span class="line">  <span class="comment">/* Step 2: 使用 &#x27;env_setup_vm&#x27; 初始化用户空间 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (2/4) */</span></span><br><span class="line">  <span class="keyword">if</span> (env_setup_vm(e)) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Step 3: 初始化字段：</span></span><br><span class="line"><span class="comment">   *   &#x27;env_user_tlb_mod_entry&#x27; (lab4), &#x27;env_runs&#x27; (lab6), &#x27;env_id&#x27; (lab3),</span></span><br><span class="line"><span class="comment">   * &#x27;env_asid&#x27; (lab3), &#x27;env_parent_id&#x27; (lab3)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * Hint:</span></span><br><span class="line"><span class="comment">   *   asid: asid_alloc</span></span><br><span class="line"><span class="comment">   *   envid: mkenvid</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  e-&gt;env_user_tlb_mod_entry = <span class="number">0</span>; <span class="comment">// for lab4</span></span><br><span class="line">  e-&gt;env_runs = <span class="number">0</span>;               <span class="comment">// for lab6</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (3/4) */</span></span><br><span class="line">  e-&gt;env_id = mkenvid(e);</span><br><span class="line">  <span class="keyword">if</span> (asid_alloc(&amp;(e-&gt;env_asid)) == -E_NO_FREE_ENV) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">  &#125;</span><br><span class="line">  e-&gt;env_parent_id = parent_id;</span><br><span class="line">  <span class="comment">/* Step 4: 初始化 CP0 寄存器与栈顶寄存器 sp */</span></span><br><span class="line">  <span class="comment">// Timer interrupt (STATUS_IM4) will be enabled.</span></span><br><span class="line">  e-&gt;env_tf.cp0_status = STATUS_IM4  STATUS_KUp  STATUS_IEp;</span><br><span class="line">  <span class="comment">// Keep space for &#x27;argc&#x27; and &#x27;argv&#x27;.</span></span><br><span class="line">  e-&gt;env_tf.regs[<span class="number">29</span>] = USTACKTOP - <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="type">char</span> **);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 5: 移出控制块并赋值 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.4: Your code here. (4/4) */</span></span><br><span class="line">  LIST_REMOVE(e, env_link);</span><br><span class="line">  *new = e;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化两个 ID 时，使用了两个不需要填空的函数，体现了操作系统生成不重复的 ID 的方式和位图法保存 ASID 的应用，这边也来看一下吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算一个 ASID 并存入参数指针内</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">asid_alloc</span><span class="params">(u_int *asid)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; NASID; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> index = i &gt;&gt; <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> inner = i &amp; <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">if</span> ((asid_bitmap[index] &amp; (<span class="number">1</span> &lt;&lt; inner)) == <span class="number">0</span>) &#123;</span><br><span class="line">      asid_bitmap[index] = <span class="number">1</span> &lt;&lt; inner;</span><br><span class="line">      *asid = i;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -E_NO_FREE_ENV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据当前 env ，计算其 env_id</span></span><br><span class="line">u_int <span class="title function_">mkenvid</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  <span class="type">static</span> u_int i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((++i) &lt;&lt; (<span class="number">1</span> + LOG2NENV))  (e - envs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  在设置<strong>寄存器初始化</strong>时，我们使用了两个赋值语句，这两句关键语句需要解释一下：</p>
<ul>
<li><code>e-&gt;env_tf.cp0_status = STATUS_IM4 STATUS_KUp STATUS_IEp</code><ul>
<li>  初始化 CP0 的 SR 寄存器， IM4 代表允许响应4号中断、 KUp 代表处于用户态、 IEp 代表允许中断，这里实际上是初始化了<strong>中断响应机制</strong>所需的寄存器条件</li>
</ul>
</li>
<li><code>e-&gt;env_tf.regs[29] = USTACKTOP - sizeof(int) - sizeof(char **)</code><ul>
<li>  在 USTACKTOP 下存放的实际上就是用户栈，还记得倒置的 mips 栈吗，这里就是栈顶</li>
</ul>
</li>
</ul>
<p>对于 SR 寄存器，更具体的解释如下： 指导书P66  </p>
<h2 id="创建内核进程-env-create-Exercise-3-7"><a href="#创建内核进程-env-create-Exercise-3-7" class="headerlink" title="创建内核进程 - env_create -Exercise 3.7"></a>创建内核进程 - <code>env_create</code> -Exercise 3.7</h2><ul>
<li>  函数作用：创建一个内核进程，并加载 ELF 文件</li>
<li>  申请没有父进程的进程控制块</li>
<li>  初始化 priority 和 ENV_RUNNABLE</li>
<li>  加载 ELF 文件并插入调度队列</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> *  使用 &#x27;binary&#x27; 与 &#x27;priority&#x27; 字段创建一个进程</span></span><br><span class="line"><span class="comment"> *  在进程调度开始之前创建**内核**进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> Env *<span class="title function_">env_create</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *binary, <span class="type">size_t</span> size, <span class="type">int</span> priority)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">  <span class="comment">/* Step 1: 申请一个进程控制块，因为没有父进程所以 parent_id = 0,  &#x27;env_alloc&#x27; */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (1/3) */</span></span><br><span class="line">  env_alloc(&amp;e, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/* Step 2: 标记 &#x27;priority&#x27; 并设置为 ENV_RUNNABLE，表示可以运行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (2/3) */</span></span><br><span class="line">  e-&gt;env_pri = (u_int) priority;</span><br><span class="line">  e-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">  <span class="comment">/* Step 3: 加载 ELF 文件，并插入 &#x27;env_sched_list&#x27; 头，表示允许调度 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.7: Your code here. (3/3) */</span></span><br><span class="line">  load_icode(e, binary, size);</span><br><span class="line">  TAILQ_INSERT_HEAD(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">  <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>ENV_CREATE_PRIORITY</code>：MOS 创建内核<strong>示例</strong>进程时使用的宏，定义在 <code>include/env.h</code> 中</li>
</ul>
<p>这里用到的 <code>##x##</code> 可以理解成变量替换后的字符串拼接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// priority = y</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE_PRIORITY(x, y)                                             \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, y);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// priority = 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENV_CREATE(x)                                                         \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">extern u_char binary_##x##_start[];                           \</span></span><br><span class="line"><span class="meta">extern u_int binary_##x##_size;                               \</span></span><br><span class="line"><span class="meta">env_create(binary_##x##_start, (u_int)binary_##x##_size, 1);  \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="comment">// 创建进程，binary字段来自名为 binary_user_bare_loop_start 的外部数组，定义在 user/bare/loop.b.c 中</span></span><br><span class="line">ENV_CREATE_PRIORITY(user_bare_loop, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p> </p>
<h2 id="再探-mmu-h"><a href="#再探-mmu-h" class="headerlink" title="再探 mmu.h"></a>再探 <code>mmu.h</code></h2><p>至此，一个新的<strong>内核进程</strong>创建过程就结束了，在 Lab4 中还会用部分函数创建<strong>用户进程</strong>。回顾一下。在申请进程之前，我们先初始化了进程控制块链表(<code>env_init</code>)，在申请过程中初始化了它的内存空间、页表(<code>env_setup_vm</code>)与进程控制块字段，最后返回(<code>env_alloc</code>)。 借助 Lab2 已有的布局和进程建立的过程，我们可以大致构建起一个不断完善的内存体系，这时候 <code>include/mmu.h</code> 内的内存布局图就可以再拿出来用了。不过实际上，仍有一些字段我们没有使用，这些字段在 Lab4 中会再加以利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Part 2.  Our conventions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> o 4G -----------&gt;  +----------------------------+------------0x100000000</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg2</span></span><br><span class="line"><span class="comment"> o  KSEG2    -----&gt; +----------------------------+------------0xc000 0000</span></span><br><span class="line"><span class="comment"> o                            Devices             kseg1</span></span><br><span class="line"><span class="comment"> o  KSEG1    -----&gt; +----------------------------+------------0xa000 0000</span></span><br><span class="line"><span class="comment"> o                        Invalid Memory           /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+-----------Physical Memory Max</span></span><br><span class="line"><span class="comment"> o                         ...                    kseg0</span></span><br><span class="line"><span class="comment"> o  KSTACKTOP-----&gt; +----------------------------+-----------0x8040 0000---end</span></span><br><span class="line"><span class="comment"> o                         Kernel Stack              KSTKSIZE            /\</span></span><br><span class="line"><span class="comment"> o                  +----------------------------+----------                </span></span><br><span class="line"><span class="comment"> o                         Kernel Text                                  PDMAP</span></span><br><span class="line"><span class="comment"> o  KERNBASE -----&gt; +----------------------------+-----------0x8001 0000    </span></span><br><span class="line"><span class="comment"> o                        Exception Entry          \/                    \/</span></span><br><span class="line"><span class="comment"> o  ULIM     -----&gt; +----------------------------+------------0x8000 0000-------</span></span><br><span class="line"><span class="comment"> o                           User VPT                PDMAP                /\</span></span><br><span class="line"><span class="comment"> o  UVPT     -----&gt; +----------------------------+------------0x7fc0 0000    </span></span><br><span class="line"><span class="comment"> o                             pages                 PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UPAGES   -----&gt; +----------------------------+------------0x7f80 0000    </span></span><br><span class="line"><span class="comment"> o                             envs                  PDMAP                 </span></span><br><span class="line"><span class="comment"> o  UTOP,UENVS ---&gt; +----------------------------+------------0x7f40 0000    </span></span><br><span class="line"><span class="comment"> o  UXSTACKTOP -/        user exception stack        BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f f000    </span></span><br><span class="line"><span class="comment"> o                                                   BY2PG                 </span></span><br><span class="line"><span class="comment"> o  USTACKTOP ----&gt; +----------------------------+------------0x7f3f e000    </span></span><br><span class="line"><span class="comment"> o                       normal user stack           BY2PG                 </span></span><br><span class="line"><span class="comment"> o                  +----------------------------+------------0x7f3f d000    </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  .                            .                         kuseg</span></span><br><span class="line"><span class="comment"> a                  .                            .                           </span></span><br><span class="line"><span class="comment"> a                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~                           </span></span><br><span class="line"><span class="comment"> a                                                                         </span></span><br><span class="line"><span class="comment"> o   UTEXT   -----&gt; +----------------------------+------------0x0040 0000    </span></span><br><span class="line"><span class="comment"> o                        reserved for COW           BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UCOW    -----&gt; +----------------------------+------------0x003f f000    </span></span><br><span class="line"><span class="comment"> o                     reversed for temporary        BY2PG                 </span></span><br><span class="line"><span class="comment"> o   UTEMP   -----&gt; +----------------------------+------------0x003f e000    </span></span><br><span class="line"><span class="comment"> o                         invalid memory                                 \/</span></span><br><span class="line"><span class="comment"> a 0 ------------&gt;  +----------------------------+ ----------------------------</span></span><br><span class="line"><span class="comment"> o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> </p>
<ul>
<li>  UPAGES 和 UENVS 处于用户可见区内，包含内核的页面控制块和进程控制块，每个进程拷贝成了相同的内容</li>
</ul>
<h2 id="执行进程-env-run-Exercise-3-8"><a href="#执行进程-env-run-Exercise-3-8" class="headerlink" title="执行进程 - env_run - Exercise 3.8"></a>执行进程 - <code>env_run</code> - Exercise 3.8</h2><ul>
<li>  函数作用：切换并运行指定进程</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Overview:</span></span><br><span class="line"><span class="comment"> * 切换当前运行进程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Hints:</span></span><br><span class="line"><span class="comment"> *   使用 &#x27;env_pop_tf&#x27;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span> &#123;</span><br><span class="line">  assert(e-&gt;env_status == ENV_RUNNABLE);</span><br><span class="line">  pre_env_run(e); <span class="comment">// WARNING: DO NOT MODIFY THIS LINE!</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 1: 保存当前运行栈 */</span></span><br><span class="line">  <span class="keyword">if</span> (curenv) &#123;</span><br><span class="line">    curenv-&gt;env_tf = *((<span class="keyword">struct</span> Trapframe *)KSTACKTOP - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 2: 变更全局变量 curenv */</span></span><br><span class="line">  curenv = e;</span><br><span class="line">  curenv-&gt;env_runs++; <span class="comment">// lab6</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Step 3: 更改当前运行进程的页目录 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (1/2) */</span></span><br><span class="line">  cur_pgdir = curenv-&gt;env_pgdir;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Step 4: 使用 &#x27;env_pop_tf&#x27; 更新寄存器，并返回用户态 */</span></span><br><span class="line">  <span class="comment">/* Exercise 3.8: Your code here. (2/2) */</span></span><br><span class="line">  env_pop_tf(&amp;curenv-&gt;env_tf, curenv-&gt;env_asid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  返回用户态，实际上是个精妙的过程，只不过我们的填空不需要完成这部分，但实在是值得研究研究</li>
</ul>
<h2 id="env-pop-tf"><a href="#env-pop-tf" class="headerlink" title="env_pop_tf"></a><code>env_pop_tf</code></h2><ul>
<li>  修改 CP0 寄存器和 sp 寄存器，为跳回用户态提供数据</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(env_pop_tf)</span><br><span class="line">.set reorder</span><br><span class="line">.set at</span><br><span class="line">sll     a1, a1, 6</span><br><span class="line">mtc0    a1, CP0_ENTRYHI    # 把 ENTRYHI 中保存 ASID 的部分改为 curenv-&gt;env_asid</span><br><span class="line">move    sp, a0             # 把栈指针变更为 &amp;curenv-&gt;env_tf</span><br><span class="line">j       ret_from_exception # 离开异常处理程序，返回用户态</span><br><span class="line">END(env_pop_tf)</span><br></pre></td></tr></table></figure>

<h2 id="ret-from-exception"><a href="#ret-from-exception" class="headerlink" title="ret_from_exception"></a><code>ret_from_exception</code></h2><ul>
<li>  刚才在 <code>env_pop_tf</code> 的最后一句中，我们跳转到了这个汇编函数，它的作用是离开异常处理程序，回到用户态，虽然当前调用不算是异常处理，但是想要完成的作用都一样：<strong>恢复用户态现场，返回用户态执行</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FEXPORT(ret_from_exception)</span><br><span class="line">RESTORE_SOME         # 从 sp（视作 tf）中恢复除了 sp 以外的大部分寄存器</span><br><span class="line">lw      k0, TF_EPC(sp)   # 从 tf 中取出 EPC </span><br><span class="line">lw      sp, TF_REG29(sp) # 从 env_tf 中取得用户栈指针，赋值给 sp ，即切换到用户栈</span><br><span class="line">.set noreorder</span><br><span class="line">jr      k0               # 跳转至用户态 EPC ，离开异常处理程序</span><br><span class="line">rfe                      # 调用 rfe，使 SR 寄存器中的二重栈出栈一层</span><br><span class="line">.set reorder</span><br></pre></td></tr></table></figure>

<ul>
<li>  这里的 EPC 在初始化进程块时就被赋值成了 <strong>ELF 程序入口点</strong>，也就是说会直接 jr 到加载的 ELF 程序开始</li>
<li>  其中最关键的是 lw sp这一句，把用户栈指针从 tf 中取出，恢复了用户栈</li>
<li>  最后使用的 rfe 指令也刚好把 <code>env_alloc</code> 时初始化的二重栈用上了。每个进程都需要由此启动，所以确实<strong>都需要执行一次 rfe 指令</strong></li>
<li>  md，太妙了</li>
</ul>
<p> </p>
<h1 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h1><p>P7 的痛苦回忆又回来了.jpg</p>
<blockquote>
<p>我们实验里认为中断是异常的一种，并且是仅有的一种<strong>异步异常</strong>。</p>
</blockquote>
<h2 id="异常处理逻辑"><a href="#异常处理逻辑" class="headerlink" title="异常处理逻辑"></a>异常处理逻辑</h2><ul>
<li>  设置 <strong>EPC</strong> 指向返回地址</li>
<li>  设置 SR 寄存器，强制 CPU 进入内核态</li>
<li>  设置 Cause 寄存器记录异常原因</li>
<li>  跳转到异常处理程序入口，执行处理</li>
</ul>
<p> </p>
<h2 id="异常分发程序-exc-gen-entry-Exercise-3-9"><a href="#异常分发程序-exc-gen-entry-Exercise-3-9" class="headerlink" title="异常分发程序 - exc_gen_entry - Exercise 3.9"></a>异常分发程序 - <code>exc_gen_entry</code> - Exercise 3.9</h2><ul>
<li>  异常分发程序：根据发生的异常跳转到异常处理程序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section .text.exc_gen_entry</span><br><span class="line">exc_gen_entry:</span><br><span class="line">SAVE_ALL                      # 将当前寄存器形成 TrapFrame 保存在内核栈 KSTACKTOP 内</span><br><span class="line">/* Exercise 3.9: Your code here. */</span><br><span class="line">mfc0 t0, CP0_CAUSE</span><br><span class="line">andi t0, 0x7c                 # 获取 Cause 寄存器中的 ExcCode</span><br><span class="line">lw t0, exception_handlers(t0) # 通过 handler 获取分发的处理函数入口</span><br><span class="line">jr t0                         # 跳转到对应的异常处理入口，响应异常</span><br></pre></td></tr></table></figure>

<ul>
<li>  <code>lw t0, exception_handlers(t0)</code> 指令明明是个访存指令，如何做到获取处理函数地址的呢？</li>
</ul>
<p>实际上这是由于 <code>exception_handlers</code> 这个异常向量组以数组的形式保存在内存中。只需要将 t0 寄存器作为下标，我们就能直接访问了这个数组的对应内容（这个内容存放的就是处理函数的地址） 为了程序能找到这个分发程序和处理 TLB Miss 的程序，我们在 <code>kernal.lds</code> 中放置了它们所在的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. = 0x80000000;</span><br><span class="line">.tlb_miss_entry : &#123;</span><br><span class="line">*(.text.tlb_miss_entry)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">= 0x80000080;</span><br><span class="line">.exc_gen_entry : &#123;</span><br><span class="line">*(.text.exc_gen_entry)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（虽然处理 TLB 的函数会直接跳到主异常分发程序，没啥用（</p>
<h2 id="异常向量组-exception-handlers"><a href="#异常向量组-exception-handlers" class="headerlink" title="异常向量组 - exception_handlers"></a>异常向量组 - <code>exception_handlers</code></h2><ul>
<li>  异常分发程序通过 <code>exception_handlers</code> 数组定位中断处理程序，而定义在 <code>kern/traps.c</code> 中的 <code>exception_handlers</code> 就称作<strong>异常向量组</strong>。</li>
</ul>
<p>这部分指导书的逻辑很明确，就直接借用了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_int</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_tlb</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_sys</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_mod</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">handle_reserved</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义在哪个文件可以参考 Report 内容，在思考题中出现过</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> (*exception_handlers[<span class="number">32</span>])(<span class="type">void</span>) = &#123;</span><br><span class="line">    [<span class="number">0</span> ... <span class="number">31</span>] = handle_reserved,</span><br><span class="line">    [<span class="number">0</span>] = handle_int,</span><br><span class="line">    [<span class="number">2</span> ... <span class="number">3</span>] = handle_tlb,</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(LAB)  LAB &gt;= 4</span></span><br><span class="line">    [<span class="number">1</span>] = handle_mod,</span><br><span class="line">    [<span class="number">8</span>] = handle_sys,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过把相应处理函数的地址填到对应数组项中，我们初始化了如下异常： 0 号异常的处理函数为handle_int，表示中断，由时钟中断、控制台中断等中断造成 1 号异常的处理函数为handle_mod，表示存储异常，进行存储操作时该页被标记为只读 2 号异常的处理函数为handle_tlb，表示TLB load 异常 3 号异常的处理函数为handle_tlb，表示TLB store 异常 8 号异常的处理函数为handle_sys，表示系统调用，用户进程通过执行syscall 指令陷 入内核</p>
</blockquote>
<p>通过访问对应的异常下标，就能在异常分发程序中进入对应的处理函数（目前中断还不行），最后调用 <code>ret_from_exception</code> 返回用户态</p>
<h2 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h2><ul>
<li>  中断处理的流程</li>
<li>  进入异常分发程序，判断为中断</li>
<li>  进入<strong>中断处理程序</strong> <code>handle_int</code>，判断中断种类，再进行分发</li>
<li>  处理中断结束后，进入 <code>ret_from_exception</code> 返回用户态</li>
</ul>
<p>目前我们的 MOS 只能处理一种<strong>时钟中断</strong>，所以中断处理就只有一种选择（）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NESTED(handle_int, TF_SIZE, zero)</span><br><span class="line">mfc0    t0, CP0_CAUSE</span><br><span class="line">mfc0    t2, CP0_STATUS</span><br><span class="line">and     t0, t2              # 获取可以处理的时钟中断</span><br><span class="line">andi    t1, t0, STATUS_IM4  # 中断号 4 号：时钟中断</span><br><span class="line">bnez    t1, timer_irq</span><br><span class="line">// TODO: handle other irqs</span><br><span class="line">timer_irq:</span><br><span class="line">sw      zero, (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_INTERRUPT_ACK)</span><br><span class="line">li      a0, 0               # 将时钟响应位置0</span><br><span class="line">j       schedule            # 执行 schedule(0)</span><br><span class="line">END(handle_int)</span><br></pre></td></tr></table></figure>

<h2 id="时钟中断-kclock-init-Exercise-3-11"><a href="#时钟中断-kclock-init-Exercise-3-11" class="headerlink" title="时钟中断 - kclock_init - Exercise 3.11"></a>时钟中断 - <code>kclock_init</code> - Exercise 3.11</h2><p>MOS 系统产生定时的时钟中断，并根据这些中断分配每个进程运行的时间片（限制进程一次性运行的时间长度）</p>
<ul>
<li>  初始化并启用时钟中断</li>
</ul>
<p><code>kern/kclock.S</code> 中的 <code>kclock_init</code> 函数完成了时钟中断的初始化，该函数向 <code>KSEG1 DEV_RTC_ADDRESS DEV_RTC_HZ</code> 位置写入200，其中 <code>KSEG1 DEV_RTC_ADDRESS</code> 是模拟器（GXemul）映射<strong>实时钟</strong>的位置。偏移量为 <code>DEV_RTC_HZ</code> 表示设置实时钟中断的频率，200 表示1 秒钟中断200 次。 随后再调用 <code>kern/env_asm.S</code> 中的 <code>enable_irq</code> 函数开启中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAF(kclock_init)</span><br><span class="line">li      t0, 200 // the timer interrupt frequency in Hz</span><br><span class="line"></span><br><span class="line">/* Write &#x27;t0&#x27; into the timer (RTC) frequency register.</span><br><span class="line"> *</span><br><span class="line"> * Hint:</span><br><span class="line"> *   To access device through mmio, a physical address must be converted to a</span><br><span class="line"> *   kseg1 address.</span><br><span class="line"> * #define DEV_RTC_HZ 0x0100</span><br><span class="line"> * #define DEV_RTC_ADDRESS 0x15000000</span><br><span class="line"> *  #define KSEG1 0xA0000000U</span><br><span class="line"> */</span><br><span class="line">/* Exercise 3.11: Your code here. */</span><br><span class="line">sw t0 , (KSEG1  DEV_RTC_ADDRESS  DEV_RTC_HZ)</span><br><span class="line">jr      ra</span><br><span class="line">END(kclock_init)</span><br></pre></td></tr></table></figure>

<p><code>enable_irq</code> 函数在 Report 里也有，文章太长就不写力</p>
<ul>
<li>  时钟中断的处理</li>
<li><ol>
<li> 中断产生，进入异常分发程序</li>
<li> 判断为中断，进入中断处理程序</li>
<li> 判断为时钟中断，执行处理函数</li>
<li> 执行 <code>schedule(0)</code>，进行进程调度</li>
</ol>
</li>
</ul>
<h2 id="进程调度-schedule-Exercise-3-12"><a href="#进程调度-schedule-Exercise-3-12" class="headerlink" title="进程调度 - schedule - Exercise 3.12"></a>进程调度 - <code>schedule</code> - Exercise 3.12</h2><ul>
<li>  函数功能：根据参数 <code>yield</code> 和当前进程状态进行进程调度</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Hints:</span></span><br><span class="line"><span class="comment"> *   1. 使用 static 变量 count 记录剩余时间片</span></span><br><span class="line"><span class="comment"> *   2. 不需要在 &#x27;noreturn&#x27; 函数中使用 return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">schedule</span><span class="params">(<span class="type">int</span> yield)</span> &#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// remaining time slices of current env</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span> =</span> curenv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We always decrease the &#x27;count&#x27; by 1.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If &#x27;yield&#x27; is set, or &#x27;count&#x27; has been decreased to 0, or &#x27;e&#x27; (previous &#x27;curenv&#x27;) is</span></span><br><span class="line"><span class="comment"> * &#x27;NULL&#x27;, or &#x27;e&#x27; is not runnable, then we pick up a new env from &#x27;env_sched_list&#x27; (list of</span></span><br><span class="line"><span class="comment"> * all runnable envs), set &#x27;count&#x27; to its priority, and schedule it with &#x27;env_run&#x27;. **Panic</span></span><br><span class="line"><span class="comment"> * if that list is empty**.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* Exercise 3.12: Your code here. */</span></span><br><span class="line"><span class="keyword">if</span> (yield != <span class="number">0</span>  count == <span class="number">0</span>  e == <span class="literal">NULL</span>  e-&gt;env_status != ENV_RUNNABLE) &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">TAILQ_REMOVE(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">NULL</span> &amp;&amp; e-&gt;env_status == ENV_RUNNABLE) &#123;</span><br><span class="line">TAILQ_INSERT_TAIL(&amp;env_sched_list, e, env_sched_link);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (TAILQ_EMPTY(&amp;env_sched_list)) &#123;</span><br><span class="line">panic(<span class="string">&quot;schedule: no runnable envs&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">e = TAILQ_FIRST(&amp;env_sched_list);</span><br><span class="line">count = e-&gt;env_pri;</span><br><span class="line">&#125;</span><br><span class="line">count--;</span><br><span class="line">env_run(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  在 <code>schedule</code> 函数中，我们没有使用 <code>return</code>，而直接进入了新一轮的 <code>env_run</code>，保存当前已运行的部分内容，开始新的进程。</li>
<li>  这也说明了为什么只有 <code>timer_irq</code> 没有调用 <code>ret_from_exceprion</code> 函数，因为<strong>不用回到原本执行进程</strong>的用户态了</li>
</ul>
<p>  Lab3 大体到这里就结束了，要写的要看的也太多了，有点逆天。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/2023/04/buaa-os-probe-lab3/">https://cookedbear.github.io/2023/04/buaa-os-probe-lab3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171223110.png?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/buaa-os-2023-lab4-report/" title="BUAA-OS-2023-Lab4-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171232980.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-2023-Lab4-Report</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/buaa-os-2023-lab3-report/" title="BUAA-OS-2023-Lab3-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171232178.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-2023-Lab3-Report</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/buaa-os-2023-lab0-report/" title="BUAA-OS-2023-Lab0-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171229777.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-09</div><div class="title">BUAA-OS-2023-Lab0-Report</div></div></a></div><div><a href="/2023/03/buaa-os-2023-lab1-exam/" title="BUAA-OS-2023-Lab1-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171229827.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-20</div><div class="title">BUAA-OS-2023-Lab1-Exam</div></div></a></div><div><a href="/2023/03/buaa-os-2023-lab1-report/" title="BUAA-OS-2023-Lab1-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171230060.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-17</div><div class="title">BUAA-OS-2023-Lab1-Report</div></div></a></div><div><a href="/2023/03/buaa-os-2023-lab2-report/" title="BUAA-OS-2023-Lab2-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171231619.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-26</div><div class="title">BUAA-OS-2023-Lab2-Report</div></div></a></div><div><a href="/2023/04/buaa-os-2023-lab3-exam/" title="BUAA-OS-2023-Lab3-Exam"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171231921.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-18</div><div class="title">BUAA-OS-2023-Lab3-Exam</div></div></a></div><div><a href="/2023/04/buaa-os-2023-lab3-report/" title="BUAA-OS-2023-Lab3-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305171232178.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-14</div><div class="title">BUAA-OS-2023-Lab3-Report</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab3-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-number">1.</span> <span class="toc-text">Lab3 - 进程与异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">进程控制块与初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97-PCB"><span class="toc-number">2.1.</span> <span class="toc-text">进程控制块 - PCB</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E9%A1%B5%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-map-segment-Exercise-3-2"><span class="toc-number">2.2.</span> <span class="toc-text">跨页地址映射 - map_segment - Exercise 3.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9D%97%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96-env-init-Exercise-3-1"><span class="toc-number">2.3.</span> <span class="toc-text">进程块队列初始化 - env_init - Exercise 3.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#env-id-%E4%B8%8E%E8%BF%9B%E7%A8%8B%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.4.</span> <span class="toc-text">env_id 与进程表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E4%B8%AD%E7%9A%84-ASID-%E5%88%86%E4%BB%A3%E6%9C%BA%E5%88%B6-%EF%BC%88%E6%9C%89%E7%A9%BA%E5%86%8D%E8%A1%A5%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">Linux 中的 ASID 分代机制 （有空再补）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%95%9C%E5%83%8F"><span class="toc-number">3.</span> <span class="toc-text">加载二进制镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ELF-%E6%96%87%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">ELF 文件函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD-ELF-%E6%96%87%E4%BB%B6-load-icode-Exercise-3-6"><span class="toc-number">3.2.</span> <span class="toc-text">加载 ELF 文件 - load_icode - Exercise 3.6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#elf-load-seg"><span class="toc-number">3.3.</span> <span class="toc-text">elf_load_seg</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E6%98%A0%E5%B0%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-load-icode-mapper-Exercise-3-5"><span class="toc-number">3.4.</span> <span class="toc-text">页映射回调函数 - load_icode_mapper - Exercise 3.5</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">4.</span> <span class="toc-text">进程创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%A1%B5%E7%9B%AE%E5%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96-env-setup-vm-Exercise-3-3"><span class="toc-number">4.1.</span> <span class="toc-text">进程页目录初始化 - env_setup_vm - Exercise 3.3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%B9%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9B%E7%A8%8B%E5%9D%97-env-alloc-Exercise-3-4"><span class="toc-number">4.2.</span> <span class="toc-text">申请并初始化进程块 - env_alloc - Exercise 3.4</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B-env-create-Exercise-3-7"><span class="toc-number">4.3.</span> <span class="toc-text">创建内核进程 - env_create -Exercise 3.7</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2-mmu-h"><span class="toc-number">4.4.</span> <span class="toc-text">再探 mmu.h</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%BF%9B%E7%A8%8B-env-run-Exercise-3-8"><span class="toc-number">4.5.</span> <span class="toc-text">执行进程 - env_run - Exercise 3.8</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#env-pop-tf"><span class="toc-number">4.6.</span> <span class="toc-text">env_pop_tf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ret-from-exception"><span class="toc-number">4.7.</span> <span class="toc-text">ret_from_exception</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">5.</span> <span class="toc-text">中断和异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">5.1.</span> <span class="toc-text">异常处理逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%88%86%E5%8F%91%E7%A8%8B%E5%BA%8F-exc-gen-entry-Exercise-3-9"><span class="toc-number">5.2.</span> <span class="toc-text">异常分发程序 - exc_gen_entry - Exercise 3.9</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E7%BB%84-exception-handlers"><span class="toc-number">5.3.</span> <span class="toc-text">异常向量组 - exception_handlers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86"><span class="toc-number">5.4.</span> <span class="toc-text">中断处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD-kclock-init-Exercise-3-11"><span class="toc-number">5.5.</span> <span class="toc-text">时钟中断 - kclock_init - Exercise 3.11</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-schedule-Exercise-3-12"><span class="toc-number">5.6.</span> <span class="toc-text">进程调度 - schedule - Exercise 3.12</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/buaa-os-theory-chapter3-2/" title="BUAA-OS-Theory-Chapter3-2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282208594.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OS-Theory-Chapter3-2"/></a><div class="content"><a class="title" href="/2023/05/buaa-os-theory-chapter3-2/" title="BUAA-OS-Theory-Chapter3-2">BUAA-OS-Theory-Chapter3-2</a><time datetime="2023-05-27T14:07:13.000Z" title="发表于 2023-05-27 22:07:13">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/buaa-os-theory-chapter3-1/" title="BUAA-OS-Theory-Chapter3-1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282208594.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OS-Theory-Chapter3-1"/></a><div class="content"><a class="title" href="/2023/05/buaa-os-theory-chapter3-1/" title="BUAA-OS-Theory-Chapter3-1">BUAA-OS-Theory-Chapter3-1</a><time datetime="2023-05-27T13:45:35.000Z" title="发表于 2023-05-27 21:45:35">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/buaa-os-theory-chapter2/" title="BUAA-OS-Theory-Chapter2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282208594.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OS-Theory-Chapter2"/></a><div class="content"><a class="title" href="/2023/05/buaa-os-theory-chapter2/" title="BUAA-OS-Theory-Chapter2">BUAA-OS-Theory-Chapter2</a><time datetime="2023-05-27T07:58:06.000Z" title="发表于 2023-05-27 15:58:06">2023-05-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/buaa-os-theory-chapter1/" title="BUAA-OS-Theory-Chapter1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282208594.png?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-OS-Theory-Chapter1"/></a><div class="content"><a class="title" href="/2023/05/buaa-os-theory-chapter1/" title="BUAA-OS-Theory-Chapter1">BUAA-OS-Theory-Chapter1</a><time datetime="2023-05-27T07:49:05.000Z" title="发表于 2023-05-27 15:49:05">2023-05-27</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>