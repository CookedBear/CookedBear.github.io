<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>编译课设编译器设计文档 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编译器设计文档文档要求请自选一种编译器的源代码进行阅读分析，在此基础上完成总体架构设计，然后在编译器实现的每个阶段完成相应部分的设计文档，格式及内容不限，每个阶段均需写出编码之前的设计，编码完成之后对设计的修改情况。文档包括如下内容：  参考编译器介绍：总结所阅读的编译器的总体结构、接口设计、文件组织等内容 编译器总体设计：介绍自己的将要实现的编译器的总体结构、接口设计、文件组织等内容 词法分析设">
<meta property="og:type" content="article">
<meta property="og:title" content="编译课设编译器设计文档">
<meta property="og:url" content="https://cookedbear.github.io/p/a137a2e9.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="编译器设计文档文档要求请自选一种编译器的源代码进行阅读分析，在此基础上完成总体架构设计，然后在编译器实现的每个阶段完成相应部分的设计文档，格式及内容不限，每个阶段均需写出编码之前的设计，编码完成之后对设计的修改情况。文档包括如下内容：  参考编译器介绍：总结所阅读的编译器的总体结构、接口设计、文件组织等内容 编译器总体设计：介绍自己的将要实现的编译器的总体结构、接口设计、文件组织等内容 词法分析设">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-12-18T19:16:58.000Z">
<meta property="article:modified_time" content="2024-02-20T18:06:43.059Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="Compile Principle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/p/a137a2e9.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '编译课设编译器设计文档',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-21 02:06:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 小工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:80/"><span> bdpan</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:81/"><span> 25時生成器</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:9667/"><span> 程序员备忘录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 小工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:80/"><span> bdpan</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:81/"><span> 25時生成器</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:9667/"><span> 程序员备忘录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">编译课设编译器设计文档</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-12-18T19:16:58.000Z" title="发表于 2023-12-19 03:16:58">2023-12-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-20T18:06:43.059Z" title="更新于 2024-02-21 02:06:43">2024-02-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Compile-Principle/">Compile Principle</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="编译课设编译器设计文档"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="编译器设计文档"><a href="#编译器设计文档" class="headerlink" title="编译器设计文档"></a>编译器设计文档</h1><h1 id="文档要求"><a href="#文档要求" class="headerlink" title="文档要求"></a>文档要求</h1><p>请自选一种编译器的源代码进行阅读分析，在此基础上完成总体架构设计，然后在编译器实现的每个阶段完成相应部分的设计文档，格式及内容不限，每个阶段均需写出编码之前的设计，编码完成之后对设计的修改情况。<br>文档包括如下内容：</p>
<ol>
<li>参考编译器介绍：总结所阅读的编译器的<strong>总体结构、接口设计、文件组织</strong>等内容</li>
<li>编译器总体设计：介绍自己的将要实现的编译器的<strong>总体结构、接口设计、文件组织</strong>等内容</li>
<li>词法分析设计：编码前的设计、编码完成之后的修改</li>
<li>语法分析设计：编码前的设计、编码完成之后的修改</li>
<li>错误处理设计：编码前的设计、编码完成之后的修改</li>
<li>代码生成设计：编码前的设计、编码完成之后的修改</li>
<li>代码优化设计：编码前的设计、编码完成之后的修改，未选择 MIPS 代码生成的同学无需完成此项内容</li>
</ol>
<p>应在各个阶段任务完成相应部分并提交，最终提交一份完整的文档，文档格式为 <strong>pdf</strong> 版本。</p>
<h1 id="参考编译器介绍"><a href="#参考编译器介绍" class="headerlink" title="参考编译器介绍"></a>参考编译器介绍</h1><p>一个凝练的小编译器 <a target="_blank" rel="noopener" href="https://github.com/rswier/c4">c4</a>，实现了词法分析、语法分析、目标代码生成，在 525 行内使用了四个函数（实际上也就是三个大模块 + main 函数）完成对简单 C 语言程序的编译，虽然其中的代码实现比较复杂，但是逻辑相对清晰，能够很直观地理解编译的进程。但是它没有实现错误处理和代码优化（）</p>
<p>除此之外也参考了许多往届学长的课设代码，大致地了解了编译器的各个模块</p>
<h1 id="编译器总体设计"><a href="#编译器总体设计" class="headerlink" title="编译器总体设计"></a>编译器总体设计</h1><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>本编译器设计按照主流编译器的编译过程，也就是课程释放的作业顺序编排工作的步骤实现了从 SysC 语言的输入到 mips 汇编语言的输出：</p>
<blockquote>
<p><strong>词法分析</strong> → <strong>语法分析</strong> → <strong>语义分析与中间代码生成</strong> → <strong>目标代码生成</strong> → <strong>代码优化</strong></p>
<p><strong>符号表管理</strong>与<strong>错误处理</strong></p>
</blockquote>
<p>这五个主要流程分为前端和后端两部分，前端包括词法分析（核心类为 <code>TokenAnalyzer</code>）、语法分析（核心类为 <code>NodePaeser</code>）、中间代码生成（核心类为 <code>LLCenter</code>），后端包括目标代码生成（核心类为 <code>MipsCenter</code>）和代码优化（实际未进行优化）。</p>
<h2 id="文件组织"><a href="#文件组织" class="headerlink" title="文件组织"></a>文件组织</h2><p>总体文件组织如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|   Compiler.java</span><br><span class="line">|   config.json</span><br><span class="line">|</span><br><span class="line">+---exception</span><br><span class="line">|       NoFileException.java</span><br><span class="line">|       StatusCode.java</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">|   |   ErrorChecker.java</span><br><span class="line">|   |   NodeParser.java</span><br><span class="line">|   |   TokenAnalyzer.java</span><br><span class="line">|   |</span><br><span class="line">|   +---ast</span><br><span class="line">|   |       AddExpNode.java</span><br><span class="line">|   |       BlockItemNode.java</span><br><span class="line">|   |       BlockNode.java</span><br><span class="line">|   |       BTypeNode.java</span><br><span class="line">|   |       CompUnitNode.java</span><br><span class="line">|   |       CondNode.java</span><br><span class="line">|   |       ConstDeclNode.java</span><br><span class="line">|   |       ConstDefNode.java</span><br><span class="line">|   |       ConstExpNode.java</span><br><span class="line">|   |       ConstInitValNode.java</span><br><span class="line">|   |       DeclNode.java</span><br><span class="line">|   |       EqExpNode.java</span><br><span class="line">|   |       ExpNode.java</span><br><span class="line">|   |       ForStmtNode.java</span><br><span class="line">|   |       FuncDefNode.java</span><br><span class="line">|   |       FuncFParamNode.java</span><br><span class="line">|   |       FuncFParamsNode.java</span><br><span class="line">|   |       FuncRParamsNode.java</span><br><span class="line">|   |       FuncTypeNode.java</span><br><span class="line">|   |       IdentNode.java</span><br><span class="line">|   |       InitValNode.java</span><br><span class="line">|   |       LAndExpNode.java</span><br><span class="line">|   |       LOrExpNode.java</span><br><span class="line">|   |       LValNode.java</span><br><span class="line">|   |       MainFuncDefNode.java</span><br><span class="line">|   |       MulExpNode.java</span><br><span class="line">|   |       NodeCategory.java</span><br><span class="line">|   |       NumberNode.java</span><br><span class="line">|   |       PrimaryExpNode.java</span><br><span class="line">|   |       RelExpNode.java</span><br><span class="line">|   |       StmtCategory.java</span><br><span class="line">|   |       StmtNode.java</span><br><span class="line">|   |       UnaryExpNode.java</span><br><span class="line">|   |       UnaryOpNode.java</span><br><span class="line">|   |       VarDeclNode.java</span><br><span class="line">|   |       VarDefNode.java</span><br><span class="line">|   |</span><br><span class="line">|   +---shortSymbol</span><br><span class="line">|   |       Function.java</span><br><span class="line">|   |       Symbol.java</span><br><span class="line">|   |       SymbolTable.java</span><br><span class="line">|   |       Var.java</span><br><span class="line">|   |</span><br><span class="line">|   \---token</span><br><span class="line">|           Token.java</span><br><span class="line">|           TokenCategory.java</span><br><span class="line">|</span><br><span class="line">+---llvm</span><br><span class="line">|   |   LLCenter.java</span><br><span class="line">|   |   Visitor.java</span><br><span class="line">|   |</span><br><span class="line">|   +---identifier</span><br><span class="line">|   |       Identifier.java</span><br><span class="line">|   |</span><br><span class="line">|   +---symbol</span><br><span class="line">|   |       Symbol.java</span><br><span class="line">|   |       SymbolTable.java</span><br><span class="line">|   |</span><br><span class="line">|   +---type</span><br><span class="line">|   |       ArrayType.java</span><br><span class="line">|   |       BasicType.java</span><br><span class="line">|   |       BlockType.java</span><br><span class="line">|   |       LabelType.java</span><br><span class="line">|   |       PointerType.java</span><br><span class="line">|   |       Type.java</span><br><span class="line">|   |       TypeList.java</span><br><span class="line">|   |       VoidType.java</span><br><span class="line">|   |</span><br><span class="line">|   \---value</span><br><span class="line">|       |   ArrayValue.java</span><br><span class="line">|       |   BasicBlock.java</span><br><span class="line">|       |   Builder.java</span><br><span class="line">|       |   ConstantValue.java</span><br><span class="line">|       |   FuncFParam.java</span><br><span class="line">|       |   Function.java</span><br><span class="line">|       |   GlobalVar.java</span><br><span class="line">|       |   Use.java</span><br><span class="line">|       |   User.java</span><br><span class="line">|       |   Value.java</span><br><span class="line">|       |</span><br><span class="line">|       \---instruction</span><br><span class="line">|               AllocaInstr.java</span><br><span class="line">|               BinaryInstr.java</span><br><span class="line">|               BitCastInstr.java</span><br><span class="line">|               BranchInstr.java</span><br><span class="line">|               CallInstr.java</span><br><span class="line">|               GepInstr.java</span><br><span class="line">|               IcmpInstr.java</span><br><span class="line">|               InstrType.java</span><br><span class="line">|               Instruction.java</span><br><span class="line">|               JumpInstr.java</span><br><span class="line">|               LoadInstr.java</span><br><span class="line">|               ReturnInstr.java</span><br><span class="line">|               StoreInstr.java</span><br><span class="line">|</span><br><span class="line">+---mips</span><br><span class="line">|   |   Builder.java</span><br><span class="line">|   |   MipsCenter.java</span><br><span class="line">|   |   RegisterFile.java</span><br><span class="line">|   |</span><br><span class="line">|   +---data</span><br><span class="line">|   +---instr</span><br><span class="line">|   |       AbstractInstr.java</span><br><span class="line">|   |       BranchDInstr.java</span><br><span class="line">|   |       CalDInstr.java</span><br><span class="line">|   |       CalSInstr.java</span><br><span class="line">|   |       DataRecord.java</span><br><span class="line">|   |       DataTag.java</span><br><span class="line">|   |       InstrType.java</span><br><span class="line">|   |       JumpInstr.java</span><br><span class="line">|   |       LabelInstr.java</span><br><span class="line">|   |       MemSInstr.java</span><br><span class="line">|   |       PseudoInstruction.java</span><br><span class="line">|   |       Syscall.java</span><br><span class="line">|   |       UtilsSInstr.java</span><br><span class="line">|   |</span><br><span class="line">|   \---operands</span><br><span class="line">|           Imm.java</span><br><span class="line">|           Label.java</span><br><span class="line">|           Operand.java</span><br><span class="line">|           Register.java</span><br><span class="line">|</span><br><span class="line">\---utils</span><br><span class="line">    |   Calculator.java</span><br><span class="line">    |   Logger.java</span><br><span class="line">    |   OutputRecord.java</span><br><span class="line">    |   Pair.java</span><br><span class="line">    |   ParameterParser.java</span><br><span class="line">    |   Settings.java</span><br><span class="line">    |</span><br><span class="line">    \---error</span><br><span class="line">            Error.java</span><br><span class="line">            ErrorType.java</span><br></pre></td></tr></table></figure>

<p>分功能介绍见文档后续内容</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>各功能部分按照一定的规则输入和输出进行划分，接口供给定义如下：</p>
<ul>
<li>工具类：创建文件流，从源文件读入字符串序列；分析参数并创建输出文件</li>
<li>词法分析：输入为工具类提供的 <code>ArrayList&lt;String&gt;</code> 形式的源文件，输出为语法分析后得到的 <code>ArrayList&lt;Token&gt;</code> 形式的词法单元</li>
<li>语法分析：输入为词法分析提供的 <code>ArrayList&lt;Token&gt;</code>，输出为语法分析后得到的语法树顶层节点 <code>CompUnitNode</code></li>
<li>错误处理：输入为语法分析得到的语法树，输出为语法树中存在的语法错误，若存在错误则不进行后续部分，编译程序直接退出</li>
<li>中间代码生成：输入为语法分析得到的语法树，输出为语法树对应的线性 <code>ArrayList&lt;Value&gt;</code> llvm 指令序列和等价的字符序列</li>
<li>目标代码生成：输入为中间代码生成得到的 llvm 指令序列，输出为 <code>ArrayList&lt;AbstrctInstruction&gt;</code> 的线性 mips 指令序列和等价字符序列</li>
<li>代码优化：本编译器不涉及代码优化部分，故不存在相应接口</li>
</ul>
<h1 id="工具类设计"><a href="#工具类设计" class="headerlink" title="工具类设计"></a>工具类设计</h1><h2 id="文件组织-1"><a href="#文件组织-1" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---exception</span><br><span class="line">|       NoFileException.java</span><br><span class="line">|       StatusCode.java</span><br><span class="line">|</span><br><span class="line">\---utils</span><br><span class="line">    |   Calculator.java</span><br><span class="line">    |   Logger.java</span><br><span class="line">    |   OutputRecord.java</span><br><span class="line">    |   Pair.java</span><br><span class="line">    |   ParameterParser.java</span><br><span class="line">    |   Settings.java</span><br><span class="line">    |</span><br><span class="line">    \---error</span><br><span class="line">            Error.java</span><br><span class="line">            ErrorType.java</span><br></pre></td></tr></table></figure>

<h2 id="具体设计"><a href="#具体设计" class="headerlink" title="具体设计"></a>具体设计</h2><p><code>utils</code> 包包括了编译器执行过程中需要用到的一些辅助类、保存类和相关的信息。</p>
<h3 id="utils-Calculator"><a href="#utils-Calculator" class="headerlink" title="utils/Calculator"></a>utils/Calculator</h3><ul>
<li><code>public static produceConst(Value v1, TokenCategory tc, Value v2)</code> </li>
</ul>
<p>按照 TokenCategory 不同，执行在中间代码生成过程中对常数进行对应的优化运算，减少 llvm 指令的条数</p>
<h3 id="utils-Logger"><a href="#utils-Logger" class="headerlink" title="utils/Logger"></a>utils/Logger</h3><ul>
<li><code>public static void initLogger()</code></li>
</ul>
<p>初始化输入输出文件流，为各功能部分提供对应的写入/读取文件</p>
<ul>
<li><code>public static void process(int statusCode, String msg)</code></li>
</ul>
<p>编译器运行过程中的相关信息显示，根据不同 <code>statusCode</code> 区分信息级别</p>
<ul>
<li><code>public static void printFile(String content, String targetType)</code></li>
</ul>
<p>编译器各功能部分对外的输出接口，根据所处的功能阶段不同调用不同的 <code>targetType</code> 进行对应文件的输出</p>
<h3 id="utils"><a href="#utils" class="headerlink" title="utils/*"></a>utils/*</h3><ul>
<li><p><code>Settings</code> 类与 <code>Logger</code> 类联动控制文件的输出与否</p>
</li>
<li><p><code>Pair</code> 类是一个实现 <code>&lt;K, V&gt;</code> 结构的工具类</p>
</li>
<li><p><code>ParameterParser</code> 类实现了对命令行参数的解析，实际测评无用，可供课下测试使用</p>
</li>
<li><p><code>OutputRecord</code> 类已弃用</p>
</li>
<li><p>软件包 <code>error</code> 存放运行时产生的错误种类，供 <code>Logger</code> 进行信息级别区分和输出</p>
</li>
</ul>
<h3 id="exception"><a href="#exception" class="headerlink" title="exception/*"></a>exception/*</h3><ul>
<li>本软件包提供具体的错误类，可加入更具体的错误信息供 <code>Logger</code> 输出</li>
</ul>
<h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，解析参数并初始化设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/* Init */</span></span><br><span class="line">   <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123; ParameterParser.setParameter(args); &#125;</span><br><span class="line">Logger.initLogger();</span><br></pre></td></tr></table></figure>



<h1 id="词法分析设计"><a href="#词法分析设计" class="headerlink" title="词法分析设计"></a>词法分析设计</h1><h2 id="文件组织-2"><a href="#文件组织-2" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   TokenAnalyzer.java</span><br><span class="line">    |</span><br><span class="line">    \---token</span><br><span class="line">            Token.java</span><br><span class="line">            TokenCategory.java</span><br></pre></td></tr></table></figure>

<h2 id="具体设计-1"><a href="#具体设计-1" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-TokenAnalyzer"><a href="#frontend-TokenAnalyzer" class="headerlink" title="frontend/TokenAnalyzer"></a>frontend/TokenAnalyzer</h3><p>词法分析的核心类，采用单例模式进行调用。关键处理点在于通过字符的移动和匹配对当前的短语进行匹配，匹配成功后形成对应的 Token，存入短语集合中，供后续词法分析使用。</p>
<ul>
<li><code>public int getChar(BufferedInputStream buffer)</code> ：从输入字符串中获取下一个字符，进行后续匹配</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getChar</span><span class="params">(BufferedInputStream buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = buffer.read();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public ArrayList&lt;Token&gt; getToken(BufferedInputStream buffer)</code>：解析核心函数，通过对输入字符串的逐字符判断，进入不同的解析方法得出具体单词，最终返回解析得到的 token 序列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;Token&gt; <span class="title function_">getToken</span><span class="params">(BufferedInputStream buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cha</span> <span class="operator">=</span> getChar(buffer);</span><br><span class="line">	<span class="keyword">while</span> (cha != -<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;/&#x27;</span>) &#123; </span><br><span class="line">            <span class="comment">/* 排除注释 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;\n&#x27;</span> || Character.isWhitespace((<span class="type">char</span>) cha)) &#123; </span><br><span class="line">            <span class="comment">/* 排除空白符、换行符 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&quot;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析字符串 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;=&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析等号、逻辑等 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;!&#x27;</span>) &#123;</span><br><span class="line">         	<span class="comment">/* 解析逻辑非 */</span>   </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&gt;&#x27;</span> || (<span class="type">char</span>) cha == <span class="string">&#x27;&lt;&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析比较运算符 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">char</span>) cha == <span class="string">&#x27;&amp;&#x27;</span> || ((<span class="type">char</span>) cha == <span class="string">&#x27;|&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析逻辑与、或 */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isLetter((<span class="type">char</span>) cha) || (<span class="type">char</span>) cha == <span class="string">&#x27;_&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析标识符 */</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tk</span> <span class="operator">=</span> stringBuilder.toString();</span><br><span class="line">            <span class="keyword">switch</span> (tk) &#123; </span><br><span class="line">                <span class="comment">/* 解析关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;main&quot;</span> -&gt; <span class="comment">/* 解析 main 关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;const&quot;</span> -&gt; <span class="comment">/* 解析 const 关键字 */</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;int&quot;</span> -&gt; <span class="comment">/* 解析 int 关键字 */</span></span><br><span class="line">                <span class="comment">/* 解析其他关键字 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="comment">/* 其余解析逻辑 */</span>) &#123;</span><br><span class="line">            <span class="comment">/* 解析其余语法成分，如各类括号、分号等 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="frontend-token"><a href="#frontend-token" class="headerlink" title="frontend/token/*"></a>frontend/token/*</h3><ul>
<li>Token 类是保存短语单元的对象类，保存了当前词的详细信息（类型、字符串、所在行数）</li>
<li>TokenCategory 类是枚举类，用于保存所有可能出现的 token 种类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> frontend.token;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">TokenCategory</span> &#123;</span><br><span class="line">    IDENFR, INTCON, STRCON,</span><br><span class="line">    MAINTK, CONSTTK, INTTK, BREAKTK, CONTINUETK, VOIDTK, IFTK, ELSETK, FORTK,</span><br><span class="line">    NOT, AND, OR, PLUS, MINU, MULT, DIV, MOD,</span><br><span class="line">    GETINTTK, PRINTFTK, RETURNTK,</span><br><span class="line">    LSS, LEQ, GRE, GEQ, EQL, NEQ, ASSIGN,</span><br><span class="line">    SEMICN, COMMA, LPARENT, RPARENT, LBRACK, RBRACK, LBRACE, RBRACE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Compiler-1"><a href="#Compiler-1" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，产生一个 <code>ArrayList&lt;Token&gt;</code> 供语法分析解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lexer */</span></span><br><span class="line">ArrayList&lt;Token&gt; tokenList = TokenAnalyzer.getInstance().getToken(Logger.getSource());</span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">tokenList.forEach(i -&gt; tokens.append(i.toString()));</span><br><span class="line">Logger.printFile(tokens.toString(), <span class="string">&quot;lexer&quot;</span>); <span class="comment">// printToken(tokenList);</span></span><br></pre></td></tr></table></figure>

<h1 id="语法分析设计"><a href="#语法分析设计" class="headerlink" title="语法分析设计"></a>语法分析设计</h1><h2 id="文件组织-3"><a href="#文件组织-3" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   NodeParser.java</span><br><span class="line">    |</span><br><span class="line">    +---ast</span><br><span class="line">            AddExpNode.java</span><br><span class="line">            BlockItemNode.java</span><br><span class="line">            BlockNode.java</span><br><span class="line">            BTypeNode.java</span><br><span class="line">            CompUnitNode.java</span><br><span class="line">            CondNode.java</span><br><span class="line">            ConstDeclNode.java</span><br><span class="line">            ConstDefNode.java</span><br><span class="line">            ConstExpNode.java</span><br><span class="line">            ConstInitValNode.java</span><br><span class="line">            DeclNode.java</span><br><span class="line">            EqExpNode.java</span><br><span class="line">            ExpNode.java</span><br><span class="line">            ForStmtNode.java</span><br><span class="line">            FuncDefNode.java</span><br><span class="line">            FuncFParamNode.java</span><br><span class="line">            FuncFParamsNode.java</span><br><span class="line">            FuncRParamsNode.java</span><br><span class="line">            FuncTypeNode.java</span><br><span class="line">            IdentNode.java</span><br><span class="line">            InitValNode.java</span><br><span class="line">            LAndExpNode.java</span><br><span class="line">            LOrExpNode.java</span><br><span class="line">            LValNode.java</span><br><span class="line">            MainFuncDefNode.java</span><br><span class="line">            MulExpNode.java</span><br><span class="line">            NodeCategory.java</span><br><span class="line">            NumberNode.java</span><br><span class="line">            PrimaryExpNode.java</span><br><span class="line">            RelExpNode.java</span><br><span class="line">            StmtCategory.java</span><br><span class="line">            StmtNode.java</span><br><span class="line">            UnaryExpNode.java</span><br><span class="line">            UnaryOpNode.java</span><br><span class="line">            VarDeclNode.java</span><br><span class="line">            VarDefNode.java</span><br></pre></td></tr></table></figure>

<h2 id="具体设计-2"><a href="#具体设计-2" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-NodeParser"><a href="#frontend-NodeParser" class="headerlink" title="frontend/NodeParser"></a>frontend/NodeParser</h3><p>语法分析核心类，采用单例模式调用。通过逐个读取 token 的内容来进行语法树的构建。</p>
<ul>
<li><code>private Token matchToken(TokenCategory tokenCategory)</code>：读取 token 的函数，如果待取出的 token 和预想的种类不同就不进行取出，同时具有一定的错误处理能力</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Token <span class="title function_">matchToken</span><span class="params">(TokenCategory tokenCategory)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (token.getTokenCategory() == tokenCategory) &#123;</span><br><span class="line">        <span class="type">Token</span> <span class="variable">temp</span> <span class="operator">=</span> token;</span><br><span class="line">        getToken();</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span>(tokenCategory) &#123;</span><br><span class="line">                <span class="comment">/* 处理 ijk 三种错误处理类型 */</span></span><br><span class="line">            <span class="keyword">case</span> SEMICN  -&gt; </span><br><span class="line">            <span class="keyword">case</span> RPARENT -&gt; </span><br><span class="line">            <span class="keyword">case</span> RBRACK  -&gt; </span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                Logger.process(StatusCode.UNEXPECTED_TOKEN_ERROR, <span class="string">&quot;Match utils.error frontend.token &quot;</span> + token.getToken() + <span class="string">&quot; at line &quot;</span> + lineCount);</span><br><span class="line">                Logger.exit(StatusCode.UNEXPECTED_TOKEN_ERROR);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public CompUnitNode compUnitNode()</code>：解析 <code>compUnit</code> 节点，也就是语法树的根节点，通过逐层调用内部函数来进行语法成分的解析，每一个相对应的函数都会返回一个和函数名相同的类型的对象，其余函数完全按照语法树进行解析即可，不再占用篇幅展示</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> CompUnitNode <span class="title function_">compUnitNode</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;DeclNode&gt; declNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;FuncDefNode&gt; funcDefNodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    MainFuncDefNode mainFuncDefNode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not main &amp;&amp; func: int function &#x27;(&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> (!peekAt(<span class="number">2</span>).getTokenCategory().equals(TokenCategory.LPARENT)) &#123;</span><br><span class="line">        declNodes.add(declNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// not main: int &#x27;main&#x27;</span></span><br><span class="line">    <span class="keyword">while</span>(!peekAt(<span class="number">1</span>).getTokenCategory().equals(TokenCategory.MAINTK)) &#123;</span><br><span class="line">        funcDefNodes.add(funcDefNode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main: left choice</span></span><br><span class="line">    mainFuncDefNode = mainFuncDefNode();</span><br><span class="line"></span><br><span class="line">    outputs.add(<span class="keyword">new</span> <span class="title class_">OutputRecord</span>(NodeCategory.CompUnit));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompUnitNode</span>(declNodes, funcDefNodes, mainFuncDefNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="frontend-ast"><a href="#frontend-ast" class="headerlink" title="frontend/ast/*"></a>frontend/ast/*</h3><p><code>ast</code> 软件包内包含了所有在核心类 <code>NodeParser</code> 中创建的节点类，同时对应了语法文档中的非终结符，文档中以较为复杂的 <code>StmtNode</code>，也就是语法中的 <code>Stmt</code> 作为示例进行说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StmtNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LValNode lValNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExpNode expNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ExpNode&gt; expNodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockNode blockNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CondNode condNode;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;StmtNode&gt; stmtNodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ForStmtNode forStmtNode1, forStmtNode2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Token tokenCategory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String formatString;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StmtCategory stmtCategory;</span><br><span class="line">    <span class="keyword">private</span> Token ifTk, elseTk, forTk;</span><br><span class="line">    <span class="keyword">private</span> Token lp, rp;</span><br><span class="line">    <span class="keyword">private</span> Token eq, semicolon, semicolon2;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Token&gt; comma;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据不同的 Stmt 使用不同的构造函数，赋值内容省略 */</span></span><br><span class="line">    <span class="comment">/* Stmt -&gt; LVal &#x27;=&#x27; Exp &#x27;;&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(LValNode lValNode, ExpNode expNode, Token eq, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; [Exp] &#x27;;&#x27;  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ExpNode expNode, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; Block  */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(BlockNode blockNode)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;if&#x27; &#x27;(&#x27; Cond &#x27;)&#x27; Stmt [ &#x27;else&#x27; Stmt] */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ArrayList&lt;StmtNode&gt; stmtNodes,</span></span><br><span class="line"><span class="params">                    Token ifTk, Token elseTk, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;for&#x27; &#x27;(&#x27; [ForStmt] &#x27;;&#x27; [Cond] &#x27;;&#x27; [ForStmt] &#x27;)&#x27; Stmt */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ArrayList&lt;StmtNode&gt; stmtNodes,</span></span><br><span class="line"><span class="params">                    ForStmtNode forStmtNode1, ForStmtNode forStmtNode2,</span></span><br><span class="line"><span class="params">                    Token forTk, Token semicolon, Token semicolon2, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(CondNode condNode, ForStmtNode forStmtNode2, ArrayList&lt;StmtNode&gt; stmtNodes, Token lp, Token rp)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/** Stmt -&gt; &#x27;break&#x27; &#x27;;&#x27; &amp; &#x27;continue&#x27; &#x27;;&#x27;</span></span><br><span class="line"><span class="comment">      * for break; continue; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(Token tokenCategory, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;return&#x27; [Exp] &#x27;;&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ExpNode expNode, Token tokenCategory, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; LVal &#x27;=&#x27; &#x27;getint&#x27; &#x27;(&#x27; &#x27;)&#x27; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(LValNode lValNode, Token tokenCategory, Token eq, Token lp,</span></span><br><span class="line"><span class="params">                    Token rp, Token semicolon)</span> &#123; &#125;</span><br><span class="line">    <span class="comment">/* Stmt -&gt; &#x27;printf&#x27; &#x27;(&#x27; FormatString &#123; &#x27;,&#x27; Exp &#x27;)&#x27; &#x27;;&#x27; &#125; */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StmtNode</span><span class="params">(ArrayList&lt;ExpNode&gt; expNodes, Token tokenCategory, String formatString,</span></span><br><span class="line"><span class="params">                    ArrayList&lt;Token&gt; comma, Token lp, Token rp, Token semicolon, <span class="type">int</span> line)</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* getter、setter、代码生成相关方法省略 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* 语法树输出函数，省略部分种类分支 */</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">switch</span> (stmtCategory) &#123;</span><br><span class="line">            <span class="keyword">case</span> LVal -&gt; &#123;</span><br><span class="line">                sb.append(lValNode);</span><br><span class="line">                sb.append(eq);</span><br><span class="line">                sb.append(expNode);</span><br><span class="line">                sb.append(semicolon);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> Exp -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Block -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> If -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> For -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Continue, Break -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Return -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> GetInt -&gt; &#123; &#125;</span><br><span class="line">            <span class="keyword">case</span> Printf -&gt; &#123;</span><br><span class="line">                sb.append(tokenCategory).append(lp).append(<span class="string">&quot;STRCON &quot;</span>).append(formatString).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; expNodes.size(); i++) &#123;</span><br><span class="line">                    sb.append(comma.get(i)).append(expNodes.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(rp).append(semicolon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(<span class="string">&quot;&lt;&quot;</span>).append(NodeCategory.Stmt).append(<span class="string">&quot;&gt;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在语法分析部分结束后，会形成一个以 <code>CompUnitNode</code> 为根节点的语法树，每个非叶节点都含有语法成分对应的子节点对象，输出语法树成分时调用递归的 <code>toString</code> 函数即可全部输出</p>
<h3 id="Compiler-2"><a href="#Compiler-2" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，返回一个 CompUnitNode 供错误处理和中间代码生成使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Parser */</span></span><br><span class="line">   NodeParser.getInstance().setTokenList(tokenList);</span><br><span class="line">   <span class="type">CompUnitNode</span> <span class="variable">compUnit</span> <span class="operator">=</span> NodeParser.getInstance().compUnitNode();</span><br><span class="line"></span><br><span class="line">   Logger.printFile(compUnit.toString(), <span class="string">&quot;parser&quot;</span>); <span class="comment">// printOutputs(compUnit.toString());</span></span><br></pre></td></tr></table></figure>

<h1 id="错误处理设计"><a href="#错误处理设计" class="headerlink" title="错误处理设计"></a>错误处理设计</h1><h2 id="文件组织-4"><a href="#文件组织-4" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---frontend</span><br><span class="line">    |   ErrorChecker.java</span><br><span class="line">    |</span><br><span class="line">    +---shortSymbol</span><br><span class="line">            Function.java</span><br><span class="line">            Symbol.java</span><br><span class="line">            SymbolTable.java</span><br><span class="line">            Var.java</span><br></pre></td></tr></table></figure>

<h2 id="具体设计-3"><a href="#具体设计-3" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="frontend-ErrorChecker"><a href="#frontend-ErrorChecker" class="headerlink" title="frontend/ErrorChecker"></a>frontend/ErrorChecker</h3><p>错误处理的核心类，采用单例模式调用。对可能出现错误的 ast 语法类和其父类，都编写了相应的 Error 函数，递归调用到指定的对象中检查是否存在错误，如对变量可能的重定义错误，设置了如下函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 变量声明: VarDecl → BType VarDef &#123; &#x27;,&#x27; VarDef &#125; &#x27;;&#x27; // i */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">varDeclError</span><span class="params">(VarDeclNode node)</span> &#123;</span><br><span class="line">    node.getVarDefNodes().forEach(<span class="built_in">this</span>::varDefError); <span class="comment">/* 递归调用 varDefError 检查每个 VarDefNode 是否含有错误*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 变量定义: VarDef → Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; // b</span></span><br><span class="line"><span class="comment"> *                  | Ident &#123; &#x27;[&#x27; ConstExp &#x27;]&#x27; &#125; &#x27;=&#x27; InitVal // k*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">varDefError</span><span class="params">(VarDefNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (existNow(node.getIdentNode().getIdent())) &#123;</span><br><span class="line">        <span class="comment">/* 已经存在同名符号声明，记录当前错误 ErrorType.NameRedefinition 并返回 */</span></span><br><span class="line">        insert(<span class="keyword">new</span> <span class="title class_">Error</span>(node.getIdentNode().getLineCount(), ErrorType.NameRedefinition));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    node.getConstExpNodes().forEach(<span class="built_in">this</span>::constExpError);</span><br><span class="line">    tables.get(tables.size() - <span class="number">1</span>).add(node.getIdentNode().getIdent(),</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">Var</span>(node.getIdentNode().getIdent(), node.getConstExpNodes().size(), <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">if</span> (node.getInitValNode() != <span class="literal">null</span>) &#123;</span><br><span class="line">        initValError(node.getInitValNode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其余的语法类同理，均为逐层调用函数进行错误的检查</p>
<h3 id="frontend-shortSymbol"><a href="#frontend-shortSymbol" class="headerlink" title="frontend/shortSymbol/*"></a>frontend/shortSymbol/*</h3><p><code>shortSymbol</code> 软件包主要作用为建立错误处理时使用的符号表，该符号表包含的信息要少于代码生成时使用的符号表，结构也相对简单</p>
<ul>
<li><code>SymbolTable</code> 类是符号表类，创建一个可以存放当前层符号的表，内部符号使用 <code>HashMap&lt;String, Symbol&gt;</code> 进行管理，便于快速查找；同时提供了查找、插入等操作函数，供错误处理核心类调用对是否发生错误进行判断</li>
<li><code>Symbol</code> 类是符号类，仅包含标识符名，<code>Var</code> 和 <code>Function</code> 两个类对其进行继承，分别代表当前符号表管理区域中的变量声明和函数声明，两个类的对象都要存放在符号表的 <code>HashMap</code> 中管理</li>
</ul>
<h3 id="Compiler-3"><a href="#Compiler-3" class="headerlink" title="Compiler"></a>Compiler</h3><p>在主运行类中调用方式如下，调用错误处理类单例进行解析并输出，如果存在错误则使用 <code>Logger</code> 终止编译程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Error */</span></span><br><span class="line">   ErrorChecker.getInstance().compUnitError(compUnit);</span><br><span class="line">   Logger.printFile(ErrorChecker.getInstance().getErrors(), <span class="string">&quot;error&quot;</span>); <span class="comment">// printErrors(ErrorChecker.getInstance().getErrors());</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Logger.hasError) &#123; Logger.exit(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure>

<h1 id="中间代码生成设计"><a href="#中间代码生成设计" class="headerlink" title="中间代码生成设计"></a>中间代码生成设计</h1><h2 id="文件组织-5"><a href="#文件组织-5" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---llvm</span><br><span class="line">    |   LLCenter.java</span><br><span class="line">    |   Visitor.java</span><br><span class="line">    |</span><br><span class="line">    +---identifier</span><br><span class="line">    |       Identifier.java</span><br><span class="line">    |</span><br><span class="line">    +---symbol</span><br><span class="line">    |       Symbol.java</span><br><span class="line">    |       SymbolTable.java</span><br><span class="line">    |</span><br><span class="line">    +---type</span><br><span class="line">    |       ArrayType.java</span><br><span class="line">    |       BasicType.java</span><br><span class="line">    |       BlockType.java</span><br><span class="line">    |       LabelType.java</span><br><span class="line">    |       PointerType.java</span><br><span class="line">    |       Type.java</span><br><span class="line">    |       TypeList.java</span><br><span class="line">    |       VoidType.java</span><br><span class="line">    |</span><br><span class="line">    \---value</span><br><span class="line">        |   ArrayValue.java</span><br><span class="line">        |   BasicBlock.java</span><br><span class="line">        |   Builder.java</span><br><span class="line">        |   ConstantValue.java</span><br><span class="line">        |   FuncFParam.java</span><br><span class="line">        |   Function.java</span><br><span class="line">        |   GlobalVar.java</span><br><span class="line">        |   Use.java</span><br><span class="line">        |   User.java</span><br><span class="line">        |   Value.java</span><br><span class="line">        |</span><br><span class="line">        \---instruction</span><br><span class="line">                AllocaInstr.java</span><br><span class="line">                BinaryInstr.java</span><br><span class="line">                BitCastInstr.java</span><br><span class="line">                BranchInstr.java</span><br><span class="line">                CallInstr.java</span><br><span class="line">                GepInstr.java</span><br><span class="line">                IcmpInstr.java</span><br><span class="line">                InstrType.java</span><br><span class="line">                Instruction.java</span><br><span class="line">                JumpInstr.java</span><br><span class="line">                LoadInstr.java</span><br><span class="line">                ReturnInstr.java</span><br><span class="line">                StoreInstr.java</span><br></pre></td></tr></table></figure>

<h2 id="具体设计-4"><a href="#具体设计-4" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="llvm-LLCenter"><a href="#llvm-LLCenter" class="headerlink" title="llvm/LLCenter"></a>llvm/LLCenter</h3><p><code>LLCenter</code> 类是生成中间代码时的中控类，编译过程中产生的 llvm 指令都会存放在中控类中，并指导进行输出，同时存放 llvm 产生的函数和全局变量，生成复杂的全局函数/变量表</p>
<ul>
<li><code>public static void initFunction()</code>：初始化函数表，添加四个库函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Function</span> <span class="variable">getInt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.I32_TYPE, <span class="string">&quot;getint&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="type">Function</span> <span class="variable">putint</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putint&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(TypeList.I32_TYPE, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    <span class="type">Function</span> <span class="variable">putch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putch&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(TypeList.I32_TYPE, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Function</span> <span class="variable">putstr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Function</span>(TypeList.VOID_TYPE, <span class="string">&quot;putstr&quot;</span>, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;() &#123;&#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">FuncFParam</span>(<span class="keyword">new</span> <span class="title class_">PointerType</span>(TypeList.I8_TYPE), <span class="string">&quot;0&quot;</span>));</span><br><span class="line">    &#125;&#125;);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;getint&quot;</span>, getInt);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putint&quot;</span>, putint);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putch&quot;</span>, putch);</span><br><span class="line">    declareFunction.put(<span class="string">&quot;putstr&quot;</span>, putstr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="llvm-Vistor"><a href="#llvm-Vistor" class="headerlink" title="llvm/Vistor"></a>llvm/Vistor</h3><p><code>Vistor</code> 类是 llvm 生成过程中重要的类，从语法树的根节点开始，开始逐级调用传递 Vistor 的 visit 函数，并在 visit 函数中解析语法结构，生成语法树对应的 llvm 语句。Vistor 类主要在遍历过程中存放当前处理的上下文信息，如是否在函数中、循环层数、基本块信息和跳转目标地址等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Vistor 类部分信息字段 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Visitor</span> <span class="variable">visitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Visitor</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">blockCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">paramCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">loopDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicBlock</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;BasicBlock&gt; continueBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;BasicBlock&gt; breakBlocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Function currentFunction;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SymbolTable</span> <span class="variable">currentTable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SymbolTable</span>();  <span class="comment">/* Add an initial table without parent */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, GlobalVar&gt; globalVarTable = LLCenter.globalVarTable;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, Function&gt; functionTable = LLCenter.functionTable;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> Builder.getInstance();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isGlobal</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">inFuncDef</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFillValue</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="llvm-identifier"><a href="#llvm-identifier" class="headerlink" title="llvm/identifier/*"></a>llvm/identifier/*</h3><ul>
<li><code>identifier</code> 软件包只含有一个 <code>Identifier</code> 类，存放 llvm 指令的序号、标识等信息，标识的产生并不重复，由 Vistor 在遍历语法树的过程中产生</li>
</ul>
<h3 id="llvm-symbol"><a href="#llvm-symbol" class="headerlink" title="llvm/symbol/*"></a>llvm/symbol/*</h3><ul>
<li><code>symbol</code> 软件包存放了代码生成过程中用到的符号结构和符号表结构，只有变量/常量会使用此类，当 vistor 发现一个对象的定义时就创建一个 <code>Symbol</code> 对象存放在 vistor 携带的 <code>SymbolTable</code> 实例中</li>
</ul>
<h3 id="llvm-type"><a href="#llvm-type" class="headerlink" title="llvm/type/*"></a>llvm/type/*</h3><ul>
<li><code>type</code> 软件包包含了llvm 指令对象的种类，包含基本类型（<code>i32</code>、<code>i1</code>）、指针类型（<code>i32*</code>）、数组类型（<code>[a x i32]</code>）和空类型，每一个 llvm 的 value 都拥有其对应的 type</li>
</ul>
<h3 id="llvm-value"><a href="#llvm-value" class="headerlink" title="llvm/value/*"></a>llvm/value/*</h3><ul>
<li><code>value</code> 软件包包含了 llvm 的绝大部分指令，“万物皆 value”，本编译器首先将 value 的指令划分出来形成一个独立的软件包 <code>instruction</code>，其余的 value 直接形成文件（数组量ArrayValue、基本块BasicBlock、常值量ConstantValue、函数形参FuncFParam、 函数Function、全局变量GlobalVar），并形成一个工厂类Builder负责在 vistor 遍历时产生 llvm 指令插入到 LLCenter 中。</li>
<li><code>instruction</code> 软件包包含了 llvm 最终生成时的所有可见指令，继承 <code>Instruction</code> 类，并持有一个枚举类选择指令的类型与功能，最后重写指令的 <code>toString</code> 方法便于最后部分对指令进行输出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">InstrType</span> &#123;</span><br><span class="line">    ADD(<span class="string">&quot;add&quot;</span>), SUB(<span class="string">&quot;sub&quot;</span>), MUL(<span class="string">&quot;mul&quot;</span>), DIV(<span class="string">&quot;sdiv&quot;</span>), REM(<span class="string">&quot;srem&quot;</span>),</span><br><span class="line">    BR(<span class="string">&quot;br&quot;</span>), CALL(<span class="string">&quot;call&quot;</span>), RET(<span class="string">&quot;ret&quot;</span>),</span><br><span class="line">    ALLOCA(<span class="string">&quot;alloca&quot;</span>), STORE(<span class="string">&quot;store&quot;</span>), LOAD(<span class="string">&quot;load&quot;</span>), GEP(<span class="string">&quot;getelementptr&quot;</span>),</span><br><span class="line">    ZEXT(<span class="string">&quot;zext&quot;</span>),</span><br><span class="line">    EQ(<span class="string">&quot;icmp eq&quot;</span>), NE(<span class="string">&quot;icmp ne&quot;</span>), SGT(<span class="string">&quot;icmp sgt&quot;</span>),</span><br><span class="line">    SGE(<span class="string">&quot;icmp sge&quot;</span>), SLT(<span class="string">&quot;icmp slt&quot;</span>), SLE(<span class="string">&quot;icmp sle&quot;</span>),</span><br><span class="line">    <span class="comment">/* temp no usage */</span></span><br><span class="line">    ICMP(<span class="string">&quot;icmp&quot;</span>), AND(<span class="string">&quot;and&quot;</span>), OR(<span class="string">&quot;or&quot;</span>), NOR(<span class="string">&quot;nor&quot;</span>), NOT(<span class="string">&quot;not&quot;</span>), BITCAST(<span class="string">&quot;bitcast&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String typeName;</span><br><span class="line">    InstrType(String typeName) &#123; <span class="built_in">this</span>.typeName = typeName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> typeName; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="frontend-ast-1"><a href="#frontend-ast-1" class="headerlink" title="frontend/ast/*"></a>frontend/ast/*</h3><ul>
<li>语法树类中在 llvm 部分为每个语法结构都添加了 <code>visit</code> 函数用于访问并生成 llvm 代码，以条件表达式为例，进行短路求值的构造：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* CondNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock)</span> &#123;</span><br><span class="line">    <span class="comment">/* thenBlock 为成立时跳转块，elseBlock 为不成立时的跳转块 */</span></span><br><span class="line">    <span class="keyword">return</span> lOrExpNode.visit(visitor, thenBlock, elseBlock, visitor.getBlock());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LOrExpNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock, BasicBlock andBlock)</span> &#123;</span><br><span class="line">    <span class="comment">/* only process same level branch */</span></span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> andBlock;</span><br><span class="line">    visitor.setBlock(currentBlock);</span><br><span class="line">    <span class="keyword">if</span> (or == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 单一 &amp;&amp; 判断，不需进行短路 */</span></span><br><span class="line">        <span class="type">Value</span> <span class="variable">andValue</span> <span class="operator">=</span> lAndExpNode.visit(visitor, thenBlock, elseBlock, andBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 为下一个判断式生成基本块 */</span></span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">childAndBlock</span> <span class="operator">=</span> visitor.builder.buildBlockBegin(visitor.getCurrentFunction());</span><br><span class="line">        visitor.getCurrentFunction().pushBlock(childAndBlock);</span><br><span class="line">        visitor.setBlock(currentBlock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 为子与表达式设置跳转块：成功则直接结束。失败则进行下一个 &amp;&amp; 表达式判断 */</span></span><br><span class="line">        lAndExpNode.visit(visitor, thenBlock, childAndBlock, andBlock);</span><br><span class="line">        <span class="comment">/* 为子或表达式设置跳转块：与自身的跳转情况一致 */</span></span><br><span class="line">        Objects.requireNonNull(lOrExpNode).visit(visitor, thenBlock, elseBlock, childAndBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* LAndExpNode.java */</span></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">visit</span><span class="params">(Visitor visitor, BasicBlock thenBlock, BasicBlock elseBlock, BasicBlock eqBlock)</span> &#123;</span><br><span class="line">    <span class="type">BasicBlock</span> <span class="variable">currentBlock</span> <span class="operator">=</span> eqBlock;</span><br><span class="line">    visitor.setBlock(currentBlock);</span><br><span class="line">    <span class="type">Value</span> <span class="variable">eqValue</span> <span class="operator">=</span> eqExpNode.visit(visitor);</span><br><span class="line">    <span class="comment">/* 解析子相等表达式 */</span></span><br><span class="line">    <span class="keyword">if</span> (and == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* 单一表达式，调用 Builder 生成跳转 llvm 指令*/</span></span><br><span class="line">    	<span class="type">BranchInstr</span> <span class="variable">finalBranch</span> <span class="operator">=</span> visitor.builder.buildBranch(eqValue, thenBlock, elseBlock, visitor.getBlock());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 为子表达式设置跳转块，为自身设置跳转指令 */</span></span><br><span class="line">        <span class="type">BasicBlock</span> <span class="variable">childEqBlock</span> <span class="operator">=</span> visitor.builder.buildBlockBegin(visitor.getCurrentFunction());</span><br><span class="line">        visitor.getCurrentFunction().pushBlock(childEqBlock);</span><br><span class="line">        visitor.setBlock(currentBlock);</span><br><span class="line">        <span class="type">BranchInstr</span> <span class="variable">finalBranch</span> <span class="operator">=</span> visitor.builder.buildBranch(eqValue, childEqBlock, elseBlock, visitor.getBlock());</span><br><span class="line">        <span class="type">Value</span> <span class="variable">andExpValue</span> <span class="operator">=</span> Objects.requireNonNull(lAndExpNode).visit(visitor, thenBlock, elseBlock, childEqBlock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h1><h2 id="文件组织-6"><a href="#文件组织-6" class="headerlink" title="文件组织"></a>文件组织</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|</span><br><span class="line">+---mips</span><br><span class="line">    |   Builder.java</span><br><span class="line">    |   MipsCenter.java</span><br><span class="line">    |   RegisterFile.java</span><br><span class="line">    |</span><br><span class="line">    +---data</span><br><span class="line">    +---instr</span><br><span class="line">    |       AbstractInstr.java</span><br><span class="line">    |       BranchDInstr.java</span><br><span class="line">    |       CalDInstr.java</span><br><span class="line">    |       CalSInstr.java</span><br><span class="line">    |       DataRecord.java</span><br><span class="line">    |       DataTag.java</span><br><span class="line">    |       InstrType.java</span><br><span class="line">    |       JumpInstr.java</span><br><span class="line">    |       LabelInstr.java</span><br><span class="line">    |       MemSInstr.java</span><br><span class="line">    |       PseudoInstruction.java</span><br><span class="line">    |       Syscall.java</span><br><span class="line">    |       UtilsSInstr.java</span><br><span class="line">    |</span><br><span class="line">    \---operands</span><br><span class="line">            Imm.java</span><br><span class="line">            Label.java</span><br><span class="line">            Operand.java</span><br><span class="line">            Register.java</span><br></pre></td></tr></table></figure>



<h2 id="具体设计-5"><a href="#具体设计-5" class="headerlink" title="具体设计"></a>具体设计</h2><h3 id="mips-MipsCenter"><a href="#mips-MipsCenter" class="headerlink" title="mips/MipsCenter"></a>mips/MipsCenter</h3><p>和中间代码生成类似，在目标代码生成时也设置了一个中控类，用于存放所有的 mips 指令和编译时的信息，其功能比 LLCenter 更复杂，分成了几个区段，在生成 mips 指令时进行辅助</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* --------------- data segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;DataRecord&gt; dataSegment = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;GlobalVar, DataRecord&gt; tagMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> dataOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">gpValue</span> <span class="operator">=</span> <span class="number">0x10008000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">spValue</span> <span class="operator">=</span> <span class="number">0x7fffeffc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- text segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;AbstractInstr&gt; instructions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- data segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;DataRecord&gt; <span class="title function_">getDataSegment</span><span class="params">()</span> &#123; <span class="keyword">return</span> dataSegment; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushData</span><span class="params">(GlobalVar globalVar, DataTag data)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- text segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFunction</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushInstr</span><span class="params">(String comment,AbstractInstr instruction)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushInstr</span><span class="params">(AbstractInstr instruction, String blockLabel)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- stack segment --------------- */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;Value, Integer&gt; stacks = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;()&#123;&#123; put(<span class="keyword">new</span> <span class="title class_">Value</span>(TypeList.I1_TYPE, <span class="literal">null</span>), <span class="number">4</span>); &#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findStackValue</span><span class="params">(Value target)</span> &#123; <span class="keyword">return</span> stacks.containsKey(target); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushStack</span><span class="params">(Value target)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">flushStack</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStackSize</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStackOffset</span><span class="params">(Value target)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- register segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">RegisterFile</span> <span class="variable">registerFile</span> <span class="operator">=</span> RegisterFile.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Operand <span class="title function_">dispatchRegister</span><span class="params">(Value patch, <span class="type">boolean</span> needLoad, <span class="type">boolean</span>... inStorePointer)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadStore</span><span class="params">(Pair&lt;Register, Value&gt; storePair, <span class="type">boolean</span> isLoad)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeRegisterBack</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --------------- output segment --------------- */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMips</span><span class="params">()</span> &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="mips-RegisterFile"><a href="#mips-RegisterFile" class="headerlink" title="mips/RegisterFile"></a>mips/RegisterFile</h3><ul>
<li>在生成目标代码指令过程中对寄存器进行管理的类，模拟一个真正的寄存器，记录其中正在被占用的寄存器和可释放、申请的寄存器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initial</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">dispatchIdleRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">dispatchTargetRegister</span><span class="params">(Value value, Register register)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">recycleRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">recycleRegister</span><span class="params">(Register recycle)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Pair&lt;Register, Value&gt; <span class="title function_">recycleRegister</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">pickOut</span><span class="params">()</span> &#123; <span class="keyword">return</span> useList.getFirst(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasIdle</span><span class="params">()</span> &#123; <span class="keyword">return</span> !idles.isEmpty(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Value <span class="title function_">getValue</span><span class="params">(Register register)</span> &#123; <span class="keyword">return</span> dispatches.getOrDefault(register, <span class="literal">null</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Register <span class="title function_">getRegister</span><span class="params">(Value value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> HashMap&lt;Register, Value&gt; <span class="title function_">getDispatches</span><span class="params">()</span> &#123; <span class="keyword">return</span> dispatches; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="mips-operands"><a href="#mips-operands" class="headerlink" title="mips/operands/*"></a>mips/operands/*</h3><ul>
<li><code>operands</code> 软件包存放的是 mips 指令的操作数类，可以分为立即数（<code>Imm</code>）、寄存器（<code>Register</code>）和标签（<code>Label</code>）三类，它们在不同的指令中出现，不可直接换用</li>
</ul>
<p>操作数是指令内部 value 的具象，也就是承载着 llvm 的 value 的一个对象，我们将多种 llvm 指令转化为 能够表达同等意思的 mips 指令，靠的就是 mips 指令对这些操作数的动作。例如一个 Binary 的 llvm 指令可以将其两个运算的 value 提取出来当作两个 operands，并生成一条同样的运算类的 mips 指令，而运算的两个操作数就是这两个 value，由此就简单地实现了 llvm 到 mips 的转化。</p>
<h3 id="mips-instr"><a href="#mips-instr" class="headerlink" title="mips/instr/*"></a>mips/instr/*</h3><ul>
<li><code>instr</code> 软件包存放的是 mips 指令的种类，这些类的对象就实际对应一条可执行的 mips 指令，均继承自 <code>AbstractInstr</code> 类，再额外实现相关的字段</li>
</ul>
<h3 id="llvm-value-instruction"><a href="#llvm-value-instruction" class="headerlink" title="llvm/value/instruction/*"></a>llvm/value/instruction/*</h3><ul>
<li>llvm 的每一条指令都需要转化成对应的 mips 指令，所以在每个 llvm 指令类中都新建 <code>generateMips</code> 方法，实现从 llvm 到 mips 的转化</li>
</ul>
<p>以 BinaryInstr 为例进行转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateMips</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">lhs</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(operands.get(<span class="number">0</span>).getUseValue(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">rhs</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(operands.get(<span class="number">1</span>).getUseValue(), <span class="literal">true</span>);</span><br><span class="line">    <span class="type">Operand</span> <span class="variable">rd</span> <span class="operator">=</span> MipsCenter.getInstance().dispatchRegister(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Register &amp;&amp; rhs <span class="keyword">instanceof</span> Register) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (instrType) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD, SUB -&gt;</span><br><span class="line">            <span class="keyword">case</span> EQ -&gt;</span><br><span class="line">            <span class="comment">/* case 其余种类 -&gt; */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Register &amp;&amp; rhs <span class="keyword">instanceof</span> Imm) &#123;</span><br><span class="line">        <span class="comment">/* 实现类似的判断 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs <span class="keyword">instanceof</span> Imm &amp;&amp; rhs <span class="keyword">instanceof</span> Register) &#123;</span><br><span class="line">        <span class="comment">/* 实现类似的判断 */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* both imm */</span></span><br><span class="line">        <span class="comment">/* 可直接对立即数进行优化运算得出其结果*/</span></span><br><span class="line">        <span class="keyword">assert</span> lhs <span class="keyword">instanceof</span> Imm;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lhsImm</span> <span class="operator">=</span> ((Imm) lhs).getImmValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rhsImm</span> <span class="operator">=</span> ((Imm) rhs).getImmValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (instrType) &#123;</span><br><span class="line">            <span class="keyword">case</span> ADD -&gt; res = lhsImm + rhsImm;</span><br><span class="line">            <span class="keyword">case</span> SUB -&gt; res = lhsImm - rhsImm;</span><br><span class="line">            <span class="comment">/* case 其余种类 -&gt; */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 插入 mips 指令 */</span></span><br><span class="line">        MipsCenter.getInstance().pushInstr(<span class="built_in">this</span>.toString(), <span class="keyword">new</span> <span class="title class_">PseudoInstruction</span>(LI, (Register) rd, <span class="keyword">new</span> <span class="title class_">Imm</span>(res)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><p>本编译器未进行代码优化，本部分无相关内容</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/p/a137a2e9.html">https://cookedbear.github.io/p/a137a2e9.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/Compile-Principle/">Compile Principle</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/feaaa974.html" title="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》"><img class="cover" src="https://cdn.cloudflare.steamstatic.com/steam/apps/2510890/header_schinese.jpg?t=1708421482" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》</div></div></a></div><div class="next-post pull-right"><a href="/p/9291ce54.html" title="编译技术实验课程感想"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">编译技术实验课程感想</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/9291ce54.html" title="编译技术实验课程感想"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-19</div><div class="title">编译技术实验课程感想</div></div></a></div><div><a href="/p/373cf855.html" title="编译课设编译器优化文档"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-12-15</div><div class="title">编译课设编译器优化文档</div></div></a></div><div><a href="/p/942e82b.html" title="BUAA-CompilePrincipal-Chapter4"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-10-10</div><div class="title">BUAA-CompilePrincipal-Chapter4</div></div></a></div><div><a href="/p/97267d88.html" title="BUAA-CompilePrincipal-Chapter3"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-24</div><div class="title">BUAA-CompilePrincipal-Chapter3</div></div></a></div><div><a href="/p/79281ca4.html" title="BUAA-CompilePrincipal-Chapter2"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-19</div><div class="title">BUAA-CompilePrincipal-Chapter2</div></div></a></div><div><a href="/p/43299.html" title="BUAA-CompilePrincipal-Chapter1"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112117797.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-04</div><div class="title">BUAA-CompilePrincipal-Chapter1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3"><span class="toc-number">1.</span> <span class="toc-text">编译器设计文档</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E8%A6%81%E6%B1%82"><span class="toc-number">2.</span> <span class="toc-text">文档要求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E7%BC%96%E8%AF%91%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">参考编译器介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">编译器总体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">总体结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87"><span class="toc-number">4.2.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.</span> <span class="toc-text">接口设计</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.</span> <span class="toc-text">工具类设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-1"><span class="toc-number">5.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#utils-Calculator"><span class="toc-number">5.2.1.</span> <span class="toc-text">utils&#x2F;Calculator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utils-Logger"><span class="toc-number">5.2.2.</span> <span class="toc-text">utils&#x2F;Logger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#utils"><span class="toc-number">5.2.3.</span> <span class="toc-text">utils&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exception"><span class="toc-number">5.2.4.</span> <span class="toc-text">exception&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler"><span class="toc-number">5.2.5.</span> <span class="toc-text">Compiler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">6.</span> <span class="toc-text">词法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-2"><span class="toc-number">6.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">6.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-TokenAnalyzer"><span class="toc-number">6.2.1.</span> <span class="toc-text">frontend&#x2F;TokenAnalyzer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-token"><span class="toc-number">6.2.2.</span> <span class="toc-text">frontend&#x2F;token&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-1"><span class="toc-number">6.2.3.</span> <span class="toc-text">Compiler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.</span> <span class="toc-text">语法分析设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-3"><span class="toc-number">7.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">7.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-NodeParser"><span class="toc-number">7.2.1.</span> <span class="toc-text">frontend&#x2F;NodeParser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-ast"><span class="toc-number">7.2.2.</span> <span class="toc-text">frontend&#x2F;ast&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-2"><span class="toc-number">7.2.3.</span> <span class="toc-text">Compiler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">错误处理设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-4"><span class="toc-number">8.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">8.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-ErrorChecker"><span class="toc-number">8.2.1.</span> <span class="toc-text">frontend&#x2F;ErrorChecker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-shortSymbol"><span class="toc-number">8.2.2.</span> <span class="toc-text">frontend&#x2F;shortSymbol&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compiler-3"><span class="toc-number">8.2.3.</span> <span class="toc-text">Compiler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.</span> <span class="toc-text">中间代码生成设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-5"><span class="toc-number">9.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">9.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-LLCenter"><span class="toc-number">9.2.1.</span> <span class="toc-text">llvm&#x2F;LLCenter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-Vistor"><span class="toc-number">9.2.2.</span> <span class="toc-text">llvm&#x2F;Vistor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-identifier"><span class="toc-number">9.2.3.</span> <span class="toc-text">llvm&#x2F;identifier&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-symbol"><span class="toc-number">9.2.4.</span> <span class="toc-text">llvm&#x2F;symbol&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-type"><span class="toc-number">9.2.5.</span> <span class="toc-text">llvm&#x2F;type&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-value"><span class="toc-number">9.2.6.</span> <span class="toc-text">llvm&#x2F;value&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#frontend-ast-1"><span class="toc-number">9.2.7.</span> <span class="toc-text">frontend&#x2F;ast&#x2F;*</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90"><span class="toc-number">10.</span> <span class="toc-text">目标代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-6"><span class="toc-number">10.1.</span> <span class="toc-text">文件组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">10.2.</span> <span class="toc-text">具体设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mips-MipsCenter"><span class="toc-number">10.2.1.</span> <span class="toc-text">mips&#x2F;MipsCenter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mips-RegisterFile"><span class="toc-number">10.2.2.</span> <span class="toc-text">mips&#x2F;RegisterFile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mips-operands"><span class="toc-number">10.2.3.</span> <span class="toc-text">mips&#x2F;operands&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mips-instr"><span class="toc-number">10.2.4.</span> <span class="toc-text">mips&#x2F;instr&#x2F;*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#llvm-value-instruction"><span class="toc-number">10.2.5.</span> <span class="toc-text">llvm&#x2F;value&#x2F;instruction&#x2F;*</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="toc-number">11.</span> <span class="toc-text">代码优化</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/204601f4.html" title="BUAA-FPGA多核并行计算-Exp2-2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-FPGA多核并行计算-Exp2-2"/></a><div class="content"><a class="title" href="/p/204601f4.html" title="BUAA-FPGA多核并行计算-Exp2-2">BUAA-FPGA多核并行计算-Exp2-2</a><time datetime="2024-03-20T15:24:39.000Z" title="发表于 2024-03-20 23:24:39">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/74b98825.html" title="BUAA-X86汇编程序设计-Exp1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-X86汇编程序设计-Exp1"/></a><div class="content"><a class="title" href="/p/74b98825.html" title="BUAA-X86汇编程序设计-Exp1">BUAA-X86汇编程序设计-Exp1</a><time datetime="2024-03-20T06:11:24.000Z" title="发表于 2024-03-20 14:11:24">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task3"/></a><div class="content"><a class="title" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3">BUAA-SoftwareEngineering-Task3</a><time datetime="2024-03-16T06:41:29.000Z" title="发表于 2024-03-16 14:41:29">2024-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task2"/></a><div class="content"><a class="title" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2">BUAA-SoftwareEngineering-Task2</a><time datetime="2024-03-15T14:51:13.000Z" title="发表于 2024-03-15 22:51:13">2024-03-15</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>