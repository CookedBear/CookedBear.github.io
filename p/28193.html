<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-2023-Lab6-Challenge | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Lab6 挑战性任务任务目标在 Lab6 的后半程，我们在 MOS 上实现了一个基本的外部指令 Shell，其能够通过不断创建 sh.c 的进程，并调用其他文件来处理用户指令。在 Lab6 的挑战任务中，我们要在这基础上对 Shell 进行迭代开发，使其能完成更丰富的服务要求。 实现一行多命令 用 ; 分开同一行内的两条命令，表示依次执行前后两条命令。; 左右的命令都可以为空。  在 Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-2023-Lab6-Challenge">
<meta property="og:url" content="https://cookedbear.github.io/p/28193.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="Lab6 挑战性任务任务目标在 Lab6 的后半程，我们在 MOS 上实现了一个基本的外部指令 Shell，其能够通过不断创建 sh.c 的进程，并调用其他文件来处理用户指令。在 Lab6 的挑战任务中，我们要在这基础上对 Shell 进行迭代开发，使其能完成更丰富的服务要求。 实现一行多命令 用 ; 分开同一行内的两条命令，表示依次执行前后两条命令。; 左右的命令都可以为空。  在 Linux">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-06-10T04:18:04.000Z">
<meta property="article:modified_time" content="2023-09-14T07:12:40.324Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/p/28193.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-2023-Lab6-Challenge',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-14 15:12:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 小工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:80/"><span> bdpan</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:81/"><span> 25時生成器</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:9667/"><span> 程序员备忘录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 小工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:80/"><span> bdpan</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:81/"><span> 25時生成器</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://103.151.216.224:9667/"><span> 程序员备忘录</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-2023-Lab6-Challenge</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-10T04:18:04.000Z" title="发表于 2023-06-10 12:18:04">2023-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-14T07:12:40.324Z" title="更新于 2023-09-14 15:12:40">2023-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-2023-Lab6-Challenge"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Lab6-挑战性任务"><a href="#Lab6-挑战性任务" class="headerlink" title="Lab6 挑战性任务"></a>Lab6 挑战性任务</h1><h1 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h1><p>在 Lab6 的后半程，我们在 MOS 上实现了一个基本的外部指令 Shell，其能够通过不断创建 <code>sh.c</code> 的进程，并调用其他文件来处理用户指令。在 Lab6 的挑战任务中，我们要在这基础上对 Shell 进行迭代开发，使其能完成更丰富的服务要求。</p>
<h1 id="实现一行多命令"><a href="#实现一行多命令" class="headerlink" title="实现一行多命令"></a>实现一行多命令</h1><blockquote>
<p>用 <code>;</code> 分开同一行内的两条命令，表示<strong>依次</strong>执行前后两条命令。<code>;</code> 左右的命令都可以为空。</p>
</blockquote>
<p>在 Linux 的控制台中也支持这样的指令，例如在控制台输入如下指令会有对应的现象：</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029503.png" alt="image-20230607102927426"></p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306071029406.png" alt="image-20230607102937379"></p>
<p>可以看到先实现了 <code>clear</code> 操作，后进行了 <code>echo</code> 操作。</p>
<p>我们要求，用 <code>;</code> 隔开的两条指令必须有执行的先后顺序，即<strong>先执行左侧指令，后执行右侧指令</strong>。利用 <code>gettoken</code> 中自支持的 <code>;</code> 在 <code>parsecmd</code> 中新添加判断分支即可实现对 <code>;</code> 的识别。</p>
<p>由于执行两条指令，并保证指令执行的先后顺序，则需要先 <code>fork</code> 进程并执行左侧指令，使用 <code>wait</code> 等待其执行完后再继续解析右侧指令（重复 <code>parsecmd</code> 即可）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">parsecmd</span><span class="params">(<span class="type">char</span> **argv, <span class="type">int</span> *rightpipe)</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">		<span class="type">int</span> c = gettoken(<span class="number">0</span>, &amp;t);</span><br><span class="line">		<span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> ((*rightpipe = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    debugf(<span class="string">&quot;parsed &#x27;;&#x27;, created %x\n&quot;</span>, *rightpipe);</span><br><span class="line">                    wait(*rightpipe);</span><br><span class="line"></span><br><span class="line">                    close(<span class="number">0</span>);close(<span class="number">1</span>);</span><br><span class="line">                    dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<ul>
<li>upd 23.6.16：这里需要处理重定向的问题，以防左侧指令修改了输出 fd ，但右侧指令的 fd 不仅没有恢复为控制台，修改的 fd 还被左侧指令关了的情况。所以需要调 <code>opencons</code> 把控制台重新开开，并且 <code>dup</code> 给两个 fd。</li>
</ul>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>为了体现 shell 的两条指令是分开执行的，这里采用不会实时结束的 <code>cat.b</code> 作为左端指令.</p>
<p>当运行 <code>cat.b</code> 并输入 <code>Ctrl + D</code> 时，应该继续右侧指令的解析与执行。现试输入 <code>cat.b ; ls.b</code> 和不包含单侧指令的数据测试功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat.b ; ls.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3004       // 识别到 <span class="string">&#x27;;&#x27;</span>，并创建新 Shell 3004</span><br><span class="line">llaabb66CChhaalllleennggee     // cat.b 执行内容，使用 Ctrl + D 结束</span><br><span class="line">[00003805] destroying 00003805 // cat.b 执行结束，终止其进程 3805</span><br><span class="line">[00003805] free <span class="built_in">env</span> 00003805</span><br><span class="line">i am killed ... </span><br><span class="line">[00003004] destroying 00003004 // 子 Shell 执行完毕，终止其进程 3004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b // ls.b 执行内容</span><br><span class="line">[00004004] destroying 00004004 // ls.b 执行结束，终止其进程 4004</span><br><span class="line">[00004004] free <span class="built_in">env</span> 00004004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803 // 原 Shell 执行完毕，终止其进程 2803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ... </span><br><span class="line">$ cat.b;</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 5004</span><br><span class="line">ssssssssss</span><br><span class="line">[00005805] destroying 00005805</span><br><span class="line">[00005805] free <span class="built_in">env</span> 00005805</span><br><span class="line">i am killed ... </span><br><span class="line">[00005004] destroying 00005004</span><br><span class="line">[00005004] free <span class="built_in">env</span> 00005004</span><br><span class="line">i am killed ... </span><br><span class="line">[00004803] destroying 00004803 // 原有 Shell 无命令处理，直接终止进程 4803</span><br><span class="line">[00004803] free <span class="built_in">env</span> 00004803</span><br><span class="line">i am killed ... </span><br><span class="line"></span><br><span class="line">$ ;cat.b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 6804</span><br><span class="line">[00006804] destroying 00006804 // 子 Shell 无命令处理，直接终止进程 6804</span><br><span class="line">[00006804] free <span class="built_in">env</span> 00006804</span><br><span class="line">i am killed ... </span><br><span class="line">aaaaaa</span><br><span class="line">[00007004] destroying 00007004</span><br><span class="line">[00007004] free <span class="built_in">env</span> 00007004</span><br><span class="line">i am killed ... </span><br><span class="line">[00006003] destroying 00006003</span><br><span class="line">[00006003] free <span class="built_in">env</span> 00006003</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure>

<p>测试中 Shell 均能正常回显，可认为功能实现。</p>
<h1 id="实现后台任务"><a href="#实现后台任务" class="headerlink" title="实现后台任务"></a>实现后台任务</h1><blockquote>
<p>用 <code>&amp;</code> 分开同一行内的两条命令，表示<strong>同时</strong>执行前后两条命令。<code>&amp;</code> 左侧的命令应被置于后台执行，Shell 只等待 <code>&amp;</code> 右侧的命令执行完毕，然后继续执行后续语句，此时用户可以输入新的命令，并且可能同时观察到后台任务的输出。</p>
<p><strong>左侧命令不可为空</strong>。</p>
</blockquote>
<p>与 <code>;</code> 类似，<code>&amp;</code> 也要求实现两条指令的运行，但是要求其同时运行，只等待右侧指令。处理时同样要修改 <code>parsecmd</code> 的 <code>switch</code>，在这里要额外注意不要用 <code>rightpipe</code> 承载 <code>fork</code> 的返回值了。因为在 <code>runcmd</code> 中需要等待 <code>rightpipe</code> 执行结束才能完成，而 Shell 应该只等待右侧命令的执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;&amp;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> argc; <span class="comment">// parse end</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dup(opencons(), <span class="number">1</span>);dup(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            debugf(<span class="string">&quot;parsed &#x27;&amp;&#x27;, created %x\n&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> parsecmd(argv, rightpipe);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">			<span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">				debugf(<span class="string">&quot;syntax error: &lt; not followed by word\n&quot;</span>);</span><br><span class="line">				<span class="built_in">exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Open &#x27;t&#x27; for reading, dup it onto fd 0, and then close the original fd.</span></span><br><span class="line">			<span class="comment">/* Exercise 6.5: Your code here. (1/3) */</span></span><br><span class="line">			<span class="keyword">if</span> ((r = open(t, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				user_panic(<span class="string">&quot;redirction_1: open file in shell failed!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			fd = r;</span><br><span class="line">			dup(fd, <span class="number">0</span>);</span><br><span class="line">			close(fd);</span><br></pre></td></tr></table></figure>

<p>不知道怎么测试合适，就先不测了（</p>
<h1 id="实现引号支持"><a href="#实现引号支持" class="headerlink" title="实现引号支持"></a>实现引号支持</h1><blockquote>
<p>实现引号支持后，shell 可以处理如： <code>echo.b &quot;ls.b | cat.b&quot;</code> 这样的命令。即 shell 在解析时，会将双引号内的内容看作单个字符串，将 <code>ls.b | cat.b</code> 作为一个参数传递给 <code>echo.b</code></p>
</blockquote>
<p>实质上我们要把引号中的这些内容当作一个 <code>w</code> 类型处理，所以与其修改 <code>parsecmd</code> 的逻辑，不如直接从 <code>_gettoken</code> 入手，直接把引号处理成一个内容再返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; _gettoken</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*s == <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">		debugf(<span class="string">&quot;parsed &#x27;\&quot;&#x27;: begin\n&quot;</span>);</span><br><span class="line">		s++;</span><br><span class="line">		*p1 = s;</span><br><span class="line">		debugf(<span class="string">&quot;parsed: &quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (*s &amp;&amp; *(s++) != <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">			debugf(<span class="string">&quot;%c&quot;</span>, *(s - <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		*(s - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">		*p2 = s;</span><br><span class="line">		debugf(<span class="string">&quot;\nparsed &#x27;\&quot;&#x27;: end\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>整体实现相对简单，可以参照前后的解析方式，在面向对象第一单元的解析器也是一个道理（划</p>
<p>需要注意的就是 <code>p1</code> 和 <code>p2</code> 两个指针的定位， <code>p1</code> 应该指向 token 的起始字符，而 <code>p2</code> 应该指向 token 结束后的下一个字符；还有就是引号这个符号是要去掉的，也不要忘记用 0 将引号内的部分截断。</p>
<h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试主要看能否把引号内包含的 <code>SYMBOL</code> 正确解析为字符即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b <span class="string">&quot;sh.b | cat.b&quot;</span></span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: begin</span><br><span class="line">parsed: sh.b | cat.b</span><br><span class="line">parsed <span class="string">&#x27;&quot;&#x27;</span>: end</span><br><span class="line">sh.b | cat.b</span><br><span class="line">[00003004] destroying 00003004</span><br><span class="line">[00003004] free <span class="built_in">env</span> 00003004</span><br><span class="line">i am killed ... </span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure>



<h1 id="实现键入命令时任意位置的修改"><a href="#实现键入命令时任意位置的修改" class="headerlink" title="实现键入命令时任意位置的修改"></a>实现键入命令时任意位置的修改</h1><blockquote>
<p>现有的 shell 不支持在输入命令时移动光标。你需要实现：键入命令时，可以使用 Left 和 Right 移动光标位置，并可以在当前光标位置进行字符的增加与删除。要求每次在不同位置键入后，可以完整回显修改后的命令，并且键入回车后可以正常运行修改后的命令。</p>
</blockquote>
<p>在 MOS 的 Shell 中，我们设计了 <code>readline</code> 函数处理指令的输入，它实际上利用了一个控制台，并从中逐个读取字符，从而解析读入的字符串。设计的核心，读入实际上一次只向目标缓冲区 <code>buf</code> 中读取一个字符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(<span class="number">0</span>, buf + i, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>



<p>因为 <code>readline</code> 会直接向表示指令的 <code>buf</code> 中直接写入内容，当我们想要删除时可能会稍显麻烦，于是我们采用一个临时的 <code>char</code> 保存每次 <code>read</code> 获得的字符，并根据其值判断下一步该如何处理。由于在判断应该如何回显时需要注意光标的位置，所以我们用一个变量 <code>i</code> 代表光标所在下标，用变量 <code>len</code> 代表已经读入 <code>buf</code> 的总长度。在此基础上修改 <code>readline</code> 函数使其支持原生功能应该不是难事，不再赘述。</p>
<p>首先我们来处理<strong>键入光标时的左右移动</strong>。</p>
<p>在终端中，ANSI 标准声明左右方向键分别为 <code>\033[D</code> 和 <code>\033[C</code>，也就是说，在向控制台输入 “←” 时，实际上会<strong>解析成三个字符</strong>，即 <code>\033</code> 、<code>[</code>、 <code>D</code> 。那么我们就对暂时读入的字符（称为 <code>temp</code>）进行判断，如果是 <code>\033</code>，就进入方向键的判断，连续获取到左、右键代表的三个字符后，才能令光标变量做出对应的修改。</p>
<p>还有一点需要注意：光标在 0 字符时的 ← 与 光标在末端字符的 → 需要考虑其处理方式，首先不能修改光标变量的值了，否则会造成越界；其次可以让控制台显示的光标停在原地，这样就不会跑到左边的 <code>$</code> 字符那里了（</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123;          <span class="comment">// get input ←</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;            <span class="comment">// have space for cursor to move left</span></span><br><span class="line">                i -= <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[C&quot;</span>);   <span class="comment">// print a reverse arrow to pull back the cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;  <span class="comment">// get input →</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; len) &#123;         <span class="comment">// have space for cursor to move right</span></span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[D&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<p>随后处理移动后的插入与删除。实际上我们实现的核心在这里就变成了字符串的操作，还有就是如何在终端上覆盖旧字符串，显示正确的新字符串。</p>
<p>注意到， <code>BackSpace</code> 键的 ASCII 码为 127 （<code>0x7f</code>），而在原程序的循环中已经为我们判断了 <code>buf[i] == 0x7f</code> 的分支判断，我们需要先删掉它然后新开一个 <code>case</code> （</p>
<p>类似的，<code>Delete</code> 键在读入时和 <code>~</code> 键的 ASCII 相同，所以也要做响应的处理，注意退格位置不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x7f</span>:</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;                   <span class="comment">// cursor at left bottom, ignore backspace</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = (--i); j &lt;= len - <span class="number">1</span>; j++) &#123; <span class="comment">// move chars already in buf</span></span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;                          <span class="comment">// cut the last char</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, (i + <span class="number">1</span>), buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;~&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (i == len) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= len - <span class="number">1</span>; j++) &#123;</span><br><span class="line">        buf[j] = buf[j + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    buf[--len] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD%s \033[%dD&quot;</span>, i, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s \033[%dD&quot;</span>, buf, (len - i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>最后的 <code>printf</code> 用处是覆盖原有的字符串，再把新的字符串打印上去，打印后再控制光标的位置。这个操作可以分成三部分：</p>
<ul>
<li><code>\033[%dD</code>：终端的光标向左移动 <code>i + 1</code> 个字符</li>
<li><code>%s&lt;space&gt;</code>：把新字符串从光标所在处打印出来，<strong>追加一个空格</strong>（因为删除后字符串变短，需要覆盖掉多出来的一个字符）</li>
<li><code>\033[%dD</code>：终端的光标向左移动 <code>len - i + 1</code> 个字符</li>
</ul>
<p>至于为什么移动的字符是这些值，可以拿笔试一试，主要还是为了保证光标的位置不发生改变</p>
<h2 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h2><p>测试过程中发现如果网络不太稳定，就会输出 <code>[D</code> 之类的字符，不太理解原因，初步推断可能是因为传输字符速度慢，被解析成了分开的三个字符进行输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ha2Dhal3Dha[2Dh[1Djhalt</span><br><span class="line">spawn jhalt: -10</span><br><span class="line">[00002803] destroying 00002803</span><br><span class="line">[00002803] free <span class="built_in">env</span> 00002803</span><br><span class="line">i am killed ...</span><br></pre></td></tr></table></figure>





<h1 id="实现程序名称中-b-的省略"><a href="#实现程序名称中-b-的省略" class="headerlink" title="实现程序名称中 .b 的省略"></a>实现程序名称中 <code>.b</code> 的省略</h1><blockquote>
<p>目前的用户程序被烧录到文件系统中后，其可执行文件以 <code>.b</code> 为后缀，为 shell 中命令的输入带来了不便。你需要修改现有的实现，以允许命令中的程序名称省略 <code>.b</code> 后缀，例如当用户指定的程序路径不存在时，尝试在路径后追加 <code>.b</code> 再打开。</p>
</blockquote>
<p>比较简单的一个小功能。</p>
<p>在 Shell 中具体运行外部命令的原理是创建一个子进程，加载命令对应的 ELF 文件，传递相应参数，然后 Shell 等待子进程上加载的程序运行结束后再循环执行。在创建子进程时，我们用到的是在 <code>runcmd</code> 中使用的 <code>spawn</code>，其参数为 <code>argv[0]</code>。我们只需要在打开 <code>argv[0]</code> 失败后再尝试打开追加 <code>.b</code> 后的 <code>argv[0]</code> 即可。如果仍然无法打开，说明指令名错误。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> child;</span><br><span class="line"><span class="keyword">if</span> ((child = spawn(argv[<span class="number">0</span>], argv)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">strcpy</span>(name, (<span class="type">const</span> <span class="type">char</span> *) argv[<span class="number">0</span>]);</span><br><span class="line">    name[len] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    name[len + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// add &#x27;.b&#x27; to old filename</span></span><br><span class="line">    child = spawn(name, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h2><p>尝试省略文件中的 <code>.b</code> 后进行调用，效果如下（已省略进程销毁输出）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ echo.b aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">echo</span> aaa</span><br><span class="line">aaa</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">aaa.txt testarg.b cat.b pingpong.b testbss.b newmotd testpiperace.b testpipe.b motd init.b num.b lorem testfdsharing.b testshell.sh script ls.b echo.b sh.b halt.b testptelibrary.b </span><br></pre></td></tr></table></figure>



<h1 id="实现更丰富的命令"><a href="#实现更丰富的命令" class="headerlink" title="实现更丰富的命令"></a>实现更丰富的命令</h1><blockquote>
<p>参考实验环境中的 Linux 命令 <code>tree</code>、<code>mkdir</code>、<code>touch</code> 来实现这三个命令，请尽可能地实现其完整的功能。</p>
</blockquote>
<h2 id="tree-命令"><a href="#tree-命令" class="headerlink" title="tree 命令"></a><code>tree</code> 命令</h2><p><code>tree</code> 命令，用于输出指定路径的文件树，使用字符码进行树状表示的生成。</p>
<p>本次实现的 <code>tree</code> 命令包括一个参数的实现：</p>
<blockquote>
<p><code>-d</code>：只输出目录文件，省略非目录的输出</p>
</blockquote>
<p>输出指定目录的文件树，可以分成以下几部分：</p>
<ul>
<li>打开指定目录的文件控制块</li>
<li>遍历目录中的每个文件，并进行输出</li>
<li>递归地对每个<strong>目录</strong>重复第二步，直至不存在子目录</li>
</ul>
<p>在这里需要注意输出的形式，由于需要保持缩进，于是我们在递归的过程中需要保留文件的深度；又由于目录中最后一个文件需要输出 <code>└──</code> 而不是 <code>├──</code> ，所以需要判断当前输出的文件是不是目录中的最后一个文件。同时需要注意输出缩进时的输出格式，如果不是本目录最后一个文件，中途的文件夹也应该输出 <code>│</code>，否则会出现以下的状况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">├── testa</span><br><span class="line">    ├── testb</span><br><span class="line">        └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line">└── testb</span><br></pre></td></tr></table></figure>

<p>很显然 <code>testa</code> 文件夹中输出时没有输出最开头的 <code>│</code>，应该判断是不是最后一个文件，并且补上</p>
<p>一个更复杂的情况如下，不过这次的输出是正确的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testa $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">│   └── a</span><br><span class="line">├── b</span><br><span class="line">│   ├── a</span><br><span class="line">│   ├── b</span><br><span class="line">│   │   └── c.c</span><br><span class="line">│   └── c.c</span><br><span class="line">└── c</span><br><span class="line">    ├── c.c</span><br><span class="line">    └── a</span><br><span class="line">        └── c.c</span><br></pre></td></tr></table></figure>

<ul>
<li>注意 a b 两文件夹下的内容输出时，必须在第一个字符输出 <code>│</code>，而 c 文件夹下内容则相反</li>
<li>内层文件夹也要递归地遵守这个规则</li>
</ul>
<p>输出使用到的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printFile</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> depth, <span class="type">int</span> pos, <span class="type">int</span> isDir)</span> &#123;</span><br><span class="line">    <span class="comment">// 输出预留的缩进</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> ; i &lt; depth; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (poss[i] == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;│   &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pos = 1 即最后一个文件</span></span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;├── &quot;</span>); &#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;└── &quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDir == <span class="number">1</span>) &#123;      <span class="comment">// 目录文件会输出为蓝色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[0;34m%s\033[0m\n&quot;</span>, name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfsFile</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fdnum, size, va, j, len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fdnum = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;open %s: %d&quot;</span>, path, fdnum); &#125;</span><br><span class="line">    fd = (<span class="keyword">struct</span> Fd *) num2fd(fdnum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="keyword">struct</span> Filefd *) fd)-&gt;f_file.f_type != FTYPE_DIR) &#123;</span><br><span class="line">        fileCount++; <span class="comment">// 对文件计数，并返回（不存在子目录）</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dircCount++; <span class="comment">// 对目录计数，准备输出其内的所有文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = ((<span class="keyword">struct</span> Filefd *)fd)-&gt;f_file.f_size;</span><br><span class="line">    va = (<span class="type">int</span>) fd2data(fd);</span><br><span class="line">    <span class="comment">// 遍历目录中的每个文件（文件控制块）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += BY2FILE) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> File *) (va + i);</span><br><span class="line">        <span class="keyword">if</span> (file-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得完整的路径名，为递归调用预留</span></span><br><span class="line">        <span class="type">char</span> fullPath[MAXPATHLEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">strcpy</span>(fullPath, path);</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath) + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        fullPath[<span class="built_in">strlen</span>(fullPath)] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        len = <span class="built_in">strlen</span>(fullPath);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(file-&gt;f_name); j++) &#123;</span><br><span class="line">            fullPath[len + j] = file-&gt;f_name[j];</span><br><span class="line">        &#125;</span><br><span class="line">        fullPath[len + j] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断是否达到目录末尾，控制输出中的 &#x27;pos&#x27; 变量</span></span><br><span class="line">        <span class="type">int</span> pos = (i == size || (file + <span class="number">1</span>)-&gt;f_name[<span class="number">0</span>] == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (directory != <span class="number">1</span> || file-&gt;f_type == FTYPE_DIR) &#123;</span><br><span class="line">            poss[depth] = pos; <span class="comment">// 把当前层是否为最后一个文件的状态保存，输出时使用</span></span><br><span class="line">            printFile(file-&gt;f_name, depth, pos, (file-&gt;f_type == FTYPE_DIR));</span><br><span class="line">        &#125;</span><br><span class="line">        dfsFile(fullPath, depth + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">// printf(&quot;%s\n&quot;, fullPath);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意的是判断到达目录末尾的方式，一个是遍历到了目录的最后一个控制块，或者是下一个控制块<strong>名称为空</strong>（名称为空意味着文件不存在）</li>
</ul>
<p>顶层的调用函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tree</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">st</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断输入文件类型</span></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(path, &amp;st)) &lt; <span class="number">0</span>) &#123; user_panic(<span class="string">&quot;stat %s: %d&quot;</span>, path, r); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123; user_panic(<span class="string">&quot;%s is not a directory!&quot;</span>, path); &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 开始递归</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">    dfsFile(path, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后需要对输出进行计数</span></span><br><span class="line">    <span class="keyword">if</span> (directory == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories\n&quot;</span>, dircCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n%d directories, %d files\n&quot;</span>, dircCount, fileCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后文件的 <code>main</code> 函数可以封装如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    ARGBEGIN &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            directory = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            usage();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125; ARGEND</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(argc == <span class="number">0</span>)</span> &#123; <span class="comment">// 默认为根目录</span></span><br><span class="line">        tree(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         <span class="comment">// 选定指定目录</span></span><br><span class="line">        tree(argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成 <code>tree.c</code> 后，需要回到 <code>user</code> 目录中修改 <code>include.mk</code>，在 <code>USERAPP</code> 中把 <code>tree.b</code> 加进去，这样刚写完的文件就会编译并烧录进磁盘了，这样就可以使用了</p>
<h2 id="mkdir-amp-touch-命令"><a href="#mkdir-amp-touch-命令" class="headerlink" title="mkdir &amp; touch 命令"></a><code>mkdir</code> &amp; <code>touch</code> 命令</h2><p>其实两个命令实现的功能类似，唯一差异在创建文件后的文件类型 <code>f_type</code>：<code>mkdir</code> 需要 <code>FTYPE_DIR</code> ， <code>touch</code> 则是 <code>FTYPE_REG</code></p>
<p>内核中其实已经在 <code>fs/fs.c</code> 中预留好了创建文件的函数，但是没有向用户态提供接口。我们可以通过新增 <code>fsipc</code> 类型从而让文件服务函数调用这个接口，从而实现文件的创建</p>
<p>Lab5 Probe 中已经详细介绍过创建 <code>fsipc_*</code> 的过程了，这里就只写代码了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/fsreq.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FSREQ_CREATE 8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> req_path[MAXPATHLEN];</span><br><span class="line">    u_int f_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/fsipc.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, u_int f_type, <span class="keyword">struct</span> Fd* fd)</span> &#123;</span><br><span class="line">    u_int perm;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_create</span> *<span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">    req = (<span class="keyword">struct</span> Fsreq_create *)fsipcbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The path is too long.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *)req-&gt;req_path, path);</span><br><span class="line">    req-&gt;f_type = f_type;</span><br><span class="line">    <span class="keyword">return</span> fsipc(FSREQ_CREATE, req, fd, &amp;perm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (req) &#123;</span><br><span class="line">    <span class="keyword">case</span> FSREQ_CREATE:</span><br><span class="line">        serve_create(whom, (<span class="keyword">struct</span> Fsreq_create *)REQVA);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">serve_create</span><span class="params">(u_int envid, <span class="keyword">struct</span> Fsreq_create *rq)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(rq-&gt;req_path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ipc_send(envid, r, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// touch 和 mkdir 的区别仅限于此，所以只需要控制这个值的传递就能实现两个函数</span></span><br><span class="line">    f-&gt;f_type = rq-&gt;f_type;</span><br><span class="line">    ipc_send(envid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">file_create</span><span class="params">(<span class="type">char</span> *path, <span class="keyword">struct</span> File **pfile)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fsipc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *, u_int, <span class="keyword">struct</span> Fd *)</span>;</span><br></pre></td></tr></table></figure>

<p>以上便创建了创建文件的 <code>fsipc</code> 请求。接下来两个函数实际上是对这个请求的调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unimplemented open modes</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_CREAT 0x0100 <span class="comment">/* create if nonexistent */</span></span></span><br></pre></td></tr></table></figure>

<p>我们利用上面这个定义，对 <code>open</code> 函数做一些改动，使得当传入函数的 <code>omode</code> 包含 <code>O_CREAT</code> 时，就会触发文件创建的过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: Prepare the &#x27;fd&#x27; using &#x27;fsipc_open&#x27; in fsipc.c.</span></span><br><span class="line">    <span class="comment">/* Exercise 5.9: Your code here. (2/5) */</span></span><br><span class="line">    <span class="keyword">if</span> ((mode &amp; O_CREAT) == <span class="number">0</span>) &#123;   <span class="comment">// 如果不包含 O_CREAT 走正常的路线，不进行变动</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                       <span class="comment">// mkdir &amp; touch</span></span><br><span class="line">        mode &amp;= ~O_CREAT;</span><br><span class="line">        <span class="comment">// 如果打开文件失败就进行文件创建，反之则报错（已存在文件，不能再创建）</span></span><br><span class="line">        <span class="keyword">if</span> ((r = fsipc_open(path, mode, fd)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fsipc_create(path, mode, fd); <span class="comment">// mode = f_type</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// already exist.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当进入 <code>else</code> 分支时，此时的 <code>mode</code> 就不再是代表文件打开的方式了，它代表的是创建文件的类型，我们在这里不修改 <code>open</code> 的参数数量，而通过 <code>mode</code> 这个参数进行额外信息的传递</li>
</ul>
<p>最后顶层封装两个功能函数，加入相关的函数声明，并在对应的文件的 <code>main</code> 方法中调用即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/file.c (实现在哪里其实不影响)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkdir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">if</span> ((r = open(path, O_CREAT | FTYPE_DIR)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir: path %s already exist!\n&quot;</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;mkdir %s: %d\n&quot;</span>, path, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="修改-Shell-中重定向符的实现"><a href="#修改-Shell-中重定向符的实现" class="headerlink" title="修改 Shell 中重定向符的实现"></a>修改 Shell 中重定向符的实现</h2><p>在 Linux 的 Shell 中，我们可以通过重定向符 <code>&gt;</code> 将输出重定向到文件中，我们的 MOS 也可以实现类似的操作，但是不能创建新文件并进行输入，我们在这里对 <code>sh.c</code> 文件进行修改，使其能实现此功能</p>
<p>实现要点就是在原有要打开文件的地方进行判断，如果打开失败了就追加一句创建文件的函数</p>
<p>注意要<strong>再调用一次 <code>open</code></strong> 以传递新创建文件的文件管理符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> (gettoken(<span class="number">0</span>, &amp;t) != <span class="string">&#x27;w&#x27;</span>) &#123;</span><br><span class="line">        debugf(<span class="string">&quot;syntax error: &gt; not followed by word\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Open &#x27;t&#x27; for writing, dup it onto fd 1, and then close the original fd.</span></span><br><span class="line">    <span class="comment">/* Exercise 6.5: Your code here. (2/3) */</span></span><br><span class="line">    <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = touch(t)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;redirction_2: create file in shell failed!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = open(t, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                user_panic(<span class="string">&quot;redirction_2: open file in shell failed!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fd = r;</span><br><span class="line">    dup(fd, <span class="number">1</span>);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user_panic(&quot;&gt; redirection not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>



<h2 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h2><p>三个函数的功能可以相互验证：先通过 <code>touch</code>、<code>mkdir</code> 创建新的文件/目录，再调用 <code>tree</code> 对这些文件的存在和位置进行检查，如果 <code>tree</code> 能检查并正确输出，说明文件创建和文件树的功能都是正常的。下面的输出隐藏了进程销毁信息</p>
<ul>
<li>本处的功能测试已经完成了相对目录的实现，故输入使用了相对目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> b.c</span><br><span class="line">created file: b.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a.c</span><br><span class="line">created file: a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa</span><br><span class="line">created path: /testdir/testa</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">mkdir</span> testa/testb</span><br><span class="line">created path: /testdir/testa/testb</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/testb/a.c</span><br><span class="line">created file: testa/testb/a.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> testa/test.c</span><br><span class="line">created file: testa/test.c</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">├── a</span><br><span class="line">├── b.c</span><br><span class="line">├── a.c</span><br><span class="line">└── testa</span><br><span class="line">    ├── testb</span><br><span class="line">    │   └── a.c</span><br><span class="line">    └── test.c</span><br><span class="line"></span><br><span class="line">3 directories, 5 files</span><br></pre></td></tr></table></figure>



<h1 id="实现历史命令功能"><a href="#实现历史命令功能" class="headerlink" title="实现历史命令功能"></a>实现历史命令功能</h1><blockquote>
<p>在 Linux 的 shell 中我们输入的命令都会被保存起来，并可以通过 Up 和 Down 键回溯，这为我们的 shell 操作带来了极大的方便。在此项任务中，需要实现保存所有输入至 shell 的命令，并可以通过 <code>history.b</code> 命令输出所有的历史命令，以及通过上下键回溯命令并运行。</p>
</blockquote>
<p>实现这个功能的要点如下：</p>
<ul>
<li>首先需要在 <code>sh.c</code> 中调用 <code>touch</code> 函数生成 <code>.history</code> 文件</li>
<li>将每条解析的命令都输入进 <code>.history</code> 文件中，这里需要额外实现<strong>文件的追加写入</strong></li>
<li>在输入中实现对 Up/Down 键的识别，并回显对应的指令</li>
<li>实现 <code>history.c</code> 的 <code>history</code> 功能，读取 <code>.history</code> 文件，显示全部历史命令</li>
</ul>
<h2 id="history-文件的生成"><a href="#history-文件的生成" class="headerlink" title=".history 文件的生成"></a><code>.history</code> 文件的生成</h2><p>当我们在解析指令结束后，应该对指令进行保存，如果是第一次解析，则需要额外创建一个存放历史指令的 <code>.history</code> 文件。在这里我们使用一个变量 <code>int hisCount = 0</code> 表示已经处理过的历史指令数，当历史为空则进行文件的创建。</p>
<p>与光标的左右移动类似，我们需要一个表示当前指令所处行数的变量 <code>int curLine = 0</code>，用以指明当前输入显示的行数</p>
<h2 id="文件的追加输入模式-O-APPEND"><a href="#文件的追加输入模式-O-APPEND" class="headerlink" title="文件的追加输入模式 - O_APPEND"></a>文件的追加输入模式 - <code>O_APPEND</code></h2><p>在 MOS 系统中，我们只实现了从头打开文件，即 <code>f_offset = 0</code> 的打开方式，在这里为了便于我们对 <code>.history</code> 文件的输入，试实现文件的追加输入模式：<code>O_APPEND</code> 。</p>
<p>由于 <code>O_APPEND</code> 只是指定了文件打开时的偏移指针位置，原则上我们仍需要控制文件的打开方式。为了不遮盖原本的打开方式，可以把 <code>O_APPEND</code> 的控制位放大一点，以实现应有的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> O_APPEND 0X00002000 <span class="comment">/* open file and redirect cursor to the last char */</span></span></span><br></pre></td></tr></table></figure>

<p>设置好后，接下来需要修改 <code>open</code> 函数以识别 <code>O_APPEND</code>，并尝试在文件服务进程中的 <code>serve_open</code> 函数中实现对偏移指针的定位，这样我们就不需要再更改 <code>open</code> 函数的逻辑了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs/serv.c -&gt; serve_open</span></span><br><span class="line"></span><br><span class="line">	o-&gt;o_mode = rq-&gt;req_omode;</span><br><span class="line">	ff-&gt;f_fd.fd_omode = o-&gt;o_mode;</span><br><span class="line">	ff-&gt;f_fd.fd_dev_id = devfile.dev_id;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// add here for O_APPEND</span></span><br><span class="line">	<span class="keyword">if</span> (o-&gt;o_mode &amp; O_APPEND) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fff</span> =</span> (<span class="keyword">struct</span> Fd *) ff;</span><br><span class="line">		fff-&gt;fd_offset = f-&gt;f_size; <span class="comment">// redirect the file pointer</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>回到 <code>sh.c</code>，完成写入历史命令和回显的功能。为了便于快速找到对应的指令数，我们事先实现一个数组 <code>int hisBuf</code>，其内存放第 $i$ 条指令所占的字节数，便于我们在 <code>.history</code> 中快速找到指定的行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisCount, curLine;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> hisBuf[<span class="number">1024</span>];</span><br></pre></td></tr></table></figure>



<p>然后在 <code>sh.c</code> 内实现一个快速读取第 <code>target</code> 行指令的函数，将其存入 <code>code</code> 指向的空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readPast</span><span class="params">(<span class="type">int</span> target, <span class="type">char</span> *code)</span> &#123;</span><br><span class="line">	<span class="type">int</span> r, fd, spot = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> buff[<span class="number">10240</span>];</span><br><span class="line">	<span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G1&quot;</span>);<span class="keyword">return</span> fd; &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; target; i++) &#123;</span><br><span class="line">		spot += (hisBuf[i] + <span class="number">1</span>); <span class="comment">// + &#x27;\n&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = readn(fd, buff, spot)) != spot) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G2&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = readn(fd, code, hisBuf[target])) != hisBuf[target]) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G3&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line">	<span class="keyword">if</span> ((r = close(fd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G4&quot;</span>);<span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line">	code[hisBuf[target]] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先读取 0 ~ target - 1条指令，并丢弃，然后读取第 target 条指令，保存在传入的参数 <code>code</code> 内。读取前面指令时需要根据预设的 <code>hisBuf</code> 控制读取的字符数，需要注意每一条语句后面都存放一个 <code>\n</code> 用以区分，所以需要多读一个字符。</li>
</ul>
<h2 id="历史指令的写入"><a href="#历史指令的写入" class="headerlink" title="历史指令的写入"></a>历史指令的写入</h2><p>相对简单的一部分。</p>
<p>当 Shell 检测到 换行符时，便会判断指令输入的结束，从而开始解析，我们就从这里开始写入历史命令。</p>
<p>在 <code>readline</code> 函数的 <code>switch</code> 分支内，针对 <code>case &#39;\r&#39;</code> 与 <code>case &#39;\n&#39;</code> 需要做写入文件的操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">        buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="comment">// printf(&quot;hisCount: %d\n&quot;, hisCount);</span></span><br><span class="line">        <span class="keyword">if</span> (hisCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r = touch(<span class="string">&quot;/.history&quot;</span>)) != <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> hisFd;</span><br><span class="line">        <span class="keyword">if</span> ((hisFd = open(<span class="string">&quot;/.history&quot;</span>, O_APPEND | O_WRONLY)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, buf, len)) != len) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = write(hisFd, <span class="string">&quot;\n&quot;</span>, <span class="number">1</span>)) != <span class="number">1</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="keyword">if</span> ((r = close(hisFd)) &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(); &#125;</span><br><span class="line">        hisBuf[hisCount++] = len;</span><br><span class="line">        curLine = hisCount; </span><br><span class="line">		<span class="comment">// cannot &#x27;curLine++&#x27;, otherwise usable instrctions will be [0, curLine + 1]</span></span><br><span class="line">        <span class="built_in">memset</span>(curIn, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(curIn));</span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里要在每一条指令写入后追加一个和常规指令有区分的字符，为了方便这里就选了 <code>\n</code>，原因可以在 <code>history</code> 功能实现时再看。再注意写入时使用刚刚写好的（追加 + 只写）即可。</li>
<li>当按下回车时，不能简单地让 <code>curLine++</code> ，因为可能当前 <code>curLine</code> 并不在最底端，此时错误的自增操作会让 <code>curLine</code> 的值出错 </li>
</ul>
<h2 id="up-down-键的识别-amp-指令回显"><a href="#up-down-键的识别-amp-指令回显" class="headerlink" title="up/down 键的识别 &amp; 指令回显"></a>up/down 键的识别 &amp; 指令回显</h2><p>最后修改 <code>readline</code> 的逻辑，需要在键入方向键的分支处继续判断。同时为了能够恢复当前已经输入的字符，我们把已输入的字符也存入一个缓冲的字符数组 <code>char curIn</code> 内，在按下 down 键时视情况回显。</p>
<p>每次回显，都需要实时变动 <code>buf</code> 的内容，也包括显示的光标位置。因为我们可能会在此基础上修改 <code>buf</code>，或直接运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; readline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\033&#x27;</span>:</span><br><span class="line">    read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">        read(<span class="number">0</span>, &amp;temp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="string">&#x27;D&#x27;</span>) &#123; <span class="comment">// have space for left</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;C&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;A&#x27;</span>) &#123; <span class="comment">// up</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[B&quot;</span>);     <span class="comment">// 恢复光标位置</span></span><br><span class="line">            <span class="keyword">if</span> (curLine != <span class="number">0</span>) &#123;   <span class="comment">// 处在第一行时应忽略 up 的输入</span></span><br><span class="line">                buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (curLine == hisCount) &#123; <span class="comment">// 显示的是正在输入的字符</span></span><br><span class="line">                    <span class="built_in">strcpy</span>(curIn, buf);    <span class="comment">// 暂时保存在 curIn 中，暂时视作一条指令</span></span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 使用 &lt;space&gt; + 光标移动，清空当前行</span></span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">                <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 读入指定的历史指令并输出，重定位光标</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(--curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">                i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">                len = i; <span class="comment">// redirect cursor</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;B&#x27;</span>) &#123; <span class="comment">// 同理</span></span><br><span class="line">            buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, i); &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123; <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); &#125;</span><br><span class="line">            <span class="keyword">if</span> (len != <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;\033[%dD&quot;</span>, len); &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> + curLine &lt; hisCount) &#123;     <span class="comment">// 注意这里的判断</span></span><br><span class="line">                <span class="keyword">if</span> ((r = readPast(++curLine, buf)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">strcpy</span>(buf, curIn);</span><br><span class="line">                curLine = hisCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">            i = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            len = i;</span><br><span class="line">            <span class="comment">// redirect cursor</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这部分比较重要的就是边界情况的处理和写入后光标的定位。<ul>
<li>输入 up 键，需要把光标向下移动一行（固定，不要乱跑），使 <code>curLine--</code>，如果 <code>curLine == 0</code> （第一条指令）就不再响应</li>
<li>输入 down 键，光标不需移动，<code>curLine++</code>，如果 <code>curLine + 1 = hisCount</code> （即马上要从 <code>.history</code> 的最后一行换成最开始预存的缓冲输入时）需要特别处理；若 <code>curLine == hisCount</code> 则不再响应</li>
<li>无论输入 up/down 键，只要重新回显了字符，就需要借助 <code>printf(&quot;\033[A&quot;);</code> 等方法实现的光标移动和打印空格把当前行原本的内容清空后再输出</li>
</ul>
</li>
</ul>
<h2 id="history-b-功能的实现"><a href="#history-b-功能的实现" class="headerlink" title="history.b 功能的实现"></a><code>history.b</code> 功能的实现</h2><p>还是一样的，别忘了把 <code>history.b</code> 加入 <code>include.mk</code>，让程序进行编译并烧录磁盘</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/history.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">        usage();</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;history instruction:\n\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd, r, line = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">1</span>], print;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(<span class="string">&quot;/.history&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        user_panic(<span class="string">&quot;history: %d&quot;</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no history instruction.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    print = temp[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, line);</span><br><span class="line">    <span class="keyword">while</span> ((r = read(fd, &amp;temp, <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, print);</span><br><span class="line">        <span class="keyword">if</span> (print == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %4d : &quot;</span>, ++line);</span><br><span class="line">        &#125;</span><br><span class="line">        print = temp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\ntotal instruction: %d\nhistory finished.\n\n&quot;</span>, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是对文件的打开、读取、判断和输出。而判断是否为一条指令的标准就是 <code>\n</code>，这也就是在前面写入指令时要加入一个分隔符的理由。我们根据 <code>\n</code> 编排输出的方式，从而实现历史命令的输出。</p>
<h2 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="上下键指令回显"><a href="#上下键指令回显" class="headerlink" title="上下键指令回显"></a>上下键指令回显</h3><p>先在 Shell 中输入几条指令，随后输入半条还没有执行的指令，然后连续按上下键观察变化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ input halfway</span><br><span class="line">[2000] /testdir $ tree             // press ↑</span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a          // press ↑</span><br><span class="line">[2000] /testdir $ tree             // press ↓</span><br><span class="line">[2000] /testdir $ input halfway    // press ↓</span><br></pre></td></tr></table></figure>

<ul>
<li>并且可以随时修改回显的任意一条指令，并随时按下回车输出</li>
</ul>
<h3 id="history-指令功能"><a href="#history-指令功能" class="headerlink" title="history 指令功能"></a><code>history</code> 指令功能</h3><p>在上一测试的基础上直接输入 <code>history</code> 观察输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /testdir $ <span class="built_in">history</span></span><br><span class="line"><span class="built_in">history</span> instruction:</span><br><span class="line"></span><br><span class="line">    1 : <span class="built_in">mkdir</span> testdir</span><br><span class="line">    2 : <span class="built_in">cd</span> testdir</span><br><span class="line">    3 : <span class="built_in">touch</span> a</span><br><span class="line">    4 : tree</span><br><span class="line">    5 : input half|<span class="built_in">cut</span>|way</span><br><span class="line">    6 : <span class="built_in">history</span></span><br><span class="line"></span><br><span class="line">total instruction: 6</span><br><span class="line"><span class="built_in">history</span> finished.</span><br><span class="line"></span><br><span class="line">[00007804] destroying 00007804</span><br></pre></td></tr></table></figure>

<p>检测到 <code>.history</code> 文件的内容可以正常写入、读出，并且 <code>history</code> 指令功能也正常实现</p>
<h1 id="选做部分-2：支持相对路径"><a href="#选做部分-2：支持相对路径" class="headerlink" title="选做部分 2：支持相对路径"></a>选做部分 2：支持相对路径</h1><blockquote>
<p>MOS 中现有的文件系统操作并不支持相对路径，对于一切路径都从根目录开始查找，因此在 shell 命令中也需要用绝对路径指代文件，这为命令的描述带来了不便。</p>
<p>现在，我们需要在 MOS 中<strong>支持相对路径的输入与解析</strong>，并且当前工作路径的保存是进程级别的，也就是说不同进程的工作目录可能不同。</p>
</blockquote>
<p>首先我们要求：只有以 <code>/</code> 开头的目录才会被识别为绝对路径，此外的所有非 <code>/</code> 开头路径（包括 <code>./</code> ）都会被识别为相对路径并进行识别与处理。</p>
<p>需要完成的工作有以下几点：</p>
<ul>
<li>在内核态中为进程维护一个表示当前工作目录的字符数组 <code>char r_path</code></li>
<li>通过系统调用向用户态提供更改 <code>r_path</code> 的接口，实现用户调用函数 <code>chdir()</code> 和 <code>getcwd()</code></li>
<li>更改 <code>sys_exofork</code> 逻辑，使其能令子进程<strong>继承</strong>父进程的工作目录</li>
<li>修改 <code>sh.c</code> 实现<strong>内部命令</strong> <code>cd</code> 和<strong>外部命令</strong> <code>pwd</code></li>
<li>修改文件操作函数（Shell 已有命令能调用的只有 <code>open</code> 函数），识别并提供相对路径的功能支持</li>
<li>更改已实现的 Shell 命令对文件的操作</li>
<li>优化 Shell 输出界面</li>
</ul>
<h2 id="维护工作目录数组"><a href="#维护工作目录数组" class="headerlink" title="维护工作目录数组"></a>维护工作目录数组</h2><p>为了便于管理与复制，同时能够体现不同进程目录不同的特点，这里直接将字符数组放置在进程控制块中，当然在内核态中开一个大二维数组也是可行的，比修改进程控制块更安全。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/env.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">char</span> r_path[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在创建进程时，也需要在创建进程的函数中初始化进程的目录为 <code>/ </code> 根目录</p>
<h2 id="系统调用设置接口-amp-实现用户调用函数"><a href="#系统调用设置接口-amp-实现用户调用函数" class="headerlink" title="系统调用设置接口 &amp; 实现用户调用函数"></a>系统调用设置接口 &amp; 实现用户调用函数</h2><p>为了便于用户态<strong>获取/修改</strong>当前进程所处的工作目录，我们添加两个系统调用为用户态提供接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// include/syscall.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    SYS_get_rpath,</span><br><span class="line">    SYS_set_rpath,</span><br><span class="line">    MAX_SYSNO,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(newPath) &gt; <span class="number">1024</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(curenv-&gt;r_path, newPath);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dst == <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(dst, curenv-&gt;r_path);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *syscall_table[MAX_SYSNO] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    [SYS_get_rpath] = sys_get_rpath,</span><br><span class="line">    [SYS_set_rpath] = sys_set_rpath,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/syscall_lib.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_set_rpath, newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> msyscall(SYS_get_rpath, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// user/lib/file.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_set_rpath(newPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> syscall_get_rpath(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后在相应的头文件中添加声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/include/lib.h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_set_rpath</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">syscall_get_rpath</span><span class="params">(<span class="type">char</span> *dst)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">chdir</span><span class="params">(<span class="type">char</span> *newPath)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getcwd</span><span class="params">(<span class="type">char</span> *path)</span>;</span><br></pre></td></tr></table></figure>



<p>实现用户态函数后，可以直接新建 <code>pwd.c</code> 文件，直接调用 <code>getcwd</code> 函数输出当前路径</p>
<h2 id="工作目录传递"><a href="#工作目录传递" class="headerlink" title="工作目录传递"></a>工作目录传递</h2><p>现在在单个进程中，我们已经完成了工作目录的修改，现在需要在<strong>所有会出现创建进程的位置</strong>添加对父进程工作目录的复制工作。算过来也就只有 <code>env_alloc</code>、<code>fork</code>、<code>spawn</code> 三个函数会创建进程，而它们最终也都会调用 <code>sys_exofork</code> 作为进程创建的核心函数。所以直接修改 <code>sys_exofork</code> 来实现父子进程中的工作目录复制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// kern/syscall_all.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sys_exofork</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"></span><br><span class="line">	try(env_alloc(&amp;e, curenv-&gt;env_id));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">strcpy</span>(e-&gt;r_path, curenv-&gt;r_path); <span class="comment">// copy at here</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="实现内部命令-cd"><a href="#实现内部命令-cd" class="headerlink" title="实现内部命令 cd"></a>实现内部命令 <code>cd</code></h2><p>这里实现的 <code>cd</code> 指令需要作为<strong>内部指令</strong>，也就是执行后并不<strong>切换进程</strong>，而是继续处理。处理方法是在读入结束后、解析开始前的这一段空隙对输入指令做一次预处理，如果满足 <code>cd</code> 指令格式，就进行工作目录切换，切换后重新读入；反之则开始解析，准备调用外部命令。</p>
<p>要注意的是，Linux 中只输入 <code>cd</code> 相当于<strong>跳转至家目录</strong>，MOS 就直接跳根目录得了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parseCD(buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            user_panic(<span class="string">&quot;fork: %d&quot;</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">        runcmd(buf);</span><br><span class="line">        <span class="built_in">exit</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上面一段在 main 函数中先预先判断是否存在 <code>cd</code>，如果存在，则不应创建进程，而直接解析，反之就应该创建子进程并运行指令。</p>
<p><code>parseCD</code> 函数实现时需要注意：<code>cd</code> 并不一定出现在指令开头，也可能出现在 <code>ins1; cd</code> 的格式中，所以需要对 <code>;</code> 和 <code>&amp;</code> 进行特判。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sh.c -&gt; runcmd</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">&quot;cd&quot;</span>, argv[<span class="number">0</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="type">char</span> cur[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        cur[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *p = argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;.&#x27;</span>) &#123; p += <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line">        syscall_get_rpath(cur);</span><br><span class="line">        <span class="type">int</span> len1 = <span class="built_in">strlen</span>(cur);</span><br><span class="line">        <span class="type">int</span> len2 = <span class="built_in">strlen</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">1</span>) &#123; <span class="comment">// cur: &#x27;/&#x27;</span></span><br><span class="line">            <span class="built_in">strcpy</span>(cur + <span class="number">1</span>, p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;         <span class="comment">// cur: &#x27;/a&#x27;</span></span><br><span class="line">            cur[len1] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="built_in">strcpy</span>(cur + len1 + <span class="number">1</span>, p);</span><br><span class="line">            cur[len1 + <span class="number">1</span> + len2] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">			</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(cur, argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cur:%s\n&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((r = stat(cur, &amp;st)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;4&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">if</span> (!st.st_isdir) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s is not a directory\n&quot;</span>, cur);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;5&quot;</span>);<span class="built_in">exit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = chdir(cur)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;6&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这段函数的功能是获取 <code>cd</code> 后的绝对路径，并进行工作目录的切换；关键是输入的相对路径与工作路径之间的拼接。<code>cd</code> 大概可以分成以下几类， <code>if-else</code> 中的逻辑也是这么写的：</p>
<ul>
<li>输入路径为绝对路径（<code>/xxxx</code>、没有输入路径（默认为根目录 <code>/</code>））：不需要进行拼接，直接进行目录判断和跳转即可</li>
<li>输入路径为相对路径，形式上分两种（<code>./yyy</code> 、<code>zzz</code>）：根据形式不同，需要进行处理<ul>
<li>如果有 <code>./</code> 出现，需要先去掉，统一形式为 <code>zzz</code></li>
<li>获取工作目录，再进行字符串拼接，获取绝对目录</li>
</ul>
</li>
</ul>
<p>切换工作目录前要查看要跳转的路径是不是一个目录，若不是目录应不允许切换</p>
<h2 id="open-函数支持相对路径"><a href="#open-函数支持相对路径" class="headerlink" title="open 函数支持相对路径"></a><code>open</code> 函数支持相对路径</h2><p>我们已经实现的用户程序中，只有 <code>open</code> 会用到程序的路径名，并且 <code>ls</code>、<code>tree</code>、<code>mkdir</code>，甚至 <code>spawn</code> 都需要 <code>open</code> 函数支持，所以与其更改每个用户函数的接口，不如直接修改 <code>open</code> 函数逻辑，让文件系统支持输入相对路径。最后再在用户程序中做一些微调就能够正常使用了。</p>
<p>类似地， <code>open</code> 函数的输入路径也可能分为绝对路径和相对路径两种，这取决于用户的字符串输入。所以处理方式可以和上面 <code>cd</code> 的方式保持一致，直接 CV 都能用</p>
<h2 id="用户程序功能调整"><a href="#用户程序功能调整" class="headerlink" title="用户程序功能调整"></a>用户程序功能调整</h2><p>在已经实现好的用户程序中，大多数指令的默认情况都会以根目录为输入目录，如直接键入 <code>tree</code> 就会生成根目录文件树，现在我们就要把默认情况改为 <code>./</code> ，即输出当前工作目录的文件树</p>
<p>需要更改的文件有 <code>ls</code> 和 <code>tree</code></p>
<p>还有一个相对特殊的 <code>spawn</code>，它的默认打开路径就是只能从根目录开始，如果带上相对路径，那么在 <code>cd</code> 至其他路径后再输入外部命令，<code>spawn</code> 会先调用 <code>open</code>打开<strong>相对路径下的</strong>用户程序， Shell 就会因为 <code>spawn</code> 了错误的文件而无法运行。例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">cd</span> <span class="built_in">test</span></span><br><span class="line">$ <span class="built_in">ls</span> </span><br><span class="line">// 此刻 Shell 中在尝试调用工作目录下的 ls.b ，也即 /test/ls.b，显然这个文件是不存在的</span><br></pre></td></tr></table></figure>



<p>所以为了避免 <code>open</code> 将指令解析成相对路径文件，直接在最前面加一个 <code>/</code> 声明为绝对路径就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/lib/spawn.c -&gt; spawn</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> path[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (prog[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        path[<span class="number">0</span>] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(path + <span class="number">1</span>, prog);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(path, prog);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Shell-界面优化"><a href="#Shell-界面优化" class="headerlink" title="Shell 界面优化"></a>Shell 界面优化</h2><p>既然已经支持了工作路径的使用，所以不如在 Shell 的工作状态下输出当前的工作目录，更符合 Linux 的界面风格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user/sh.c -&gt; main</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (interactive) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = getcwd(curPath)) &lt; <span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;G&quot;</span>);<span class="built_in">exit</span>(); &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[%04x] %s $ &quot;</span>, syscall_getenvid(), curPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h2><h3 id="纯指令功能"><a href="#纯指令功能" class="headerlink" title="纯指令功能"></a>纯指令功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure>



<h3 id="一条多语句测试"><a href="#一条多语句测试" class="headerlink" title="一条多语句测试"></a>一条多语句测试</h3><p>省略销毁进程输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] /a $ <span class="built_in">mkdir</span> b ; <span class="built_in">cd</span> b</span><br><span class="line">parsed <span class="string">&#x27;;&#x27;</span>, created 3803</span><br><span class="line">created path: /a/b</span><br><span class="line">cur:/a/b</span><br><span class="line"></span><br><span class="line">[2000] /a/b $ halt</span><br><span class="line">halt at halt.c:4: halt mos!</span><br></pre></td></tr></table></figure>



<h3 id="spawn-amp-open-功能测试"><a href="#spawn-amp-open-功能测试" class="headerlink" title="spawn &amp; open 功能测试"></a>spawn &amp; open 功能测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2000] / $ <span class="built_in">mkdir</span> testdir</span><br><span class="line">created path: /testdir</span><br><span class="line"></span><br><span class="line">[2000] / $ <span class="built_in">cd</span> testdir</span><br><span class="line">cur:/testdir</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ <span class="built_in">touch</span> a</span><br><span class="line">created file: a</span><br><span class="line"></span><br><span class="line">[2000] /testdir $ tree</span><br><span class="line">./</span><br><span class="line">└── a</span><br><span class="line"></span><br><span class="line">1 directories, 1 files</span><br></pre></td></tr></table></figure>

<ul>
<li>此处的 <code>touch</code> 在相对目录中使用 <code>spawn</code> 创建，可以正常打开根目录的用户程序</li>
<li><code>tree</code> 指令内部在 <code>open</code> 中使用了相对路径 <code>./</code> ，也可以正常解析</li>
</ul>
<p>lab6 挑战性任务需求的功能到这里就全部实现力，是时候休息一把了（×</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/p/28193.html">https://cookedbear.github.io/p/28193.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/10387.html" title="从负开始的 Vue 学习 (1)"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306122322922.jpg?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">从负开始的 Vue 学习 (1)</div></div></a></div><div class="next-post pull-right"><a href="/p/13765.html" title="BUAA-OS-2023-Lab6-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112055861.jpg?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-2023-Lab6-Report</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/1727.html" title="BUAA-OS-TOP"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306132108192.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">BUAA-OS-TOP</div></div></a></div><div><a href="/p/13765.html" title="BUAA-OS-2023-Lab6-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112055861.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-04</div><div class="title">BUAA-OS-2023-Lab6-Report</div></div></a></div><div><a href="/p/2190.html" title="BUAA-OS-Theory-Chapter7"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter7</div></div></a></div><div><a href="/p/51279.html" title="BUAA-OS-Theory-Chapter6"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter6</div></div></a></div><div><a href="/p/51471.html" title="BUAA-OS-Theory-Chapter5"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter5</div></div></a></div><div><a href="/p/2510.html" title="BUAA-OS-Theory-Chapter4"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter4</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">67</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Lab6-%E6%8C%91%E6%88%98%E6%80%A7%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">Lab6 挑战性任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">2.</span> <span class="toc-text">任务目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E8%A1%8C%E5%A4%9A%E5%91%BD%E4%BB%A4"><span class="toc-number">3.</span> <span class="toc-text">实现一行多命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">实现后台任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%BC%95%E5%8F%B7%E6%94%AF%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">实现引号支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-1"><span class="toc-number">5.1.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%94%AE%E5%85%A5%E5%91%BD%E4%BB%A4%E6%97%B6%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="toc-number">6.</span> <span class="toc-text">实现键入命令时任意位置的修改</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-2"><span class="toc-number">6.1.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0%E4%B8%AD-b-%E7%9A%84%E7%9C%81%E7%95%A5"><span class="toc-number">7.</span> <span class="toc-text">实现程序名称中 .b 的省略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-3"><span class="toc-number">7.1.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E5%91%BD%E4%BB%A4"><span class="toc-number">8.</span> <span class="toc-text">实现更丰富的命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tree-%E5%91%BD%E4%BB%A4"><span class="toc-number">8.1.</span> <span class="toc-text">tree 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mkdir-amp-touch-%E5%91%BD%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">mkdir &amp; touch 命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9-Shell-%E4%B8%AD%E9%87%8D%E5%AE%9A%E5%90%91%E7%AC%A6%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.</span> <span class="toc-text">修改 Shell 中重定向符的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-4"><span class="toc-number">8.4.</span> <span class="toc-text">测试用例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%86%E5%8F%B2%E5%91%BD%E4%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">9.</span> <span class="toc-text">实现历史命令功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#history-%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E6%88%90"><span class="toc-number">9.1.</span> <span class="toc-text">.history 文件的生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E5%8A%A0%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F-O-APPEND"><span class="toc-number">9.2.</span> <span class="toc-text">文件的追加输入模式 - O_APPEND</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%8C%87%E4%BB%A4%E7%9A%84%E5%86%99%E5%85%A5"><span class="toc-number">9.3.</span> <span class="toc-text">历史指令的写入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#up-down-%E9%94%AE%E7%9A%84%E8%AF%86%E5%88%AB-amp-%E6%8C%87%E4%BB%A4%E5%9B%9E%E6%98%BE"><span class="toc-number">9.4.</span> <span class="toc-text">up&#x2F;down 键的识别 &amp; 指令回显</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#history-b-%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.5.</span> <span class="toc-text">history.b 功能的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-5"><span class="toc-number">9.6.</span> <span class="toc-text">测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E9%94%AE%E6%8C%87%E4%BB%A4%E5%9B%9E%E6%98%BE"><span class="toc-number">9.6.1.</span> <span class="toc-text">上下键指令回显</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E6%8C%87%E4%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">9.6.2.</span> <span class="toc-text">history 指令功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%89%E5%81%9A%E9%83%A8%E5%88%86-2%EF%BC%9A%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">10.</span> <span class="toc-text">选做部分 2：支持相对路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E6%95%B0%E7%BB%84"><span class="toc-number">10.1.</span> <span class="toc-text">维护工作目录数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%AE%BE%E7%BD%AE%E6%8E%A5%E5%8F%A3-amp-%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">系统调用设置接口 &amp; 实现用户调用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E4%BC%A0%E9%80%92"><span class="toc-number">10.3.</span> <span class="toc-text">工作目录传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4-cd"><span class="toc-number">10.4.</span> <span class="toc-text">实现内部命令 cd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0%E6%94%AF%E6%8C%81%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">10.5.</span> <span class="toc-text">open 函数支持相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E5%8A%9F%E8%83%BD%E8%B0%83%E6%95%B4"><span class="toc-number">10.6.</span> <span class="toc-text">用户程序功能调整</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shell-%E7%95%8C%E9%9D%A2%E4%BC%98%E5%8C%96"><span class="toc-number">10.7.</span> <span class="toc-text">Shell 界面优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B-6"><span class="toc-number">10.8.</span> <span class="toc-text">测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E6%8C%87%E4%BB%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">10.8.1.</span> <span class="toc-text">纯指令功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E5%A4%9A%E8%AF%AD%E5%8F%A5%E6%B5%8B%E8%AF%95"><span class="toc-number">10.8.2.</span> <span class="toc-text">一条多语句测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spawn-amp-open-%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">10.8.3.</span> <span class="toc-text">spawn &amp; open 功能测试</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/74b98825.html" title="BUAA-X86汇编程序设计-Exp1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-X86汇编程序设计-Exp1"/></a><div class="content"><a class="title" href="/p/74b98825.html" title="BUAA-X86汇编程序设计-Exp1">BUAA-X86汇编程序设计-Exp1</a><time datetime="2024-03-20T06:11:24.000Z" title="发表于 2024-03-20 14:11:24">2024-03-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task3"/></a><div class="content"><a class="title" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3">BUAA-SoftwareEngineering-Task3</a><time datetime="2024-03-16T06:41:29.000Z" title="发表于 2024-03-16 14:41:29">2024-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task2"/></a><div class="content"><a class="title" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2">BUAA-SoftwareEngineering-Task2</a><time datetime="2024-03-15T14:51:13.000Z" title="发表于 2024-03-15 22:51:13">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/b94f504e.html" title="BUAA-FPGA多核并行计算-Exp2-1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-FPGA多核并行计算-Exp2-1"/></a><div class="content"><a class="title" href="/p/b94f504e.html" title="BUAA-FPGA多核并行计算-Exp2-1">BUAA-FPGA多核并行计算-Exp2-1</a><time datetime="2024-03-14T15:23:27.000Z" title="发表于 2024-03-14 23:23:27">2024-03-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>