<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-OS-Theory-Chapter3-2 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第三章 内存管理 - Part2分页式存储管理 通过分页式存储管理可以把一个逻辑地址连续的程序装入到若干不连续的物理地址中，这可充分利用存储空间、减少移动带来的开销  主要针对的问题：  动态内存分配 碎片、紧凑问题  定义：  页：每个作业的地址空间分成的大小相同的片 存储块&#x2F;页框：主存的存储空间也被分为与页相同大小的片  分页地址结构 页号 | 偏移量  分页式结构下，地址由两部分组成，页号可">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-OS-Theory-Chapter3-2">
<meta property="og:url" content="https://cookedbear.github.io/p/8889.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="第三章 内存管理 - Part2分页式存储管理 通过分页式存储管理可以把一个逻辑地址连续的程序装入到若干不连续的物理地址中，这可充分利用存储空间、减少移动带来的开销  主要针对的问题：  动态内存分配 碎片、紧凑问题  定义：  页：每个作业的地址空间分成的大小相同的片 存储块&#x2F;页框：主存的存储空间也被分为与页相同大小的片  分页地址结构 页号 | 偏移量  分页式结构下，地址由两部分组成，页号可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp">
<meta property="article:published_time" content="2023-05-27T14:07:13.000Z">
<meta property="article:modified_time" content="2023-09-14T07:12:40.392Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/p/8889.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-OS-Theory-Chapter3-2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-14 15:12:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-OS-Theory-Chapter3-2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-27T14:07:13.000Z" title="发表于 2023-05-27 22:07:13">2023-05-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-14T07:12:40.392Z" title="更新于 2023-09-14 15:12:40">2023-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Operating-System/">Operating System</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-OS-Theory-Chapter3-2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第三章-内存管理-Part2"><a href="#第三章-内存管理-Part2" class="headerlink" title="第三章 内存管理 - Part2"></a>第三章 内存管理 - Part2</h1><h1 id="分页式存储管理"><a href="#分页式存储管理" class="headerlink" title="分页式存储管理"></a>分页式存储管理</h1><blockquote>
<p>通过分页式存储管理可以把一个逻辑地址连续的程序装入到若干不连续的物理地址中，这可充分利用存储空间、减少移动带来的开销</p>
</blockquote>
<p>主要针对的问题：</p>
<ul>
<li>动态内存分配</li>
<li>碎片、紧凑问题</li>
</ul>
<p>定义：</p>
<ul>
<li>页：每个作业的<strong>地址空间</strong>分成的<strong>大小相同</strong>的片</li>
<li>存储块/页框：主存的<strong>存储空间</strong>也被分为与页相同大小的片</li>
</ul>
<h2 id="分页地址结构"><a href="#分页地址结构" class="headerlink" title="分页地址结构"></a>分页地址结构</h2><blockquote>
<p><code>页号 | 偏移量</code></p>
</blockquote>
<p>分页式结构下，地址由两部分组成，页号可以是物理块号也可以是逻辑页号，两者可以转换</p>
<ul>
<li><p>逻辑地址、物理地址在同一系统内的页/块内偏移位数（大小）一致</p>
</li>
<li><p>给定一个逻辑地址空间中的地址为 A ，页面的大小为 L ，则页号 P 和页内地址 d（从0 开始编号）为</p>
<ul>
<li>$P=INT[\frac A L],d=[A]modL$</li>
</ul>
</li>
<li><p><strong>页面大小</strong>是由硬件决定的，通常选用$2^n$作为页大小，最常用的页面大小为4KB</p>
<ul>
<li>若采用小页面：页内碎片、内存碎片减少，提高内存利用率；页面数多，<strong>页表</strong>占用内存大；换进换出速度降低，但<strong>效率高</strong>；若采用大页面则特点相反</li>
<li>分页开销为$\frac{se}p+\frac p 2$（页面大小$p=\sqrt{2se}$，进程平均字节s，页表项e）</li>
</ul>
</li>
<li><p>逻辑上相邻的页，在物理地址上不一定相邻</p>
</li>
</ul>
<h2 id="页表数据结构"><a href="#页表数据结构" class="headerlink" title="页表数据结构"></a>页表数据结构</h2><ul>
<li>进程页表：每个进程具有一个页表，描述该进程逻辑页与物理块的映射关系</li>
<li>物理页面表：整个系统只拥有一个物理页面表，描述物理空间的分配情况</li>
<li>请求表：整个系统有一个请求表，描述系统内各进程页表的大小额位置，用于地址转换</li>
</ul>
<p>页表的作用：</p>
<ul>
<li>记录进程的内存分配情况</li>
<li>实现进程运行时的动态重定位</li>
<li>访问内存数据需要访问内存两次（页表+内存地址）</li>
</ul>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>当逻辑地址较大时会导致页表增大，可以采用多级页表或动态调入页表的方式解决</p>
<ul>
<li>动态调入页表：只把部分页表项调入内存，待需要其他页面时再调入</li>
</ul>
<h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><ul>
<li>逻辑地址划分：<code>二级页表|一级页表|页内地址</code></li>
<li>将一级页表再进行分页，将页表分散地存放在物理块中，再使用外部页表记录这些页</li>
<li>正在运行的进程必须调入二级页表，但是一级页表可以按需调入内存</li>
<li>对多级页表来说，各级页表存放的都是<strong>物理块号</strong>，他们指向内存中的下级页表或真正的被访问页</li>
</ul>
<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201213740.png" alt="image-20230220121318596" style="zoom:67%;" />

<h2 id="地址变换过程"><a href="#地址变换过程" class="headerlink" title="地址变换过程"></a>地址变换过程</h2><p>逻辑地址转换为物理地址：</p>
<ul>
<li>根据页号在页表中查询对应的项（页表始址+页号*页表项长度）</li>
<li>读出页表项对应的物理块号</li>
<li>使用<code>块号+页内地址</code>合成出物理地址</li>
</ul>
<h2 id="纯分页系统"><a href="#纯分页系统" class="headerlink" title="纯分页系统"></a>纯分页系统</h2><blockquote>
<p>若系统不支持内存主存的页面对换功能，就必须把程序的页一次性地装入内存；若当前内存不足则必须等待空闲</p>
</blockquote>
<p>优点</p>
<ul>
<li>没有外碎片，每个内碎片小于页大小（毕竟按页分块）</li>
<li>程序不必连续在内存中存放，系统可以轻易完成该进程新数据的装载</li>
</ul>
<p>缺点：</p>
<ul>
<li>程序需要一次性全部装入内存，占用开销大</li>
</ul>
<h2 id="MMU（Memory-Management-Unit）"><a href="#MMU（Memory-Management-Unit）" class="headerlink" title="MMU（Memory Management Unit）"></a>MMU（Memory Management Unit）</h2><blockquote>
<p>CPU为了提高地址转换效率，添加了一个硬件单元MMU，其主要包括：</p>
<ul>
<li>快表TLB：存放于虚拟地址相关的物理地址</li>
<li>TLB控制单元：TLB内容的填充覆盖、越界检查</li>
<li>页表查找单元：当TLB未命中时查找页表并输送给TLB单元</li>
</ul>
</blockquote>
<ul>
<li>MMU的工作流程：<ul>
<li>先在TLB中查询，成功匹配则分段查询（如果有多级页表）页表并得到物理地址；若未匹配则到外部页表中查询并置换进TLB中</li>
<li>根据TLB项判断是否符合访问规范</li>
<li>符合规范后再分段查询页表，返回物理地址</li>
</ul>
</li>
</ul>
<h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><blockquote>
<p>TLB，即Translation Lookaside Buffer，是专门针对页表项的高速缓存Cache，其<strong>内容是</strong>页表中的一部分或全部内容</p>
</blockquote>
<ul>
<li>TLB的工作流程<ul>
<li>接收CPU产生的逻辑地址并将其分解为虚拟页码和页内地址</li>
<li>根据页码号在TLB中寻找有无对应的条目：成功匹配则返回物理块；若未命中则前往完整页表中寻找，并将页表项复制进TLB中</li>
<li>最终合成出物理块+页内地址形式的物理地址</li>
</ul>
</li>
<li>通常TLB的条目数在$64\textasciitilde1024$之间，并且有些条目有可能不能被替换出TLB（比如内核代码）</li>
<li><code>ASID</code>：其可以用来唯一地标识进程，只有当申请访问的程序和页表项对应的进程一致（<code>ASID</code>相同）才允许访问，否则即说明<strong>页表项失效</strong><ul>
<li>（说明不同的程序正在访问相同的虚拟页码，因不同程序的映射规则不同，对应的物理块也不会一致，此时存放的物理块号是错误的）</li>
<li>如果允许TLB同时包含多个进程的页表项时，每次选择页表TLB都必须被<code>flushed</code>或删除，以确保下一个进程不会使用不匹配的映射</li>
</ul>
</li>
</ul>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><blockquote>
<p>一般意义上的页表构造了一个虚拟页$\to$物理块的映射，当虚拟页数量大时会消耗大量内存；而反置页表则是构建了一个物理块$\to$虚拟页的映射，其为每个物理块都说明了对应的虚拟页</p>
</blockquote>
<ul>
<li>反置页表项：<code>进程ID|逻辑页号</code></li>
<li>反置页表中，每一个物理块$i$都对应着反置页表的第$i$项，而第$i$项的信息则提示了这个物理块属于哪个进程、<strong>对应了哪个逻辑页</strong></li>
<li>通过构造反向的映射，<strong>反置页表的大小</strong>只与物理内存的大小相关</li>
<li><strong>反置页表的工作流程</strong>：<ul>
<li>利用进程ID和虚拟页号在反置页表中<strong>遍历所有项</strong>（相当于查询所有物理块）</li>
<li>如<strong>第$i$项</strong>产生匹配，则该虚拟页对应的**物理块号就为$i$**；如未发生匹配，则说明此虚拟页未存放在内存中，申请从主存中调页</li>
<li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305282220544.png" alt="image-20230220183050472" style="zoom:67%;" /></li>
</ul>
</li>
<li>可以借助哈希表，将反置页表改造成反置链表：通过虚拟页码指向对应链表的头，进而仅查询该链表中的表项，从而减少遍历带来的时间消耗<ul>
<li><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302201834843.png" alt="image-20230220183423808" style="zoom:67%;" /></li>
<li>（只查询图中<code>Page Table</code>中的<code>Chain</code>内容即可）</li>
</ul>
</li>
<li>采用反置页表的系统难<strong>共享内存</strong>：每个物理块只对应一个虚拟页条目</li>
</ul>
<h2 id="页共享与保护"><a href="#页共享与保护" class="headerlink" title="页共享与保护"></a>页共享与保护</h2><ul>
<li>页的共享：对于多个程序需要共享同一个物理块的数据/程序时，应让它们包含该块的虚拟地址全部指向相同的物理块</li>
<li>共享带来的问题：<ul>
<li>若共享、不共享数据被划分在同一块内，将泄露数据；可以采用分段存储管理的方式专门对公开数据进行共享</li>
</ul>
</li>
<li>页的保护：<ul>
<li>地址越界保护</li>
<li>在页表中设置保护位：定义访问时的操作权限（有可能不同进程对相同的共享数据拥有不同的权限）</li>
</ul>
</li>
</ul>
<h1 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h1><blockquote>
<p>对于一个程序的各组成部分来说，他们对内存的需求并不相同</p>
</blockquote>
<ul>
<li>编程用户<ul>
<li>用户一般按照<strong>逻辑关系</strong>对作业分段，并根据名字访问程序段和数据段</li>
</ul>
</li>
<li>信息共享<ul>
<li>共享是以信息的<strong>逻辑单位</strong>——段，为基础的；而存储却是以物理单位——页，进行的</li>
<li>共享段的难度要比共享页的难度高</li>
</ul>
</li>
<li>信息保护<ul>
<li>一个页中可能存放了多个程序的内容，简单的页分享可能会导致数据的错误泄露</li>
<li>可以对信息采取段为单位进行分享和保护</li>
</ul>
</li>
<li>动态增长<ul>
<li>在进程运行的过程中，某些数据段可能会不断增长，存储管理方法存在困难</li>
</ul>
</li>
<li>动态链接<ul>
<li>在程序运行时才把目标程序和主程序进行链接</li>
</ul>
</li>
</ul>
<h2 id="分段地址空间"><a href="#分段地址空间" class="headerlink" title="分段地址空间"></a>分段地址空间</h2><blockquote>
<p>将<strong>段</strong>作为地址的分割依据，使得地址空间由各个分段组成，这些段可以不相连，但一个段的内部地址一定连续</p>
</blockquote>
<ul>
<li><strong>逻辑地址结构</strong>：<code>段号|位移量</code><ul>
<li>分区：按照磁盘的物理地址对内存进行划分</li>
<li>分页：按照固定大小的页对内存进行划分</li>
<li>分段：按照程序段长度对内存进行划分（分段长度自由，前两者都已固定）</li>
</ul>
</li>
</ul>
<h2 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h2><ul>
<li>段表记录了段号与内存物理地址的对应关系，并存放于内存当中</li>
<li>基址与长度由段表寄存器给出</li>
<li>优点：<ul>
<li>易于实现段的共享与保护</li>
</ul>
</li>
<li>缺点：<ul>
<li>处理地址花费时间，也要考虑段表的占用内存</li>
<li>为满足分段的动态增长、减少外碎片，要采用拼接内存的手段</li>
<li>在辅存中难管理不定长度的分段</li>
<li>分段尺寸受到内存大小的限制，不能超出内存空间</li>
</ul>
</li>
</ul>
<h3 id="地址变换过程-1"><a href="#地址变换过程-1" class="headerlink" title="地址变换过程"></a>地址变换过程</h3><ul>
<li>查询申请访问的段号是否在段表内，如果超界则产生中断</li>
<li>检查段内位移量是否超出段的长度，如果超界则产生中断</li>
<li>若均为越界，则返回对应段号所在的物理地址<strong>基址</strong>，与段内位移量相加则得到物理地址</li>
</ul>
<h3 id="段共享"><a href="#段共享" class="headerlink" title="段共享"></a>段共享</h3><blockquote>
<p>若对于某一个程序/程序段，会被众多用户/程序调用，那么就可以共享这个段，声明其为<strong>可重入的</strong>，这样只需要保留一份<strong>只读代码</strong>在内存当中即可</p>
</blockquote>
<h1 id="分页式与分段式的比较"><a href="#分页式与分段式的比较" class="headerlink" title="分页式与分段式的比较"></a>分页式与分段式的比较</h1><ul>
<li>分页式地址空间是一维线性的；分段式则是二维地址空间</li>
<li><strong>页</strong>是信息的物理单位，其大小固定；<strong>段</strong>是信息的逻辑单位，其大小不定（但总具有完整的意义）</li>
<li>分页用户不可见，系统直接操作内存；分段用户可见</li>
</ul>
<p>分页有效解决了碎片问题，同时使得程序可以不连续存放</p>
<p>分段实现了数据高效共享与保护，可便捷所需空间动态增长的程序，也利于动态链接</p>
<h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><blockquote>
<p>段页式内存管理是分段、分页原理的结合：系统先将程序分为若干段，再把每段按照固定大小进行分页</p>
</blockquote>
<ul>
<li><strong>逻辑地址结构</strong>：<code>段号|段内页号|页内地址</code></li>
<li>访问时先访问内存的段表，找到<strong>对应页表</strong>的起始地址；再查该段的页表，找到段内页号对应的物理块号，最后根据物理块和页内地址访问物理内存</li>
<li>在逻辑上，程序被分成了长度不同的段，<strong>段内连续</strong>；在空间上，程序的段被分为了长度相同的页，<strong>段内不连续</strong></li>
</ul>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202002672.png" alt="image-20230220200154810"></p>
<h2 id="x86的段页式实现（待补）"><a href="#x86的段页式实现（待补）" class="headerlink" title="x86的段页式实现（待补）"></a>x86的段页式实现（待补）</h2><h1 id="覆盖与交换"><a href="#覆盖与交换" class="headerlink" title="覆盖与交换"></a>覆盖与交换</h1><blockquote>
<p>覆盖，就是一个相对独立的程序单位。一个大的程序可以划分为一系列的覆盖</p>
</blockquote>
<ul>
<li>覆盖段：程序执行时并不要求同时装入主存的一组覆盖；这个覆盖段被分到同一个存储区域（覆盖区）</li>
<li>使用覆盖则必须在编程时提前确定模块间的覆盖关系，时间换空间</li>
</ul>
<blockquote>
<p>交换，把暂时不用的数据/程序从内存转移到辅存中，再把使用的数据转入主存</p>
</blockquote>
<ul>
<li>交换可以增加并发的程序数目；提供适当的响应时间</li>
<li>交换会增加处理机开销；没有考虑执行过程中地址访问的统计特性</li>
</ul>
<blockquote>
<p>因为<strong>在同一个覆盖段内</strong>的两个覆盖不会同时使用，所以可以对两个覆盖进行交换</p>
</blockquote>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><blockquote>
<p>局部性原理指在执行过程中的一个较短的时间内执行的指令和其操作数的地址都在都某区域内并受到约束</p>
</blockquote>
<ul>
<li>时间局部性：一条指令、一段数据的前后两次访问集中在某时间内</li>
<li>空间局部性：邻近的几条指令，访问的数据集中在某区域内</li>
<li>当程序出现对某数据结构的多次操作，通常局限在较小的范围内</li>
</ul>
<blockquote>
<p>快排的局部性比堆排好：堆排使得数据在整个数组内做大范围的跳动，而快排的数据访问间隔比较小，显然快排的空间局部性更好</p>
</blockquote>
<h1 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h1><blockquote>
<p>虚拟存储为每个进程提供了一个连续完整的地址空间，利用了主存和磁盘的特点（类似于Cache和主存的关系，下沉了一层，但两者<strong>有一定区别</strong>）</p>
</blockquote>
<blockquote>
<p>虚拟内存把地址空间定义为连续的虚拟内存地址，欺骗程序在使用一大段连续地址</p>
</blockquote>
<ul>
<li>每个进程都认为自己正在独占系统的所有内存；但并不是所有内容都直接放置在内存中，操作系统遵循<strong>覆盖</strong>的规则保留一部分内容</li>
<li>虚存保护了每个进程的地址访问操作，防止出现冲突</li>
<li>虚拟存储在主存和硬盘存储间<strong>交换</strong>，利用了主存的快速、硬盘的大空间特点</li>
</ul>
<h2 id="虚拟存储的基本原理"><a href="#虚拟存储的基本原理" class="headerlink" title="虚拟存储的基本原理"></a>虚拟存储的基本原理</h2><ul>
<li>按需装载：只需要将当前需要的分页/分段读入内存，后续需要的页/程序段在使用时再读入</li>
<li>缺页调入：在执行过程中发生缺页/缺段时从磁盘调入内存</li>
<li>不用调出：操作系统将内存不常用的页/段归还磁盘外存，调出后的空间供新的页/段调入使用</li>
</ul>
<h2 id="虚拟存储的特征"><a href="#虚拟存储的特征" class="headerlink" title="虚拟存储的特征"></a>虚拟存储的特征</h2><ul>
<li>离散性：物理内存分配上的不连续性、虚拟地址使用上的不连续性</li>
<li><strong>多次性</strong>：（<strong>分时复用</strong>）分多次调用程序进入内存，使得虚拟存储具有了在逻辑上<strong>扩大内存</strong>的功能；这时虚拟存储最重要的特征</li>
<li>对换性：内存、外存可进行交换，提高内存利用率</li>
<li>虚拟性：虚拟存储允许程序从逻辑的角度上访问存储器，而不需考虑实际的物理空间</li>
</ul>
<blockquote>
<p>虚拟性以多次性和对换性为基础</p>
<p>多次性、对换性以离散性为基础</p>
</blockquote>
<p>优点：</p>
<ul>
<li>程序调用的内存限制扩大，通常大于物理内存</li>
<li>可容纳更多的程序并发执行</li>
<li>不影响编程时的程序结构（与覆盖技术相比）</li>
</ul>
<p>缺点：</p>
<ul>
<li>时间换空间，以CPU工作时间和内外存交互的长时间为代价</li>
</ul>
<p>限制：</p>
<ul>
<li><strong>虚拟内存的最大容量由计算机的地址结构决定</strong></li>
</ul>
<h2 id="虚拟内存与Cache"><a href="#虚拟内存与Cache" class="headerlink" title="虚拟内存与Cache"></a>虚拟内存与Cache</h2><p>相同点：</p>
<ul>
<li>都为分层存储体系：充分利用高速存储器的速度和低速存储器的容量</li>
<li>原理相同：利用程序的局部性原理，进行信息的部分调用</li>
</ul>
<p>不同点：</p>
<ul>
<li>Cache侧重访问低速存储器的速度问题，虚存侧重高速存储器的容量问题（+内存管理、保护等）</li>
<li>CPU可直接访问内存；但不能直接访问外存，仍需要调取至内存才能访问</li>
<li>透明性不同：Cache作为硬件对程序员透明；虚存采用软件管理，受操作系统控制（对实现存储管理的系统程序员不透明，对应用管理员透明）</li>
<li>损失不同：主存未命中的损失远大于Cache未命中的损失</li>
</ul>
<h2 id="虚拟内存名词解释"><a href="#虚拟内存名词解释" class="headerlink" title="虚拟内存名词解释"></a>虚拟内存名词解释</h2><h3 id="进程的逻辑空间（虚拟空间）"><a href="#进程的逻辑空间（虚拟空间）" class="headerlink" title="进程的逻辑空间（虚拟空间）"></a>进程的逻辑空间（虚拟空间）</h3><p>使用虚存技术后对单个程序可见的空间，从0开始编址。这段空间逻辑上连续，但并不实际存在于内存/外存中</p>
<img src="C:\Users\Bo\AppData\Roaming\Typora\typora-user-images\image-20230220212737131.png" alt="image-20230220212737131" style="zoom: 60%;" />

<h3 id="虚拟地址空间与虚拟存储（内存）空间"><a href="#虚拟地址空间与虚拟存储（内存）空间" class="headerlink" title="虚拟地址空间与虚拟存储（内存）空间"></a>虚拟地址空间与虚拟存储（内存）空间</h3><p>进程的虚拟地址空间是进程在内存中存放的逻辑视图</p>
<p>一个程序的虚拟地址空间与虚拟存储空间大小相同</p>
<h3 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a>交换分区</h3><p>一段按页划分的磁盘空间，对用户不可见</p>
<p>在物理内存不足时存放内存数据，为其他进程解放物理内存</p>
<h2 id="虚拟内存需要解决的问题"><a href="#虚拟内存需要解决的问题" class="headerlink" title="虚拟内存需要解决的问题"></a>虚拟内存需要解决的问题</h2><ul>
<li>地址映射问题：<strong>进程的逻辑空间</strong>到实际内存的映射问题</li>
<li>调入问题：调入机制、调入块的选择</li>
<li>替换问题：调出相关问题</li>
<li>更新问题：内存、外存数据的同步</li>
<li>其他问题：存储保护、程序重定位等</li>
</ul>
<h2 id="虚存的地址映射"><a href="#虚存的地址映射" class="headerlink" title="虚存的地址映射"></a>虚存的地址映射</h2><ul>
<li>内核在进程创建时没有把程序与数据交换进物理内存中（此时仅建立<code>虚存-磁盘</code>的映射），等到需要使用时才会通过<strong>缺页机制</strong>交换数据</li>
<li>用户可执行文件和共享库都以文件的形式存储在磁盘中，在页表中类型为<code>file backed</code></li>
<li><code>heap</code>和<code>stack</code>在磁盘上没有对应的文件，类型为<code>anonymous</code>，<strong>地址为空</strong></li>
<li><strong>未分配部分</strong>没有对应的页表项，只有当<code>malloc</code>申请内存时才建立页表项</li>
</ul>
<h2 id="虚存的调用机制"><a href="#虚存的调用机制" class="headerlink" title="虚存的调用机制"></a>虚存的调用机制</h2><blockquote>
<p>调入主存的数据有两类：</p>
<ul>
<li>OS的核心程序与数据</li>
<li>正在运行的用户进程相关的程序与数据</li>
</ul>
<p>借助<strong>缺页错误处理</strong>机制进行调用</p>
</blockquote>
<ul>
<li><p>调用时间：</p>
<ul>
<li>OS在系统启动时调入</li>
<li>用户数据调入有不同策略：预调页、按需调页</li>
</ul>
</li>
<li><p>预调页：同时将<strong>所有页</strong>都调入内存中，阻止大量开始运行时产生的页错误</p>
</li>
<li><p>按需调页：只有当缺页时才进行调用，类似使用<strong>交换</strong>的分页系统</p>
</li>
<li><p><strong>缺页错误处理机制过程</strong>：</p>
<ul>
<li>现场保护：发现异常进入内核态，保存现场信息</li>
<li><strong>页面定位</strong>：查找异常的虚拟页面</li>
<li>权限检查：检查虚拟地址有效性、安全保护位，出错则<code>kill</code></li>
<li>新页面调入1：通过页面置换找到一个需要换出的物理页</li>
<li><strong>旧页面写回</strong>：把这个物理页写回外存（需要置为忙状态，以防被其他进程抢占）</li>
<li><strong>新页面调入2</strong>：将虚存所需的页面从外存调入内存</li>
<li><strong>更新页表</strong>：项操作系统发出中断，更新内存的页表项</li>
<li>恢复现场</li>
</ul>
</li>
</ul>
<h1 id="实存管理与虚存管理"><a href="#实存管理与虚存管理" class="headerlink" title="实存管理与虚存管理"></a>实存管理与虚存管理</h1><p>实存管理方法：分区、分页、分段、段页式</p>
<p>虚存管理方法：（向外存）请求分页、请求分段、请求段页式</p>
<h2 id="请求分页-段式系统"><a href="#请求分页-段式系统" class="headerlink" title="请求分页/段式系统"></a>请求分页/段式系统</h2><p>与原本的分页/段式类似，只不过内存中只存放了部分的程序和数据，待其启动后再按需从外存中以页/段为单位进行调用即可</p>
<ul>
<li>硬件支持：页表/段表机制、缺页/缺段时的中断机构和地址变换机构</li>
<li>软件支持：请求调页/段、请求页/段置换的功能</li>
<li>页表项：<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202302202155726.png" alt="image-20230220215555699" style="zoom:67%;" /><ul>
<li>驻留位：1-在内存；0-在外存</li>
<li>保护位：只读、可写、可执行</li>
<li>修改位：此页在内存中有无修改操作</li>
<li>访问位：用于页面置换算法</li>
</ul>
</li>
</ul>
<h2 id="虚存页面置换策略"><a href="#虚存页面置换策略" class="headerlink" title="虚存页面置换策略"></a>虚存页面置换策略</h2><h3 id="最优置换策略"><a href="#最优置换策略" class="headerlink" title="最优置换策略"></a>最优置换策略</h3><blockquote>
<p>把所有页中未来最久不会被使用的页替换出去</p>
</blockquote>
<ul>
<li>具有最低的页错误率，然而这种方法不可能被实现</li>
</ul>
<h3 id="先进先出策略"><a href="#先进先出策略" class="headerlink" title="先进先出策略"></a>先进先出策略</h3><blockquote>
<p>当需要替换页时，把最先进入的页替换出去</p>
</blockquote>
<ul>
<li>借助一个队列，新访问的页面插入队尾，替换的页从队首出队</li>
<li><strong>性能较差</strong>：较早调入的页访问通常较多</li>
<li>Belady现象：分配的页面数增多，但缺页率却增高的现象</li>
</ul>
<blockquote>
<p>FIFO的置换特征，与进程访问内存的动态特征是矛盾的</p>
</blockquote>
<h3 id="Second-Chance策略、Clock（最近未使用算法）策略"><a href="#Second-Chance策略、Clock（最近未使用算法）策略" class="headerlink" title="Second Chance策略、Clock（最近未使用算法）策略"></a>Second Chance策略、Clock（最近未使用算法）策略</h3><blockquote>
<p>Second Chance是改进后的FIFO法，给每一个页面一个标记位，记录此页面是否被访问过</p>
</blockquote>
<ul>
<li>如果将要被换出的页面曾被访问过，就清除标记位，放至队尾重新入队；否则直接出队</li>
<li>当所有页面<strong>都被访问过</strong>时，也直接出队</li>
</ul>
<blockquote>
<p>Clock在Second Chance的基础上变更为了<strong>环形队列</strong>；在注意指针移动的基础上，其余操作保持一致</p>
</blockquote>
<ul>
<li><strong>FIFO类算法对比</strong>：<ul>
<li>命中率：Clock = Second &gt; FIFO</li>
<li>复杂度：Second &gt; Clock &gt; FIFO</li>
<li>代价：Second &gt; Clock &gt; FIFO</li>
</ul>
</li>
</ul>
<h3 id="LRU（最近最少使用）策略"><a href="#LRU（最近最少使用）策略" class="headerlink" title="LRU（最近最少使用）策略"></a>LRU（最近最少使用）策略</h3><blockquote>
<p>根据页面的历史访问记录进行替换：最近使用过的数据将来的访问几率更高</p>
<p>这种算法是局部性原理的合理近似，但硬件开销较大</p>
</blockquote>
<ul>
<li>设置一个栈，保存当前的所有页面号</li>
<li>当某个页面被访问时，取出栈中的页面号，重新压栈</li>
<li>当需要替换时，退出栈底的元素</li>
</ul>
<h4 id="AGING（老化算法）策略（-待补）"><a href="#AGING（老化算法）策略（-待补）" class="headerlink" title="AGING（老化算法）策略（*待补）"></a>AGING（老化算法）策略（*待补）</h4><blockquote>
<p>AGING是LRU的一种简化，性能上接近LRU，但减少了硬件开销</p>
</blockquote>
<ul>
<li>为每个页面设置一个移位寄存器，并设置一位访问位R，每隔一段时间，所有寄存器右移1位，并将R值从左移入。</li>
</ul>
<h3 id="虚存同步更新问题"><a href="#虚存同步更新问题" class="headerlink" title="虚存同步更新问题"></a>虚存同步更新问题</h3><blockquote>
<p>当一个页面被换出时，为了保持内存外存信息的一致性，必要时需要进行信息的更新</p>
</blockquote>
<ul>
<li>换出页面为<code>file backed</code>类，并未被修改：直接<code>discard</code>，因外存含有副本</li>
<li>换出页面为<code>file backed</code>类，但有修改：写回原有位置，因外存副本过期</li>
<li>换出页面为<code>anonymous</code>类，若第一次换出+未修改：写入<code>Swap</code>区；否则<code>discard</code></li>
<li>换出页面为<code>anonymous</code>类，且有修改：写入<code>Swap</code>区</li>
</ul>
<h2 id="工作集与驻留集管理"><a href="#工作集与驻留集管理" class="headerlink" title="工作集与驻留集管理"></a>工作集与驻留集管理</h2><blockquote>
<ul>
<li><strong>工作集</strong>：<strong>过去一段时间内</strong>进程访问的页面集合</li>
<li><strong>驻留集</strong>：进程被分配的物理页集合</li>
</ul>
</blockquote>
<h3 id="工作集策略"><a href="#工作集策略" class="headerlink" title="工作集策略"></a>工作集策略</h3><blockquote>
<p>引入工作集是为了调整驻留集的大小</p>
</blockquote>
<p>当进程开始执行后，工作集随着页面加载逐渐稳定；当进程的局部性区域变化时，工作集进行一次快速扩张和收缩，再到达一个稳定的值</p>
<h1 id="页表与自映射"><a href="#页表与自映射" class="headerlink" title="页表与自映射"></a>页表与自映射</h1><blockquote>
<p>假设页式内存管理中，一页大小为 a Byte，一个页表项的大小为 b Byte，且页表起始地址为 x（保证<strong>页对齐</strong>），求页目录（自映射）的地址？</p>
</blockquote>
<p>在实验课中我们很容易就能回答，答案是 x + x &gt;&gt; 10，但是怎么来的还是要有自己的理解。</p>
<p>首先可知，页表在所有页面的第 x / a 页上，那么页目录就应该从页表的起始地址向后数和页面数同样多的页表项数，这样取到的页表项就恰好对应页表的起始地址，也就是向后数 (x / a) * b Byte</p>
<p>最后再加上起始的页表基地址，结果为 <strong>x + (x / a) * b</strong></p>
<p>在这里代入 MOS 的数据，就是 x + (x / 4096) * 4 = x + x &gt;&gt; 10了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/p/8889.html">https://cookedbear.github.io/p/8889.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/2510.html" title="BUAA-OS-Theory-Chapter4"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-OS-Theory-Chapter4</div></div></a></div><div class="next-post pull-right"><a href="/p/9209.html" title="BUAA-OS-Theory-Chapter3-1"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">BUAA-OS-Theory-Chapter3-1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-13</div><div class="title">BUAA-SoftwareEngineering-Task0</div></div></a></div><div><a href="/p/1727.html" title="BUAA-OS-TOP"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306132108192.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">BUAA-OS-TOP</div></div></a></div><div><a href="/p/28193.html" title="BUAA-OS-2023-Lab6-Challenge"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306101220252.png?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-10</div><div class="title">BUAA-OS-2023-Lab6-Challenge</div></div></a></div><div><a href="/p/13765.html" title="BUAA-OS-2023-Lab6-Report"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112055861.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-04</div><div class="title">BUAA-OS-2023-Lab6-Report</div></div></a></div><div><a href="/p/2190.html" title="BUAA-OS-Theory-Chapter7"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter7</div></div></a></div><div><a href="/p/51279.html" title="BUAA-OS-Theory-Chapter6"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-30</div><div class="title">BUAA-OS-Theory-Chapter6</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-Part2"><span class="toc-number">1.</span> <span class="toc-text">第三章 内存管理 - Part2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">分页式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">分页地址结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">页表数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">两级页表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">地址变换过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%AF%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.</span> <span class="toc-text">纯分页系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MMU%EF%BC%88Memory-Management-Unit%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">MMU（Memory Management Unit）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">2.5.1.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">反置页表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.6.</span> <span class="toc-text">页共享与保护</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">分段式存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">3.1.</span> <span class="toc-text">分段地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">段表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">地址变换过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%85%B1%E4%BA%AB"><span class="toc-number">3.2.2.</span> <span class="toc-text">段共享</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E5%BC%8F%E4%B8%8E%E5%88%86%E6%AE%B5%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">4.</span> <span class="toc-text">分页式与分段式的比较</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">段页式内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#x86%E7%9A%84%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%BE%85%E8%A1%A5%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">x86的段页式实现（待补）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">6.</span> <span class="toc-text">覆盖与交换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">局部性原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8"><span class="toc-number">7.</span> <span class="toc-text">虚拟存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">虚拟存储的基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">7.2.</span> <span class="toc-text">虚拟存储的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8ECache"><span class="toc-number">7.3.</span> <span class="toc-text">虚拟内存与Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟内存名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E7%A9%BA%E9%97%B4%EF%BC%88%E8%99%9A%E6%8B%9F%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">7.4.1.</span> <span class="toc-text">进程的逻辑空间（虚拟空间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89%E7%A9%BA%E9%97%B4"><span class="toc-number">7.4.2.</span> <span class="toc-text">虚拟地址空间与虚拟存储（内存）空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E5%88%86%E5%8C%BA"><span class="toc-number">7.4.3.</span> <span class="toc-text">交换分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.5.</span> <span class="toc-text">虚拟内存需要解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E7%9A%84%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">7.6.</span> <span class="toc-text">虚存的地址映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E7%9A%84%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">7.7.</span> <span class="toc-text">虚存的调用机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E8%99%9A%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">实存管理与虚存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5-%E6%AE%B5%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.1.</span> <span class="toc-text">请求分页&#x2F;段式系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.</span> <span class="toc-text">虚存页面置换策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.1.</span> <span class="toc-text">最优置换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.2.</span> <span class="toc-text">先进先出策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Second-Chance%E7%AD%96%E7%95%A5%E3%80%81Clock%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.3.</span> <span class="toc-text">Second Chance策略、Clock（最近未使用算法）策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%EF%BC%88%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%EF%BC%89%E7%AD%96%E7%95%A5"><span class="toc-number">8.2.4.</span> <span class="toc-text">LRU（最近最少使用）策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AGING%EF%BC%88%E8%80%81%E5%8C%96%E7%AE%97%E6%B3%95%EF%BC%89%E7%AD%96%E7%95%A5%EF%BC%88-%E5%BE%85%E8%A1%A5%EF%BC%89"><span class="toc-number">8.2.4.1.</span> <span class="toc-text">AGING（老化算法）策略（*待补）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%AD%98%E5%90%8C%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.5.</span> <span class="toc-text">虚存同步更新问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E4%B8%8E%E9%A9%BB%E7%95%99%E9%9B%86%E7%AE%A1%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">工作集与驻留集管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E9%9B%86%E7%AD%96%E7%95%A5"><span class="toc-number">8.3.1.</span> <span class="toc-text">工作集策略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E4%B8%8E%E8%87%AA%E6%98%A0%E5%B0%84"><span class="toc-number">9.</span> <span class="toc-text">页表与自映射</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task0"/></a><div class="content"><a class="title" href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0">BUAA-SoftwareEngineering-Task0</a><time datetime="2024-03-12T16:13:26.000Z" title="发表于 2024-03-13 00:13:26">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task0"/></a><div class="content"><a class="title" href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0">BUAA-SoftwareEngineering-Task0</a><time datetime="2024-03-12T16:10:25.000Z" title="发表于 2024-03-13 00:10:25">2024-03-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/5ed428af.html" title="BUAA-X86汇编程序设计笔记"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292225468.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-X86汇编程序设计笔记"/></a><div class="content"><a class="title" href="/p/5ed428af.html" title="BUAA-X86汇编程序设计笔记">BUAA-X86汇编程序设计笔记</a><time datetime="2024-02-28T17:54:28.000Z" title="发表于 2024-02-29 01:54:28">2024-02-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/feaaa974.html" title="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》"><img src="https://cdn.cloudflare.steamstatic.com/steam/apps/2510890/header_schinese.jpg?t=1708421482" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》"/></a><div class="content"><a class="title" href="/p/feaaa974.html" title="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》">超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》</a><time datetime="2024-02-20T17:54:28.000Z" title="发表于 2024-02-21 01:54:28">2024-02-21</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>