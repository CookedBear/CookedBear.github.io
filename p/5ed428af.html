<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>BUAA-X86汇编程序设计笔记 | sin</title><meta name="author" content="CookedBear"><meta name="copyright" content="CookedBear"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="X86汇编程序设计本文章是北航计算机学院于 2024 年春季学期开设的一般专业课《X86汇编程序设计》的学习笔记，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！ 基本知识数制及数制间的转换开摆！ 二进制数与十六进制数的运算开摆！ ASCII码和BCD码 BCD 码：用二进制编码的十进制数，每一位数用四位二进制数表示 ASCII 码：标准码有 128 个字符  IBM-PC计算机组织本节以最基">
<meta property="og:type" content="article">
<meta property="og:title" content="BUAA-X86汇编程序设计笔记">
<meta property="og:url" content="https://cookedbear.github.io/p/5ed428af.html">
<meta property="og:site_name" content="sin">
<meta property="og:description" content="X86汇编程序设计本文章是北航计算机学院于 2024 年春季学期开设的一般专业课《X86汇编程序设计》的学习笔记，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！ 基本知识数制及数制间的转换开摆！ 二进制数与十六进制数的运算开摆！ ASCII码和BCD码 BCD 码：用二进制编码的十进制数，每一位数用四位二进制数表示 ASCII 码：标准码有 128 个字符  IBM-PC计算机组织本节以最基">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292225468.jpg?imageMogr2/format/webp">
<meta property="article:published_time" content="2024-02-28T17:54:28.000Z">
<meta property="article:modified_time" content="2024-03-07T10:59:53.767Z">
<meta property="article:author" content="CookedBear">
<meta property="article:tag" content="BUAA">
<meta property="article:tag" content="Elevate">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292225468.jpg?imageMogr2/format/webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://cookedbear.github.io/p/5ed428af.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":150},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'BUAA-X86汇编程序设计笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-07 18:59:53'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/center-atom.css" ><meta name="generator" content="Hexo 5.4.2"></head><body>
    <div id='loader'>
        
        <div class="loading-left-bg"></div>
        <div class="loading-right-bg"></div>
        <div class="spinner-box">
            <div class="configure-border-1">
                <div class="configure-core"></div>
            </div>
            <div class="configure-border-2">
                <div class="configure-core"></div>
            </div>
            <div class="loading-word">加载中...</div>
        </div>
        
    </div>
        
    <script>
        var endLoading = function () {
        document.body.style.overflow = 'auto';
        document.getElementById('loader').classList.add("loading");
        }
        window.addEventListener('load',endLoading);
    </script>
    <div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292225468.jpg?imageMogr2/format/webp')"><nav id="nav"><span id="blog-info"><a href="/" title="sin"><span class="site-name">sin</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA-X86汇编程序设计笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-28T17:54:28.000Z" title="发表于 2024-02-29 01:54:28">2024-02-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-07T10:59:53.767Z" title="更新于 2024-03-07 18:59:53">2024-03-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Elevate/">Elevate()</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="BUAA-X86汇编程序设计笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="X86汇编程序设计"><a href="#X86汇编程序设计" class="headerlink" title="X86汇编程序设计"></a>X86汇编程序设计</h1><p>本文章是北航计算机学院于 2024 年春季学期开设的一般专业课《X86汇编程序设计》的学习笔记，由于学习过程中掌握并不牢靠，如有错误请读者不吝赐教！</p>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="数制及数制间的转换"><a href="#数制及数制间的转换" class="headerlink" title="数制及数制间的转换"></a>数制及数制间的转换</h2><p>开摆！</p>
<h2 id="二进制数与十六进制数的运算"><a href="#二进制数与十六进制数的运算" class="headerlink" title="二进制数与十六进制数的运算"></a>二进制数与十六进制数的运算</h2><p>开摆！</p>
<h2 id="ASCII码和BCD码"><a href="#ASCII码和BCD码" class="headerlink" title="ASCII码和BCD码"></a>ASCII码和BCD码</h2><ul>
<li>BCD 码：用二进制编码的十进制数，每一位数用四位二进制数表示</li>
<li>ASCII 码：标准码有 128 个字符</li>
</ul>
<h1 id="IBM-PC计算机组织"><a href="#IBM-PC计算机组织" class="headerlink" title="IBM-PC计算机组织"></a>IBM-PC计算机组织</h1><p>本节以最基础的 Intel 8086/8088 为例进行学习，8086 的指令为 16 位，8088 为 8 位。</p>
<p>8088 和 8086 的体系结构和指令系统、指令编码格式、寻址方式完全相同，软件也完全兼容。</p>
<h2 id="IBM-PC微型计算机的基本结构"><a href="#IBM-PC微型计算机的基本结构" class="headerlink" title="IBM-PC微型计算机的基本结构"></a>IBM-PC微型计算机的基本结构</h2><ul>
<li>可直接寻址的内存：$2^{20}=1MB$</li>
<li>地址线有 20 根，但字长只有 16 位</li>
</ul>
<h2 id="Intel-8086-CPU-寄存器结构"><a href="#Intel-8086-CPU-寄存器结构" class="headerlink" title="Intel 8086 CPU 寄存器结构"></a>Intel 8086 CPU 寄存器结构</h2><blockquote>
<p>Intel 8086/8088 CPU 主要由运算器、控制器以及工作寄存器三部分组成</p>
</blockquote>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器共有 8 个：AX、BX、CX、DX、SP、BP、SI、DI；</p>
<ul>
<li>数据寄存器：前四个寄存器，可以拆分为两个 8 位的寄存器，即 AX→AH:AL<ul>
<li>AX：通常存储计算结果和操作数</li>
<li><strong>BX：间接寻址时存放基地址</strong></li>
<li>CX：循环指令、移位指令的计数器</li>
<li>DX：双字乘除法运算的拓展寄存器；IO 指令中存放 IO 端口的地址</li>
</ul>
</li>
<li>指针寄存器：后四个寄存器，主要用于存放地址（<strong>只有 BP 使用堆栈基地址</strong>）<ul>
<li>SP：栈指针寄存器，栈生长方式在<a href="#%E5%A0%86%E6%A0%88">堆栈</a>一节再进行详细介绍</li>
<li>BP：堆栈段的基址指针，<strong>和 BX 作用类似</strong>，用于传递参数</li>
<li>SI：源变址寄存器，用作寻址的偏移量，不能和 DI 互换，某些指令会<strong>隐含指定</strong>所使用的寄存器</li>
<li>DI：目的变址寄存器，同上</li>
</ul>
</li>
</ul>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><blockquote>
<p>段是内存空间的一片区域，表示一个段需要使用段的基地址来进行表示</p>
</blockquote>
<p>段寄存器存放对应段的基地址，但因为地址是20位的，所以寄存器仅存放了地址的高16位，具体地址可由低四位的偏移量以及公式推导得来</p>
<ul>
<li>段：代码段、数据段、堆栈段、附加段</li>
<li>寄存器：CS、DS、SS、ES</li>
</ul>
<h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>指令指针寄存器（IP）是一个专用的 16 位寄存器，它表示的是当前要执行的指令在<strong>代码段</strong>中的偏移地址（也就是实际地址相对于 CS 寄存器的偏移），在可使用的指令中，只有转移指令、子程序调用+返回指令、中断调用+返回指令三类指令能够主动修改 IP 的值。</p>
<blockquote>
<p>标志寄存器可以暂且不考虑。</p>
</blockquote>
<h2 id="PC机的内存组织"><a href="#PC机的内存组织" class="headerlink" title="PC机的内存组织"></a>PC机的内存组织</h2><blockquote>
<ul>
<li>内存大小：20 根地址线 → $2^{20}=1MB$</li>
<li>单字长 16 位，一个字由 <strong>2 字节</strong>构成</li>
</ul>
</blockquote>
<h3 id="内存地址、字"><a href="#内存地址、字" class="headerlink" title="内存地址、字"></a>内存地址、字</h3><p>在内存的排布中，需要遵守一些规则：</p>
<ul>
<li>单字的地址是第 1 个字节的地址</li>
<li><strong>单字</strong>存放在内存中时，<strong>低字节在低地址一侧，高字节在高地址一侧</strong></li>
<li><strong>双字</strong>存放在内存中时，<strong>低字在低地址一侧，高字在高地址一侧</strong></li>
</ul>
<h3 id="内存地址的分段"><a href="#内存地址的分段" class="headerlink" title="内存地址的分段"></a>内存地址的分段</h3><p>前面提到了，内存地址划分为了段的基地址和段内的偏移地址，实际地址通过这两个地址来进行计算得到。</p>
<p>考虑到过大的段内地址使得内存分配十分浪费，过小的段内地址会进行频繁的段切换，使用段地址、段内地址均 16 位+二者重叠 12 位的做法能够更好地利用内存空间。</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292316091.png" alt="image-20240229231652056"></p>
<p>在这种分段方法中，总计可以分为 64K 个段，每一段又<strong>最多</strong>能拥有 64KB 的空间，给内存分配带来了灵活性。</p>
<h3 id="物理地址和逻辑地址"><a href="#物理地址和逻辑地址" class="headerlink" title="物理地址和逻辑地址"></a>物理地址和逻辑地址</h3><p>在 8086 的体系中，也存在物理地址和逻辑地址之分。</p>
<ul>
<li>逻辑地址：使用 <code>段地址:段内地址</code> 的格式表示，前后均为 16 位二进制，可以表示地址在程序段中的逻辑位置</li>
<li>物理地址：没有分页与映射机制，所以直接使用逻辑地址就能得到物理地址（反之也成立）</li>
</ul>
<p>物理地址的计算公式如下：<br>$$<br>段地址&lt;&lt;10H+段内地址=物理地址<br>$$<br>在这种地址处理机制下，逻辑地址和分段的灵活性使得一个物理地址可以对应多个逻辑地址</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="堆栈结构"><a href="#堆栈结构" class="headerlink" title="堆栈结构"></a>堆栈结构</h3><p>8086 中，堆栈的位置和大小是由 SS 和 SP 寄存器确定的：SS 寄存器保存栈的边界（栈自身增长的极限地址），SP 寄存器保存的是栈边界到当前栈顶地址的偏移量</p>
<p>也就是说，无论栈发生怎样的变化，SS 寄存器都不会发生改变；数据存取始终在 SS+SP 地址发生；存入数据时 SP 会减少，取出相反</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292336305.png" alt="image-20240229233619270"></p>
<blockquote>
<p>在这个图中栈开始从 24100H 存放数据，一致增长到 24080H，SP 寄存器减少了 20H</p>
</blockquote>
<h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><p>堆栈的操作遵守 FIFO 规则，操作分为压入和弹出两种，<strong>操作必须以单字为单位进行</strong>，不允许一次操作一个字节/双字。</p>
<h1 id="寻址方式与指令系统"><a href="#寻址方式与指令系统" class="headerlink" title="寻址方式与指令系统"></a>寻址方式与指令系统</h1><p>汇编语言程序由基本指令与基本伪指令组成，本节仅介绍部分指令</p>
<p>8086 指令的汇编语言格式与 mips 指令相似；但是机器语言格式区别较为明显，字长不同使得指令的字段变化十分明显。下面将对指令格式、指令系统和简单的寻址方式等进行介绍</p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><h3 id="指令的汇编语言格式"><a href="#指令的汇编语言格式" class="headerlink" title="指令的汇编语言格式"></a>指令的汇编语言格式</h3><p>8086/8088 指令由操作码和操作数两部分构成，表示为 <code>OP  DST, SRC</code>。大部分指令有两个操作数，部分指令仅有单个操作数或无操作数。</p>
<p>当指令无操作数时，操作的对象一般是预定好的。例如 STD 指令无操作数，其功能是设置方向标志寄存器 DF 为 1。</p>
<h3 id="指令的机器语言格式"><a href="#指令的机器语言格式" class="headerlink" title="指令的机器语言格式"></a>指令的机器语言格式</h3><p>8086/8088 的机器码格式相较于 mips 而言更复杂，一条指令的长度可以是 1-7 个字节，单条指令的前后字节都可能根据指令类型起到不同的作用。</p>
<p>可以将指令分为三段：操作码字节、寻址方式字节和段超越字节。</p>
<p>每个指令不一定都含有这三段，但是每一段都能起到对应的说明作用。</p>
<p><strong>操作码字节</strong></p>
<p>操作码字节一般只占用一个字节，表示本指令的操作和操作数的地址码。</p>
<p>根据指令的不同，操作码可以分为两种基本格式：</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011008353.png" alt="image-20240301100811199"></p>
<ul>
<li>d 位和 s 位分别在两个/一个操作数时有效：<ul>
<li>d 位（destination）：指定位于寄存器中的操作数是目的操作数（d=1）还是源操作数（d=0）</li>
<li>s 位（signed）：控制立即数的扩展方式，s=1 时符号拓展、s=0 时零拓展</li>
</ul>
</li>
<li>w 位（word）表示本指令的操作对象是字（w=1）或字节（w=0）</li>
</ul>
<p><strong>寻址方式字节</strong></p>
<p>寻址方式字节表示操作数的寻址方式，通常是指令的第二个字节，其定义如下：</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011013181.png" alt="image-20240301101307105"></p>
<p>由于 8086/8088 指令中必然有一个操作数为寄存器的值，所以必定会存在寄存器字段。</p>
<ul>
<li>mod 位：寻址方式，控制另一个操作数的来源<ul>
<li>mod=11：寄存器，由 r/m 位控制寄存器编号</li>
<li>mod=00：直接内存，由 r/m 位控制地址的运算方式</li>
<li>mod=01/10：计算内存，在mod=00的基础上加上了偏移量（字节/字）</li>
</ul>
</li>
<li>reg 位：指令中所使用寄存器的编号，reg+w → 寄存器<ul>
<li>操作码字节中的 d 位控制了 reg 所指向的寄存器充当的是什么操作数</li>
<li>操作码字节中的 w 位控制了 reg 是取整个字还是一个字节</li>
</ul>
</li>
<li>r/m 位：寄存器/内存，根据 mod 位取值确定不同的内容</li>
</ul>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011104112.png" alt="image-20240301110403008"></p>
<blockquote>
<p>reg 与 r/m（mod=00）时寄存器的取法，需要注意 r/m 与 w 位无关，总是取出整个字</p>
</blockquote>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011105170.png" alt="image-20240301110501082"></p>
<blockquote>
<p>在不同 mod 位的控制下，r/m 位计算地址时的规则（得出的值会用作地址去内存中读出）</p>
</blockquote>
<p><strong>段超越字节</strong></p>
<p><strong>当使用寄存器 BP 寻址时，段寄存器默认为 SS；使用 BX、SI、DI 寻址时，默认为 DS。</strong>若想主动指定段寄存器，可以使用段超越字节。</p>
<p>段超越字节在操作码字节前，可以在这个字接种指定一个 seg 寄存器，用作后面紧邻指令的段寄存器。</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403011107923.png" alt="image-20240301110757855"></p>
<blockquote>
<p>seg：段寄存器</p>
<p>00 → ES     01 → CS</p>
<p>10 → SS     11 → DS</p>
</blockquote>
<h2 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h2><p>在寻址方式字节中，简单的介绍了指令寻址的写法，对于完整的 8086/8088 指令而言，总共有三类寻址方式：</p>
<ul>
<li>数据相关寻址</li>
<li>转移、过程调用寻址</li>
<li>I/O 指令寻址（在<a href="">第八章</a>进行介绍）</li>
</ul>
<p>在进行寻址方式的介绍前，有一个我认为需要区别于 mips 的关键点：</p>
<p>8086/8088 指令大多数都可以直接操作内存，可以直接通过<strong>中括号</strong> <code>[]</code> 将括号内的数字/寄存器值/内存值<strong>转化为地址</strong>，然后直接访问内存取出内存值；而在 mips 中只有 save/load 类指令能操作内存，8086/8088 的自由度要大上不少。注意取偏移时只能使用基址寄存器和变址寄存器（BX、<strong>BP</strong>；SI、DI）</p>
<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><blockquote>
<p><strong>立即寻址</strong>指的是指令所需操作数直接包含在指令代码中，通常是一个<strong>常量或常数</strong>。</p>
<p>常数为 8 位或 16 位</p>
</blockquote>
<ul>
<li>立即寻址方式（立即数）只能出现在源操作数位置，目的操作数可以是寄存器/内存</li>
<li>立即数的运算需要注意位宽的匹配，不要出现两个操作数位宽不同的情况</li>
<li>立即数表示方式：<ul>
<li>常数：直接写在指令中</li>
<li>常量：先通过伪指令 EQU 定义后，直接在指令中写常量名</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VALUE EQU 512      ; 定义常量 VALUE</span><br><span class="line">MOV AL, 05H</span><br><span class="line">MOV AL, 00000101b</span><br><span class="line">MOV AX, 512</span><br><span class="line">MOV AX, VALUE      ; 直接使用 VALUE 赋值</span><br></pre></td></tr></table></figure>

<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><blockquote>
<p>寄存器寻址指的是指令中所需要的操作数来自某个寄存器，存取操作完全在 CPU 内部进行，执行速度快</p>
<p>可以来自全字寄存器，也可以来自半字寄存器</p>
</blockquote>
<p>没有什么好解释的，部分指令虽然不含操作数，但仍可能使用隐含寄存器（PUSHF：PSW 是源寄存器，存入堆栈所在的内存）</p>
<h3 id="直接-寄存器间接-寄存器相对-基址变址寻址"><a href="#直接-寄存器间接-寄存器相对-基址变址寻址" class="headerlink" title="直接/寄存器间接/寄存器相对/基址变址寻址"></a>直接/寄存器间接/寄存器相对/基址变址寻址</h3><blockquote>
<p><strong>直接寻址</strong>是指操作数的偏移地址直接在指令中指出的寻址方式。</p>
<p><strong>寄存器间接寻址</strong>指的是操作数的有效地址 EA 不是位于指令中，而是位于且<strong>仅位于</strong>基址寄存器 BX、BP 或变址寄存器 SI、DI 中。</p>
<p><strong>寄存器相对寻址</strong>指的是操作数的有效地址 EA 是一个基址/变址寄存器和指令中指定的位移量的和。</p>
<p><strong>基址变址寻址</strong>指的是操作数的有效地址 EA 是<strong>基址寄存器+变址寄存器</strong>的值</p>
</blockquote>
<ul>
<li>直接：用<strong>立即数</strong>直接在<strong>内存中</strong>取数<ul>
<li><code>MOV AX, [02000H]</code></li>
</ul>
</li>
<li>寄存器间接：用基址/变址寄存器的值在内存中取数<ul>
<li><code>MOV AX, [BX]</code></li>
</ul>
</li>
<li>寄存器相对：传统 <code>lw/sw</code>，注意可能是 DS 或 SS<ul>
<li><code>MOV AX, 10H[SI]</code></li>
</ul>
</li>
<li>基址变址：基址寄存器+变址寄存器<ul>
<li><code>MOV [BP+DI], [BX][SI]</code>（指令意为从 BX 和 SI 寄存器中取出值，相加得到内存地址，取出值后存入 BP 和 DI 寄存器值的和所指向的内存空间）</li>
</ul>
</li>
</ul>
<h3 id="转移指令寻址"><a href="#转移指令寻址" class="headerlink" title="转移指令寻址"></a>转移指令寻址</h3><h4 id="标号与过程名"><a href="#标号与过程名" class="headerlink" title="标号与过程名"></a>标号与过程名</h4><p>定义数据的变量/符号实质上确定的使它在数据段内的偏移地址，定义代码段/函数可以使用标号和过程名（标签）</p>
<ul>
<li>直接定义了代码段中的偏移值</li>
</ul>
<h4 id="段内直接寻址"><a href="#段内直接寻址" class="headerlink" title="段内直接寻址"></a>段内直接寻址</h4><blockquote>
<p>段内直接寻址是要转向指令实际的有效地址是 IP 寄存器和立即数偏移量之和（PC+offset）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP SHOUT F1   ; 此处即为段内直接寻址，此处代表 F1 与当前 IP 的位移量</span><br></pre></td></tr></table></figure>

<ul>
<li>通常是标号、过程名</li>
<li>条件转移指令只能使用 8 位位移量，不需使用 SHORT 等操作符</li>
<li>JMP 指令携带 <code>NEAR PTR</code> 或 <code>SHORT</code> 操作符则使用 8 位位移量，否则使用 16 位位移量</li>
</ul>
<h4 id="段内间接寻址"><a href="#段内间接寻址" class="headerlink" title="段内间接寻址"></a>段内间接寻址</h4><ul>
<li>通常是寄存器，或寄存器指向的内存值</li>
</ul>
<p>说白了就是 jr，跳转的寄存器中保存的是相对于当前代码段（CS 寄存器）的偏移值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; p1 作为过程名、ADD1 作为变量名</span><br><span class="line">MOV AX, OFFSET p1      ; 让 AX 存放 p1 相对于代码段的偏移</span><br><span class="line">MOV ADD1, AX           ; 把 AX 存放到 ADD1 指向的内存</span><br><span class="line">CALL ADD1              ; 段内间接转移：从 ADD1 指向的地址中取出值，然后作为偏移量转移</span><br><span class="line">MOV BX, OFFSET ADD1    ; 让 BX 存放 ADD1 相对于数据段的偏移</span><br><span class="line">CALL [BX]              ; 以 BX 存放值为地址，取出对应的值，然后作为偏移量转移</span><br></pre></td></tr></table></figure>



<h4 id="段间寻址"><a href="#段间寻址" class="headerlink" title="段间寻址"></a>段间寻址</h4><p>段间寻址的两种方式与段内寻址类似，只不过需要在偏移/目标地址之外给出转移目标的<strong>段地址</strong>。</p>
<ul>
<li>直接寻址使用的标号或过程名需要具有 <code>FAR</code> 属性</li>
<li>间接寻址的转移地址不再来自寄存器，而是在内存中的一个双字：<ul>
<li>高字在高地址、低字在低地址</li>
<li>转移后：低字→IP、高字→CS</li>
</ul>
</li>
</ul>
<h2 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h2><p>这一节主要介绍 8086/8088 的指令集，接下来的内容会尽量按照课本中给出的顺序记录，同时进行一些内容和示例的精简。</p>
<p><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403012122770.png" alt="image-20240301212220732"></p>
<p>取地址可以使用 OFFSET、SEG 操作符，也可以用 LEA 获取变量的偏移量</p>
<p>根据地址取值可以使用中括号，，取出指向内存单元的内容</p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>数据传送指令负责把运算过程中所需的数据、地址或立即数传送到寄存器或存储单元中。主要指令有：</p>
<h4 id="MOV、XCHG"><a href="#MOV、XCHG" class="headerlink" title="MOV、XCHG"></a>MOV、XCHG</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV DST, SRC   ; 将 SRC 的内容转移至 DST</span><br><span class="line">XCHG OP1, OP2  ; 交换 OP1 和 OP2</span><br></pre></td></tr></table></figure>

<ul>
<li>目的操作数不能为立即数</li>
<li>源操作数和目的操作数不能同时为内存/段寄存器</li>
<li>数据位宽必须保持一致，可以使用<strong>操作符进行强制类型转换</strong>（BYTE/WORD/DWORD PTR）</li>
<li><code>XCHG</code> 指令不允许出现立即数作为操作数</li>
</ul>
<h4 id="PUSH、POP"><a href="#PUSH、POP" class="headerlink" title="PUSH、POP"></a>PUSH、POP</h4><p>堆栈操作指令，包括四条指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH SRC   ; 将 SRC 的值存入栈帧</span><br><span class="line">POP DST    ; 将栈顶的值写入 DST</span><br><span class="line">PUSHF      ; </span><br><span class="line">POPF       ; 将 PSW 的值存入战阵</span><br></pre></td></tr></table></figure>

<ul>
<li>8086/8088 的栈帧只能以单字为单位存取</li>
<li>POP 指令不允许使用 CS 寄存器</li>
<li>不需手动修改 SP 寄存器的值</li>
</ul>
<h4 id="LEA、LDS、LES"><a href="#LEA、LDS、LES" class="headerlink" title="LEA、LDS、LES"></a>LEA、LDS、LES</h4><p>类似于 load 类指令，以上三个指令从指定地址取出值写入寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEA  reg, src  ; 完全是 lw，reg 不能是段寄存器</span><br><span class="line">LDS  reg, src  ; 取双字，低字写入 reg 中、高字写入 DS 寄存器中</span><br><span class="line">LES  reg, src  ; 与 LDS 类似，高字写入 ES 寄存器中</span><br></pre></td></tr></table></figure>

<h4 id="传送指令举例"><a href="#传送指令举例" class="headerlink" title="传送指令举例"></a>传送指令举例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, BL            ; AX 16 位，BL 8 位，两者位宽不匹配</span><br><span class="line">MOV AL, 257           ; 257 实际为 0101H，也就是需要 16 位（WORD）存储，AL 8 位</span><br><span class="line">MOV [BX], 0           ; 0 未指定位宽，必须显式指定是对字节/字操作，正确见下</span><br><span class="line"></span><br><span class="line">MOV BYTE PTR [BX], 0  ; 指定了 [BX] 的内存为 BYTE，此时 0 被视作字节</span><br><span class="line">MOV WORD PTR [BX], 0  ; 同理 WORD</span><br><span class="line"></span><br><span class="line">MOV AX, AX            ; 无实际作用，可以用于延时</span><br><span class="line"></span><br><span class="line">NOP                   ; No Operation，无实际作用</span><br><span class="line"></span><br><span class="line">MOV 02000H, AX        ; 无法将数值存入立即数中</span><br><span class="line">MOV [DX], AL          ; DX 不能作为寻址寄存器，应选用 BX、BP、SI、DI 四者之一</span><br><span class="line">MOV X1+1, AX          ; 对 X1+1 而言，先将变量 X1 解释为地址偏移值，+1 后再执行 MOV 操作</span><br></pre></td></tr></table></figure>

<h4 id="内存图与传送指令"><a href="#内存图与传送指令" class="headerlink" title="内存图与传送指令"></a>内存图与传送指令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 数据定义</span><br><span class="line">X1 DW 02000H</span><br><span class="line">X2 EQU 100</span><br><span class="line">X3 DB &#x27;1&#x27;</span><br><span class="line">X4 DD 12345678H</span><br><span class="line">X5 DD ?</span><br></pre></td></tr></table></figure>

<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403061509344.png" alt="image-20240306150914232" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 移动操作：X4 → X5 (DD → DD)</span><br><span class="line"></span><br><span class="line">MOV X5, X4              ; 显然不能实现 内存 → 内存，而且不能移动双字</span><br><span class="line"></span><br><span class="line">LEA DI, X5              ; 将 X5 的地址存放在 DI 寄存器中</span><br><span class="line">MOV [DI], WORD PTR X4   ; 仍然有 内存 → 内存 的现象</span><br><span class="line">MOV AX, X4              ; </span><br><span class="line"></span><br><span class="line">MOV AX, WORD PTR X4     ; 先利用 AX 寄存器输送 X4 的低字</span><br><span class="line">MOV [DI], AX            ; 放入 X5 的低字</span><br><span class="line">MOV AX, WORD PTR X4+2   ; 输送 X4 高字</span><br><span class="line">MOV [DI+2], AX          ; 放入 X5 高字</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 移动操作： X3 → X5 (DB → DD)</span><br><span class="line"></span><br><span class="line">MOV X5, X3              ; 显然不能 内存 → 内存</span><br><span class="line"></span><br><span class="line">MOV BYTE PTR X5, X3     ; 仍然在 内存 → 内存</span><br><span class="line"></span><br><span class="line">MOV AL, X3              ; </span><br><span class="line">MOV BYTE PTR X5, AL     ; 实现了 X5 最低字节的覆写</span><br><span class="line"></span><br><span class="line">XOR AL, AL              ; 清零 AL 寄存器</span><br><span class="line">MOV BYTE PTR X5+1, AL   ; 利用 AL 清零剩余字节</span><br><span class="line">MOV BYTE PTR X5+2, AL   ;</span><br><span class="line">MOV BYTE PTR X5+3, AL   ;</span><br><span class="line"></span><br><span class="line">; 间接寻址模式</span><br><span class="line">MOV BX, OFFSET X5       ; 取出 X5 地址偏移</span><br><span class="line">MOV AL, X3              ; 取出 X3 对应的值</span><br><span class="line">MOV [BX], AL            ; 寄存器间接寻址，目标地址 DS + BX</span><br><span class="line"></span><br><span class="line">; 重复三次覆盖高字节</span><br><span class="line">XOP AL, AL</span><br><span class="line">INC BX</span><br><span class="line">MOV [BX], AL</span><br></pre></td></tr></table></figure>

<p>最后一段的 <code>BX</code> 寄存器一定不能使用 <code>BP</code> 寄存器作为偏移寄存器，因为 <code>[BX]</code> 会以 <code>DS</code> 为基地址，而 <code>[BP]</code> 会以 <code>SS</code> 为基地址，<code>[BP]</code> 会把堆栈已存放的内容覆盖</p>
<h3 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h3><h4 id="部分标志寄存器"><a href="#部分标志寄存器" class="headerlink" title="部分标志寄存器"></a>部分标志寄存器</h4><ul>
<li>ZF：若运算结果为 0，则 ZF = 1</li>
<li>SF：等于运算结果的<strong>符号位</strong></li>
<li>CF：运算加法（发生进位）或减法（发生借位）时 CF = 1</li>
<li>OF：运算操作是否溢出，溢出时 OF = 1</li>
</ul>
<h4 id="基础算数指令"><a href="#基础算数指令" class="headerlink" title="基础算数指令"></a>基础算数指令</h4><p>只介绍基础的二进制数运算指令，下列指令都需要匹配类型，数据结果存储在 dst 中。加减操作中只有自增自减指令不会影响进位标志（CF）；乘法也会影响标志位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;  字节、单字运算</span><br><span class="line">ADD  dst, src  ; 直接相加</span><br><span class="line">ADC  dst, src  ; 带进位加，dst = dst + src + CF</span><br><span class="line">INC  opr       ; opr 自增</span><br><span class="line">SUB  dst, src  ; 直接相减</span><br><span class="line">SBB  dst, src  ; 带进位减，dst = dst - src - CF</span><br><span class="line">DEC  opr       ; opr 自减</span><br><span class="line"></span><br><span class="line">MUL  src       ; 无符号数乘法</span><br><span class="line">IMUL  src      ; 有符号数乘法</span><br><span class="line"></span><br><span class="line">DIV  src       ; 无符号数除法，AX / src = AL ······ AH</span><br><span class="line">IDIV  src      ; 有符号数除法</span><br><span class="line"></span><br><span class="line">;  考虑溢出的单字加法，实际上只需考虑进位标志</span><br><span class="line">X  DW ?</span><br><span class="line">Y  DW ?</span><br><span class="line">Z  DD ?</span><br><span class="line"></span><br><span class="line">MOV  DX, 0</span><br><span class="line">MOV  AX, X             ; 将 X 保存在 AX 中</span><br><span class="line">ADD  AX, Y             ; 计算 X + Y</span><br><span class="line">ADC  DX, 0             ; DX 加上进位标志</span><br><span class="line">MOV  WORD PTR Z+2, DX  ; 高字放回</span><br><span class="line">MOV  WORD PTR Z, AX    ; 低字放回</span><br><span class="line"></span><br><span class="line">;  双字减法，最好用竖式</span><br><span class="line">X DD ?</span><br><span class="line">Y DD ?</span><br><span class="line">Z DD ?</span><br><span class="line"></span><br><span class="line">MOV DX, WORD PTR X+2</span><br><span class="line">MOV AX, WORD PTR X     ; 加载高低双字 X</span><br><span class="line">SUB AX, WORD PTR Y     ; 先做低字减法，保留退位</span><br><span class="line">SBB DX, WORD PTR Y+2   ; 带进位标志计算减法</span><br><span class="line">MOV WORD PTR Z+2, DX   ; 高字放回</span><br><span class="line">MOV WORD PTR Z, AX     ; 低字放回</span><br></pre></td></tr></table></figure>

<ul>
<li>乘除法操作会对寄存器做隐性的类型匹配，但是<strong>内存操作数不会判断，需要手动声明</strong>！</li>
<li>乘除法的 OP 不允许是<strong>立即数</strong>，可以为内存或寄存器</li>
<li>乘法：<ul>
<li><code>src</code> 为 8 位： <code>AL × src → AX</code></li>
<li><code>src</code> 为 16 位： <code>AX × src → DX:AX</code> </li>
</ul>
</li>
<li>除法：<ul>
<li><code>src</code> 为 8 位：<code>AX / src → AL ······AH</code></li>
<li><code>src</code> 为 16 位：<code>DX:AX / src → AX ······ DX</code></li>
<li><strong>需要额外注意溢出</strong>：16 位除以 2 位 → 15 位，AL溢出了，程序会产生中断/直接停止</li>
</ul>
</li>
</ul>
<h4 id="CMP、NEG"><a href="#CMP、NEG" class="headerlink" title="CMP、NEG"></a>CMP、NEG</h4><p>CMP 指令虽然会产生标志位，但是实际上实现的是数值相减，只不过结果并未存入 dst 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEG  opr         ; opr 变为 -opr</span><br><span class="line">CMP  opr1, opr2  ; opr1 - opr2 计算标志位</span><br></pre></td></tr></table></figure>

<h4 id="CWB、CWD"><a href="#CWB、CWD" class="headerlink" title="CWB、CWD"></a>CWB、CWD</h4><p>这两条指令都将 8 位的数据拓展至 16 位，<code>CBW</code> 指令将 <code>AL</code> <strong>符号扩展</strong>至 <code>AH</code>；类似的，<code>CWD</code> 指令将 <code>AX</code> 中的符号位直接拓展到 <code>DX</code> 寄存器中（结果非 0 即 0FFFF）</p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><ul>
<li>逻辑运算指令：AND、OR、XOR、NOT</li>
<li>测试指令：TEST</li>
<li>移位指令：SHL(SHR)、SAL(SAR)、ROL(ROR)、RCL(RCR)</li>
</ul>
<p>对逻辑运算指令而言，<code>src</code> 可以是<strong>立即数</strong>（8/16），使用灵活</p>
<ul>
<li>数字 → ASCII 数字：<code>OR AL, 030H</code></li>
<li>大写字母 → 小写字母：<code>OR AL, 020H</code></li>
</ul>
<p>对移位指令而言，有下图：</p>
<img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403061836662.png" alt="image-20240306183607598" style="zoom:67%;" />

<h3 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h3><ul>
<li>条件转移指令：JA、JB、JE</li>
<li>无条件转移指令：JMP</li>
<li>循环指令：LOOP、LOOPZ、LOOPNZ</li>
<li>调用与返回指令：CALL、RET、RETF</li>
</ul>
<p>条件跳转指令 ABE 比较的是两个无符号数的大小，分别对应 Above、Below 和 Equal</p>
<p>无条件跳转指令相当于 mips 中的 <code>j</code> 指令，需要注意<strong>寻址方式</strong>：</p>
<ul>
<li>段内直接转移：<code>JMP NEAR PTR 标号 | JMP SHORT 标号</code>，8 位</li>
<li>段内间接转移：<code>JMP WORD PTR &lt;REG | MEM&gt;</code></li>
<li>段间直接转移：<code>JMP FAR PTR 标号</code>，16 位</li>
<li>段间间接转移：<code>JMP DWORD PTR &lt;REG | MEM&gt;</code></li>
</ul>
<p>如果跳标号，就看 SHORT/NEAR/FAR，SHORT 不需要加 PTR</p>
<p>如果跳寄存器，就看有没有取地址，取了就看 WORD/DWORD PTR，没取就直接用</p>
<p>循环指令中，使用的循环计数器均为 <code>CX</code> 寄存器，在执行循环体前先更新计数器，LOOP：<code>CX</code> 不为 0 时转移、JCXZ：<code>CX</code> 为 0 时转移</p>
<p>CALL 指令的执行过程与调用的 dst 相关（四种分类和上面寻址方式一致）：</p>
<ul>
<li>段内标号：返回地址偏移值入栈；<code>IP = IP + D16</code></li>
<li>段内寄存器：返回地址偏移值入栈；<code>IP = dst</code></li>
<li>段外标号：返回地址段值入栈、偏移值入栈；<code>IP = dst 偏移值</code>；<code>CS = dst 段地址</code></li>
<li>段外寄存器：返回地址段值入栈、偏移值入栈；<code>IP = EA[15:0]</code>；<code>CS=EA[31:16]</code></li>
</ul>
<p>对于 RET 指令而言，执行的完全就是 CALL 的逆过程</p>
<h1 id="汇编语言程序格式"><a href="#汇编语言程序格式" class="headerlink" title="汇编语言程序格式"></a>汇编语言程序格式</h1><p>本章节介绍 8086/8088 汇编语言中的程序结构、内存布局、指令与伪指令、关键字，以及汇编程序运行过程前/中的调试工作。</p>
<h2 id="分段式程序结构"><a href="#分段式程序结构" class="headerlink" title="分段式程序结构"></a>分段式程序结构</h2><p>8086 程序在内存中是以分段形式来组织的，程序在执行时会使用<strong>代码段、数据段和堆栈段</strong>。它们统合形成完整的汇编程序。</p>
<h3 id="程序组成"><a href="#程序组成" class="headerlink" title="程序组成"></a>程序组成</h3><blockquote>
<p>在汇编语言中，无论是常数、常量、标号、符号名、指令助记符、伪指令、操作符、参数等，都<strong>不区分大小写</strong>。</p>
</blockquote>
<ul>
<li>在命名规则上，标号和符号名都必须以字母或专用字符（<code>?,@,-</code>）开头，当常数以 <code>A-F</code> 开头时，都要在前端补充一个 0，从而与标识符区分</li>
</ul>
<p>代码段中的内容由主程序和组过程组成，两者都是统一的过程，需要使用伪指令指定。过程必须有一个名字，当只有主程序时，可以省去命名过程。</p>
<p>程序起始处的必备内容：初始化 SS、SP、DS 寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MOV AX, STACK1       ; </span><br><span class="line">MOV SS, AX           ; 初始化栈帧基地址</span><br><span class="line">MOV SP, STACK_BTM    ; 初始化栈帧长度</span><br><span class="line">MOV AX, DATA1        ; </span><br><span class="line">MOV DS, AX           ; 挂载数据段部分</span><br></pre></td></tr></table></figure>

<p>必备函数：回到 MS-DOS 的命令提示符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXIT:   MOV AX, 4C00H</span><br><span class="line">		INT 21H</span><br></pre></td></tr></table></figure>

<ul>
<li>向 AH 中放入功能号 <code>4CH</code>，向 AL 中放入返回码 <code>00H</code></li>
<li>调用 MS-DOS 例程，<code>4C</code> 号功能调用作用是返回命令提示符</li>
</ul>
<p>程序终止处的必备内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">END	MAIN</span><br></pre></td></tr></table></figure>

<p>END 表示本模块的总结束，后续的内容不会进入汇编，END 后跟着的标号说明本程序的入口是 <code>MAIN</code></p>
<h2 id="定义程序结构的伪指令"><a href="#定义程序结构的伪指令" class="headerlink" title="定义程序结构的伪指令"></a>定义程序结构的伪指令</h2><h3 id="SEGMENT-amp-END"><a href="#SEGMENT-amp-END" class="headerlink" title="SEGMENT&amp;END"></a>SEGMENT&amp;END</h3><p>在定义段时需要使用 <code>SEGMENT</code> 和 <code>ENDS</code> 指令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NAME&gt;	SEGMENT	[对齐类型][组合类型][类别名]</span><br><span class="line">	...</span><br><span class="line">&lt;NAME&gt;	ENDS</span><br></pre></td></tr></table></figure>

<ul>
<li>段名：由用户喜好定义，无特殊限制</li>
<li>对齐类型：相当于 align，确定了段整体的对齐方式，可选项有BYTE（字节）、WORD（字，2B）、PARA（节，16B）、PAGE（页，256B）</li>
<li>组合类型：确定段之间的组合方式<ul>
<li>NONE：缺省，本段独立、不指定组合类型</li>
<li>PUBLIC：将段名相同的小段<strong>拼接</strong>为一个大段，共用基地址</li>
<li>COMMON：将段名相同的段覆盖到同一起始地址上</li>
<li>STACK：说明是堆栈段的一部分，同名段连接为一个连续段<ul>
<li>SS：连续段的首地址</li>
<li>SP：最大偏移地址</li>
</ul>
</li>
<li>MEMORY：本段在内存中应定位在所有连接在一起的段的前面</li>
<li>AT：本段直接以节边界对齐，定位在内存的某个位置</li>
</ul>
</li>
<li>类别名：用引号括起来，程序在连接时会把同名的程序放在连续的内存区中，但仍然属于不同的段；<strong>优先级低于组合类型</strong></li>
</ul>
<h3 id="ASSUME"><a href="#ASSUME" class="headerlink" title="ASSUME"></a>ASSUME</h3><p>一种设定指令，告诉汇编器各段应该具体是哪些程序段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASSUME CS:AAA, DS:BBB, SS:CCC</span><br></pre></td></tr></table></figure>

<p><code>AAA、BBB、CCC</code> 指的都是某个段的段首地址，用这些地址初始化寄存器（<strong>但实际上并没有将地址放进去</strong>）</p>
<h3 id="PROC-amp-ENDP"><a href="#PROC-amp-ENDP" class="headerlink" title="PROC&amp;ENDP"></a>PROC&amp;ENDP</h3><blockquote>
<p>汇编程序中定义的函数（子过程）需要定义为过程。过程通过定义伪指令 <code>PROC</code> 和 <code>ENDP</code> 实现</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;NAME&gt;	PROC	[NEAR|FAR]</span><br><span class="line">		...</span><br><span class="line">		RET		; 过程的最后一条指令通常为 RET，以返回调用者</span><br><span class="line">&lt;NAME&gt;	ENDP</span><br></pre></td></tr></table></figure>

<p>与标号类似，但是<strong>定义时没有冒号</strong>，<code>NEAR|FAR</code> 定义了过程属性，<code>NEAR</code> 调用时仅压栈 CALL 指令下一条的偏移，<code>FAR</code> 则压栈段地址与偏移；<code>NEAR</code> 过程不修改 <code>RET</code> 指令，<code>FAR</code> 过程将 <code>RET</code> 转化为 <code>RETF</code>，从堆栈弹出两个字充当 IP 和 CS 值</p>
<h3 id="ORG"><a href="#ORG" class="headerlink" title="ORG"></a>ORG</h3><p>定位伪指令，为某指令、数据指定一个特定的偏移地址，可以使用 ORG 进行限制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATA1	SEGMENT	PARA AT 0B800H	; STRING 在 DATA1 中</span><br><span class="line">		ORG	2000H				; 指定 2000H</span><br><span class="line">STRING	DB	&#x27;ABCD&#x27;				; 设定首地址 DATA1 距离为 2000H</span><br><span class="line">DATA1	ENDS					; 也就是 B800H + 2000H → BA000H</span><br></pre></td></tr></table></figure>

<h3 id="END、NAME、TITLE"><a href="#END、NAME、TITLE" class="headerlink" title="END、NAME、TITLE"></a>END、NAME、TITLE</h3><ul>
<li>END：出现在每个程序、模块的末尾；若带标号则指明了程序开始执行的入口点</li>
<li>NAME：模块名</li>
<li>TITLE：标题名</li>
</ul>
<h2 id="数据定义与内存分配"><a href="#数据定义与内存分配" class="headerlink" title="数据定义与内存分配"></a>数据定义与内存分配</h2><h3 id="常数和常量"><a href="#常数和常量" class="headerlink" title="常数和常量"></a>常数和常量</h3><blockquote>
<p>常数和常量指没有任何属性的纯数值，在汇编过后，这些量都会变成纯二进制数</p>
</blockquote>
<p>常数类型：二进制数（B）、八进制数（O）、十进制数（D）、十六进制数（H）</p>
<p>常量定义：使用伪指令 <code>EQU</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PORT_ADDR	EQU	2B5H</span><br><span class="line">STACK_BTM	EQU	$-STACK_AREA</span><br><span class="line">; $ 是当前位置计数器，代表当前的偏移值</span><br></pre></td></tr></table></figure>

<h3 id="变量与定义"><a href="#变量与定义" class="headerlink" title="变量与定义"></a>变量与定义</h3><blockquote>
<p>变量的实质是代表存放在内存单元中的数据，这些数据允许程序在运行期间由指令修改。</p>
</blockquote>
<p>汇编语言中的变量名代表了存放数据的内存单元的<strong>地址</strong>，可以通过 <code>OFFSET</code> 和 <code>LEA</code> 指令获取变量的地址</p>
<p>变量的定义使用伪指令 <code>DB、DW、DD、DF、DT</code> 实现（字节、单字、双字、三个字、10Byte 的压缩 BCD） 码</p>
<p>在汇编中，变量名+1永远只会给偏移地址+1，不会+变量大小</p>
<ul>
<li><code>$</code>：地址表达式，指向下一个位置</li>
<li><code>DUP</code>：重复操作符，</li>
<li><code>?</code>：不预置任何内容</li>
<li>字符串表达式：用引号、逗号分配字符串，初始化为字符的 ASCII 码<ul>
<li>DD、DW 不允许两个以上字符的字符串作为参数</li>
</ul>
</li>
<li>地址表达式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeat_count DUP (operand, ...,operand)</span><br><span class="line">; repeat_count 是正整数常量、整个句子表示重复 operand 的全部内容总共 repeat_count 次</span><br></pre></td></tr></table></figure>

<h2 id="表达式与操作符"><a href="#表达式与操作符" class="headerlink" title="表达式与操作符"></a>表达式与操作符</h2><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>表达式是操作数的一种，它由常量、变量、寄存器、标号和一些操作符相组合，程序在汇编时会按照一定的优先顺序进行计算得出数值或地址</p>
<h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><p>常用的算术操作符有 <code>+, -, *, /, MOD</code>，MOD 是求余数的双目操作符；算术操作的数和结果都必须是整数，除法运算的结果只保留商</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>主要有 <code>AND、OR、XOR、NOT</code> 四个，逻辑操作符是按位操作符，只能用于数字表达式中，需要注意数字的类型匹配</p>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><p>关系操作符对两个表达式进行比较，常数 or 同一段的两个内存地址，结果为真时=0FFFFH，结果为假时=0；主要的几个关系操作符有：EQ、NE、LT、LE、GT、GE，含义见首字母缩写</p>
<h3 id="数值回送操作符"><a href="#数值回送操作符" class="headerlink" title="数值回送操作符"></a>数值回送操作符</h3><h4 id="TYPE、LENGTH、SIZE"><a href="#TYPE、LENGTH、SIZE" class="headerlink" title="TYPE、LENGTH、SIZE"></a>TYPE、LENGTH、SIZE</h4><ul>
<li>TYPE 指令用于求出变量、数组的类型，其返回值如下：</li>
</ul>
<table>
<thead>
<tr>
<th>变量或标号</th>
<th>属性</th>
<th>类型值</th>
</tr>
</thead>
<tbody><tr>
<td>DB 类型变量</td>
<td>BYTE</td>
<td>1</td>
</tr>
<tr>
<td>DW 类型变量</td>
<td>WORD</td>
<td>2</td>
</tr>
<tr>
<td>DD 类型变量</td>
<td>DWORD</td>
<td>4</td>
</tr>
<tr>
<td>段内标号、过程名</td>
<td>NEAR</td>
<td>-1</td>
</tr>
<tr>
<td>段间标号、过程名</td>
<td>FAR</td>
<td>-2</td>
</tr>
</tbody></table>
<p>使用时可以充当其他指令的操作数，例如 <code>MOV AL, TYPE VAR</code></p>
<ul>
<li>LENGTH 指令用于求出变量名的单元数：使用 DUP 则是 DUP 的次数、未使用则是 1</li>
<li>SIZE 指令用于求出分配给变量名的字节数</li>
</ul>
<h4 id="OFFSET、SEG"><a href="#OFFSET、SEG" class="headerlink" title="OFFSET、SEG"></a>OFFSET、SEG</h4><ul>
<li>OFFSET 指令计算变量名、标号和过程名的偏移值地址</li>
<li>SEG 指令计算其所处的段地址</li>
</ul>
<h3 id="属性操作符"><a href="#属性操作符" class="headerlink" title="属性操作符"></a>属性操作符</h3><p><code>PTR、段操作符、SHORT、THIS、HIGH、LOW</code> 六种操作符</p>
<ul>
<li><code>PTR</code> 的作用是强制说明或转换存储单元的类型为指定的种类，修改视为一次性修改</li>
<li><code>THIS</code> 为某个变量指定一个<strong>类型</strong>；为一个标号/过程名指定一种<strong>转移距离</strong></li>
<li>段操作符就是段超越的表示方式</li>
<li><code>SHORT</code> 操作符说明 <code>JMP</code> 的跳转地址为 8 位偏移量，而不再是 16 位（范围为 <code>IP-128 \~ IP+128</code> 字节）</li>
<li><code>HIGH</code> 和 <code>LOW</code> 操作符为字节分离操作符，<code>HIGH</code> 说明取出变量的高字节、<code>LOW</code> 同理<ul>
<li>注意字节分离操作符不能应用于内存操作数（取它们的字节可以使用 <code>BYTE PTR</code>）</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X1	EQU	THIS BYTE  		; X1 视为 BYTE 类型的量</span><br><span class="line">MOV AX,	ES: [BX][SI]	;指定数据取自 ES 段</span><br></pre></td></tr></table></figure>



<h2 id="汇编、连接和运行"><a href="#汇编、连接和运行" class="headerlink" title="汇编、连接和运行"></a>汇编、连接和运行</h2><blockquote>
<p>接下来的部分是<strong>汇编程序设计</strong>，主要关注 8086/8088 程序的实际操作</p>
</blockquote>
<h1 id="数制转换及乘除法"><a href="#数制转换及乘除法" class="headerlink" title="数制转换及乘除法"></a>数制转换及乘除法</h1><blockquote>
<p>待补充</p>
</blockquote>
<h1 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h1><blockquote>
<p>待补充</p>
</blockquote>
<h1 id="子程序和跳转表"><a href="#子程序和跳转表" class="headerlink" title="子程序和跳转表"></a>子程序和跳转表</h1><blockquote>
<p>待补充</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io">CookedBear</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cookedbear.github.io/p/5ed428af.html">https://cookedbear.github.io/p/5ed428af.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cookedbear.github.io" target="_blank">sin</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BUAA/">BUAA</a><a class="post-meta__tags" href="/tags/Elevate/">Elevate</a></div><div class="post_share"><div class="social-share" data-image="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202402292225468.jpg?imageMogr2/format/webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/p/384b4d9.html" title="BUAA-SoftwareEngineering-Task0"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">BUAA-SoftwareEngineering-Task0</div></div></a></div><div class="next-post pull-right"><a href="/p/feaaa974.html" title="超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》"><img class="cover" src="https://cdn.cloudflare.steamstatic.com/steam/apps/2510890/header_schinese.jpg?t=1708421482" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">超低配主播女孩，略显可惜的小品作——《Pricolage -IDOLIZED-》</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/p/d4de58c7.html" title="BUAA-OO-TOP"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202309112056684.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-14</div><div class="title">BUAA-OO-TOP</div></div></a></div><div><a href="/p/1727.html" title="BUAA-OS-TOP"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202306132108192.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-22</div><div class="title">BUAA-OS-TOP</div></div></a></div><div><a href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="title">BUAA-SoftwareEngineering-Task3</div></div></a></div><div><a href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-15</div><div class="title">BUAA-SoftwareEngineering-Task2</div></div></a></div><div><a href="/p/b94f504e.html" title="BUAA-FPGA多核并行计算-Exp2-1"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">BUAA-FPGA多核并行计算-Exp2-1</div></div></a></div><div><a href="/p/a164ec81.html" title="BUAA-FPGA多核并行计算-Exp1"><img class="cover" src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-14</div><div class="title">BUAA-FPGA多核并行计算-Exp1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202305132152908.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CookedBear</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">66</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CookedBear"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CookedBear" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">ReStart</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#X86%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">X86汇编程序设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E5%8F%8A%E6%95%B0%E5%88%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">数制及数制间的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%8E%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">2.2.</span> <span class="toc-text">二进制数与十六进制数的运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII%E7%A0%81%E5%92%8CBCD%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">ASCII码和BCD码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IBM-PC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E7%BB%87"><span class="toc-number">3.</span> <span class="toc-text">IBM-PC计算机组织</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IBM-PC%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">IBM-PC微型计算机的基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Intel-8086-CPU-%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">Intel 8086 CPU 寄存器结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">通用寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.2.3.</span> <span class="toc-text">指令指针寄存器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PC%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%84%E7%BB%87"><span class="toc-number">3.3.</span> <span class="toc-text">PC机的内存组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E3%80%81%E5%AD%97"><span class="toc-number">3.3.1.</span> <span class="toc-text">内存地址、字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">3.3.2.</span> <span class="toc-text">内存地址的分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.3.</span> <span class="toc-text">物理地址和逻辑地址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">3.4.</span> <span class="toc-text">堆栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">堆栈结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E6%93%8D%E4%BD%9C"><span class="toc-number">3.4.2.</span> <span class="toc-text">堆栈操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">寻址方式与指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">指令格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">指令的汇编语言格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.2.</span> <span class="toc-text">指令的机器语言格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.1.</span> <span class="toc-text">立即寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.2.</span> <span class="toc-text">寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5-%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5-%E5%AF%84%E5%AD%98%E5%99%A8%E7%9B%B8%E5%AF%B9-%E5%9F%BA%E5%9D%80%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.3.</span> <span class="toc-text">直接&#x2F;寄存器间接&#x2F;寄存器相对&#x2F;基址变址寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.4.</span> <span class="toc-text">转移指令寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%8F%B7%E4%B8%8E%E8%BF%87%E7%A8%8B%E5%90%8D"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">标号与过程名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%86%85%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">段内直接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E5%86%85%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">段内间接寻址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%97%B4%E5%AF%BB%E5%9D%80"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">段间寻址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.3.</span> <span class="toc-text">指令系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.1.</span> <span class="toc-text">数据传送指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MOV%E3%80%81XCHG"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">MOV、XCHG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUSH%E3%80%81POP"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">PUSH、POP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LEA%E3%80%81LDS%E3%80%81LES"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">LEA、LDS、LES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">传送指令举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%BE%E4%B8%8E%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">内存图与传送指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.2.</span> <span class="toc-text">算术运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">部分标志寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%95%B0%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">基础算数指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMP%E3%80%81NEG"><span class="toc-number">4.3.2.3.</span> <span class="toc-text">CMP、NEG</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CWB%E3%80%81CWD"><span class="toc-number">4.3.2.4.</span> <span class="toc-text">CWB、CWD</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.3.</span> <span class="toc-text">逻辑运算指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.4.</span> <span class="toc-text">控制转移指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E6%A0%BC%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">汇编语言程序格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%BC%8F%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">分段式程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90"><span class="toc-number">5.1.1.</span> <span class="toc-text">程序组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E7%9A%84%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">定义程序结构的伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEGMENT-amp-END"><span class="toc-number">5.2.1.</span> <span class="toc-text">SEGMENT&amp;END</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ASSUME"><span class="toc-number">5.2.2.</span> <span class="toc-text">ASSUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PROC-amp-ENDP"><span class="toc-number">5.2.3.</span> <span class="toc-text">PROC&amp;ENDP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ORG"><span class="toc-number">5.2.4.</span> <span class="toc-text">ORG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#END%E3%80%81NAME%E3%80%81TITLE"><span class="toc-number">5.2.5.</span> <span class="toc-text">END、NAME、TITLE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">5.3.</span> <span class="toc-text">数据定义与内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E6%95%B0%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">常数和常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">5.3.2.</span> <span class="toc-text">变量与定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.</span> <span class="toc-text">表达式与操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.4.1.</span> <span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.2.</span> <span class="toc-text">算术操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.4.3.</span> <span class="toc-text">逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.4.</span> <span class="toc-text">关系操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9B%9E%E9%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.5.</span> <span class="toc-text">数值回送操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TYPE%E3%80%81LENGTH%E3%80%81SIZE"><span class="toc-number">5.4.5.1.</span> <span class="toc-text">TYPE、LENGTH、SIZE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OFFSET%E3%80%81SEG"><span class="toc-number">5.4.5.2.</span> <span class="toc-text">OFFSET、SEG</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.4.6.</span> <span class="toc-text">属性操作符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="toc-number">5.5.</span> <span class="toc-text">汇编、连接和运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%B9%98%E9%99%A4%E6%B3%95"><span class="toc-number">6.</span> <span class="toc-text">数制转换及乘除法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">字符串处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%B7%B3%E8%BD%AC%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text">子程序和跳转表</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task3"/></a><div class="content"><a class="title" href="/p/9a8de563.html" title="BUAA-SoftwareEngineering-Task3">BUAA-SoftwareEngineering-Task3</a><time datetime="2024-03-16T06:41:29.000Z" title="发表于 2024-03-16 14:41:29">2024-03-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403130016509.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-SoftwareEngineering-Task2"/></a><div class="content"><a class="title" href="/p/ed8ad5f5.html" title="BUAA-SoftwareEngineering-Task2">BUAA-SoftwareEngineering-Task2</a><time datetime="2024-03-15T14:51:13.000Z" title="发表于 2024-03-15 22:51:13">2024-03-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/b94f504e.html" title="BUAA-FPGA多核并行计算-Exp2-1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-FPGA多核并行计算-Exp2-1"/></a><div class="content"><a class="title" href="/p/b94f504e.html" title="BUAA-FPGA多核并行计算-Exp2-1">BUAA-FPGA多核并行计算-Exp2-1</a><time datetime="2024-03-14T15:23:27.000Z" title="发表于 2024-03-14 23:23:27">2024-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/p/a164ec81.html" title="BUAA-FPGA多核并行计算-Exp1"><img src="https://cookedbear-2003-1307884465.cos.ap-beijing.myqcloud.com/NotePics/202403142326098.jpg?imageMogr2/format/webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="BUAA-FPGA多核并行计算-Exp1"/></a><div class="content"><a class="title" href="/p/a164ec81.html" title="BUAA-FPGA多核并行计算-Exp1">BUAA-FPGA多核并行计算-Exp1</a><time datetime="2024-03-14T08:53:26.000Z" title="发表于 2024-03-14 16:53:26">2024-03-14</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By CookedBear</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer src="https://gcore.jsdelivr.net/combine/npm/jquery@latest/dist/jquery.min.js,gh/weilining/jsdelivr/jquery/circlemagic/circlemagic.min.js,gh/weilining/jsdelivr@latest/jquery/circlemagic/butterflycirclemagic.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>